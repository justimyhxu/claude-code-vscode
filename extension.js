var yi = Object.create;
var {
    getPrototypeOf: ki,
    defineProperty: s1,
    getOwnPropertyNames: jG,
    getOwnPropertyDescriptor: mi
} = Object, BG = Object.prototype.hasOwnProperty;
var o = (v, z, U) => {
        U = v != null ? yi(ki(v)) : {};
        let V = z || !v || !v.__esModule ? s1(U, "default", {
            value: v,
            enumerable: !0
        }) : U;
        for (let N of jG(v))
            if (!BG.call(V, N)) s1(V, N, {
                get: () => v[N],
                enumerable: !0
            });
        return V
    },
    xG = new WeakMap,
    Xi = (v) => {
        var z = xG.get(v),
            U;
        if (z) return z;
        if (z = s1({}, "__esModule", {
                value: !0
            }), v && typeof v === "object" || typeof v === "function") jG(v).map((V) => !BG.call(z, V) && s1(z, V, {
            get: () => v[V],
            enumerable: !(U = mi(v, V)) || U.enumerable
        }));
        return xG.set(v, z), z
    },
    _ = (v, z) => () => (z || v((z = {
        exports: {}
    }).exports, z), z.exports);
var S8 = (v, z) => {
    for (var U in z) s1(v, U, {
        get: z[U],
        enumerable: !0,
        configurable: !0,
        set: (V) => z[U] = () => V
    })
};
var AG = _((AA6, DG) => {
    DG.exports = HG;
    HG.sync = ci;
    var JG = require("fs");

    function gi(v, z) {
        var U = z.pathExt !== void 0 ? z.pathExt : process.env.PATHEXT;
        if (!U) return !0;
        if (U = U.split(";"), U.indexOf("") !== -1) return !0;
        for (var V = 0; V < U.length; V++) {
            var N = U[V].toLowerCase();
            if (N && v.substr(-N.length).toLowerCase() === N) return !0
        }
        return !1
    }

    function qG(v, z, U) {
        if (!v.isSymbolicLink() && !v.isFile()) return !1;
        return gi(z, U)
    }

    function HG(v, z, U) {
        JG.stat(v, function(V, N) {
            U(V, V ? !1 : qG(N, v, z))
        })
    }

    function ci(v, z) {
        return qG(JG.statSync(v), v, z)
    }
});
var FG = _(($A6, LG) => {
    LG.exports = wG;
    wG.sync = ii;
    var $G = require("fs");

    function wG(v, z, U) {
        $G.stat(v, function(V, N) {
            U(V, V ? !1 : ZG(N, z))
        })
    }

    function ii(v, z) {
        return ZG($G.statSync(v), z)
    }

    function ZG(v, z) {
        return v.isFile() && li(v, z)
    }

    function li(v, z) {
        var {
            mode: U,
            uid: V,
            gid: N
        } = v, K = z.uid !== void 0 ? z.uid : process.getuid && process.getuid(), x = z.gid !== void 0 ? z.gid : process.getgid && process.getgid(), j = parseInt("100", 8), B = parseInt("010", 8), O = parseInt("001", 8), J = j | B, q = U & O || U & B && N === x || U & j && V === K || U & J && K === 0;
        return q
    }
});
var IG = _((ZA6, GG) => {
    var wA6 = require("fs"),
        TN;
    if (process.platform === "win32" || global.TESTING_WINDOWS) TN = AG();
    else TN = FG();
    GG.exports = pJ;
    pJ.sync = hi;

    function pJ(v, z, U) {
        if (typeof z === "function") U = z, z = {};
        if (!U) {
            if (typeof Promise !== "function") throw TypeError("callback not provided");
            return new Promise(function(V, N) {
                pJ(v, z || {}, function(K, x) {
                    if (K) N(K);
                    else V(x)
                })
            })
        }
        TN(v, z || {}, function(V, N) {
            if (V) {
                if (V.code === "EACCES" || z && z.ignoreErrors) V = null, N = !1
            }
            U(V, N)
        })
    }

    function hi(v, z) {
        try {
            return TN.sync(v, z || {})
        } catch (U) {
            if (z && z.ignoreErrors || U.code === "EACCES") return !1;
            else throw U
        }
    }
});
var PG = _((LA6, SG) => {
    var k7 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys",
        MG = require("path"),
        pi = k7 ? ";" : ":",
        bG = IG(),
        RG = (v) => Object.assign(Error(`not found: ${v}`), {
            code: "ENOENT"
        }),
        WG = (v, z) => {
            let U = z.colon || pi,
                V = v.match(/\//) || k7 && v.match(/\\/) ? [""] : [...k7 ? [process.cwd()] : [], ...(z.path || process.env.PATH || "").split(U)],
                N = k7 ? z.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "",
                K = k7 ? N.split(U) : [""];
            if (k7) {
                if (v.indexOf(".") !== -1 && K[0] !== "") K.unshift("")
            }
            return {
                pathEnv: V,
                pathExt: K,
                pathExtExe: N
            }
        },
        EG = (v, z, U) => {
            if (typeof z === "function") U = z, z = {};
            if (!z) z = {};
            let {
                pathEnv: V,
                pathExt: N,
                pathExtExe: K
            } = WG(v, z), x = [], j = (O) => new Promise((J, q) => {
                if (O === V.length) return z.all && x.length ? J(x) : q(RG(v));
                let H = V[O],
                    D = /^".*"$/.test(H) ? H.slice(1, -1) : H,
                    A = MG.join(D, v),
                    w = !D && /^\.[\\\/]/.test(v) ? v.slice(0, 2) + A : A;
                J(B(w, O, 0))
            }), B = (O, J, q) => new Promise((H, D) => {
                if (q === N.length) return H(j(J + 1));
                let A = N[q];
                bG(O + A, {
                    pathExt: K
                }, (w, Z) => {
                    if (!w && Z)
                        if (z.all) x.push(O + A);
                        else return H(O + A);
                    return H(B(O, J, q + 1))
                })
            });
            return U ? j(0).then((O) => U(null, O), U) : j(0)
        },
        ni = (v, z) => {
            z = z || {};
            let {
                pathEnv: U,
                pathExt: V,
                pathExtExe: N
            } = WG(v, z), K = [];
            for (let x = 0; x < U.length; x++) {
                let j = U[x],
                    B = /^".*"$/.test(j) ? j.slice(1, -1) : j,
                    O = MG.join(B, v),
                    J = !B && /^\.[\\\/]/.test(v) ? v.slice(0, 2) + O : O;
                for (let q = 0; q < V.length; q++) {
                    let H = J + V[q];
                    try {
                        if (bG.sync(H, {
                                pathExt: N
                            }))
                            if (z.all) K.push(H);
                            else return H
                    } catch (D) {}
                }
            }
            if (z.all && K.length) return K;
            if (z.nothrow) return null;
            throw RG(v)
        };
    SG.exports = EG;
    EG.sync = ni
});
var CG = _((FA6, nJ) => {
    var _G = (v = {}) => {
        let z = v.env || process.env;
        if ((v.platform || process.platform) !== "win32") return "PATH";
        return Object.keys(z).reverse().find((V) => V.toUpperCase() === "PATH") || "Path"
    };
    nJ.exports = _G;
    nJ.exports.default = _G
});
var uG = _((GA6, YG) => {
    var fG = require("path"),
        Qi = PG(),
        di = CG();

    function TG(v, z) {
        let U = v.options.env || process.env,
            V = process.cwd(),
            N = v.options.cwd != null,
            K = N && process.chdir !== void 0 && !process.chdir.disabled;
        if (K) try {
            process.chdir(v.options.cwd)
        } catch (j) {}
        let x;
        try {
            x = Qi.sync(v.command, {
                path: U[di({
                    env: U
                })],
                pathExt: z ? fG.delimiter : void 0
            })
        } catch (j) {} finally {
            if (K) process.chdir(V)
        }
        if (x) x = fG.resolve(N ? v.options.cwd : "", x);
        return x
    }

    function oi(v) {
        return TG(v) || TG(v, !0)
    }
    YG.exports = oi
});
var yG = _((IA6, dJ) => {
    var QJ = /([()\][%!^"`<>&|;, *?])/g;

    function ri(v) {
        return v = v.replace(QJ, "^$1"), v
    }

    function ai(v, z) {
        if (v = `${v}`, v = v.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\""), v = v.replace(/(?=(\\+?)?)\1$/, "$1$1"), v = `"${v}"`, v = v.replace(QJ, "^$1"), z) v = v.replace(QJ, "^$1");
        return v
    }
    dJ.exports.command = ri;
    dJ.exports.argument = ai
});
var mG = _((MA6, kG) => {
    kG.exports = /^#!(.*)/
});
var gG = _((bA6, XG) => {
    var ti = mG();
    XG.exports = (v = "") => {
        let z = v.match(ti);
        if (!z) return null;
        let [U, V] = z[0].replace(/#! ?/, "").split(" "), N = U.split("/").pop();
        if (N === "env") return V;
        return V ? `${N} ${V}` : N
    }
});
var iG = _((RA6, cG) => {
    var oJ = require("fs"),
        si = gG();

    function ei(v) {
        let U = Buffer.alloc(150),
            V;
        try {
            V = oJ.openSync(v, "r"), oJ.readSync(V, U, 0, 150, 0), oJ.closeSync(V)
        } catch (N) {}
        return si(U.toString())
    }
    cG.exports = ei
});
var nG = _((WA6, pG) => {
    var vl = require("path"),
        lG = uG(),
        hG = yG(),
        zl = iG(),
        Ul = process.platform === "win32",
        Vl = /\.(?:com|exe)$/i,
        Nl = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

    function Kl(v) {
        v.file = lG(v);
        let z = v.file && zl(v.file);
        if (z) return v.args.unshift(v.file), v.command = z, lG(v);
        return v.file
    }

    function xl(v) {
        if (!Ul) return v;
        let z = Kl(v),
            U = !Vl.test(z);
        if (v.options.forceShell || U) {
            let V = Nl.test(z);
            v.command = vl.normalize(v.command), v.command = hG.command(v.command), v.args = v.args.map((K) => hG.argument(K, V));
            let N = [v.command].concat(v.args).join(" ");
            v.args = ["/d", "/s", "/c", `"${N}"`], v.command = process.env.comspec || "cmd.exe", v.options.windowsVerbatimArguments = !0
        }
        return v
    }

    function jl(v, z, U) {
        if (z && !Array.isArray(z)) U = z, z = null;
        z = z ? z.slice(0) : [], U = Object.assign({}, U);
        let V = {
            command: v,
            args: z,
            options: U,
            file: void 0,
            original: {
                command: v,
                args: z
            }
        };
        return U.shell ? V : xl(V)
    }
    pG.exports = jl
});
var oG = _((EA6, dG) => {
    var rJ = process.platform === "win32";

    function aJ(v, z) {
        return Object.assign(Error(`${z} ${v.command} ENOENT`), {
            code: "ENOENT",
            errno: "ENOENT",
            syscall: `${z} ${v.command}`,
            path: v.command,
            spawnargs: v.args
        })
    }

    function Bl(v, z) {
        if (!rJ) return;
        let U = v.emit;
        v.emit = function(V, N) {
            if (V === "exit") {
                let K = QG(N, z);
                if (K) return U.call(v, "error", K)
            }
            return U.apply(v, arguments)
        }
    }

    function QG(v, z) {
        if (rJ && v === 1 && !z.file) return aJ(z.original, "spawn");
        return null
    }

    function Ol(v, z) {
        if (rJ && v === 1 && !z.file) return aJ(z.original, "spawnSync");
        return null
    }
    dG.exports = {
        hookChildProcess: Bl,
        verifyENOENT: QG,
        verifyENOENTSync: Ol,
        notFoundError: aJ
    }
});
var eJ = _((SA6, m7) => {
    var rG = require("child_process"),
        tJ = nG(),
        sJ = oG();

    function aG(v, z, U) {
        let V = tJ(v, z, U),
            N = rG.spawn(V.command, V.args, V.options);
        return sJ.hookChildProcess(N, V), N
    }

    function Jl(v, z, U) {
        let V = tJ(v, z, U),
            N = rG.spawnSync(V.command, V.args, V.options);
        return N.error = N.error || sJ.verifyENOENTSync(N.status, V), N
    }
    m7.exports = aG;
    m7.exports.spawn = aG;
    m7.exports.sync = Jl;
    m7.exports._parse = tJ;
    m7.exports._enoent = sJ
});
var fI = _((b$6, CI) => {
    var {
        PassThrough: Uh
    } = require("stream");
    CI.exports = function() {
        var v = [],
            z = new Uh({
                objectMode: !0
            });
        return z.setMaxListeners(0), z.add = U, z.isEmpty = V, z.on("unpipe", N), Array.prototype.slice.call(arguments).forEach(U), z;

        function U(K) {
            if (Array.isArray(K)) return K.forEach(U), this;
            return v.push(K), K.once("end", N.bind(null, K)), K.once("error", z.emit.bind(z, "error")), K.pipe(z, {
                end: !1
            }), this
        }

        function V() {
            return v.length == 0
        }

        function N(K) {
            if (v = v.filter(function(x) {
                    return x !== K
                }), !v.length && z.readable) z.end()
        }
    }
});
var Nz = _((n$6, vM) => {
    var wh = Number.MAX_SAFE_INTEGER || 9007199254740991,
        Zh = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
    vM.exports = {
        MAX_LENGTH: 256,
        MAX_SAFE_COMPONENT_LENGTH: 16,
        MAX_SAFE_BUILD_LENGTH: 250,
        MAX_SAFE_INTEGER: wh,
        RELEASE_TYPES: Zh,
        SEMVER_SPEC_VERSION: "2.0.0",
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
    }
});
var Kz = _((Q$6, zM) => {
    var Lh = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...v) => console.error("SEMVER", ...v) : () => {};
    zM.exports = Lh
});
var c7 = _((P8, UM) => {
    var {
        MAX_SAFE_COMPONENT_LENGTH: Rq,
        MAX_SAFE_BUILD_LENGTH: Fh,
        MAX_LENGTH: Gh
    } = Nz(), Ih = Kz();
    P8 = UM.exports = {};
    var Mh = P8.re = [],
        bh = P8.safeRe = [],
        A6 = P8.src = [],
        Rh = P8.safeSrc = [],
        $6 = P8.t = {},
        Wh = 0,
        Wq = "[a-zA-Z0-9-]",
        Eh = [
            ["\\s", 1],
            ["\\d", Gh],
            [Wq, Fh]
        ],
        Sh = (v) => {
            for (let [z, U] of Eh) v = v.split(`${z}*`).join(`${z}{0,${U}}`).split(`${z}+`).join(`${z}{1,${U}}`);
            return v
        },
        o6 = (v, z, U) => {
            let V = Sh(z),
                N = Wh++;
            Ih(v, N, z), $6[v] = N, A6[N] = z, Rh[N] = V, Mh[N] = new RegExp(z, U ? "g" : void 0), bh[N] = new RegExp(V, U ? "g" : void 0)
        };
    o6("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    o6("NUMERICIDENTIFIERLOOSE", "\\d+");
    o6("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Wq}*`);
    o6("MAINVERSION", `(${A6[$6.NUMERICIDENTIFIER]})\\.(${A6[$6.NUMERICIDENTIFIER]})\\.(${A6[$6.NUMERICIDENTIFIER]})`);
    o6("MAINVERSIONLOOSE", `(${A6[$6.NUMERICIDENTIFIERLOOSE]})\\.(${A6[$6.NUMERICIDENTIFIERLOOSE]})\\.(${A6[$6.NUMERICIDENTIFIERLOOSE]})`);
    o6("PRERELEASEIDENTIFIER", `(?:${A6[$6.NONNUMERICIDENTIFIER]}|${A6[$6.NUMERICIDENTIFIER]})`);
    o6("PRERELEASEIDENTIFIERLOOSE", `(?:${A6[$6.NONNUMERICIDENTIFIER]}|${A6[$6.NUMERICIDENTIFIERLOOSE]})`);
    o6("PRERELEASE", `(?:-(${A6[$6.PRERELEASEIDENTIFIER]}(?:\\.${A6[$6.PRERELEASEIDENTIFIER]})*))`);
    o6("PRERELEASELOOSE", `(?:-?(${A6[$6.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${A6[$6.PRERELEASEIDENTIFIERLOOSE]})*))`);
    o6("BUILDIDENTIFIER", `${Wq}+`);
    o6("BUILD", `(?:\\+(${A6[$6.BUILDIDENTIFIER]}(?:\\.${A6[$6.BUILDIDENTIFIER]})*))`);
    o6("FULLPLAIN", `v?${A6[$6.MAINVERSION]}${A6[$6.PRERELEASE]}?${A6[$6.BUILD]}?`);
    o6("FULL", `^${A6[$6.FULLPLAIN]}$`);
    o6("LOOSEPLAIN", `[v=\\s]*${A6[$6.MAINVERSIONLOOSE]}${A6[$6.PRERELEASELOOSE]}?${A6[$6.BUILD]}?`);
    o6("LOOSE", `^${A6[$6.LOOSEPLAIN]}$`);
    o6("GTLT", "((?:<|>)?=?)");
    o6("XRANGEIDENTIFIERLOOSE", `${A6[$6.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    o6("XRANGEIDENTIFIER", `${A6[$6.NUMERICIDENTIFIER]}|x|X|\\*`);
    o6("XRANGEPLAIN", `[v=\\s]*(${A6[$6.XRANGEIDENTIFIER]})(?:\\.(${A6[$6.XRANGEIDENTIFIER]})(?:\\.(${A6[$6.XRANGEIDENTIFIER]})(?:${A6[$6.PRERELEASE]})?${A6[$6.BUILD]}?)?)?`);
    o6("XRANGEPLAINLOOSE", `[v=\\s]*(${A6[$6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${A6[$6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${A6[$6.XRANGEIDENTIFIERLOOSE]})(?:${A6[$6.PRERELEASELOOSE]})?${A6[$6.BUILD]}?)?)?`);
    o6("XRANGE", `^${A6[$6.GTLT]}\\s*${A6[$6.XRANGEPLAIN]}$`);
    o6("XRANGELOOSE", `^${A6[$6.GTLT]}\\s*${A6[$6.XRANGEPLAINLOOSE]}$`);
    o6("COERCEPLAIN", `(^|[^\\d])(\\d{1,${Rq}})(?:\\.(\\d{1,${Rq}}))?(?:\\.(\\d{1,${Rq}}))?`);
    o6("COERCE", `${A6[$6.COERCEPLAIN]}(?:$|[^\\d])`);
    o6("COERCEFULL", A6[$6.COERCEPLAIN] + `(?:${A6[$6.PRERELEASE]})?(?:${A6[$6.BUILD]})?(?:$|[^\\d])`);
    o6("COERCERTL", A6[$6.COERCE], !0);
    o6("COERCERTLFULL", A6[$6.COERCEFULL], !0);
    o6("LONETILDE", "(?:~>?)");
    o6("TILDETRIM", `(\\s*)${A6[$6.LONETILDE]}\\s+`, !0);
    P8.tildeTrimReplace = "$1~";
    o6("TILDE", `^${A6[$6.LONETILDE]}${A6[$6.XRANGEPLAIN]}$`);
    o6("TILDELOOSE", `^${A6[$6.LONETILDE]}${A6[$6.XRANGEPLAINLOOSE]}$`);
    o6("LONECARET", "(?:\\^)");
    o6("CARETTRIM", `(\\s*)${A6[$6.LONECARET]}\\s+`, !0);
    P8.caretTrimReplace = "$1^";
    o6("CARET", `^${A6[$6.LONECARET]}${A6[$6.XRANGEPLAIN]}$`);
    o6("CARETLOOSE", `^${A6[$6.LONECARET]}${A6[$6.XRANGEPLAINLOOSE]}$`);
    o6("COMPARATORLOOSE", `^${A6[$6.GTLT]}\\s*(${A6[$6.LOOSEPLAIN]})$|^$`);
    o6("COMPARATOR", `^${A6[$6.GTLT]}\\s*(${A6[$6.FULLPLAIN]})$|^$`);
    o6("COMPARATORTRIM", `(\\s*)${A6[$6.GTLT]}\\s*(${A6[$6.LOOSEPLAIN]}|${A6[$6.XRANGEPLAIN]})`, !0);
    P8.comparatorTrimReplace = "$1$2$3";
    o6("HYPHENRANGE", `^\\s*(${A6[$6.XRANGEPLAIN]})\\s+-\\s+(${A6[$6.XRANGEPLAIN]})\\s*$`);
    o6("HYPHENRANGELOOSE", `^\\s*(${A6[$6.XRANGEPLAINLOOSE]})\\s+-\\s+(${A6[$6.XRANGEPLAINLOOSE]})\\s*$`);
    o6("STAR", "(<|>)?=?\\s*\\*");
    o6("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    o6("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
});
var nN = _((d$6, VM) => {
    var Ph = Object.freeze({
            loose: !0
        }),
        _h = Object.freeze({}),
        Ch = (v) => {
            if (!v) return _h;
            if (typeof v !== "object") return Ph;
            return v
        };
    VM.exports = Ch
});
var Eq = _((o$6, xM) => {
    var NM = /^[0-9]+$/,
        KM = (v, z) => {
            let U = NM.test(v),
                V = NM.test(z);
            if (U && V) v = +v, z = +z;
            return v === z ? 0 : U && !V ? -1 : V && !U ? 1 : v < z ? -1 : 1
        },
        fh = (v, z) => KM(z, v);
    xM.exports = {
        compareIdentifiers: KM,
        rcompareIdentifiers: fh
    }
});
var X4 = _((r$6, BM) => {
    var QN = Kz(),
        {
            MAX_LENGTH: jM,
            MAX_SAFE_INTEGER: dN
        } = Nz(),
        {
            safeRe: oN,
            t: rN
        } = c7(),
        Th = nN(),
        {
            compareIdentifiers: i7
        } = Eq();
    class s3 {
        constructor(v, z) {
            if (z = Th(z), v instanceof s3)
                if (v.loose === !!z.loose && v.includePrerelease === !!z.includePrerelease) return v;
                else v = v.version;
            else if (typeof v !== "string") throw TypeError(`Invalid version. Must be a string. Got type "${typeof v}".`);
            if (v.length > jM) throw TypeError(`version is longer than ${jM} characters`);
            QN("SemVer", v, z), this.options = z, this.loose = !!z.loose, this.includePrerelease = !!z.includePrerelease;
            let U = v.trim().match(z.loose ? oN[rN.LOOSE] : oN[rN.FULL]);
            if (!U) throw TypeError(`Invalid Version: ${v}`);
            if (this.raw = v, this.major = +U[1], this.minor = +U[2], this.patch = +U[3], this.major > dN || this.major < 0) throw TypeError("Invalid major version");
            if (this.minor > dN || this.minor < 0) throw TypeError("Invalid minor version");
            if (this.patch > dN || this.patch < 0) throw TypeError("Invalid patch version");
            if (!U[4]) this.prerelease = [];
            else this.prerelease = U[4].split(".").map((V) => {
                if (/^[0-9]+$/.test(V)) {
                    let N = +V;
                    if (N >= 0 && N < dN) return N
                }
                return V
            });
            this.build = U[5] ? U[5].split(".") : [], this.format()
        }
        format() {
            if (this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
            return this.version
        }
        toString() {
            return this.version
        }
        compare(v) {
            if (QN("SemVer.compare", this.version, this.options, v), !(v instanceof s3)) {
                if (typeof v === "string" && v === this.version) return 0;
                v = new s3(v, this.options)
            }
            if (v.version === this.version) return 0;
            return this.compareMain(v) || this.comparePre(v)
        }
        compareMain(v) {
            if (!(v instanceof s3)) v = new s3(v, this.options);
            return i7(this.major, v.major) || i7(this.minor, v.minor) || i7(this.patch, v.patch)
        }
        comparePre(v) {
            if (!(v instanceof s3)) v = new s3(v, this.options);
            if (this.prerelease.length && !v.prerelease.length) return -1;
            else if (!this.prerelease.length && v.prerelease.length) return 1;
            else if (!this.prerelease.length && !v.prerelease.length) return 0;
            let z = 0;
            do {
                let U = this.prerelease[z],
                    V = v.prerelease[z];
                if (QN("prerelease compare", z, U, V), U === void 0 && V === void 0) return 0;
                else if (V === void 0) return 1;
                else if (U === void 0) return -1;
                else if (U === V) continue;
                else return i7(U, V)
            } while (++z)
        }
        compareBuild(v) {
            if (!(v instanceof s3)) v = new s3(v, this.options);
            let z = 0;
            do {
                let U = this.build[z],
                    V = v.build[z];
                if (QN("build compare", z, U, V), U === void 0 && V === void 0) return 0;
                else if (V === void 0) return 1;
                else if (U === void 0) return -1;
                else if (U === V) continue;
                else return i7(U, V)
            } while (++z)
        }
        inc(v, z, U) {
            if (v.startsWith("pre")) {
                if (!z && U === !1) throw Error("invalid increment argument: identifier is empty");
                if (z) {
                    let V = `-${z}`.match(this.options.loose ? oN[rN.PRERELEASELOOSE] : oN[rN.PRERELEASE]);
                    if (!V || V[1] !== z) throw Error(`invalid identifier: ${z}`)
                }
            }
            switch (v) {
                case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", z, U);
                    break;
                case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", z, U);
                    break;
                case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", z, U), this.inc("pre", z, U);
                    break;
                case "prerelease":
                    if (this.prerelease.length === 0) this.inc("patch", z, U);
                    this.inc("pre", z, U);
                    break;
                case "release":
                    if (this.prerelease.length === 0) throw Error(`version ${this.raw} is not a prerelease`);
                    this.prerelease.length = 0;
                    break;
                case "major":
                    if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
                    this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                case "minor":
                    if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
                    this.patch = 0, this.prerelease = [];
                    break;
                case "patch":
                    if (this.prerelease.length === 0) this.patch++;
                    this.prerelease = [];
                    break;
                case "pre": {
                    let V = Number(U) ? 1 : 0;
                    if (this.prerelease.length === 0) this.prerelease = [V];
                    else {
                        let N = this.prerelease.length;
                        while (--N >= 0)
                            if (typeof this.prerelease[N] === "number") this.prerelease[N]++, N = -2;
                        if (N === -1) {
                            if (z === this.prerelease.join(".") && U === !1) throw Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(V)
                        }
                    }
                    if (z) {
                        let N = [z, V];
                        if (U === !1) N = [z];
                        if (i7(this.prerelease[0], z) === 0) {
                            if (isNaN(this.prerelease[1])) this.prerelease = N
                        } else this.prerelease = N
                    }
                    break
                }
                default:
                    throw Error(`invalid increment argument: ${v}`)
            }
            if (this.raw = this.format(), this.build.length) this.raw += `+${this.build.join(".")}`;
            return this
        }
    }
    BM.exports = s3
});
var g5 = _((a$6, JM) => {
    var OM = X4(),
        Yh = (v, z, U = !1) => {
            if (v instanceof OM) return v;
            try {
                return new OM(v, z)
            } catch (V) {
                if (!U) return null;
                throw V
            }
        };
    JM.exports = Yh
});
var HM = _((t$6, qM) => {
    var uh = g5(),
        yh = (v, z) => {
            let U = uh(v, z);
            return U ? U.version : null
        };
    qM.exports = yh
});
var AM = _((s$6, DM) => {
    var kh = g5(),
        mh = (v, z) => {
            let U = kh(v.trim().replace(/^[=v]+/, ""), z);
            return U ? U.version : null
        };
    DM.exports = mh
});
var ZM = _((e$6, wM) => {
    var $M = X4(),
        Xh = (v, z, U, V, N) => {
            if (typeof U === "string") N = V, V = U, U = void 0;
            try {
                return new $M(v instanceof $M ? v.version : v, U).inc(z, V, N).version
            } catch (K) {
                return null
            }
        };
    wM.exports = Xh
});
var GM = _((vw6, FM) => {
    var LM = g5(),
        gh = (v, z) => {
            let U = LM(v, null, !0),
                V = LM(z, null, !0),
                N = U.compare(V);
            if (N === 0) return null;
            let K = N > 0,
                x = K ? U : V,
                j = K ? V : U,
                B = !!x.prerelease.length;
            if (!!j.prerelease.length && !B) {
                if (!j.patch && !j.minor) return "major";
                if (j.compareMain(x) === 0) {
                    if (j.minor && !j.patch) return "minor";
                    return "patch"
                }
            }
            let J = B ? "pre" : "";
            if (U.major !== V.major) return J + "major";
            if (U.minor !== V.minor) return J + "minor";
            if (U.patch !== V.patch) return J + "patch";
            return "prerelease"
        };
    FM.exports = gh
});
var MM = _((zw6, IM) => {
    var ch = X4(),
        ih = (v, z) => new ch(v, z).major;
    IM.exports = ih
});
var RM = _((Uw6, bM) => {
    var lh = X4(),
        hh = (v, z) => new lh(v, z).minor;
    bM.exports = hh
});
var EM = _((Vw6, WM) => {
    var ph = X4(),
        nh = (v, z) => new ph(v, z).patch;
    WM.exports = nh
});
var PM = _((Nw6, SM) => {
    var Qh = g5(),
        dh = (v, z) => {
            let U = Qh(v, z);
            return U && U.prerelease.length ? U.prerelease : null
        };
    SM.exports = dh
});
var X3 = _((Kw6, CM) => {
    var _M = X4(),
        oh = (v, z, U) => new _M(v, U).compare(new _M(z, U));
    CM.exports = oh
});
var TM = _((xw6, fM) => {
    var rh = X3(),
        ah = (v, z, U) => rh(z, v, U);
    fM.exports = ah
});
var uM = _((jw6, YM) => {
    var th = X3(),
        sh = (v, z) => th(v, z, !0);
    YM.exports = sh
});
var aN = _((Bw6, kM) => {
    var yM = X4(),
        eh = (v, z, U) => {
            let V = new yM(v, U),
                N = new yM(z, U);
            return V.compare(N) || V.compareBuild(N)
        };
    kM.exports = eh
});
var XM = _((Ow6, mM) => {
    var vp = aN(),
        zp = (v, z) => v.sort((U, V) => vp(U, V, z));
    mM.exports = zp
});
var cM = _((Jw6, gM) => {
    var Up = aN(),
        Vp = (v, z) => v.sort((U, V) => Up(V, U, z));
    gM.exports = Vp
});
var xz = _((qw6, iM) => {
    var Np = X3(),
        Kp = (v, z, U) => Np(v, z, U) > 0;
    iM.exports = Kp
});
var tN = _((Hw6, lM) => {
    var xp = X3(),
        jp = (v, z, U) => xp(v, z, U) < 0;
    lM.exports = jp
});
var Sq = _((Dw6, hM) => {
    var Bp = X3(),
        Op = (v, z, U) => Bp(v, z, U) === 0;
    hM.exports = Op
});
var Pq = _((Aw6, pM) => {
    var Jp = X3(),
        qp = (v, z, U) => Jp(v, z, U) !== 0;
    pM.exports = qp
});
var sN = _(($w6, nM) => {
    var Hp = X3(),
        Dp = (v, z, U) => Hp(v, z, U) >= 0;
    nM.exports = Dp
});
var eN = _((ww6, QM) => {
    var Ap = X3(),
        $p = (v, z, U) => Ap(v, z, U) <= 0;
    QM.exports = $p
});
var _q = _((Zw6, dM) => {
    var wp = Sq(),
        Zp = Pq(),
        Lp = xz(),
        Fp = sN(),
        Gp = tN(),
        Ip = eN(),
        Mp = (v, z, U, V) => {
            switch (z) {
                case "===":
                    if (typeof v === "object") v = v.version;
                    if (typeof U === "object") U = U.version;
                    return v === U;
                case "!==":
                    if (typeof v === "object") v = v.version;
                    if (typeof U === "object") U = U.version;
                    return v !== U;
                case "":
                case "=":
                case "==":
                    return wp(v, U, V);
                case "!=":
                    return Zp(v, U, V);
                case ">":
                    return Lp(v, U, V);
                case ">=":
                    return Fp(v, U, V);
                case "<":
                    return Gp(v, U, V);
                case "<=":
                    return Ip(v, U, V);
                default:
                    throw TypeError(`Invalid operator: ${z}`)
            }
        };
    dM.exports = Mp
});
var rM = _((Lw6, oM) => {
    var bp = X4(),
        Rp = g5(),
        {
            safeRe: vK,
            t: zK
        } = c7(),
        Wp = (v, z) => {
            if (v instanceof bp) return v;
            if (typeof v === "number") v = String(v);
            if (typeof v !== "string") return null;
            z = z || {};
            let U = null;
            if (!z.rtl) U = v.match(z.includePrerelease ? vK[zK.COERCEFULL] : vK[zK.COERCE]);
            else {
                let B = z.includePrerelease ? vK[zK.COERCERTLFULL] : vK[zK.COERCERTL],
                    O;
                while ((O = B.exec(v)) && (!U || U.index + U[0].length !== v.length)) {
                    if (!U || O.index + O[0].length !== U.index + U[0].length) U = O;
                    B.lastIndex = O.index + O[1].length + O[2].length
                }
                B.lastIndex = -1
            }
            if (U === null) return null;
            let V = U[2],
                N = U[3] || "0",
                K = U[4] || "0",
                x = z.includePrerelease && U[5] ? `-${U[5]}` : "",
                j = z.includePrerelease && U[6] ? `+${U[6]}` : "";
            return Rp(`${V}.${N}.${K}${x}${j}`, z)
        };
    oM.exports = Wp
});
var sM = _((Fw6, tM) => {
    class aM {
        constructor() {
            this.max = 1000, this.map = new Map
        }
        get(v) {
            let z = this.map.get(v);
            if (z === void 0) return;
            else return this.map.delete(v), this.map.set(v, z), z
        }
        delete(v) {
            return this.map.delete(v)
        }
        set(v, z) {
            if (!this.delete(v) && z !== void 0) {
                if (this.map.size >= this.max) {
                    let V = this.map.keys().next().value;
                    this.delete(V)
                }
                this.map.set(v, z)
            }
            return this
        }
    }
    tM.exports = aM
});
var g3 = _((Gw6, Ub) => {
    var Ep = /\s+/g;
    class jz {
        constructor(v, z) {
            if (z = Pp(z), v instanceof jz)
                if (v.loose === !!z.loose && v.includePrerelease === !!z.includePrerelease) return v;
                else return new jz(v.raw, z);
            if (v instanceof Cq) return this.raw = v.value, this.set = [
                [v]
            ], this.formatted = void 0, this;
            if (this.options = z, this.loose = !!z.loose, this.includePrerelease = !!z.includePrerelease, this.raw = v.trim().replace(Ep, " "), this.set = this.raw.split("||").map((U) => this.parseRange(U.trim())).filter((U) => U.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
                let U = this.set[0];
                if (this.set = this.set.filter((V) => !vb(V[0])), this.set.length === 0) this.set = [U];
                else if (this.set.length > 1) {
                    for (let V of this.set)
                        if (V.length === 1 && yp(V[0])) {
                            this.set = [V];
                            break
                        }
                }
            }
            this.formatted = void 0
        }
        get range() {
            if (this.formatted === void 0) {
                this.formatted = "";
                for (let v = 0; v < this.set.length; v++) {
                    if (v > 0) this.formatted += "||";
                    let z = this.set[v];
                    for (let U = 0; U < z.length; U++) {
                        if (U > 0) this.formatted += " ";
                        this.formatted += z[U].toString().trim()
                    }
                }
            }
            return this.formatted
        }
        format() {
            return this.range
        }
        toString() {
            return this.range
        }
        parseRange(v) {
            let U = ((this.options.includePrerelease && Yp) | (this.options.loose && up)) + ":" + v,
                V = eM.get(U);
            if (V) return V;
            let N = this.options.loose,
                K = N ? j3[r4.HYPHENRANGELOOSE] : j3[r4.HYPHENRANGE];
            v = v.replace(K, np(this.options.includePrerelease)), y0("hyphen replace", v), v = v.replace(j3[r4.COMPARATORTRIM], Cp), y0("comparator trim", v), v = v.replace(j3[r4.TILDETRIM], fp), y0("tilde trim", v), v = v.replace(j3[r4.CARETTRIM], Tp), y0("caret trim", v);
            let x = v.split(" ").map((J) => kp(J, this.options)).join(" ").split(/\s+/).map((J) => pp(J, this.options));
            if (N) x = x.filter((J) => {
                return y0("loose invalid filter", J, this.options), !!J.match(j3[r4.COMPARATORLOOSE])
            });
            y0("range list", x);
            let j = new Map,
                B = x.map((J) => new Cq(J, this.options));
            for (let J of B) {
                if (vb(J)) return [J];
                j.set(J.value, J)
            }
            if (j.size > 1 && j.has("")) j.delete("");
            let O = [...j.values()];
            return eM.set(U, O), O
        }
        intersects(v, z) {
            if (!(v instanceof jz)) throw TypeError("a Range is required");
            return this.set.some((U) => {
                return zb(U, z) && v.set.some((V) => {
                    return zb(V, z) && U.every((N) => {
                        return V.every((K) => {
                            return N.intersects(K, z)
                        })
                    })
                })
            })
        }
        test(v) {
            if (!v) return !1;
            if (typeof v === "string") try {
                v = new _p(v, this.options)
            } catch (z) {
                return !1
            }
            for (let z = 0; z < this.set.length; z++)
                if (Qp(this.set[z], v, this.options)) return !0;
            return !1
        }
    }
    Ub.exports = jz;
    var Sp = sM(),
        eM = new Sp,
        Pp = nN(),
        Cq = Bz(),
        y0 = Kz(),
        _p = X4(),
        {
            safeRe: j3,
            t: r4,
            comparatorTrimReplace: Cp,
            tildeTrimReplace: fp,
            caretTrimReplace: Tp
        } = c7(),
        {
            FLAG_INCLUDE_PRERELEASE: Yp,
            FLAG_LOOSE: up
        } = Nz(),
        vb = (v) => v.value === "<0.0.0-0",
        yp = (v) => v.value === "",
        zb = (v, z) => {
            let U = !0,
                V = v.slice(),
                N = V.pop();
            while (U && V.length) U = V.every((K) => {
                return N.intersects(K, z)
            }), N = V.pop();
            return U
        },
        kp = (v, z) => {
            return y0("comp", v, z), v = gp(v, z), y0("caret", v), v = mp(v, z), y0("tildes", v), v = ip(v, z), y0("xrange", v), v = hp(v, z), y0("stars", v), v
        },
        a4 = (v) => !v || v.toLowerCase() === "x" || v === "*",
        mp = (v, z) => {
            return v.trim().split(/\s+/).map((U) => Xp(U, z)).join(" ")
        },
        Xp = (v, z) => {
            let U = z.loose ? j3[r4.TILDELOOSE] : j3[r4.TILDE];
            return v.replace(U, (V, N, K, x, j) => {
                y0("tilde", v, V, N, K, x, j);
                let B;
                if (a4(N)) B = "";
                else if (a4(K)) B = `>=${N}.0.0 <${+N+1}.0.0-0`;
                else if (a4(x)) B = `>=${N}.${K}.0 <${N}.${+K+1}.0-0`;
                else if (j) y0("replaceTilde pr", j), B = `>=${N}.${K}.${x}-${j} <${N}.${+K+1}.0-0`;
                else B = `>=${N}.${K}.${x} <${N}.${+K+1}.0-0`;
                return y0("tilde return", B), B
            })
        },
        gp = (v, z) => {
            return v.trim().split(/\s+/).map((U) => cp(U, z)).join(" ")
        },
        cp = (v, z) => {
            y0("caret", v, z);
            let U = z.loose ? j3[r4.CARETLOOSE] : j3[r4.CARET],
                V = z.includePrerelease ? "-0" : "";
            return v.replace(U, (N, K, x, j, B) => {
                y0("caret", v, N, K, x, j, B);
                let O;
                if (a4(K)) O = "";
                else if (a4(x)) O = `>=${K}.0.0${V} <${+K+1}.0.0-0`;
                else if (a4(j))
                    if (K === "0") O = `>=${K}.${x}.0${V} <${K}.${+x+1}.0-0`;
                    else O = `>=${K}.${x}.0${V} <${+K+1}.0.0-0`;
                else if (B)
                    if (y0("replaceCaret pr", B), K === "0")
                        if (x === "0") O = `>=${K}.${x}.${j}-${B} <${K}.${x}.${+j+1}-0`;
                        else O = `>=${K}.${x}.${j}-${B} <${K}.${+x+1}.0-0`;
                else O = `>=${K}.${x}.${j}-${B} <${+K+1}.0.0-0`;
                else if (y0("no pr"), K === "0")
                    if (x === "0") O = `>=${K}.${x}.${j}${V} <${K}.${x}.${+j+1}-0`;
                    else O = `>=${K}.${x}.${j}${V} <${K}.${+x+1}.0-0`;
                else O = `>=${K}.${x}.${j} <${+K+1}.0.0-0`;
                return y0("caret return", O), O
            })
        },
        ip = (v, z) => {
            return y0("replaceXRanges", v, z), v.split(/\s+/).map((U) => lp(U, z)).join(" ")
        },
        lp = (v, z) => {
            v = v.trim();
            let U = z.loose ? j3[r4.XRANGELOOSE] : j3[r4.XRANGE];
            return v.replace(U, (V, N, K, x, j, B) => {
                y0("xRange", v, V, N, K, x, j, B);
                let O = a4(K),
                    J = O || a4(x),
                    q = J || a4(j),
                    H = q;
                if (N === "=" && H) N = "";
                if (B = z.includePrerelease ? "-0" : "", O)
                    if (N === ">" || N === "<") V = "<0.0.0-0";
                    else V = "*";
                else if (N && H) {
                    if (J) x = 0;
                    if (j = 0, N === ">")
                        if (N = ">=", J) K = +K + 1, x = 0, j = 0;
                        else x = +x + 1, j = 0;
                    else if (N === "<=")
                        if (N = "<", J) K = +K + 1;
                        else x = +x + 1;
                    if (N === "<") B = "-0";
                    V = `${N+K}.${x}.${j}${B}`
                } else if (J) V = `>=${K}.0.0${B} <${+K+1}.0.0-0`;
                else if (q) V = `>=${K}.${x}.0${B} <${K}.${+x+1}.0-0`;
                return y0("xRange return", V), V
            })
        },
        hp = (v, z) => {
            return y0("replaceStars", v, z), v.trim().replace(j3[r4.STAR], "")
        },
        pp = (v, z) => {
            return y0("replaceGTE0", v, z), v.trim().replace(j3[z.includePrerelease ? r4.GTE0PRE : r4.GTE0], "")
        },
        np = (v) => (z, U, V, N, K, x, j, B, O, J, q, H) => {
            if (a4(V)) U = "";
            else if (a4(N)) U = `>=${V}.0.0${v?"-0":""}`;
            else if (a4(K)) U = `>=${V}.${N}.0${v?"-0":""}`;
            else if (x) U = `>=${U}`;
            else U = `>=${U}${v?"-0":""}`;
            if (a4(O)) B = "";
            else if (a4(J)) B = `<${+O+1}.0.0-0`;
            else if (a4(q)) B = `<${O}.${+J+1}.0-0`;
            else if (H) B = `<=${O}.${J}.${q}-${H}`;
            else if (v) B = `<${O}.${J}.${+q+1}-0`;
            else B = `<=${B}`;
            return `${U} ${B}`.trim()
        },
        Qp = (v, z, U) => {
            for (let V = 0; V < v.length; V++)
                if (!v[V].test(z)) return !1;
            if (z.prerelease.length && !U.includePrerelease) {
                for (let V = 0; V < v.length; V++) {
                    if (y0(v[V].semver), v[V].semver === Cq.ANY) continue;
                    if (v[V].semver.prerelease.length > 0) {
                        let N = v[V].semver;
                        if (N.major === z.major && N.minor === z.minor && N.patch === z.patch) return !0
                    }
                }
                return !1
            }
            return !0
        }
});
var Bz = _((Iw6, Bb) => {
    var Oz = Symbol("SemVer ANY");
    class UK {
        static get ANY() {
            return Oz
        }
        constructor(v, z) {
            if (z = Vb(z), v instanceof UK)
                if (v.loose === !!z.loose) return v;
                else v = v.value;
            if (v = v.trim().split(/\s+/).join(" "), Tq("comparator", v, z), this.options = z, this.loose = !!z.loose, this.parse(v), this.semver === Oz) this.value = "";
            else this.value = this.operator + this.semver.version;
            Tq("comp", this)
        }
        parse(v) {
            let z = this.options.loose ? Nb[Kb.COMPARATORLOOSE] : Nb[Kb.COMPARATOR],
                U = v.match(z);
            if (!U) throw TypeError(`Invalid comparator: ${v}`);
            if (this.operator = U[1] !== void 0 ? U[1] : "", this.operator === "=") this.operator = "";
            if (!U[2]) this.semver = Oz;
            else this.semver = new xb(U[2], this.options.loose)
        }
        toString() {
            return this.value
        }
        test(v) {
            if (Tq("Comparator.test", v, this.options.loose), this.semver === Oz || v === Oz) return !0;
            if (typeof v === "string") try {
                v = new xb(v, this.options)
            } catch (z) {
                return !1
            }
            return fq(v, this.operator, this.semver, this.options)
        }
        intersects(v, z) {
            if (!(v instanceof UK)) throw TypeError("a Comparator is required");
            if (this.operator === "") {
                if (this.value === "") return !0;
                return new jb(v.value, z).test(this.value)
            } else if (v.operator === "") {
                if (v.value === "") return !0;
                return new jb(this.value, z).test(v.semver)
            }
            if (z = Vb(z), z.includePrerelease && (this.value === "<0.0.0-0" || v.value === "<0.0.0-0")) return !1;
            if (!z.includePrerelease && (this.value.startsWith("<0.0.0") || v.value.startsWith("<0.0.0"))) return !1;
            if (this.operator.startsWith(">") && v.operator.startsWith(">")) return !0;
            if (this.operator.startsWith("<") && v.operator.startsWith("<")) return !0;
            if (this.semver.version === v.semver.version && this.operator.includes("=") && v.operator.includes("=")) return !0;
            if (fq(this.semver, "<", v.semver, z) && this.operator.startsWith(">") && v.operator.startsWith("<")) return !0;
            if (fq(this.semver, ">", v.semver, z) && this.operator.startsWith("<") && v.operator.startsWith(">")) return !0;
            return !1
        }
    }
    Bb.exports = UK;
    var Vb = nN(),
        {
            safeRe: Nb,
            t: Kb
        } = c7(),
        fq = _q(),
        Tq = Kz(),
        xb = X4(),
        jb = g3()
});
var Jz = _((Mw6, Ob) => {
    var dp = g3(),
        op = (v, z, U) => {
            try {
                z = new dp(z, U)
            } catch (V) {
                return !1
            }
            return z.test(v)
        };
    Ob.exports = op
});
var qb = _((bw6, Jb) => {
    var rp = g3(),
        ap = (v, z) => new rp(v, z).set.map((U) => U.map((V) => V.value).join(" ").trim().split(" "));
    Jb.exports = ap
});
var Db = _((Rw6, Hb) => {
    var tp = X4(),
        sp = g3(),
        ep = (v, z, U) => {
            let V = null,
                N = null,
                K = null;
            try {
                K = new sp(z, U)
            } catch (x) {
                return null
            }
            return v.forEach((x) => {
                if (K.test(x)) {
                    if (!V || N.compare(x) === -1) V = x, N = new tp(V, U)
                }
            }), V
        };
    Hb.exports = ep
});
var $b = _((Ww6, Ab) => {
    var vn = X4(),
        zn = g3(),
        Un = (v, z, U) => {
            let V = null,
                N = null,
                K = null;
            try {
                K = new zn(z, U)
            } catch (x) {
                return null
            }
            return v.forEach((x) => {
                if (K.test(x)) {
                    if (!V || N.compare(x) === 1) V = x, N = new vn(V, U)
                }
            }), V
        };
    Ab.exports = Un
});
var Lb = _((Ew6, Zb) => {
    var Yq = X4(),
        Vn = g3(),
        wb = xz(),
        Nn = (v, z) => {
            v = new Vn(v, z);
            let U = new Yq("0.0.0");
            if (v.test(U)) return U;
            if (U = new Yq("0.0.0-0"), v.test(U)) return U;
            U = null;
            for (let V = 0; V < v.set.length; ++V) {
                let N = v.set[V],
                    K = null;
                if (N.forEach((x) => {
                        let j = new Yq(x.semver.version);
                        switch (x.operator) {
                            case ">":
                                if (j.prerelease.length === 0) j.patch++;
                                else j.prerelease.push(0);
                                j.raw = j.format();
                            case "":
                            case ">=":
                                if (!K || wb(j, K)) K = j;
                                break;
                            case "<":
                            case "<=":
                                break;
                            default:
                                throw Error(`Unexpected operation: ${x.operator}`)
                        }
                    }), K && (!U || wb(U, K))) U = K
            }
            if (U && v.test(U)) return U;
            return null
        };
    Zb.exports = Nn
});
var Gb = _((Sw6, Fb) => {
    var Kn = g3(),
        xn = (v, z) => {
            try {
                return new Kn(v, z).range || "*"
            } catch (U) {
                return null
            }
        };
    Fb.exports = xn
});
var VK = _((Pw6, Rb) => {
    var jn = X4(),
        bb = Bz(),
        {
            ANY: Bn
        } = bb,
        On = g3(),
        Jn = Jz(),
        Ib = xz(),
        Mb = tN(),
        qn = eN(),
        Hn = sN(),
        Dn = (v, z, U, V) => {
            v = new jn(v, V), z = new On(z, V);
            let N, K, x, j, B;
            switch (U) {
                case ">":
                    N = Ib, K = qn, x = Mb, j = ">", B = ">=";
                    break;
                case "<":
                    N = Mb, K = Hn, x = Ib, j = "<", B = "<=";
                    break;
                default:
                    throw TypeError('Must provide a hilo val of "<" or ">"')
            }
            if (Jn(v, z, V)) return !1;
            for (let O = 0; O < z.set.length; ++O) {
                let J = z.set[O],
                    q = null,
                    H = null;
                if (J.forEach((D) => {
                        if (D.semver === Bn) D = new bb(">=0.0.0");
                        if (q = q || D, H = H || D, N(D.semver, q.semver, V)) q = D;
                        else if (x(D.semver, H.semver, V)) H = D
                    }), q.operator === j || q.operator === B) return !1;
                if ((!H.operator || H.operator === j) && K(v, H.semver)) return !1;
                else if (H.operator === B && x(v, H.semver)) return !1
            }
            return !0
        };
    Rb.exports = Dn
});
var Eb = _((_w6, Wb) => {
    var An = VK(),
        $n = (v, z, U) => An(v, z, ">", U);
    Wb.exports = $n
});
var Pb = _((Cw6, Sb) => {
    var wn = VK(),
        Zn = (v, z, U) => wn(v, z, "<", U);
    Sb.exports = Zn
});
var fb = _((fw6, Cb) => {
    var _b = g3(),
        Ln = (v, z, U) => {
            return v = new _b(v, U), z = new _b(z, U), v.intersects(z, U)
        };
    Cb.exports = Ln
});
var Yb = _((Tw6, Tb) => {
    var Fn = Jz(),
        Gn = X3();
    Tb.exports = (v, z, U) => {
        let V = [],
            N = null,
            K = null,
            x = v.sort((J, q) => Gn(J, q, U));
        for (let J of x)
            if (Fn(J, z, U)) {
                if (K = J, !N) N = J
            } else {
                if (K) V.push([N, K]);
                K = null, N = null
            } if (N) V.push([N, null]);
        let j = [];
        for (let [J, q] of V)
            if (J === q) j.push(J);
            else if (!q && J === x[0]) j.push("*");
        else if (!q) j.push(`>=${J}`);
        else if (J === x[0]) j.push(`<=${q}`);
        else j.push(`${J} - ${q}`);
        let B = j.join(" || "),
            O = typeof z.raw === "string" ? z.raw : String(z);
        return B.length < O.length ? B : z
    }
});
var gb = _((Yw6, Xb) => {
    var ub = g3(),
        yq = Bz(),
        {
            ANY: uq
        } = yq,
        qz = Jz(),
        kq = X3(),
        In = (v, z, U = {}) => {
            if (v === z) return !0;
            v = new ub(v, U), z = new ub(z, U);
            let V = !1;
            v: for (let N of v.set) {
                for (let K of z.set) {
                    let x = bn(N, K, U);
                    if (V = V || x !== null, x) continue v
                }
                if (V) return !1
            }
            return !0
        },
        Mn = [new yq(">=0.0.0-0")],
        yb = [new yq(">=0.0.0")],
        bn = (v, z, U) => {
            if (v === z) return !0;
            if (v.length === 1 && v[0].semver === uq)
                if (z.length === 1 && z[0].semver === uq) return !0;
                else if (U.includePrerelease) v = Mn;
            else v = yb;
            if (z.length === 1 && z[0].semver === uq)
                if (U.includePrerelease) return !0;
                else z = yb;
            let V = new Set,
                N, K;
            for (let D of v)
                if (D.operator === ">" || D.operator === ">=") N = kb(N, D, U);
                else if (D.operator === "<" || D.operator === "<=") K = mb(K, D, U);
            else V.add(D.semver);
            if (V.size > 1) return null;
            let x;
            if (N && K) {
                if (x = kq(N.semver, K.semver, U), x > 0) return null;
                else if (x === 0 && (N.operator !== ">=" || K.operator !== "<=")) return null
            }
            for (let D of V) {
                if (N && !qz(D, String(N), U)) return null;
                if (K && !qz(D, String(K), U)) return null;
                for (let A of z)
                    if (!qz(D, String(A), U)) return !1;
                return !0
            }
            let j, B, O, J, q = K && !U.includePrerelease && K.semver.prerelease.length ? K.semver : !1,
                H = N && !U.includePrerelease && N.semver.prerelease.length ? N.semver : !1;
            if (q && q.prerelease.length === 1 && K.operator === "<" && q.prerelease[0] === 0) q = !1;
            for (let D of z) {
                if (J = J || D.operator === ">" || D.operator === ">=", O = O || D.operator === "<" || D.operator === "<=", N) {
                    if (H) {
                        if (D.semver.prerelease && D.semver.prerelease.length && D.semver.major === H.major && D.semver.minor === H.minor && D.semver.patch === H.patch) H = !1
                    }
                    if (D.operator === ">" || D.operator === ">=") {
                        if (j = kb(N, D, U), j === D && j !== N) return !1
                    } else if (N.operator === ">=" && !qz(N.semver, String(D), U)) return !1
                }
                if (K) {
                    if (q) {
                        if (D.semver.prerelease && D.semver.prerelease.length && D.semver.major === q.major && D.semver.minor === q.minor && D.semver.patch === q.patch) q = !1
                    }
                    if (D.operator === "<" || D.operator === "<=") {
                        if (B = mb(K, D, U), B === D && B !== K) return !1
                    } else if (K.operator === "<=" && !qz(K.semver, String(D), U)) return !1
                }
                if (!D.operator && (K || N) && x !== 0) return !1
            }
            if (N && O && !K && x !== 0) return !1;
            if (K && J && !N && x !== 0) return !1;
            if (H || q) return !1;
            return !0
        },
        kb = (v, z, U) => {
            if (!v) return z;
            let V = kq(v.semver, z.semver, U);
            return V > 0 ? v : V < 0 ? z : z.operator === ">" && v.operator === ">=" ? z : v
        },
        mb = (v, z, U) => {
            if (!v) return z;
            let V = kq(v.semver, z.semver, U);
            return V < 0 ? v : V > 0 ? z : z.operator === "<" && v.operator === "<=" ? z : v
        };
    Xb.exports = In
});
var Xq = _((uw6, lb) => {
    var mq = c7(),
        cb = Nz(),
        Rn = X4(),
        ib = Eq(),
        Wn = g5(),
        En = HM(),
        Sn = AM(),
        Pn = ZM(),
        _n = GM(),
        Cn = MM(),
        fn = RM(),
        Tn = EM(),
        Yn = PM(),
        un = X3(),
        yn = TM(),
        kn = uM(),
        mn = aN(),
        Xn = XM(),
        gn = cM(),
        cn = xz(),
        ln = tN(),
        hn = Sq(),
        pn = Pq(),
        nn = sN(),
        Qn = eN(),
        dn = _q(),
        on = rM(),
        rn = Bz(),
        an = g3(),
        tn = Jz(),
        sn = qb(),
        en = Db(),
        vQ = $b(),
        zQ = Lb(),
        UQ = Gb(),
        VQ = VK(),
        NQ = Eb(),
        KQ = Pb(),
        xQ = fb(),
        jQ = Yb(),
        BQ = gb();
    lb.exports = {
        parse: Wn,
        valid: En,
        clean: Sn,
        inc: Pn,
        diff: _n,
        major: Cn,
        minor: fn,
        patch: Tn,
        prerelease: Yn,
        compare: un,
        rcompare: yn,
        compareLoose: kn,
        compareBuild: mn,
        sort: Xn,
        rsort: gn,
        gt: cn,
        lt: ln,
        eq: hn,
        neq: pn,
        gte: nn,
        lte: Qn,
        cmp: dn,
        coerce: on,
        Comparator: rn,
        Range: an,
        satisfies: tn,
        toComparators: sn,
        maxSatisfying: en,
        minSatisfying: vQ,
        minVersion: zQ,
        validRange: UQ,
        outside: VQ,
        gtr: NQ,
        ltr: KQ,
        intersects: xQ,
        simplifyRange: jQ,
        subset: BQ,
        SemVer: Rn,
        re: mq.re,
        src: mq.src,
        tokens: mq.t,
        SEMVER_SPEC_VERSION: cb.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: cb.RELEASE_TYPES,
        compareIdentifiers: ib.compareIdentifiers,
        rcompareIdentifiers: ib.rcompareIdentifiers
    }
});
var SS = _((ML6, ES) => {
    var WS = require("stream").Stream,
        _86 = require("util");
    ES.exports = q8;

    function q8() {
        this.source = null, this.dataSize = 0, this.maxDataSize = 1048576, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = []
    }
    _86.inherits(q8, WS);
    q8.create = function(v, z) {
        var U = new this;
        z = z || {};
        for (var V in z) U[V] = z[V];
        U.source = v;
        var N = v.emit;
        if (v.emit = function() {
                return U._handleEmit(arguments), N.apply(v, arguments)
            }, v.on("error", function() {}), U.pauseStream) v.pause();
        return U
    };
    Object.defineProperty(q8.prototype, "readable", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return this.source.readable
        }
    });
    q8.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments)
    };
    q8.prototype.resume = function() {
        if (!this._released) this.release();
        this.source.resume()
    };
    q8.prototype.pause = function() {
        this.source.pause()
    };
    q8.prototype.release = function() {
        this._released = !0, this._bufferedEvents.forEach(function(v) {
            this.emit.apply(this, v)
        }.bind(this)), this._bufferedEvents = []
    };
    q8.prototype.pipe = function() {
        var v = WS.prototype.pipe.apply(this, arguments);
        return this.resume(), v
    };
    q8.prototype._handleEmit = function(v) {
        if (this._released) {
            this.emit.apply(this, v);
            return
        }
        if (v[0] === "data") this.dataSize += v[1].length, this._checkIfMaxDataSizeExceeded();
        this._bufferedEvents.push(v)
    };
    q8.prototype._checkIfMaxDataSizeExceeded = function() {
        if (this._maxDataSizeExceeded) return;
        if (this.dataSize <= this.maxDataSize) return;
        this._maxDataSizeExceeded = !0;
        var v = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", Error(v))
    }
});
var fS = _((bL6, CS) => {
    var C86 = require("util"),
        _S = require("stream").Stream,
        PS = SS();
    CS.exports = e0;

    function e0() {
        this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2097152, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1
    }
    C86.inherits(e0, _S);
    e0.create = function(v) {
        var z = new this;
        v = v || {};
        for (var U in v) z[U] = v[U];
        return z
    };
    e0.isStreamLike = function(v) {
        return typeof v !== "function" && typeof v !== "string" && typeof v !== "boolean" && typeof v !== "number" && !Buffer.isBuffer(v)
    };
    e0.prototype.append = function(v) {
        var z = e0.isStreamLike(v);
        if (z) {
            if (!(v instanceof PS)) {
                var U = PS.create(v, {
                    maxDataSize: 1 / 0,
                    pauseStream: this.pauseStreams
                });
                v.on("data", this._checkDataSize.bind(this)), v = U
            }
            if (this._handleErrors(v), this.pauseStreams) v.pause()
        }
        return this._streams.push(v), this
    };
    e0.prototype.pipe = function(v, z) {
        return _S.prototype.pipe.call(this, v, z), this.resume(), v
    };
    e0.prototype._getNext = function() {
        if (this._currentStream = null, this._insideLoop) {
            this._pendingNext = !0;
            return
        }
        this._insideLoop = !0;
        try {
            do this._pendingNext = !1, this._realGetNext(); while (this._pendingNext)
        } finally {
            this._insideLoop = !1
        }
    };
    e0.prototype._realGetNext = function() {
        var v = this._streams.shift();
        if (typeof v > "u") {
            this.end();
            return
        }
        if (typeof v !== "function") {
            this._pipeNext(v);
            return
        }
        var z = v;
        z(function(U) {
            var V = e0.isStreamLike(U);
            if (V) U.on("data", this._checkDataSize.bind(this)), this._handleErrors(U);
            this._pipeNext(U)
        }.bind(this))
    };
    e0.prototype._pipeNext = function(v) {
        this._currentStream = v;
        var z = e0.isStreamLike(v);
        if (z) {
            v.on("end", this._getNext.bind(this)), v.pipe(this, {
                end: !1
            });
            return
        }
        var U = v;
        this.write(U), this._getNext()
    };
    e0.prototype._handleErrors = function(v) {
        var z = this;
        v.on("error", function(U) {
            z._emitError(U)
        })
    };
    e0.prototype.write = function(v) {
        this.emit("data", v)
    };
    e0.prototype.pause = function() {
        if (!this.pauseStreams) return;
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
        this.emit("pause")
    };
    e0.prototype.resume = function() {
        if (!this._released) this._released = !0, this.writable = !0, this._getNext();
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
        this.emit("resume")
    };
    e0.prototype.end = function() {
        this._reset(), this.emit("end")
    };
    e0.prototype.destroy = function() {
        this._reset(), this.emit("close")
    };
    e0.prototype._reset = function() {
        this.writable = !1, this._streams = [], this._currentStream = null
    };
    e0.prototype._checkDataSize = function() {
        if (this._updateDataSize(), this.dataSize <= this.maxDataSize) return;
        var v = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(Error(v))
    };
    e0.prototype._updateDataSize = function() {
        this.dataSize = 0;
        var v = this;
        if (this._streams.forEach(function(z) {
                if (!z.dataSize) return;
                v.dataSize += z.dataSize
            }), this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize
    };
    e0.prototype._emitError = function(v) {
        this._reset(), this.emit("error", v)
    }
});
var TS = _((RL6, f86) => {
    f86.exports = {
        "application/1d-interleaved-parityfec": {
            source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/3gpp-ims+xml": {
            source: "iana",
            compressible: !0
        },
        "application/3gpphal+json": {
            source: "iana",
            compressible: !0
        },
        "application/3gpphalforms+json": {
            source: "iana",
            compressible: !0
        },
        "application/a2l": {
            source: "iana"
        },
        "application/ace+cbor": {
            source: "iana"
        },
        "application/activemessage": {
            source: "iana"
        },
        "application/activity+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-costmap+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-costmapfilter+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-directory+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-endpointcost+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-endpointcostparams+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-endpointprop+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-endpointpropparams+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-error+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-networkmap+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-networkmapfilter+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-updatestreamcontrol+json": {
            source: "iana",
            compressible: !0
        },
        "application/alto-updatestreamparams+json": {
            source: "iana",
            compressible: !0
        },
        "application/aml": {
            source: "iana"
        },
        "application/andrew-inset": {
            source: "iana",
            extensions: ["ez"]
        },
        "application/applefile": {
            source: "iana"
        },
        "application/applixware": {
            source: "apache",
            extensions: ["aw"]
        },
        "application/at+jwt": {
            source: "iana"
        },
        "application/atf": {
            source: "iana"
        },
        "application/atfx": {
            source: "iana"
        },
        "application/atom+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["atom"]
        },
        "application/atomcat+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
            source: "iana"
        },
        "application/atomsvc+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
            source: "iana"
        },
        "application/atsc-held+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["held"]
        },
        "application/atsc-rdt+json": {
            source: "iana",
            compressible: !0
        },
        "application/atsc-rsat+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rsat"]
        },
        "application/atxml": {
            source: "iana"
        },
        "application/auth-policy+xml": {
            source: "iana",
            compressible: !0
        },
        "application/bacnet-xdd+zip": {
            source: "iana",
            compressible: !1
        },
        "application/batch-smtp": {
            source: "iana"
        },
        "application/bdoc": {
            compressible: !1,
            extensions: ["bdoc"]
        },
        "application/beep+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/calendar+json": {
            source: "iana",
            compressible: !0
        },
        "application/calendar+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xcs"]
        },
        "application/call-completion": {
            source: "iana"
        },
        "application/cals-1840": {
            source: "iana"
        },
        "application/captive+json": {
            source: "iana",
            compressible: !0
        },
        "application/cbor": {
            source: "iana"
        },
        "application/cbor-seq": {
            source: "iana"
        },
        "application/cccex": {
            source: "iana"
        },
        "application/ccmp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/ccxml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
            source: "iana",
            extensions: ["cdmia"]
        },
        "application/cdmi-container": {
            source: "iana",
            extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
            source: "iana",
            extensions: ["cdmid"]
        },
        "application/cdmi-object": {
            source: "iana",
            extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
            source: "iana",
            extensions: ["cdmiq"]
        },
        "application/cdni": {
            source: "iana"
        },
        "application/cea": {
            source: "iana"
        },
        "application/cea-2018+xml": {
            source: "iana",
            compressible: !0
        },
        "application/cellml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/cfw": {
            source: "iana"
        },
        "application/city+json": {
            source: "iana",
            compressible: !0
        },
        "application/clr": {
            source: "iana"
        },
        "application/clue+xml": {
            source: "iana",
            compressible: !0
        },
        "application/clue_info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/cms": {
            source: "iana"
        },
        "application/cnrp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/coap-group+json": {
            source: "iana",
            compressible: !0
        },
        "application/coap-payload": {
            source: "iana"
        },
        "application/commonground": {
            source: "iana"
        },
        "application/conference-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/cose": {
            source: "iana"
        },
        "application/cose-key": {
            source: "iana"
        },
        "application/cose-key-set": {
            source: "iana"
        },
        "application/cpl+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["cpl"]
        },
        "application/csrattrs": {
            source: "iana"
        },
        "application/csta+xml": {
            source: "iana",
            compressible: !0
        },
        "application/cstadata+xml": {
            source: "iana",
            compressible: !0
        },
        "application/csvm+json": {
            source: "iana",
            compressible: !0
        },
        "application/cu-seeme": {
            source: "apache",
            extensions: ["cu"]
        },
        "application/cwt": {
            source: "iana"
        },
        "application/cybercash": {
            source: "iana"
        },
        "application/dart": {
            compressible: !0
        },
        "application/dash+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mpd"]
        },
        "application/dash-patch+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mpp"]
        },
        "application/dashdelta": {
            source: "iana"
        },
        "application/davmount+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["davmount"]
        },
        "application/dca-rft": {
            source: "iana"
        },
        "application/dcd": {
            source: "iana"
        },
        "application/dec-dx": {
            source: "iana"
        },
        "application/dialog-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/dicom": {
            source: "iana"
        },
        "application/dicom+json": {
            source: "iana",
            compressible: !0
        },
        "application/dicom+xml": {
            source: "iana",
            compressible: !0
        },
        "application/dii": {
            source: "iana"
        },
        "application/dit": {
            source: "iana"
        },
        "application/dns": {
            source: "iana"
        },
        "application/dns+json": {
            source: "iana",
            compressible: !0
        },
        "application/dns-message": {
            source: "iana"
        },
        "application/docbook+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["dbk"]
        },
        "application/dots+cbor": {
            source: "iana"
        },
        "application/dskpp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/dssc+der": {
            source: "iana",
            extensions: ["dssc"]
        },
        "application/dssc+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xdssc"]
        },
        "application/dvcs": {
            source: "iana"
        },
        "application/ecmascript": {
            source: "iana",
            compressible: !0,
            extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
            source: "iana"
        },
        "application/edi-x12": {
            source: "iana",
            compressible: !1
        },
        "application/edifact": {
            source: "iana",
            compressible: !1
        },
        "application/efi": {
            source: "iana"
        },
        "application/elm+json": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/elm+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.cap+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/emergencycalldata.comment+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.control+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.deviceinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.ecall.msd": {
            source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.serviceinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.subscriberinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emergencycalldata.veds+xml": {
            source: "iana",
            compressible: !0
        },
        "application/emma+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["emma"]
        },
        "application/emotionml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["emotionml"]
        },
        "application/encaprtp": {
            source: "iana"
        },
        "application/epp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/epub+zip": {
            source: "iana",
            compressible: !1,
            extensions: ["epub"]
        },
        "application/eshop": {
            source: "iana"
        },
        "application/exi": {
            source: "iana",
            extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
            source: "iana",
            compressible: !0
        },
        "application/express": {
            source: "iana",
            extensions: ["exp"]
        },
        "application/fastinfoset": {
            source: "iana"
        },
        "application/fastsoap": {
            source: "iana"
        },
        "application/fdt+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["fdt"]
        },
        "application/fhir+json": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/fhir+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/fido.trusted-apps+json": {
            compressible: !0
        },
        "application/fits": {
            source: "iana"
        },
        "application/flexfec": {
            source: "iana"
        },
        "application/font-sfnt": {
            source: "iana"
        },
        "application/font-tdpfr": {
            source: "iana",
            extensions: ["pfr"]
        },
        "application/font-woff": {
            source: "iana",
            compressible: !1
        },
        "application/framework-attributes+xml": {
            source: "iana",
            compressible: !0
        },
        "application/geo+json": {
            source: "iana",
            compressible: !0,
            extensions: ["geojson"]
        },
        "application/geo+json-seq": {
            source: "iana"
        },
        "application/geopackage+sqlite3": {
            source: "iana"
        },
        "application/geoxacml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/gltf-buffer": {
            source: "iana"
        },
        "application/gml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["gml"]
        },
        "application/gpx+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["gpx"]
        },
        "application/gxf": {
            source: "apache",
            extensions: ["gxf"]
        },
        "application/gzip": {
            source: "iana",
            compressible: !1,
            extensions: ["gz"]
        },
        "application/h224": {
            source: "iana"
        },
        "application/held+xml": {
            source: "iana",
            compressible: !0
        },
        "application/hjson": {
            extensions: ["hjson"]
        },
        "application/http": {
            source: "iana"
        },
        "application/hyperstudio": {
            source: "iana",
            extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/ibe-pkg-reply+xml": {
            source: "iana",
            compressible: !0
        },
        "application/ibe-pp-data": {
            source: "iana"
        },
        "application/iges": {
            source: "iana"
        },
        "application/im-iscomposing+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/index": {
            source: "iana"
        },
        "application/index.cmd": {
            source: "iana"
        },
        "application/index.obj": {
            source: "iana"
        },
        "application/index.response": {
            source: "iana"
        },
        "application/index.vnd": {
            source: "iana"
        },
        "application/inkml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["ink", "inkml"]
        },
        "application/iotp": {
            source: "iana"
        },
        "application/ipfix": {
            source: "iana",
            extensions: ["ipfix"]
        },
        "application/ipp": {
            source: "iana"
        },
        "application/isup": {
            source: "iana"
        },
        "application/its+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["its"]
        },
        "application/java-archive": {
            source: "apache",
            compressible: !1,
            extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
            source: "apache",
            compressible: !1,
            extensions: ["ser"]
        },
        "application/java-vm": {
            source: "apache",
            compressible: !1,
            extensions: ["class"]
        },
        "application/javascript": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
            source: "iana",
            compressible: !0
        },
        "application/jose": {
            source: "iana"
        },
        "application/jose+json": {
            source: "iana",
            compressible: !0
        },
        "application/jrd+json": {
            source: "iana",
            compressible: !0
        },
        "application/jscalendar+json": {
            source: "iana",
            compressible: !0
        },
        "application/json": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["json", "map"]
        },
        "application/json-patch+json": {
            source: "iana",
            compressible: !0
        },
        "application/json-seq": {
            source: "iana"
        },
        "application/json5": {
            extensions: ["json5"]
        },
        "application/jsonml+json": {
            source: "apache",
            compressible: !0,
            extensions: ["jsonml"]
        },
        "application/jwk+json": {
            source: "iana",
            compressible: !0
        },
        "application/jwk-set+json": {
            source: "iana",
            compressible: !0
        },
        "application/jwt": {
            source: "iana"
        },
        "application/kpml-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/kpml-response+xml": {
            source: "iana",
            compressible: !0
        },
        "application/ld+json": {
            source: "iana",
            compressible: !0,
            extensions: ["jsonld"]
        },
        "application/lgr+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["lgr"]
        },
        "application/link-format": {
            source: "iana"
        },
        "application/load-control+xml": {
            source: "iana",
            compressible: !0
        },
        "application/lost+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
            source: "iana",
            compressible: !0
        },
        "application/lpf+zip": {
            source: "iana",
            compressible: !1
        },
        "application/lxf": {
            source: "iana"
        },
        "application/mac-binhex40": {
            source: "iana",
            extensions: ["hqx"]
        },
        "application/mac-compactpro": {
            source: "apache",
            extensions: ["cpt"]
        },
        "application/macwriteii": {
            source: "iana"
        },
        "application/mads+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mads"]
        },
        "application/manifest+json": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["webmanifest"]
        },
        "application/marc": {
            source: "iana",
            extensions: ["mrc"]
        },
        "application/marcxml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mrcx"]
        },
        "application/mathematica": {
            source: "iana",
            extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mathml-presentation+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-associated-procedure-description+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-deregister+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-envelope+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-msk+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-msk-response+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-protection-description+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-reception-report+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-register+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-register-response+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-schedule+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbms-user-service-description+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mbox": {
            source: "iana",
            extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mpf"]
        },
        "application/media_control+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mediaservercontrol+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mscml"]
        },
        "application/merge-patch+json": {
            source: "iana",
            compressible: !0
        },
        "application/metalink+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["metalink"]
        },
        "application/metalink4+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["meta4"]
        },
        "application/mets+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mets"]
        },
        "application/mf4": {
            source: "iana"
        },
        "application/mikey": {
            source: "iana"
        },
        "application/mipc": {
            source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
            source: "iana"
        },
        "application/mmt-aei+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["musd"]
        },
        "application/mods+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mods"]
        },
        "application/moss-keys": {
            source: "iana"
        },
        "application/moss-signature": {
            source: "iana"
        },
        "application/mosskey-data": {
            source: "iana"
        },
        "application/mosskey-request": {
            source: "iana"
        },
        "application/mp21": {
            source: "iana",
            extensions: ["m21", "mp21"]
        },
        "application/mp4": {
            source: "iana",
            extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
            source: "iana"
        },
        "application/mpeg4-iod": {
            source: "iana"
        },
        "application/mpeg4-iod-xmt": {
            source: "iana"
        },
        "application/mrb-consumer+xml": {
            source: "iana",
            compressible: !0
        },
        "application/mrb-publish+xml": {
            source: "iana",
            compressible: !0
        },
        "application/msc-ivr+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/msc-mixer+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/msword": {
            source: "iana",
            compressible: !1,
            extensions: ["doc", "dot"]
        },
        "application/mud+json": {
            source: "iana",
            compressible: !0
        },
        "application/multipart-core": {
            source: "iana"
        },
        "application/mxf": {
            source: "iana",
            extensions: ["mxf"]
        },
        "application/n-quads": {
            source: "iana",
            extensions: ["nq"]
        },
        "application/n-triples": {
            source: "iana",
            extensions: ["nt"]
        },
        "application/nasdata": {
            source: "iana"
        },
        "application/news-checkgroups": {
            source: "iana",
            charset: "US-ASCII"
        },
        "application/news-groupinfo": {
            source: "iana",
            charset: "US-ASCII"
        },
        "application/news-transmission": {
            source: "iana"
        },
        "application/nlsml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/node": {
            source: "iana",
            extensions: ["cjs"]
        },
        "application/nss": {
            source: "iana"
        },
        "application/oauth-authz-req+jwt": {
            source: "iana"
        },
        "application/oblivious-dns-message": {
            source: "iana"
        },
        "application/ocsp-request": {
            source: "iana"
        },
        "application/ocsp-response": {
            source: "iana"
        },
        "application/octet-stream": {
            source: "iana",
            compressible: !1,
            extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
            source: "iana",
            extensions: ["oda"]
        },
        "application/odm+xml": {
            source: "iana",
            compressible: !0
        },
        "application/odx": {
            source: "iana"
        },
        "application/oebps-package+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["opf"]
        },
        "application/ogg": {
            source: "iana",
            compressible: !1,
            extensions: ["ogx"]
        },
        "application/omdoc+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["omdoc"]
        },
        "application/onenote": {
            source: "apache",
            extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
            source: "iana",
            compressible: !0
        },
        "application/oscore": {
            source: "iana"
        },
        "application/oxps": {
            source: "iana",
            extensions: ["oxps"]
        },
        "application/p21": {
            source: "iana"
        },
        "application/p21+zip": {
            source: "iana",
            compressible: !1
        },
        "application/p2p-overlay+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["relo"]
        },
        "application/parityfec": {
            source: "iana"
        },
        "application/passport": {
            source: "iana"
        },
        "application/patch-ops-error+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xer"]
        },
        "application/pdf": {
            source: "iana",
            compressible: !1,
            extensions: ["pdf"]
        },
        "application/pdx": {
            source: "iana"
        },
        "application/pem-certificate-chain": {
            source: "iana"
        },
        "application/pgp-encrypted": {
            source: "iana",
            compressible: !1,
            extensions: ["pgp"]
        },
        "application/pgp-keys": {
            source: "iana",
            extensions: ["asc"]
        },
        "application/pgp-signature": {
            source: "iana",
            extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
            source: "apache",
            extensions: ["prf"]
        },
        "application/pidf+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/pidf-diff+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/pkcs10": {
            source: "iana",
            extensions: ["p10"]
        },
        "application/pkcs12": {
            source: "iana"
        },
        "application/pkcs7-mime": {
            source: "iana",
            extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
            source: "iana",
            extensions: ["p7s"]
        },
        "application/pkcs8": {
            source: "iana",
            extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
            source: "iana"
        },
        "application/pkix-attr-cert": {
            source: "iana",
            extensions: ["ac"]
        },
        "application/pkix-cert": {
            source: "iana",
            extensions: ["cer"]
        },
        "application/pkix-crl": {
            source: "iana",
            extensions: ["crl"]
        },
        "application/pkix-pkipath": {
            source: "iana",
            extensions: ["pkipath"]
        },
        "application/pkixcmp": {
            source: "iana",
            extensions: ["pki"]
        },
        "application/pls+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["pls"]
        },
        "application/poc-settings+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/postscript": {
            source: "iana",
            compressible: !0,
            extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
            source: "iana",
            compressible: !0
        },
        "application/problem+json": {
            source: "iana",
            compressible: !0
        },
        "application/problem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/provenance+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
            source: "iana"
        },
        "application/prs.cww": {
            source: "iana",
            extensions: ["cww"]
        },
        "application/prs.cyn": {
            source: "iana",
            charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
            source: "iana",
            compressible: !1
        },
        "application/prs.nprend": {
            source: "iana"
        },
        "application/prs.plucker": {
            source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
            source: "iana"
        },
        "application/prs.xsf+xml": {
            source: "iana",
            compressible: !0
        },
        "application/pskc+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["pskcxml"]
        },
        "application/pvd+json": {
            source: "iana",
            compressible: !0
        },
        "application/qsig": {
            source: "iana"
        },
        "application/raml+yaml": {
            compressible: !0,
            extensions: ["raml"]
        },
        "application/raptorfec": {
            source: "iana"
        },
        "application/rdap+json": {
            source: "iana",
            compressible: !0
        },
        "application/rdf+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
            source: "iana",
            extensions: ["rnc"]
        },
        "application/remote-printing": {
            source: "iana"
        },
        "application/reputon+json": {
            source: "iana",
            compressible: !0
        },
        "application/resource-lists+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rld"]
        },
        "application/rfc+xml": {
            source: "iana",
            compressible: !0
        },
        "application/riscos": {
            source: "iana"
        },
        "application/rlmi+xml": {
            source: "iana",
            compressible: !0
        },
        "application/rls-services+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rs"]
        },
        "application/route-apd+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["sls"]
        },
        "application/route-usd+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
            source: "iana",
            extensions: ["gbr"]
        },
        "application/rpki-manifest": {
            source: "iana",
            extensions: ["mft"]
        },
        "application/rpki-publication": {
            source: "iana"
        },
        "application/rpki-roa": {
            source: "iana",
            extensions: ["roa"]
        },
        "application/rpki-updown": {
            source: "iana"
        },
        "application/rsd+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["rsd"]
        },
        "application/rss+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["rss"]
        },
        "application/rtf": {
            source: "iana",
            compressible: !0,
            extensions: ["rtf"]
        },
        "application/rtploopback": {
            source: "iana"
        },
        "application/rtx": {
            source: "iana"
        },
        "application/samlassertion+xml": {
            source: "iana",
            compressible: !0
        },
        "application/samlmetadata+xml": {
            source: "iana",
            compressible: !0
        },
        "application/sarif+json": {
            source: "iana",
            compressible: !0
        },
        "application/sarif-external-properties+json": {
            source: "iana",
            compressible: !0
        },
        "application/sbe": {
            source: "iana"
        },
        "application/sbml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["sbml"]
        },
        "application/scaip+xml": {
            source: "iana",
            compressible: !0
        },
        "application/scim+json": {
            source: "iana",
            compressible: !0
        },
        "application/scvp-cv-request": {
            source: "iana",
            extensions: ["scq"]
        },
        "application/scvp-cv-response": {
            source: "iana",
            extensions: ["scs"]
        },
        "application/scvp-vp-request": {
            source: "iana",
            extensions: ["spq"]
        },
        "application/scvp-vp-response": {
            source: "iana",
            extensions: ["spp"]
        },
        "application/sdp": {
            source: "iana",
            extensions: ["sdp"]
        },
        "application/secevent+jwt": {
            source: "iana"
        },
        "application/senml+cbor": {
            source: "iana"
        },
        "application/senml+json": {
            source: "iana",
            compressible: !0
        },
        "application/senml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
            source: "iana"
        },
        "application/senml-etch+json": {
            source: "iana",
            compressible: !0
        },
        "application/senml-exi": {
            source: "iana"
        },
        "application/sensml+cbor": {
            source: "iana"
        },
        "application/sensml+json": {
            source: "iana",
            compressible: !0
        },
        "application/sensml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
            source: "iana"
        },
        "application/sep+xml": {
            source: "iana",
            compressible: !0
        },
        "application/sep-exi": {
            source: "iana"
        },
        "application/session-info": {
            source: "iana"
        },
        "application/set-payment": {
            source: "iana"
        },
        "application/set-payment-initiation": {
            source: "iana",
            extensions: ["setpay"]
        },
        "application/set-registration": {
            source: "iana"
        },
        "application/set-registration-initiation": {
            source: "iana",
            extensions: ["setreg"]
        },
        "application/sgml": {
            source: "iana"
        },
        "application/sgml-open-catalog": {
            source: "iana"
        },
        "application/shf+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["shf"]
        },
        "application/sieve": {
            source: "iana",
            extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
            source: "iana",
            compressible: !0
        },
        "application/simple-message-summary": {
            source: "iana"
        },
        "application/simplesymbolcontainer": {
            source: "iana"
        },
        "application/sipc": {
            source: "iana"
        },
        "application/slate": {
            source: "iana"
        },
        "application/smil": {
            source: "iana"
        },
        "application/smil+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
            source: "iana"
        },
        "application/soap+fastinfoset": {
            source: "iana"
        },
        "application/soap+xml": {
            source: "iana",
            compressible: !0
        },
        "application/sparql-query": {
            source: "iana",
            extensions: ["rq"]
        },
        "application/sparql-results+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["srx"]
        },
        "application/spdx+json": {
            source: "iana",
            compressible: !0
        },
        "application/spirits-event+xml": {
            source: "iana",
            compressible: !0
        },
        "application/sql": {
            source: "iana"
        },
        "application/srgs": {
            source: "iana",
            extensions: ["gram"]
        },
        "application/srgs+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["grxml"]
        },
        "application/sru+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["sru"]
        },
        "application/ssdl+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["ssdl"]
        },
        "application/ssml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["ssml"]
        },
        "application/stix+json": {
            source: "iana",
            compressible: !0
        },
        "application/swid+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
            source: "iana"
        },
        "application/tamp-apex-update-confirm": {
            source: "iana"
        },
        "application/tamp-community-update": {
            source: "iana"
        },
        "application/tamp-community-update-confirm": {
            source: "iana"
        },
        "application/tamp-error": {
            source: "iana"
        },
        "application/tamp-sequence-adjust": {
            source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
            source: "iana"
        },
        "application/tamp-status-query": {
            source: "iana"
        },
        "application/tamp-status-response": {
            source: "iana"
        },
        "application/tamp-update": {
            source: "iana"
        },
        "application/tamp-update-confirm": {
            source: "iana"
        },
        "application/tar": {
            compressible: !0
        },
        "application/taxii+json": {
            source: "iana",
            compressible: !0
        },
        "application/td+json": {
            source: "iana",
            compressible: !0
        },
        "application/tei+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
            source: "iana"
        },
        "application/thraud+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["tfi"]
        },
        "application/timestamp-query": {
            source: "iana"
        },
        "application/timestamp-reply": {
            source: "iana"
        },
        "application/timestamped-data": {
            source: "iana",
            extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
            source: "iana"
        },
        "application/tlsrpt+json": {
            source: "iana",
            compressible: !0
        },
        "application/tnauthlist": {
            source: "iana"
        },
        "application/token-introspection+jwt": {
            source: "iana"
        },
        "application/toml": {
            compressible: !0,
            extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
            source: "iana"
        },
        "application/trig": {
            source: "iana",
            extensions: ["trig"]
        },
        "application/ttml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["ttml"]
        },
        "application/tve-trigger": {
            source: "iana"
        },
        "application/tzif": {
            source: "iana"
        },
        "application/tzif-leap": {
            source: "iana"
        },
        "application/ubjson": {
            compressible: !1,
            extensions: ["ubj"]
        },
        "application/ulpfec": {
            source: "iana"
        },
        "application/urc-grpsheet+xml": {
            source: "iana",
            compressible: !0
        },
        "application/urc-ressheet+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vcard+json": {
            source: "iana",
            compressible: !0
        },
        "application/vcard+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vemmi": {
            source: "iana"
        },
        "application/vividence.scriptfile": {
            source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp-v2x-local-service-information": {
            source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
            source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.bsf+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.gmop+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.gtpc": {
            source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
            source: "iana"
        },
        "application/vnd.3gpp.lpp": {
            source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
            source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcdata-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcdata-payload": {
            source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcdata-signalling": {
            source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.mid-call+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.ngap": {
            source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
            source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
            source: "iana",
            extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
            source: "iana",
            extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
            source: "iana",
            extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
            source: "iana"
        },
        "application/vnd.3gpp.sms": {
            source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.srvcc-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp.ussd+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.3gpp2.sms": {
            source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
            source: "iana",
            extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
            source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
            source: "iana",
            extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
            source: "iana",
            extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
            source: "iana",
            extensions: ["imp"]
        },
        "application/vnd.acucobol": {
            source: "iana",
            extensions: ["acu"]
        },
        "application/vnd.acucorp": {
            source: "iana",
            extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
            source: "apache",
            compressible: !1,
            extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
            source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
            source: "iana",
            extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
            source: "iana",
            extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
            source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
            source: "iana",
            extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
            source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
            source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
            source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
            source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
            source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
            source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
            source: "iana"
        },
        "application/vnd.afpc.modca": {
            source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
            source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
            source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
            source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
            source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
            source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
            source: "iana"
        },
        "application/vnd.age": {
            source: "iana",
            extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
            source: "iana"
        },
        "application/vnd.ahead.space": {
            source: "iana",
            extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
            source: "iana",
            extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
            source: "iana",
            extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.amazon.ebook": {
            source: "apache",
            extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
            source: "iana"
        },
        "application/vnd.americandynamics.acc": {
            source: "iana",
            extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
            source: "iana",
            extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.android.ota": {
            source: "iana"
        },
        "application/vnd.android.package-archive": {
            source: "apache",
            compressible: !1,
            extensions: ["apk"]
        },
        "application/vnd.anki": {
            source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
            source: "iana",
            extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
            source: "apache",
            extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
            source: "iana",
            extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
            source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
            source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
            source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
            source: "iana"
        },
        "application/vnd.apache.thrift.json": {
            source: "iana"
        },
        "application/vnd.api+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.aplextor.warrp+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.apothekende.reservation+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.apple.installer+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
            source: "iana",
            extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
            source: "iana",
            extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
            source: "iana",
            extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
            source: "iana",
            extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
            compressible: !1,
            extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
            source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
            source: "iana",
            extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.artsquare": {
            source: "iana"
        },
        "application/vnd.astraea-software.iota": {
            source: "iana",
            extensions: ["iota"]
        },
        "application/vnd.audiograph": {
            source: "iana",
            extensions: ["aep"]
        },
        "application/vnd.autopackage": {
            source: "iana"
        },
        "application/vnd.avalon+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.avistar+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.balsamiq.bmml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
            source: "iana"
        },
        "application/vnd.banana-accounting": {
            source: "iana"
        },
        "application/vnd.bbf.usp.error": {
            source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
            source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.bekitzur-stech+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.bint.med-content": {
            source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.blink-idb-value-wrapper": {
            source: "iana"
        },
        "application/vnd.blueice.multipass": {
            source: "iana",
            extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
            source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
            source: "iana"
        },
        "application/vnd.bmi": {
            source: "iana",
            extensions: ["bmi"]
        },
        "application/vnd.bpf": {
            source: "iana"
        },
        "application/vnd.bpf3": {
            source: "iana"
        },
        "application/vnd.businessobjects": {
            source: "iana",
            extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cab-jscript": {
            source: "iana"
        },
        "application/vnd.canon-cpdl": {
            source: "iana"
        },
        "application/vnd.canon-lips": {
            source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cendio.thinlinc.clientconf": {
            source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
            source: "iana"
        },
        "application/vnd.chemdraw+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
            source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
            source: "iana",
            extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
            source: "iana"
        },
        "application/vnd.cinderella": {
            source: "iana",
            extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
            source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["csl"]
        },
        "application/vnd.claymore": {
            source: "iana",
            extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
            source: "iana",
            extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
            source: "iana",
            extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
            source: "iana",
            extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
            source: "iana",
            extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
            source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
            source: "iana"
        },
        "application/vnd.collection+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.collection.doc+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.collection.next+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.comicbook+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.comicbook-rar": {
            source: "iana"
        },
        "application/vnd.commerce-battelle": {
            source: "iana"
        },
        "application/vnd.commonspace": {
            source: "iana",
            extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
            source: "iana",
            extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cosmocaller": {
            source: "iana",
            extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
            source: "iana",
            extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
            source: "iana",
            extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
            source: "iana",
            extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
            source: "iana",
            extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
            source: "iana",
            extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.crypto-shade-file": {
            source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
            source: "iana"
        },
        "application/vnd.cryptomator.vault": {
            source: "iana"
        },
        "application/vnd.ctc-posml": {
            source: "iana",
            extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cups-pdf": {
            source: "iana"
        },
        "application/vnd.cups-postscript": {
            source: "iana"
        },
        "application/vnd.cups-ppd": {
            source: "iana",
            extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
            source: "iana"
        },
        "application/vnd.cups-raw": {
            source: "iana"
        },
        "application/vnd.curl": {
            source: "iana"
        },
        "application/vnd.curl.car": {
            source: "apache",
            extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
            source: "apache",
            extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cybank": {
            source: "iana"
        },
        "application/vnd.cyclonedx+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.cyclonedx+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.d3m-dataset": {
            source: "iana"
        },
        "application/vnd.d3m-problem": {
            source: "iana"
        },
        "application/vnd.dart": {
            source: "iana",
            compressible: !0,
            extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
            source: "iana",
            extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dataresource+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dbf": {
            source: "iana",
            extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
            source: "iana"
        },
        "application/vnd.dece.data": {
            source: "iana",
            extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
            source: "iana",
            extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
            source: "iana",
            extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
            source: "iana",
            extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
            source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
            source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dna": {
            source: "iana",
            extensions: ["dna"]
        },
        "application/vnd.document+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dolby.mlp": {
            source: "apache",
            extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
            source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
            source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
            source: "iana"
        },
        "application/vnd.dpgraph": {
            source: "iana",
            extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
            source: "iana",
            extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ds-keypoint": {
            source: "apache",
            extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
            source: "iana"
        },
        "application/vnd.dtg.local.flash": {
            source: "iana"
        },
        "application/vnd.dtg.local.html": {
            source: "iana"
        },
        "application/vnd.dvb.ait": {
            source: "iana",
            extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.dvbj": {
            source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
            source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
            source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
            source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
            source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
            source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
            source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
            source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
            source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-container+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-generic+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.notif-init+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.dvb.pfr": {
            source: "iana"
        },
        "application/vnd.dvb.service": {
            source: "iana",
            extensions: ["svc"]
        },
        "application/vnd.dxr": {
            source: "iana"
        },
        "application/vnd.dynageo": {
            source: "iana",
            extensions: ["geo"]
        },
        "application/vnd.dzr": {
            source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
            source: "iana"
        },
        "application/vnd.ecdis-update": {
            source: "iana"
        },
        "application/vnd.ecip.rlp": {
            source: "iana"
        },
        "application/vnd.eclipse.ditto+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ecowin.chart": {
            source: "iana",
            extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
            source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
            source: "iana"
        },
        "application/vnd.ecowin.series": {
            source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
            source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
            source: "iana"
        },
        "application/vnd.efi.img": {
            source: "iana"
        },
        "application/vnd.efi.iso": {
            source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.enliven": {
            source: "iana",
            extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
            source: "iana"
        },
        "application/vnd.eprints.data+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.epson.esf": {
            source: "iana",
            extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
            source: "iana",
            extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
            source: "iana",
            extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
            source: "iana",
            extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
            source: "iana",
            extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
            source: "iana"
        },
        "application/vnd.espass-espass+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.eszigno3+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.asic-e+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.etsi.asic-s+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.etsi.cug+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvcommand+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvprofile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvservice+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvsync+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.iptvueprofile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.mcid+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.mheg5": {
            source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.pstn+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.sci+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.simservs+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.timestamp-token": {
            source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.etsi.tsl.der": {
            source: "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.eudora.data": {
            source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
            source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
            source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
            source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.exstream-package": {
            source: "iana"
        },
        "application/vnd.ezpix-album": {
            source: "iana",
            extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
            source: "iana",
            extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
            source: "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.fastcopy-disk-image": {
            source: "iana"
        },
        "application/vnd.fdf": {
            source: "iana",
            extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
            source: "iana",
            extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
            source: "iana",
            extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
            source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.filmit.zfc": {
            source: "iana"
        },
        "application/vnd.fints": {
            source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
            source: "iana"
        },
        "application/vnd.flographit": {
            source: "iana",
            extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
            source: "iana",
            extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
            source: "iana"
        },
        "application/vnd.framemaker": {
            source: "iana",
            extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
            source: "iana",
            extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
            source: "iana",
            extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
            source: "iana",
            extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
            source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
            source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
            source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.fujitsu.oasys": {
            source: "iana",
            extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
            source: "iana",
            extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
            source: "iana",
            extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
            source: "iana",
            extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
            source: "iana",
            extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
            source: "iana"
        },
        "application/vnd.fujixerox.art4": {
            source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
            source: "iana",
            extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
            source: "iana",
            extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
            source: "iana",
            extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
            source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
            source: "iana"
        },
        "application/vnd.fut-misnet": {
            source: "iana"
        },
        "application/vnd.futoin+cbor": {
            source: "iana"
        },
        "application/vnd.futoin+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.fuzzysheet": {
            source: "iana",
            extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
            source: "iana",
            extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.geo+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.geocube+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.geogebra.file": {
            source: "iana",
            extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
            source: "iana"
        },
        "application/vnd.geogebra.tool": {
            source: "iana",
            extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
            source: "iana",
            extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
            source: "iana",
            extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
            source: "iana",
            extensions: ["g2w"]
        },
        "application/vnd.geospace": {
            source: "iana",
            extensions: ["g3w"]
        },
        "application/vnd.gerber": {
            source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
            source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
            source: "iana"
        },
        "application/vnd.gmx": {
            source: "iana",
            extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
            compressible: !1,
            extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
            compressible: !1,
            extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
            compressible: !1,
            extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
            source: "iana",
            compressible: !1,
            extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.gov.sk.e-form+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.grafeq": {
            source: "iana",
            extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
            source: "iana"
        },
        "application/vnd.groove-account": {
            source: "iana",
            extensions: ["gac"]
        },
        "application/vnd.groove-help": {
            source: "iana",
            extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
            source: "iana",
            extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
            source: "iana",
            extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
            source: "iana",
            extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
            source: "iana",
            extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
            source: "iana",
            extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hal+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["zmm"]
        },
        "application/vnd.hbci": {
            source: "iana",
            extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hcl-bireports": {
            source: "iana"
        },
        "application/vnd.hdt": {
            source: "iana"
        },
        "application/vnd.heroku+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hhe.lesson-player": {
            source: "iana",
            extensions: ["les"]
        },
        "application/vnd.hl7cda+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.hl7v2+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.hp-hpgl": {
            source: "iana",
            extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
            source: "iana",
            extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
            source: "iana",
            extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
            source: "iana",
            extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
            source: "iana",
            extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
            source: "iana",
            extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
            source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
            source: "iana",
            extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hyper-item+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hyperdrive+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.hzn-3d-crossword": {
            source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
            source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
            source: "iana"
        },
        "application/vnd.ibm.minipay": {
            source: "iana",
            extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
            source: "iana",
            extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
            source: "iana",
            extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
            source: "iana",
            extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
            source: "iana",
            extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
            source: "iana"
        },
        "application/vnd.igloader": {
            source: "iana",
            extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.imagemeter.image+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.immervision-ivp": {
            source: "iana",
            extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
            source: "iana",
            extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
            source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
            source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
            source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.informedcontrol.rms+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.informix-visionary": {
            source: "iana"
        },
        "application/vnd.infotech.project": {
            source: "iana"
        },
        "application/vnd.infotech.project+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.innopath.wamp.notification": {
            source: "iana"
        },
        "application/vnd.insors.igm": {
            source: "iana",
            extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
            source: "iana",
            extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
            source: "iana",
            extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
            source: "iana"
        },
        "application/vnd.intertrust.nncp": {
            source: "iana"
        },
        "application/vnd.intu.qbo": {
            source: "iana",
            extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
            source: "iana",
            extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.newsitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.packageitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.iptc.g2.planningitem+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ipunplugged.rcprofile": {
            source: "iana",
            extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
            source: "iana",
            extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
            source: "iana",
            extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.jam": {
            source: "iana",
            extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
            source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
            source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
            source: "iana"
        },
        "application/vnd.japannet-registration": {
            source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
            source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
            source: "iana"
        },
        "application/vnd.japannet-verification": {
            source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
            source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
            source: "iana",
            extensions: ["rms"]
        },
        "application/vnd.jisp": {
            source: "iana",
            extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
            source: "iana",
            extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
            source: "iana"
        },
        "application/vnd.kahootz": {
            source: "iana",
            extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
            source: "iana",
            extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
            source: "iana",
            extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
            source: "iana",
            extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
            source: "iana",
            extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
            source: "iana",
            extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
            source: "iana",
            extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
            source: "iana",
            extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
            source: "iana",
            extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
            source: "iana",
            extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
            source: "iana",
            extensions: ["kia"]
        },
        "application/vnd.kinar": {
            source: "iana",
            extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
            source: "iana",
            extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
            source: "iana",
            extensions: ["sse"]
        },
        "application/vnd.las": {
            source: "iana"
        },
        "application/vnd.las.las+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.las.las+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
            source: "iana"
        },
        "application/vnd.leap+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.liberty-request+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
            source: "iana",
            extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.loom": {
            source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
            source: "iana",
            extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
            source: "iana",
            extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
            source: "iana",
            extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
            source: "iana",
            extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
            source: "iana",
            extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
            source: "iana",
            extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
            source: "iana",
            extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
            source: "iana",
            extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
            source: "iana",
            extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.marlin.drm.conftoken+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.marlin.drm.license+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.marlin.drm.mdcf": {
            source: "iana"
        },
        "application/vnd.mason+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.maxar.archive.3tz+zip": {
            source: "iana",
            compressible: !1
        },
        "application/vnd.maxmind.maxmind-db": {
            source: "iana"
        },
        "application/vnd.mcd": {
            source: "iana",
            extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
            source: "iana",
            extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
            source: "iana",
            extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
            source: "iana"
        },
        "application/vnd.mfer": {
            source: "iana",
            extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
            source: "iana",
            extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.micrografx.flo": {
            source: "iana",
            extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
            source: "iana",
            extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
            source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
            source: "iana"
        },
        "application/vnd.miele+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.mif": {
            source: "iana",
            extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
            source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
            source: "iana"
        },
        "application/vnd.mobius.daf": {
            source: "iana",
            extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
            source: "iana",
            extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
            source: "iana",
            extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
            source: "iana",
            extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
            source: "iana",
            extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
            source: "iana",
            extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
            source: "iana",
            extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
            source: "iana",
            extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
            source: "iana",
            extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
            source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
            source: "iana"
        },
        "application/vnd.motorola.iprm": {
            source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
            source: "iana"
        },
        "application/vnd.ms-artgalry": {
            source: "iana",
            extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
            source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
            source: "iana",
            extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
            source: "apache"
        },
        "application/vnd.ms-excel": {
            source: "iana",
            compressible: !1,
            extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
            source: "iana",
            extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
            source: "iana",
            extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
            source: "iana",
            extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
            source: "iana",
            extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
            source: "iana",
            compressible: !0,
            extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
            source: "iana",
            extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
            source: "iana",
            extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
            source: "iana",
            extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ms-officetheme": {
            source: "iana",
            extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
            source: "apache",
            compressible: !0
        },
        "application/vnd.ms-outlook": {
            compressible: !1,
            extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
            source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
            source: "apache",
            extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
            source: "apache",
            extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ms-powerpoint": {
            source: "iana",
            compressible: !1,
            extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
            source: "iana",
            extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
            source: "iana",
            extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
            source: "iana",
            extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
            source: "iana",
            extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
            source: "iana",
            extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ms-printing.printticket+xml": {
            source: "apache",
            compressible: !0
        },
        "application/vnd.ms-printschematicket+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ms-project": {
            source: "iana",
            extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
            source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
            source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
            source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
            source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
            source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
            source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
            source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
            source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
            source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
            source: "iana",
            extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
            source: "iana",
            extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
            source: "iana",
            extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
            source: "iana",
            extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
            source: "iana",
            compressible: !1,
            extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
            source: "iana"
        },
        "application/vnd.mseq": {
            source: "iana",
            extensions: ["mseq"]
        },
        "application/vnd.msign": {
            source: "iana"
        },
        "application/vnd.multiad.creator": {
            source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
            source: "iana"
        },
        "application/vnd.music-niff": {
            source: "iana"
        },
        "application/vnd.musician": {
            source: "iana",
            extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
            source: "iana",
            extensions: ["msty"]
        },
        "application/vnd.mynfc": {
            source: "iana",
            extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.ncd.control": {
            source: "iana"
        },
        "application/vnd.ncd.reference": {
            source: "iana"
        },
        "application/vnd.nearst.inv+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nebumind.line": {
            source: "iana"
        },
        "application/vnd.nervana": {
            source: "iana"
        },
        "application/vnd.netfpx": {
            source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
            source: "iana",
            extensions: ["nlu"]
        },
        "application/vnd.nimn": {
            source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
            source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
            source: "iana"
        },
        "application/vnd.nitf": {
            source: "iana",
            extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
            source: "iana",
            extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
            source: "iana",
            extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
            source: "iana",
            extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
            source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
            source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nokia.iptv.config+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nokia.isds-radio-presets": {
            source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
            source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nokia.landmarkcollection+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nokia.n-gage.ac+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
            source: "iana",
            extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
            source: "iana",
            extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
            source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
            source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.nokia.radio-preset": {
            source: "iana",
            extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
            source: "iana",
            extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
            source: "iana",
            extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
            source: "iana",
            extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
            source: "iana",
            extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
            source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
            source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
            source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
            source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
            source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
            source: "iana",
            extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
            source: "iana",
            extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
            source: "iana",
            extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
            source: "iana",
            extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
            source: "iana",
            extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
            source: "iana",
            compressible: !1,
            extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
            source: "iana",
            extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
            source: "iana",
            extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
            source: "iana",
            extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
            source: "iana",
            compressible: !1,
            extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
            source: "iana",
            extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
            source: "iana",
            compressible: !1,
            extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
            source: "iana",
            extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
            source: "iana",
            compressible: !1,
            extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
            source: "iana",
            extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
            source: "iana",
            extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
            source: "iana",
            extensions: ["oth"]
        },
        "application/vnd.obn": {
            source: "iana"
        },
        "application/vnd.ocf+cbor": {
            source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oftn.l10n+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.cspg-hexbinary": {
            source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.dae.xhtml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.pae.gem": {
            source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.spdlist+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.ueprofile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oipf.userprofile+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.olpc-sugar": {
            source: "iana",
            extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
            source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
            source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
            source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.imd+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.ltkm": {
            source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
            source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
            source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.sgdu": {
            source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
            source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.sprov+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.bcast.stkm": {
            source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.cab-feature-handler+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.cab-pcc+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.cab-subs-invite+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.cab-user-prefs+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.dcd": {
            source: "iana"
        },
        "application/vnd.oma.dcdc": {
            source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.group-usage-list+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.lwm2m+cbor": {
            source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.lwm2m+tlv": {
            source: "iana"
        },
        "application/vnd.oma.pal+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.poc.final-report+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.poc.groups+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.push": {
            source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oma.xcap-directory+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.omads-email+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.omads-file+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.omads-folder+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.omaloc-supl-init": {
            source: "iana"
        },
        "application/vnd.onepager": {
            source: "iana"
        },
        "application/vnd.onepagertamp": {
            source: "iana"
        },
        "application/vnd.onepagertamx": {
            source: "iana"
        },
        "application/vnd.onepagertat": {
            source: "iana"
        },
        "application/vnd.onepagertatp": {
            source: "iana"
        },
        "application/vnd.onepagertatx": {
            source: "iana"
        },
        "application/vnd.openblox.game+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
            source: "iana"
        },
        "application/vnd.openeye.oeb": {
            source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
            source: "apache",
            extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
            source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
            source: "iana",
            compressible: !1,
            extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
            source: "iana",
            extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
            source: "iana",
            extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
            source: "iana",
            extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
            source: "iana",
            compressible: !1,
            extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
            source: "iana",
            extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
            source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
            source: "iana",
            compressible: !1,
            extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
            source: "iana",
            extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oracle.resource+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.orange.indata": {
            source: "iana"
        },
        "application/vnd.osa.netdeploy": {
            source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
            source: "iana",
            extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
            source: "iana"
        },
        "application/vnd.osgi.dp": {
            source: "iana",
            extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
            source: "iana",
            extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.oxli.countgraph": {
            source: "iana"
        },
        "application/vnd.pagerduty+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.palm": {
            source: "iana",
            extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
            source: "iana"
        },
        "application/vnd.paos.xml": {
            source: "iana"
        },
        "application/vnd.patentdive": {
            source: "iana"
        },
        "application/vnd.patientecommsdoc": {
            source: "iana"
        },
        "application/vnd.pawaafile": {
            source: "iana",
            extensions: ["paw"]
        },
        "application/vnd.pcos": {
            source: "iana"
        },
        "application/vnd.pg.format": {
            source: "iana",
            extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
            source: "iana",
            extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
            source: "iana"
        },
        "application/vnd.picsel": {
            source: "iana",
            extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
            source: "iana",
            extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.pocketlearn": {
            source: "iana",
            extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
            source: "iana",
            extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
            source: "iana"
        },
        "application/vnd.powerbuilder7": {
            source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
            source: "iana"
        },
        "application/vnd.powerbuilder75": {
            source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
            source: "iana"
        },
        "application/vnd.preminet": {
            source: "iana"
        },
        "application/vnd.previewsystems.box": {
            source: "iana",
            extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
            source: "iana",
            extensions: ["mgz"]
        },
        "application/vnd.psfs": {
            source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
            source: "iana",
            extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
            source: "iana",
            extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
            source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.qualcomm.brew-app-res": {
            source: "iana"
        },
        "application/vnd.quarantainenet": {
            source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
            source: "iana",
            extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
            source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-audit+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-conf+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.rainstor.data": {
            source: "iana"
        },
        "application/vnd.rapid": {
            source: "iana"
        },
        "application/vnd.rar": {
            source: "iana",
            extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
            source: "iana",
            extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
            source: "iana",
            extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
            source: "iana"
        },
        "application/vnd.resilient.logic": {
            source: "iana"
        },
        "application/vnd.restful+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.rig.cryptonote": {
            source: "iana",
            extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
            source: "apache",
            extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
            source: "apache",
            extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
            source: "apache",
            extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
            source: "iana"
        },
        "application/vnd.ruckus.download": {
            source: "iana"
        },
        "application/vnd.s3sms": {
            source: "iana"
        },
        "application/vnd.sailingtracker.track": {
            source: "iana",
            extensions: ["st"]
        },
        "application/vnd.sar": {
            source: "iana"
        },
        "application/vnd.sbm.cid": {
            source: "iana"
        },
        "application/vnd.sbm.mid2": {
            source: "iana"
        },
        "application/vnd.scribus": {
            source: "iana"
        },
        "application/vnd.sealed.3df": {
            source: "iana"
        },
        "application/vnd.sealed.csf": {
            source: "iana"
        },
        "application/vnd.sealed.doc": {
            source: "iana"
        },
        "application/vnd.sealed.eml": {
            source: "iana"
        },
        "application/vnd.sealed.mht": {
            source: "iana"
        },
        "application/vnd.sealed.net": {
            source: "iana"
        },
        "application/vnd.sealed.ppt": {
            source: "iana"
        },
        "application/vnd.sealed.tiff": {
            source: "iana"
        },
        "application/vnd.sealed.xls": {
            source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
            source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
            source: "iana"
        },
        "application/vnd.seemail": {
            source: "iana",
            extensions: ["see"]
        },
        "application/vnd.seis+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.sema": {
            source: "iana",
            extensions: ["sema"]
        },
        "application/vnd.semd": {
            source: "iana",
            extensions: ["semd"]
        },
        "application/vnd.semf": {
            source: "iana",
            extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
            source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
            source: "iana",
            extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
            source: "iana",
            extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
            source: "iana",
            extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
            source: "iana",
            extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.shopkick+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.shp": {
            source: "iana"
        },
        "application/vnd.shx": {
            source: "iana"
        },
        "application/vnd.sigrok.session": {
            source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
            source: "iana",
            extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.smaf": {
            source: "iana",
            extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
            source: "iana"
        },
        "application/vnd.smart.teacher": {
            source: "iana",
            extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
            source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
            source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
            source: "iana",
            extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
            source: "iana",
            extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
            source: "iana"
        },
        "application/vnd.sss-cod": {
            source: "iana"
        },
        "application/vnd.sss-dtf": {
            source: "iana"
        },
        "application/vnd.sss-ntf": {
            source: "iana"
        },
        "application/vnd.stardivision.calc": {
            source: "apache",
            extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
            source: "apache",
            extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
            source: "apache",
            extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
            source: "apache",
            extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
            source: "apache",
            extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
            source: "apache",
            extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
            source: "iana",
            extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
            source: "iana",
            extensions: ["sm"]
        },
        "application/vnd.street-stream": {
            source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
            source: "apache",
            extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
            source: "apache",
            extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
            source: "apache",
            extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
            source: "apache",
            extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
            source: "apache",
            extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
            source: "apache",
            extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
            source: "apache",
            extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
            source: "apache",
            extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
            source: "apache",
            extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
            source: "apache",
            extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
            source: "iana",
            extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
            source: "iana",
            extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
            source: "iana"
        },
        "application/vnd.sycle+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.syft+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.symbian.install": {
            source: "apache",
            extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
            source: "iana",
            charset: "UTF-8",
            extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
            source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
            source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
            source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0
        },
        "application/vnd.syncml.ds.notification": {
            source: "iana"
        },
        "application/vnd.tableschema+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.tao.intent-module-archive": {
            source: "iana",
            extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
            source: "iana",
            extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.tmd.mediaflex.api+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.tml": {
            source: "iana"
        },
        "application/vnd.tmobile-livetv": {
            source: "iana",
            extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
            source: "iana"
        },
        "application/vnd.trid.tpt": {
            source: "iana",
            extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
            source: "iana",
            extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
            source: "iana",
            extensions: ["tra"]
        },
        "application/vnd.truedoc": {
            source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
            source: "iana"
        },
        "application/vnd.ufdl": {
            source: "iana",
            extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
            source: "iana",
            extensions: ["utz"]
        },
        "application/vnd.umajin": {
            source: "iana",
            extensions: ["umj"]
        },
        "application/vnd.unity": {
            source: "iana",
            extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
            source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
            source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
            source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.channel": {
            source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.list": {
            source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
            source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
            source: "iana"
        },
        "application/vnd.uplanet.signal": {
            source: "iana"
        },
        "application/vnd.uri-map": {
            source: "iana"
        },
        "application/vnd.valve.source.material": {
            source: "iana"
        },
        "application/vnd.vcx": {
            source: "iana",
            extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
            source: "iana"
        },
        "application/vnd.vectorworks": {
            source: "iana"
        },
        "application/vnd.vel+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.verimatrix.vcas": {
            source: "iana"
        },
        "application/vnd.veritone.aion+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.veryant.thin": {
            source: "iana"
        },
        "application/vnd.ves.encrypted": {
            source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
            source: "iana"
        },
        "application/vnd.visio": {
            source: "iana",
            extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
            source: "iana",
            extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
            source: "iana"
        },
        "application/vnd.vsf": {
            source: "iana",
            extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
            source: "iana"
        },
        "application/vnd.wap.slc": {
            source: "iana"
        },
        "application/vnd.wap.wbxml": {
            source: "iana",
            charset: "UTF-8",
            extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
            source: "iana",
            extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
            source: "iana",
            extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
            source: "iana",
            extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
            source: "iana"
        },
        "application/vnd.wfa.p2p": {
            source: "iana"
        },
        "application/vnd.wfa.wsc": {
            source: "iana"
        },
        "application/vnd.windows.devicepairing": {
            source: "iana"
        },
        "application/vnd.wmc": {
            source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
            source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
            source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
            source: "iana"
        },
        "application/vnd.wolfram.player": {
            source: "iana",
            extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
            source: "iana",
            extensions: ["wpd"]
        },
        "application/vnd.wqd": {
            source: "iana",
            extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
            source: "iana"
        },
        "application/vnd.wt.stf": {
            source: "iana",
            extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
            source: "iana"
        },
        "application/vnd.wv.csp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.wv.ssp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.xacml+json": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.xara": {
            source: "iana",
            extensions: ["xar"]
        },
        "application/vnd.xfdl": {
            source: "iana",
            extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
            source: "iana"
        },
        "application/vnd.xmi+xml": {
            source: "iana",
            compressible: !0
        },
        "application/vnd.xmpie.cpkg": {
            source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
            source: "iana"
        },
        "application/vnd.xmpie.plan": {
            source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
            source: "iana"
        },
        "application/vnd.xmpie.xlim": {
            source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
            source: "iana",
            extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
            source: "iana",
            extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
            source: "iana",
            extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
            source: "iana",
            extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
            source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
            source: "iana",
            extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
            source: "iana",
            extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
            source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
            source: "iana"
        },
        "application/vnd.yaoweme": {
            source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
            source: "iana",
            extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
            source: "iana"
        },
        "application/vnd.zul": {
            source: "iana",
            extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["zaz"]
        },
        "application/voicexml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
            source: "iana",
            compressible: !0
        },
        "application/vq-rtcpxr": {
            source: "iana"
        },
        "application/wasm": {
            source: "iana",
            compressible: !0,
            extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["wif"]
        },
        "application/webpush-options+json": {
            source: "iana",
            compressible: !0
        },
        "application/whoispp-query": {
            source: "iana"
        },
        "application/whoispp-response": {
            source: "iana"
        },
        "application/widget": {
            source: "iana",
            extensions: ["wgt"]
        },
        "application/winhlp": {
            source: "apache",
            extensions: ["hlp"]
        },
        "application/wita": {
            source: "iana"
        },
        "application/wordperfect5.1": {
            source: "iana"
        },
        "application/wsdl+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
            source: "apache",
            compressible: !1,
            extensions: ["7z"]
        },
        "application/x-abiword": {
            source: "apache",
            extensions: ["abw"]
        },
        "application/x-ace-compressed": {
            source: "apache",
            extensions: ["ace"]
        },
        "application/x-amf": {
            source: "apache"
        },
        "application/x-apple-diskimage": {
            source: "apache",
            extensions: ["dmg"]
        },
        "application/x-arj": {
            compressible: !1,
            extensions: ["arj"]
        },
        "application/x-authorware-bin": {
            source: "apache",
            extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
            source: "apache",
            extensions: ["aam"]
        },
        "application/x-authorware-seg": {
            source: "apache",
            extensions: ["aas"]
        },
        "application/x-bcpio": {
            source: "apache",
            extensions: ["bcpio"]
        },
        "application/x-bdoc": {
            compressible: !1,
            extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
            source: "apache",
            extensions: ["torrent"]
        },
        "application/x-blorb": {
            source: "apache",
            extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
            source: "apache",
            compressible: !1,
            extensions: ["bz"]
        },
        "application/x-bzip2": {
            source: "apache",
            compressible: !1,
            extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
            source: "apache",
            extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
            source: "apache",
            extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
            source: "apache",
            extensions: ["cfs"]
        },
        "application/x-chat": {
            source: "apache",
            extensions: ["chat"]
        },
        "application/x-chess-pgn": {
            source: "apache",
            extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
            extensions: ["crx"]
        },
        "application/x-cocoa": {
            source: "nginx",
            extensions: ["cco"]
        },
        "application/x-compress": {
            source: "apache"
        },
        "application/x-conference": {
            source: "apache",
            extensions: ["nsc"]
        },
        "application/x-cpio": {
            source: "apache",
            extensions: ["cpio"]
        },
        "application/x-csh": {
            source: "apache",
            extensions: ["csh"]
        },
        "application/x-deb": {
            compressible: !1
        },
        "application/x-debian-package": {
            source: "apache",
            extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
            source: "apache",
            extensions: ["dgc"]
        },
        "application/x-director": {
            source: "apache",
            extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
            source: "apache",
            extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["res"]
        },
        "application/x-dvi": {
            source: "apache",
            compressible: !1,
            extensions: ["dvi"]
        },
        "application/x-envoy": {
            source: "apache",
            extensions: ["evy"]
        },
        "application/x-eva": {
            source: "apache",
            extensions: ["eva"]
        },
        "application/x-font-bdf": {
            source: "apache",
            extensions: ["bdf"]
        },
        "application/x-font-dos": {
            source: "apache"
        },
        "application/x-font-framemaker": {
            source: "apache"
        },
        "application/x-font-ghostscript": {
            source: "apache",
            extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
            source: "apache"
        },
        "application/x-font-linux-psf": {
            source: "apache",
            extensions: ["psf"]
        },
        "application/x-font-pcf": {
            source: "apache",
            extensions: ["pcf"]
        },
        "application/x-font-snf": {
            source: "apache",
            extensions: ["snf"]
        },
        "application/x-font-speedo": {
            source: "apache"
        },
        "application/x-font-sunos-news": {
            source: "apache"
        },
        "application/x-font-type1": {
            source: "apache",
            extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
            source: "apache"
        },
        "application/x-freearc": {
            source: "apache",
            extensions: ["arc"]
        },
        "application/x-futuresplash": {
            source: "apache",
            extensions: ["spl"]
        },
        "application/x-gca-compressed": {
            source: "apache",
            extensions: ["gca"]
        },
        "application/x-glulx": {
            source: "apache",
            extensions: ["ulx"]
        },
        "application/x-gnumeric": {
            source: "apache",
            extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
            source: "apache",
            extensions: ["gramps"]
        },
        "application/x-gtar": {
            source: "apache",
            extensions: ["gtar"]
        },
        "application/x-gzip": {
            source: "apache"
        },
        "application/x-hdf": {
            source: "apache",
            extensions: ["hdf"]
        },
        "application/x-httpd-php": {
            compressible: !0,
            extensions: ["php"]
        },
        "application/x-install-instructions": {
            source: "apache",
            extensions: ["install"]
        },
        "application/x-iso9660-image": {
            source: "apache",
            extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
            extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
            extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
            extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
            source: "nginx",
            extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
            source: "apache",
            compressible: !1,
            extensions: ["jnlp"]
        },
        "application/x-javascript": {
            compressible: !0
        },
        "application/x-keepass2": {
            extensions: ["kdbx"]
        },
        "application/x-latex": {
            source: "apache",
            compressible: !1,
            extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
            extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
            source: "apache",
            extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
            source: "nginx",
            extensions: ["run"]
        },
        "application/x-mie": {
            source: "apache",
            extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
            source: "apache",
            extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
            compressible: !1
        },
        "application/x-ms-application": {
            source: "apache",
            extensions: ["application"]
        },
        "application/x-ms-shortcut": {
            source: "apache",
            extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
            source: "apache",
            extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
            source: "apache",
            extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
            source: "apache",
            extensions: ["xbap"]
        },
        "application/x-msaccess": {
            source: "apache",
            extensions: ["mdb"]
        },
        "application/x-msbinder": {
            source: "apache",
            extensions: ["obd"]
        },
        "application/x-mscardfile": {
            source: "apache",
            extensions: ["crd"]
        },
        "application/x-msclip": {
            source: "apache",
            extensions: ["clp"]
        },
        "application/x-msdos-program": {
            extensions: ["exe"]
        },
        "application/x-msdownload": {
            source: "apache",
            extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
            source: "apache",
            extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
            source: "apache",
            extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
            source: "apache",
            extensions: ["mny"]
        },
        "application/x-mspublisher": {
            source: "apache",
            extensions: ["pub"]
        },
        "application/x-msschedule": {
            source: "apache",
            extensions: ["scd"]
        },
        "application/x-msterminal": {
            source: "apache",
            extensions: ["trm"]
        },
        "application/x-mswrite": {
            source: "apache",
            extensions: ["wri"]
        },
        "application/x-netcdf": {
            source: "apache",
            extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
            compressible: !0,
            extensions: ["pac"]
        },
        "application/x-nzb": {
            source: "apache",
            extensions: ["nzb"]
        },
        "application/x-perl": {
            source: "nginx",
            extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
            source: "nginx",
            extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
            source: "apache",
            compressible: !1,
            extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
            source: "apache",
            extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
            source: "apache",
            extensions: ["p7r"]
        },
        "application/x-pki-message": {
            source: "iana"
        },
        "application/x-rar-compressed": {
            source: "apache",
            compressible: !1,
            extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
            source: "nginx",
            extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
            source: "apache",
            extensions: ["ris"]
        },
        "application/x-sea": {
            source: "nginx",
            extensions: ["sea"]
        },
        "application/x-sh": {
            source: "apache",
            compressible: !0,
            extensions: ["sh"]
        },
        "application/x-shar": {
            source: "apache",
            extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
            source: "apache",
            compressible: !1,
            extensions: ["swf"]
        },
        "application/x-silverlight-app": {
            source: "apache",
            extensions: ["xap"]
        },
        "application/x-sql": {
            source: "apache",
            extensions: ["sql"]
        },
        "application/x-stuffit": {
            source: "apache",
            compressible: !1,
            extensions: ["sit"]
        },
        "application/x-stuffitx": {
            source: "apache",
            extensions: ["sitx"]
        },
        "application/x-subrip": {
            source: "apache",
            extensions: ["srt"]
        },
        "application/x-sv4cpio": {
            source: "apache",
            extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
            source: "apache",
            extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
            source: "apache",
            extensions: ["t3"]
        },
        "application/x-tads": {
            source: "apache",
            extensions: ["gam"]
        },
        "application/x-tar": {
            source: "apache",
            compressible: !0,
            extensions: ["tar"]
        },
        "application/x-tcl": {
            source: "apache",
            extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
            source: "apache",
            extensions: ["tex"]
        },
        "application/x-tex-tfm": {
            source: "apache",
            extensions: ["tfm"]
        },
        "application/x-texinfo": {
            source: "apache",
            extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
            source: "apache",
            extensions: ["obj"]
        },
        "application/x-ustar": {
            source: "apache",
            extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
            compressible: !0,
            extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
            compressible: !0,
            extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
            compressible: !0,
            extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
            compressible: !0,
            extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
            compressible: !1,
            extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
            compressible: !0,
            extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
            compressible: !0,
            extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
            compressible: !0,
            extensions: ["vmdk"]
        },
        "application/x-wais-source": {
            source: "apache",
            extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
            compressible: !0,
            extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
            source: "iana",
            compressible: !0
        },
        "application/x-x509-ca-cert": {
            source: "iana",
            extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
            source: "iana"
        },
        "application/x-x509-next-ca-cert": {
            source: "iana"
        },
        "application/x-xfig": {
            source: "apache",
            extensions: ["fig"]
        },
        "application/x-xliff+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["xlf"]
        },
        "application/x-xpinstall": {
            source: "apache",
            compressible: !1,
            extensions: ["xpi"]
        },
        "application/x-xz": {
            source: "apache",
            extensions: ["xz"]
        },
        "application/x-zmachine": {
            source: "apache",
            extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
            source: "iana"
        },
        "application/xacml+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xaml+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xel"]
        },
        "application/xcap-error+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xcap-ns+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xcon-conference-info-diff+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xenc+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xenc"]
        },
        "application/xhtml+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
            source: "apache",
            compressible: !0
        },
        "application/xliff+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xlf"]
        },
        "application/xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
            source: "iana",
            compressible: !0,
            extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
            source: "iana"
        },
        "application/xml-patch+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xmpp+xml": {
            source: "iana",
            compressible: !0
        },
        "application/xop+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xop"]
        },
        "application/xproc+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["xpl"]
        },
        "application/xslt+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
            source: "apache",
            compressible: !0,
            extensions: ["xspf"]
        },
        "application/xv+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
            source: "iana",
            extensions: ["yang"]
        },
        "application/yang-data+json": {
            source: "iana",
            compressible: !0
        },
        "application/yang-data+xml": {
            source: "iana",
            compressible: !0
        },
        "application/yang-patch+json": {
            source: "iana",
            compressible: !0
        },
        "application/yang-patch+xml": {
            source: "iana",
            compressible: !0
        },
        "application/yin+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["yin"]
        },
        "application/zip": {
            source: "iana",
            compressible: !1,
            extensions: ["zip"]
        },
        "application/zlib": {
            source: "iana"
        },
        "application/zstd": {
            source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
            source: "iana"
        },
        "audio/32kadpcm": {
            source: "iana"
        },
        "audio/3gpp": {
            source: "iana",
            compressible: !1,
            extensions: ["3gpp"]
        },
        "audio/3gpp2": {
            source: "iana"
        },
        "audio/aac": {
            source: "iana"
        },
        "audio/ac3": {
            source: "iana"
        },
        "audio/adpcm": {
            source: "apache",
            extensions: ["adp"]
        },
        "audio/amr": {
            source: "iana",
            extensions: ["amr"]
        },
        "audio/amr-wb": {
            source: "iana"
        },
        "audio/amr-wb+": {
            source: "iana"
        },
        "audio/aptx": {
            source: "iana"
        },
        "audio/asc": {
            source: "iana"
        },
        "audio/atrac-advanced-lossless": {
            source: "iana"
        },
        "audio/atrac-x": {
            source: "iana"
        },
        "audio/atrac3": {
            source: "iana"
        },
        "audio/basic": {
            source: "iana",
            compressible: !1,
            extensions: ["au", "snd"]
        },
        "audio/bv16": {
            source: "iana"
        },
        "audio/bv32": {
            source: "iana"
        },
        "audio/clearmode": {
            source: "iana"
        },
        "audio/cn": {
            source: "iana"
        },
        "audio/dat12": {
            source: "iana"
        },
        "audio/dls": {
            source: "iana"
        },
        "audio/dsr-es201108": {
            source: "iana"
        },
        "audio/dsr-es202050": {
            source: "iana"
        },
        "audio/dsr-es202211": {
            source: "iana"
        },
        "audio/dsr-es202212": {
            source: "iana"
        },
        "audio/dv": {
            source: "iana"
        },
        "audio/dvi4": {
            source: "iana"
        },
        "audio/eac3": {
            source: "iana"
        },
        "audio/encaprtp": {
            source: "iana"
        },
        "audio/evrc": {
            source: "iana"
        },
        "audio/evrc-qcp": {
            source: "iana"
        },
        "audio/evrc0": {
            source: "iana"
        },
        "audio/evrc1": {
            source: "iana"
        },
        "audio/evrcb": {
            source: "iana"
        },
        "audio/evrcb0": {
            source: "iana"
        },
        "audio/evrcb1": {
            source: "iana"
        },
        "audio/evrcnw": {
            source: "iana"
        },
        "audio/evrcnw0": {
            source: "iana"
        },
        "audio/evrcnw1": {
            source: "iana"
        },
        "audio/evrcwb": {
            source: "iana"
        },
        "audio/evrcwb0": {
            source: "iana"
        },
        "audio/evrcwb1": {
            source: "iana"
        },
        "audio/evs": {
            source: "iana"
        },
        "audio/flexfec": {
            source: "iana"
        },
        "audio/fwdred": {
            source: "iana"
        },
        "audio/g711-0": {
            source: "iana"
        },
        "audio/g719": {
            source: "iana"
        },
        "audio/g722": {
            source: "iana"
        },
        "audio/g7221": {
            source: "iana"
        },
        "audio/g723": {
            source: "iana"
        },
        "audio/g726-16": {
            source: "iana"
        },
        "audio/g726-24": {
            source: "iana"
        },
        "audio/g726-32": {
            source: "iana"
        },
        "audio/g726-40": {
            source: "iana"
        },
        "audio/g728": {
            source: "iana"
        },
        "audio/g729": {
            source: "iana"
        },
        "audio/g7291": {
            source: "iana"
        },
        "audio/g729d": {
            source: "iana"
        },
        "audio/g729e": {
            source: "iana"
        },
        "audio/gsm": {
            source: "iana"
        },
        "audio/gsm-efr": {
            source: "iana"
        },
        "audio/gsm-hr-08": {
            source: "iana"
        },
        "audio/ilbc": {
            source: "iana"
        },
        "audio/ip-mr_v2.5": {
            source: "iana"
        },
        "audio/isac": {
            source: "apache"
        },
        "audio/l16": {
            source: "iana"
        },
        "audio/l20": {
            source: "iana"
        },
        "audio/l24": {
            source: "iana",
            compressible: !1
        },
        "audio/l8": {
            source: "iana"
        },
        "audio/lpc": {
            source: "iana"
        },
        "audio/melp": {
            source: "iana"
        },
        "audio/melp1200": {
            source: "iana"
        },
        "audio/melp2400": {
            source: "iana"
        },
        "audio/melp600": {
            source: "iana"
        },
        "audio/mhas": {
            source: "iana"
        },
        "audio/midi": {
            source: "apache",
            extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
            source: "iana",
            extensions: ["mxmf"]
        },
        "audio/mp3": {
            compressible: !1,
            extensions: ["mp3"]
        },
        "audio/mp4": {
            source: "iana",
            compressible: !1,
            extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
            source: "iana"
        },
        "audio/mpa": {
            source: "iana"
        },
        "audio/mpa-robust": {
            source: "iana"
        },
        "audio/mpeg": {
            source: "iana",
            compressible: !1,
            extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
            source: "iana"
        },
        "audio/musepack": {
            source: "apache"
        },
        "audio/ogg": {
            source: "iana",
            compressible: !1,
            extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
            source: "iana"
        },
        "audio/parityfec": {
            source: "iana"
        },
        "audio/pcma": {
            source: "iana"
        },
        "audio/pcma-wb": {
            source: "iana"
        },
        "audio/pcmu": {
            source: "iana"
        },
        "audio/pcmu-wb": {
            source: "iana"
        },
        "audio/prs.sid": {
            source: "iana"
        },
        "audio/qcelp": {
            source: "iana"
        },
        "audio/raptorfec": {
            source: "iana"
        },
        "audio/red": {
            source: "iana"
        },
        "audio/rtp-enc-aescm128": {
            source: "iana"
        },
        "audio/rtp-midi": {
            source: "iana"
        },
        "audio/rtploopback": {
            source: "iana"
        },
        "audio/rtx": {
            source: "iana"
        },
        "audio/s3m": {
            source: "apache",
            extensions: ["s3m"]
        },
        "audio/scip": {
            source: "iana"
        },
        "audio/silk": {
            source: "apache",
            extensions: ["sil"]
        },
        "audio/smv": {
            source: "iana"
        },
        "audio/smv-qcp": {
            source: "iana"
        },
        "audio/smv0": {
            source: "iana"
        },
        "audio/sofa": {
            source: "iana"
        },
        "audio/sp-midi": {
            source: "iana"
        },
        "audio/speex": {
            source: "iana"
        },
        "audio/t140c": {
            source: "iana"
        },
        "audio/t38": {
            source: "iana"
        },
        "audio/telephone-event": {
            source: "iana"
        },
        "audio/tetra_acelp": {
            source: "iana"
        },
        "audio/tetra_acelp_bb": {
            source: "iana"
        },
        "audio/tone": {
            source: "iana"
        },
        "audio/tsvcis": {
            source: "iana"
        },
        "audio/uemclip": {
            source: "iana"
        },
        "audio/ulpfec": {
            source: "iana"
        },
        "audio/usac": {
            source: "iana"
        },
        "audio/vdvi": {
            source: "iana"
        },
        "audio/vmr-wb": {
            source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
            source: "iana"
        },
        "audio/vnd.4sb": {
            source: "iana"
        },
        "audio/vnd.audiokoz": {
            source: "iana"
        },
        "audio/vnd.celp": {
            source: "iana"
        },
        "audio/vnd.cisco.nse": {
            source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
            source: "iana"
        },
        "audio/vnd.cns.anp1": {
            source: "iana"
        },
        "audio/vnd.cns.inf1": {
            source: "iana"
        },
        "audio/vnd.dece.audio": {
            source: "iana",
            extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
            source: "iana",
            extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
            source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
            source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
            source: "iana"
        },
        "audio/vnd.dolby.mlp": {
            source: "iana"
        },
        "audio/vnd.dolby.mps": {
            source: "iana"
        },
        "audio/vnd.dolby.pl2": {
            source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
            source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
            source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
            source: "iana"
        },
        "audio/vnd.dra": {
            source: "iana",
            extensions: ["dra"]
        },
        "audio/vnd.dts": {
            source: "iana",
            extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
            source: "iana",
            extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
            source: "iana"
        },
        "audio/vnd.dvb.file": {
            source: "iana"
        },
        "audio/vnd.everad.plj": {
            source: "iana"
        },
        "audio/vnd.hns.audio": {
            source: "iana"
        },
        "audio/vnd.lucent.voice": {
            source: "iana",
            extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
            source: "iana",
            extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
            source: "iana"
        },
        "audio/vnd.nortel.vbk": {
            source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
            source: "iana",
            extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
            source: "iana",
            extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
            source: "iana",
            extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
            source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
            source: "iana"
        },
        "audio/vnd.qcelp": {
            source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
            source: "iana"
        },
        "audio/vnd.rip": {
            source: "iana",
            extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
            compressible: !1
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
            source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
            source: "iana"
        },
        "audio/vnd.wave": {
            compressible: !1
        },
        "audio/vorbis": {
            source: "iana",
            compressible: !1
        },
        "audio/vorbis-config": {
            source: "iana"
        },
        "audio/wav": {
            compressible: !1,
            extensions: ["wav"]
        },
        "audio/wave": {
            compressible: !1,
            extensions: ["wav"]
        },
        "audio/webm": {
            source: "apache",
            compressible: !1,
            extensions: ["weba"]
        },
        "audio/x-aac": {
            source: "apache",
            compressible: !1,
            extensions: ["aac"]
        },
        "audio/x-aiff": {
            source: "apache",
            extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
            source: "apache",
            compressible: !1,
            extensions: ["caf"]
        },
        "audio/x-flac": {
            source: "apache",
            extensions: ["flac"]
        },
        "audio/x-m4a": {
            source: "nginx",
            extensions: ["m4a"]
        },
        "audio/x-matroska": {
            source: "apache",
            extensions: ["mka"]
        },
        "audio/x-mpegurl": {
            source: "apache",
            extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
            source: "apache",
            extensions: ["wax"]
        },
        "audio/x-ms-wma": {
            source: "apache",
            extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
            source: "apache",
            extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
            source: "apache",
            extensions: ["rmp"]
        },
        "audio/x-realaudio": {
            source: "nginx",
            extensions: ["ra"]
        },
        "audio/x-tta": {
            source: "apache"
        },
        "audio/x-wav": {
            source: "apache",
            extensions: ["wav"]
        },
        "audio/xm": {
            source: "apache",
            extensions: ["xm"]
        },
        "chemical/x-cdx": {
            source: "apache",
            extensions: ["cdx"]
        },
        "chemical/x-cif": {
            source: "apache",
            extensions: ["cif"]
        },
        "chemical/x-cmdf": {
            source: "apache",
            extensions: ["cmdf"]
        },
        "chemical/x-cml": {
            source: "apache",
            extensions: ["cml"]
        },
        "chemical/x-csml": {
            source: "apache",
            extensions: ["csml"]
        },
        "chemical/x-pdb": {
            source: "apache"
        },
        "chemical/x-xyz": {
            source: "apache",
            extensions: ["xyz"]
        },
        "font/collection": {
            source: "iana",
            extensions: ["ttc"]
        },
        "font/otf": {
            source: "iana",
            compressible: !0,
            extensions: ["otf"]
        },
        "font/sfnt": {
            source: "iana"
        },
        "font/ttf": {
            source: "iana",
            compressible: !0,
            extensions: ["ttf"]
        },
        "font/woff": {
            source: "iana",
            extensions: ["woff"]
        },
        "font/woff2": {
            source: "iana",
            extensions: ["woff2"]
        },
        "image/aces": {
            source: "iana",
            extensions: ["exr"]
        },
        "image/apng": {
            compressible: !1,
            extensions: ["apng"]
        },
        "image/avci": {
            source: "iana",
            extensions: ["avci"]
        },
        "image/avcs": {
            source: "iana",
            extensions: ["avcs"]
        },
        "image/avif": {
            source: "iana",
            compressible: !1,
            extensions: ["avif"]
        },
        "image/bmp": {
            source: "iana",
            compressible: !0,
            extensions: ["bmp"]
        },
        "image/cgm": {
            source: "iana",
            extensions: ["cgm"]
        },
        "image/dicom-rle": {
            source: "iana",
            extensions: ["drle"]
        },
        "image/emf": {
            source: "iana",
            extensions: ["emf"]
        },
        "image/fits": {
            source: "iana",
            extensions: ["fits"]
        },
        "image/g3fax": {
            source: "iana",
            extensions: ["g3"]
        },
        "image/gif": {
            source: "iana",
            compressible: !1,
            extensions: ["gif"]
        },
        "image/heic": {
            source: "iana",
            extensions: ["heic"]
        },
        "image/heic-sequence": {
            source: "iana",
            extensions: ["heics"]
        },
        "image/heif": {
            source: "iana",
            extensions: ["heif"]
        },
        "image/heif-sequence": {
            source: "iana",
            extensions: ["heifs"]
        },
        "image/hej2k": {
            source: "iana",
            extensions: ["hej2"]
        },
        "image/hsj2": {
            source: "iana",
            extensions: ["hsj2"]
        },
        "image/ief": {
            source: "iana",
            extensions: ["ief"]
        },
        "image/jls": {
            source: "iana",
            extensions: ["jls"]
        },
        "image/jp2": {
            source: "iana",
            compressible: !1,
            extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
            source: "iana",
            compressible: !1,
            extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
            source: "iana",
            extensions: ["jph"]
        },
        "image/jphc": {
            source: "iana",
            extensions: ["jhc"]
        },
        "image/jpm": {
            source: "iana",
            compressible: !1,
            extensions: ["jpm"]
        },
        "image/jpx": {
            source: "iana",
            compressible: !1,
            extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
            source: "iana",
            extensions: ["jxr"]
        },
        "image/jxra": {
            source: "iana",
            extensions: ["jxra"]
        },
        "image/jxrs": {
            source: "iana",
            extensions: ["jxrs"]
        },
        "image/jxs": {
            source: "iana",
            extensions: ["jxs"]
        },
        "image/jxsc": {
            source: "iana",
            extensions: ["jxsc"]
        },
        "image/jxsi": {
            source: "iana",
            extensions: ["jxsi"]
        },
        "image/jxss": {
            source: "iana",
            extensions: ["jxss"]
        },
        "image/ktx": {
            source: "iana",
            extensions: ["ktx"]
        },
        "image/ktx2": {
            source: "iana",
            extensions: ["ktx2"]
        },
        "image/naplps": {
            source: "iana"
        },
        "image/pjpeg": {
            compressible: !1
        },
        "image/png": {
            source: "iana",
            compressible: !1,
            extensions: ["png"]
        },
        "image/prs.btif": {
            source: "iana",
            extensions: ["btif"]
        },
        "image/prs.pti": {
            source: "iana",
            extensions: ["pti"]
        },
        "image/pwg-raster": {
            source: "iana"
        },
        "image/sgi": {
            source: "apache",
            extensions: ["sgi"]
        },
        "image/svg+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["svg", "svgz"]
        },
        "image/t38": {
            source: "iana",
            extensions: ["t38"]
        },
        "image/tiff": {
            source: "iana",
            compressible: !1,
            extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
            source: "iana",
            extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
            source: "iana",
            compressible: !0,
            extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
            source: "iana",
            extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
            source: "iana"
        },
        "image/vnd.dece.graphic": {
            source: "iana",
            extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
            source: "iana",
            extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
            source: "iana",
            extensions: ["sub"]
        },
        "image/vnd.dwg": {
            source: "iana",
            extensions: ["dwg"]
        },
        "image/vnd.dxf": {
            source: "iana",
            extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
            source: "iana",
            extensions: ["fbs"]
        },
        "image/vnd.fpx": {
            source: "iana",
            extensions: ["fpx"]
        },
        "image/vnd.fst": {
            source: "iana",
            extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
            source: "iana",
            extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
            source: "iana",
            extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
            source: "iana"
        },
        "image/vnd.microsoft.icon": {
            source: "iana",
            compressible: !0,
            extensions: ["ico"]
        },
        "image/vnd.mix": {
            source: "iana"
        },
        "image/vnd.mozilla.apng": {
            source: "iana"
        },
        "image/vnd.ms-dds": {
            compressible: !0,
            extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
            source: "iana",
            extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
            source: "apache",
            extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
            source: "iana",
            extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
            source: "iana",
            extensions: ["b16"]
        },
        "image/vnd.radiance": {
            source: "iana"
        },
        "image/vnd.sealed.png": {
            source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
            source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
            source: "iana"
        },
        "image/vnd.svf": {
            source: "iana"
        },
        "image/vnd.tencent.tap": {
            source: "iana",
            extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
            source: "iana",
            extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
            source: "iana",
            extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
            source: "iana",
            extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
            source: "iana",
            extensions: ["pcx"]
        },
        "image/webp": {
            source: "apache",
            extensions: ["webp"]
        },
        "image/wmf": {
            source: "iana",
            extensions: ["wmf"]
        },
        "image/x-3ds": {
            source: "apache",
            extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
            source: "apache",
            extensions: ["ras"]
        },
        "image/x-cmx": {
            source: "apache",
            extensions: ["cmx"]
        },
        "image/x-freehand": {
            source: "apache",
            extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
            source: "apache",
            compressible: !0,
            extensions: ["ico"]
        },
        "image/x-jng": {
            source: "nginx",
            extensions: ["jng"]
        },
        "image/x-mrsid-image": {
            source: "apache",
            extensions: ["sid"]
        },
        "image/x-ms-bmp": {
            source: "nginx",
            compressible: !0,
            extensions: ["bmp"]
        },
        "image/x-pcx": {
            source: "apache",
            extensions: ["pcx"]
        },
        "image/x-pict": {
            source: "apache",
            extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
            source: "apache",
            extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
            source: "apache",
            extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
            source: "apache",
            extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
            source: "apache",
            extensions: ["ppm"]
        },
        "image/x-rgb": {
            source: "apache",
            extensions: ["rgb"]
        },
        "image/x-tga": {
            source: "apache",
            extensions: ["tga"]
        },
        "image/x-xbitmap": {
            source: "apache",
            extensions: ["xbm"]
        },
        "image/x-xcf": {
            compressible: !1
        },
        "image/x-xpixmap": {
            source: "apache",
            extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
            source: "apache",
            extensions: ["xwd"]
        },
        "message/cpim": {
            source: "iana"
        },
        "message/delivery-status": {
            source: "iana"
        },
        "message/disposition-notification": {
            source: "iana",
            extensions: ["disposition-notification"]
        },
        "message/external-body": {
            source: "iana"
        },
        "message/feedback-report": {
            source: "iana"
        },
        "message/global": {
            source: "iana",
            extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
            source: "iana",
            extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
            source: "iana",
            extensions: ["u8mdn"]
        },
        "message/global-headers": {
            source: "iana",
            extensions: ["u8hdr"]
        },
        "message/http": {
            source: "iana",
            compressible: !1
        },
        "message/imdn+xml": {
            source: "iana",
            compressible: !0
        },
        "message/news": {
            source: "iana"
        },
        "message/partial": {
            source: "iana",
            compressible: !1
        },
        "message/rfc822": {
            source: "iana",
            compressible: !0,
            extensions: ["eml", "mime"]
        },
        "message/s-http": {
            source: "iana"
        },
        "message/sip": {
            source: "iana"
        },
        "message/sipfrag": {
            source: "iana"
        },
        "message/tracking-status": {
            source: "iana"
        },
        "message/vnd.si.simp": {
            source: "iana"
        },
        "message/vnd.wfa.wsc": {
            source: "iana",
            extensions: ["wsc"]
        },
        "model/3mf": {
            source: "iana",
            extensions: ["3mf"]
        },
        "model/e57": {
            source: "iana"
        },
        "model/gltf+json": {
            source: "iana",
            compressible: !0,
            extensions: ["gltf"]
        },
        "model/gltf-binary": {
            source: "iana",
            compressible: !0,
            extensions: ["glb"]
        },
        "model/iges": {
            source: "iana",
            compressible: !1,
            extensions: ["igs", "iges"]
        },
        "model/mesh": {
            source: "iana",
            compressible: !1,
            extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
            source: "iana",
            extensions: ["mtl"]
        },
        "model/obj": {
            source: "iana",
            extensions: ["obj"]
        },
        "model/step": {
            source: "iana"
        },
        "model/step+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["stpx"]
        },
        "model/step+zip": {
            source: "iana",
            compressible: !1,
            extensions: ["stpz"]
        },
        "model/step-xml+zip": {
            source: "iana",
            compressible: !1,
            extensions: ["stpxz"]
        },
        "model/stl": {
            source: "iana",
            extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["dae"]
        },
        "model/vnd.dwf": {
            source: "iana",
            extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
            source: "iana"
        },
        "model/vnd.gdl": {
            source: "iana",
            extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
            source: "apache"
        },
        "model/vnd.gs.gdl": {
            source: "iana"
        },
        "model/vnd.gtw": {
            source: "iana",
            extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
            source: "iana",
            compressible: !0
        },
        "model/vnd.mts": {
            source: "iana",
            extensions: ["mts"]
        },
        "model/vnd.opengex": {
            source: "iana",
            extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
            source: "iana",
            extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
            source: "iana",
            extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
            source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
            source: "iana"
        },
        "model/vnd.sap.vds": {
            source: "iana",
            extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
            source: "iana",
            compressible: !1,
            extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
            source: "iana",
            extensions: ["bsp"]
        },
        "model/vnd.vtu": {
            source: "iana",
            extensions: ["vtu"]
        },
        "model/vrml": {
            source: "iana",
            compressible: !1,
            extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
            source: "apache",
            compressible: !1,
            extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
            source: "iana",
            extensions: ["x3db"]
        },
        "model/x3d+vrml": {
            source: "apache",
            compressible: !1,
            extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
            source: "iana",
            compressible: !0,
            extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
            source: "iana",
            extensions: ["x3dv"]
        },
        "multipart/alternative": {
            source: "iana",
            compressible: !1
        },
        "multipart/appledouble": {
            source: "iana"
        },
        "multipart/byteranges": {
            source: "iana"
        },
        "multipart/digest": {
            source: "iana"
        },
        "multipart/encrypted": {
            source: "iana",
            compressible: !1
        },
        "multipart/form-data": {
            source: "iana",
            compressible: !1
        },
        "multipart/header-set": {
            source: "iana"
        },
        "multipart/mixed": {
            source: "iana"
        },
        "multipart/multilingual": {
            source: "iana"
        },
        "multipart/parallel": {
            source: "iana"
        },
        "multipart/related": {
            source: "iana",
            compressible: !1
        },
        "multipart/report": {
            source: "iana"
        },
        "multipart/signed": {
            source: "iana",
            compressible: !1
        },
        "multipart/vnd.bint.med-plus": {
            source: "iana"
        },
        "multipart/voice-message": {
            source: "iana"
        },
        "multipart/x-mixed-replace": {
            source: "iana"
        },
        "text/1d-interleaved-parityfec": {
            source: "iana"
        },
        "text/cache-manifest": {
            source: "iana",
            compressible: !0,
            extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
            source: "iana",
            extensions: ["ics", "ifb"]
        },
        "text/calender": {
            compressible: !0
        },
        "text/cmd": {
            compressible: !0
        },
        "text/coffeescript": {
            extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
            source: "iana"
        },
        "text/cql-expression": {
            source: "iana"
        },
        "text/cql-identifier": {
            source: "iana"
        },
        "text/css": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["css"]
        },
        "text/csv": {
            source: "iana",
            compressible: !0,
            extensions: ["csv"]
        },
        "text/csv-schema": {
            source: "iana"
        },
        "text/directory": {
            source: "iana"
        },
        "text/dns": {
            source: "iana"
        },
        "text/ecmascript": {
            source: "iana"
        },
        "text/encaprtp": {
            source: "iana"
        },
        "text/enriched": {
            source: "iana"
        },
        "text/fhirpath": {
            source: "iana"
        },
        "text/flexfec": {
            source: "iana"
        },
        "text/fwdred": {
            source: "iana"
        },
        "text/gff3": {
            source: "iana"
        },
        "text/grammar-ref-list": {
            source: "iana"
        },
        "text/html": {
            source: "iana",
            compressible: !0,
            extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
            extensions: ["jade"]
        },
        "text/javascript": {
            source: "iana",
            compressible: !0
        },
        "text/jcr-cnd": {
            source: "iana"
        },
        "text/jsx": {
            compressible: !0,
            extensions: ["jsx"]
        },
        "text/less": {
            compressible: !0,
            extensions: ["less"]
        },
        "text/markdown": {
            source: "iana",
            compressible: !0,
            extensions: ["markdown", "md"]
        },
        "text/mathml": {
            source: "nginx",
            extensions: ["mml"]
        },
        "text/mdx": {
            compressible: !0,
            extensions: ["mdx"]
        },
        "text/mizar": {
            source: "iana"
        },
        "text/n3": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["n3"]
        },
        "text/parameters": {
            source: "iana",
            charset: "UTF-8"
        },
        "text/parityfec": {
            source: "iana"
        },
        "text/plain": {
            source: "iana",
            compressible: !0,
            extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
            source: "iana",
            charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
            source: "iana"
        },
        "text/prs.lines.tag": {
            source: "iana",
            extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
            source: "iana"
        },
        "text/raptorfec": {
            source: "iana"
        },
        "text/red": {
            source: "iana"
        },
        "text/rfc822-headers": {
            source: "iana"
        },
        "text/richtext": {
            source: "iana",
            compressible: !0,
            extensions: ["rtx"]
        },
        "text/rtf": {
            source: "iana",
            compressible: !0,
            extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
            source: "iana"
        },
        "text/rtploopback": {
            source: "iana"
        },
        "text/rtx": {
            source: "iana"
        },
        "text/sgml": {
            source: "iana",
            extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
            source: "iana"
        },
        "text/shex": {
            source: "iana",
            extensions: ["shex"]
        },
        "text/slim": {
            extensions: ["slim", "slm"]
        },
        "text/spdx": {
            source: "iana",
            extensions: ["spdx"]
        },
        "text/strings": {
            source: "iana"
        },
        "text/stylus": {
            extensions: ["stylus", "styl"]
        },
        "text/t140": {
            source: "iana"
        },
        "text/tab-separated-values": {
            source: "iana",
            compressible: !0,
            extensions: ["tsv"]
        },
        "text/troff": {
            source: "iana",
            extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
            source: "iana",
            charset: "UTF-8",
            extensions: ["ttl"]
        },
        "text/ulpfec": {
            source: "iana"
        },
        "text/uri-list": {
            source: "iana",
            compressible: !0,
            extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
            source: "iana",
            compressible: !0,
            extensions: ["vcard"]
        },
        "text/vnd.a": {
            source: "iana"
        },
        "text/vnd.abc": {
            source: "iana"
        },
        "text/vnd.ascii-art": {
            source: "iana"
        },
        "text/vnd.curl": {
            source: "iana",
            extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
            source: "apache",
            extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
            source: "apache",
            extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
            source: "apache",
            extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
            source: "iana",
            charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
            source: "iana"
        },
        "text/vnd.dvb.subtitle": {
            source: "iana",
            extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
            source: "iana",
            charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
            source: "iana",
            extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
            source: "iana"
        },
        "text/vnd.fly": {
            source: "iana",
            extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
            source: "iana",
            extensions: ["flx"]
        },
        "text/vnd.gml": {
            source: "iana"
        },
        "text/vnd.graphviz": {
            source: "iana",
            extensions: ["gv"]
        },
        "text/vnd.hans": {
            source: "iana"
        },
        "text/vnd.hgl": {
            source: "iana"
        },
        "text/vnd.in3d.3dml": {
            source: "iana",
            extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
            source: "iana",
            extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
            source: "iana"
        },
        "text/vnd.iptc.nitf": {
            source: "iana"
        },
        "text/vnd.latex-z": {
            source: "iana"
        },
        "text/vnd.motorola.reflex": {
            source: "iana"
        },
        "text/vnd.ms-mediapackage": {
            source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
            source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
            source: "iana"
        },
        "text/vnd.senx.warpscript": {
            source: "iana"
        },
        "text/vnd.si.uricatalogue": {
            source: "iana"
        },
        "text/vnd.sosi": {
            source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
            source: "iana",
            charset: "UTF-8",
            extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
            source: "iana",
            charset: "UTF-8"
        },
        "text/vnd.wap.si": {
            source: "iana"
        },
        "text/vnd.wap.sl": {
            source: "iana"
        },
        "text/vnd.wap.wml": {
            source: "iana",
            extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
            source: "iana",
            extensions: ["wmls"]
        },
        "text/vtt": {
            source: "iana",
            charset: "UTF-8",
            compressible: !0,
            extensions: ["vtt"]
        },
        "text/x-asm": {
            source: "apache",
            extensions: ["s", "asm"]
        },
        "text/x-c": {
            source: "apache",
            extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
            source: "nginx",
            extensions: ["htc"]
        },
        "text/x-fortran": {
            source: "apache",
            extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
            compressible: !0
        },
        "text/x-handlebars-template": {
            extensions: ["hbs"]
        },
        "text/x-java-source": {
            source: "apache",
            extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
            compressible: !0
        },
        "text/x-lua": {
            extensions: ["lua"]
        },
        "text/x-markdown": {
            compressible: !0,
            extensions: ["mkd"]
        },
        "text/x-nfo": {
            source: "apache",
            extensions: ["nfo"]
        },
        "text/x-opml": {
            source: "apache",
            extensions: ["opml"]
        },
        "text/x-org": {
            compressible: !0,
            extensions: ["org"]
        },
        "text/x-pascal": {
            source: "apache",
            extensions: ["p", "pas"]
        },
        "text/x-processing": {
            compressible: !0,
            extensions: ["pde"]
        },
        "text/x-sass": {
            extensions: ["sass"]
        },
        "text/x-scss": {
            extensions: ["scss"]
        },
        "text/x-setext": {
            source: "apache",
            extensions: ["etx"]
        },
        "text/x-sfv": {
            source: "apache",
            extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
            compressible: !0,
            extensions: ["ymp"]
        },
        "text/x-uuencode": {
            source: "apache",
            extensions: ["uu"]
        },
        "text/x-vcalendar": {
            source: "apache",
            extensions: ["vcs"]
        },
        "text/x-vcard": {
            source: "apache",
            extensions: ["vcf"]
        },
        "text/xml": {
            source: "iana",
            compressible: !0,
            extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
            source: "iana"
        },
        "text/yaml": {
            compressible: !0,
            extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
            source: "iana"
        },
        "video/3gpp": {
            source: "iana",
            extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
            source: "iana"
        },
        "video/3gpp2": {
            source: "iana",
            extensions: ["3g2"]
        },
        "video/av1": {
            source: "iana"
        },
        "video/bmpeg": {
            source: "iana"
        },
        "video/bt656": {
            source: "iana"
        },
        "video/celb": {
            source: "iana"
        },
        "video/dv": {
            source: "iana"
        },
        "video/encaprtp": {
            source: "iana"
        },
        "video/ffv1": {
            source: "iana"
        },
        "video/flexfec": {
            source: "iana"
        },
        "video/h261": {
            source: "iana",
            extensions: ["h261"]
        },
        "video/h263": {
            source: "iana",
            extensions: ["h263"]
        },
        "video/h263-1998": {
            source: "iana"
        },
        "video/h263-2000": {
            source: "iana"
        },
        "video/h264": {
            source: "iana",
            extensions: ["h264"]
        },
        "video/h264-rcdo": {
            source: "iana"
        },
        "video/h264-svc": {
            source: "iana"
        },
        "video/h265": {
            source: "iana"
        },
        "video/iso.segment": {
            source: "iana",
            extensions: ["m4s"]
        },
        "video/jpeg": {
            source: "iana",
            extensions: ["jpgv"]
        },
        "video/jpeg2000": {
            source: "iana"
        },
        "video/jpm": {
            source: "apache",
            extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
            source: "iana"
        },
        "video/mj2": {
            source: "iana",
            extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
            source: "iana"
        },
        "video/mp2p": {
            source: "iana"
        },
        "video/mp2t": {
            source: "iana",
            extensions: ["ts"]
        },
        "video/mp4": {
            source: "iana",
            compressible: !1,
            extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
            source: "iana"
        },
        "video/mpeg": {
            source: "iana",
            compressible: !1,
            extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
            source: "iana"
        },
        "video/mpv": {
            source: "iana"
        },
        "video/nv": {
            source: "iana"
        },
        "video/ogg": {
            source: "iana",
            compressible: !1,
            extensions: ["ogv"]
        },
        "video/parityfec": {
            source: "iana"
        },
        "video/pointer": {
            source: "iana"
        },
        "video/quicktime": {
            source: "iana",
            compressible: !1,
            extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
            source: "iana"
        },
        "video/raw": {
            source: "iana"
        },
        "video/rtp-enc-aescm128": {
            source: "iana"
        },
        "video/rtploopback": {
            source: "iana"
        },
        "video/rtx": {
            source: "iana"
        },
        "video/scip": {
            source: "iana"
        },
        "video/smpte291": {
            source: "iana"
        },
        "video/smpte292m": {
            source: "iana"
        },
        "video/ulpfec": {
            source: "iana"
        },
        "video/vc1": {
            source: "iana"
        },
        "video/vc2": {
            source: "iana"
        },
        "video/vnd.cctv": {
            source: "iana"
        },
        "video/vnd.dece.hd": {
            source: "iana",
            extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
            source: "iana",
            extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
            source: "iana"
        },
        "video/vnd.dece.pd": {
            source: "iana",
            extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
            source: "iana",
            extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
            source: "iana",
            extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
            source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
            source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
            source: "iana"
        },
        "video/vnd.dvb.file": {
            source: "iana",
            extensions: ["dvb"]
        },
        "video/vnd.fvt": {
            source: "iana",
            extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
            source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
            source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
            source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
            source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
            source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
            source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
            source: "iana"
        },
        "video/vnd.motorola.video": {
            source: "iana"
        },
        "video/vnd.motorola.videop": {
            source: "iana"
        },
        "video/vnd.mpegurl": {
            source: "iana",
            extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
            source: "iana",
            extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
            source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
            source: "iana"
        },
        "video/vnd.nokia.videovoip": {
            source: "iana"
        },
        "video/vnd.objectvideo": {
            source: "iana"
        },
        "video/vnd.radgamettools.bink": {
            source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
            source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
            source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
            source: "iana"
        },
        "video/vnd.sealed.swf": {
            source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
            source: "iana"
        },
        "video/vnd.uvvu.mp4": {
            source: "iana",
            extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
            source: "iana",
            extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
            source: "iana"
        },
        "video/vp8": {
            source: "iana"
        },
        "video/vp9": {
            source: "iana"
        },
        "video/webm": {
            source: "apache",
            compressible: !1,
            extensions: ["webm"]
        },
        "video/x-f4v": {
            source: "apache",
            extensions: ["f4v"]
        },
        "video/x-fli": {
            source: "apache",
            extensions: ["fli"]
        },
        "video/x-flv": {
            source: "apache",
            compressible: !1,
            extensions: ["flv"]
        },
        "video/x-m4v": {
            source: "apache",
            extensions: ["m4v"]
        },
        "video/x-matroska": {
            source: "apache",
            compressible: !1,
            extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
            source: "apache",
            extensions: ["mng"]
        },
        "video/x-ms-asf": {
            source: "apache",
            extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
            source: "apache",
            extensions: ["vob"]
        },
        "video/x-ms-wm": {
            source: "apache",
            extensions: ["wm"]
        },
        "video/x-ms-wmv": {
            source: "apache",
            compressible: !1,
            extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
            source: "apache",
            extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
            source: "apache",
            extensions: ["wvx"]
        },
        "video/x-msvideo": {
            source: "apache",
            extensions: ["avi"]
        },
        "video/x-sgi-movie": {
            source: "apache",
            extensions: ["movie"]
        },
        "video/x-smv": {
            source: "apache",
            extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
            source: "apache",
            extensions: ["ice"]
        },
        "x-shader/x-fragment": {
            compressible: !0
        },
        "x-shader/x-vertex": {
            compressible: !0
        }
    }
});
var uS = _((WL6, YS) => {
    /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015-2022 Douglas Christopher Wilson
     * MIT Licensed
     */
    YS.exports = TS()
});
var mS = _((A3) => {
    /*!
     * mime-types
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    var vx = uS(),
        T86 = require("path").extname,
        yS = /^\s*([^;\s]*)(?:;|\s|$)/,
        Y86 = /^text\//i;
    A3.charset = kS;
    A3.charsets = {
        lookup: kS
    };
    A3.contentType = u86;
    A3.extension = y86;
    A3.extensions = Object.create(null);
    A3.lookup = k86;
    A3.types = Object.create(null);
    m86(A3.extensions, A3.types);

    function kS(v) {
        if (!v || typeof v !== "string") return !1;
        var z = yS.exec(v),
            U = z && vx[z[1].toLowerCase()];
        if (U && U.charset) return U.charset;
        if (z && Y86.test(z[1])) return "UTF-8";
        return !1
    }

    function u86(v) {
        if (!v || typeof v !== "string") return !1;
        var z = v.indexOf("/") === -1 ? A3.lookup(v) : v;
        if (!z) return !1;
        if (z.indexOf("charset") === -1) {
            var U = A3.charset(z);
            if (U) z += "; charset=" + U.toLowerCase()
        }
        return z
    }

    function y86(v) {
        if (!v || typeof v !== "string") return !1;
        var z = yS.exec(v),
            U = z && A3.extensions[z[1].toLowerCase()];
        if (!U || !U.length) return !1;
        return U[0]
    }

    function k86(v) {
        if (!v || typeof v !== "string") return !1;
        var z = T86("x." + v).toLowerCase().substr(1);
        if (!z) return !1;
        return A3.types[z] || !1
    }

    function m86(v, z) {
        var U = ["nginx", "apache", void 0, "iana"];
        Object.keys(vx).forEach(function(N) {
            var K = vx[N],
                x = K.extensions;
            if (!x || !x.length) return;
            v[N] = x;
            for (var j = 0; j < x.length; j++) {
                var B = x[j];
                if (z[B]) {
                    var O = U.indexOf(vx[z[B]].source),
                        J = U.indexOf(K.source);
                    if (z[B] !== "application/octet-stream" && (O > J || O === J && z[B].substr(0, 12) === "application/")) continue
                }
                z[B] = N
            }
        })
    }
});
var gS = _((SL6, XS) => {
    XS.exports = X86;

    function X86(v) {
        var z = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
        if (z) z(v);
        else setTimeout(v, 0)
    }
});
var VD = _((PL6, iS) => {
    var cS = gS();
    iS.exports = g86;

    function g86(v) {
        var z = !1;
        return cS(function() {
                z = !0
            }),
            function(V, N) {
                if (z) v(V, N);
                else cS(function() {
                    v(V, N)
                })
            }
    }
});
var ND = _((_L6, lS) => {
    lS.exports = c86;

    function c86(v) {
        Object.keys(v.jobs).forEach(i86.bind(v)), v.jobs = {}
    }

    function i86(v) {
        if (typeof this.jobs[v] == "function") this.jobs[v]()
    }
});
var KD = _((CL6, pS) => {
    var hS = VD(),
        l86 = ND();
    pS.exports = h86;

    function h86(v, z, U, V) {
        var N = U.keyedList ? U.keyedList[U.index] : U.index;
        U.jobs[N] = p86(z, N, v[N], function(K, x) {
            if (!(N in U.jobs)) return;
            if (delete U.jobs[N], K) l86(U);
            else U.results[N] = x;
            V(K, U.results)
        })
    }

    function p86(v, z, U, V) {
        var N;
        if (v.length == 2) N = v(U, hS(V));
        else N = v(U, z, hS(V));
        return N
    }
});
var xD = _((fL6, nS) => {
    nS.exports = n86;

    function n86(v, z) {
        var U = !Array.isArray(v),
            V = {
                index: 0,
                keyedList: U || z ? Object.keys(v) : null,
                jobs: {},
                results: U ? {} : [],
                size: U ? Object.keys(v).length : v.length
            };
        if (z) V.keyedList.sort(U ? z : function(N, K) {
            return z(v[N], v[K])
        });
        return V
    }
});
var jD = _((TL6, QS) => {
    var Q86 = ND(),
        d86 = VD();
    QS.exports = o86;

    function o86(v) {
        if (!Object.keys(this.jobs).length) return;
        this.index = this.size, Q86(this), d86(v)(null, this.results)
    }
});
var oS = _((YL6, dS) => {
    var r86 = KD(),
        a86 = xD(),
        t86 = jD();
    dS.exports = s86;

    function s86(v, z, U) {
        var V = a86(v);
        while (V.index < (V.keyedList || v).length) r86(v, z, V, function(N, K) {
            if (N) {
                U(N, K);
                return
            }
            if (Object.keys(V.jobs).length === 0) {
                U(null, V.results);
                return
            }
        }), V.index++;
        return t86.bind(V, U)
    }
});
var BD = _((uL6, zx) => {
    var rS = KD(),
        e86 = xD(),
        v96 = jD();
    zx.exports = z96;
    zx.exports.ascending = aS;
    zx.exports.descending = U96;

    function z96(v, z, U, V) {
        var N = e86(v, U);
        return rS(v, z, N, function K(x, j) {
            if (x) {
                V(x, j);
                return
            }
            if (N.index++, N.index < (N.keyedList || v).length) {
                rS(v, z, N, K);
                return
            }
            V(null, N.results)
        }), v96.bind(N, V)
    }

    function aS(v, z) {
        return v < z ? -1 : v > z ? 1 : 0
    }

    function U96(v, z) {
        return -1 * aS(v, z)
    }
});
var sS = _((yL6, tS) => {
    var V96 = BD();
    tS.exports = N96;

    function N96(v, z, U) {
        return V96(v, z, null, U)
    }
});
var vP = _((kL6, eS) => {
    eS.exports = {
        parallel: oS(),
        serial: sS(),
        serialOrdered: BD()
    }
});
var OD = _((mL6, zP) => {
    zP.exports = Object
});
var VP = _((XL6, UP) => {
    UP.exports = Error
});
var KP = _((gL6, NP) => {
    NP.exports = EvalError
});
var jP = _((cL6, xP) => {
    xP.exports = RangeError
});
var OP = _((iL6, BP) => {
    BP.exports = ReferenceError
});
var qP = _((lL6, JP) => {
    JP.exports = SyntaxError
});
var Ux = _((hL6, HP) => {
    HP.exports = TypeError
});
var AP = _((pL6, DP) => {
    DP.exports = URIError
});
var wP = _((nL6, $P) => {
    $P.exports = Math.abs
});
var LP = _((QL6, ZP) => {
    ZP.exports = Math.floor
});
var GP = _((dL6, FP) => {
    FP.exports = Math.max
});
var MP = _((oL6, IP) => {
    IP.exports = Math.min
});
var RP = _((rL6, bP) => {
    bP.exports = Math.pow
});
var EP = _((aL6, WP) => {
    WP.exports = Math.round
});
var PP = _((tL6, SP) => {
    SP.exports = Number.isNaN || function(z) {
        return z !== z
    }
});
var CP = _((sL6, _P) => {
    var K96 = PP();
    _P.exports = function(z) {
        if (K96(z) || z === 0) return z;
        return z < 0 ? -1 : 1
    }
});
var TP = _((eL6, fP) => {
    fP.exports = Object.getOwnPropertyDescriptor
});
var JD = _((vF6, YP) => {
    var Vx = TP();
    if (Vx) try {
        Vx([], "length")
    } catch (v) {
        Vx = null
    }
    YP.exports = Vx
});
var yP = _((zF6, uP) => {
    var Nx = Object.defineProperty || !1;
    if (Nx) try {
        Nx({}, "a", {
            value: 1
        })
    } catch (v) {
        Nx = !1
    }
    uP.exports = Nx
});
var qD = _((UF6, kP) => {
    kP.exports = function() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return !1;
        if (typeof Symbol.iterator === "symbol") return !0;
        var z = {},
            U = Symbol("test"),
            V = Object(U);
        if (typeof U === "string") return !1;
        if (Object.prototype.toString.call(U) !== "[object Symbol]") return !1;
        if (Object.prototype.toString.call(V) !== "[object Symbol]") return !1;
        var N = 42;
        z[U] = N;
        for (var K in z) return !1;
        if (typeof Object.keys === "function" && Object.keys(z).length !== 0) return !1;
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(z).length !== 0) return !1;
        var x = Object.getOwnPropertySymbols(z);
        if (x.length !== 1 || x[0] !== U) return !1;
        if (!Object.prototype.propertyIsEnumerable.call(z, U)) return !1;
        if (typeof Object.getOwnPropertyDescriptor === "function") {
            var j = Object.getOwnPropertyDescriptor(z, U);
            if (j.value !== N || j.enumerable !== !0) return !1
        }
        return !0
    }
});
var gP = _((VF6, XP) => {
    var mP = typeof Symbol < "u" && Symbol,
        x96 = qD();
    XP.exports = function() {
        if (typeof mP !== "function") return !1;
        if (typeof Symbol !== "function") return !1;
        if (typeof mP("foo") !== "symbol") return !1;
        if (typeof Symbol("bar") !== "symbol") return !1;
        return x96()
    }
});
var HD = _((NF6, cP) => {
    cP.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null
});
var DD = _((KF6, iP) => {
    var j96 = OD();
    iP.exports = j96.getPrototypeOf || null
});
var pP = _((xF6, hP) => {
    var B96 = "Function.prototype.bind called on incompatible ",
        O96 = Object.prototype.toString,
        J96 = Math.max,
        q96 = "[object Function]",
        lP = function(z, U) {
            var V = [];
            for (var N = 0; N < z.length; N += 1) V[N] = z[N];
            for (var K = 0; K < U.length; K += 1) V[K + z.length] = U[K];
            return V
        },
        H96 = function(z, U) {
            var V = [];
            for (var N = U || 0, K = 0; N < z.length; N += 1, K += 1) V[K] = z[N];
            return V
        },
        D96 = function(v, z) {
            var U = "";
            for (var V = 0; V < v.length; V += 1)
                if (U += v[V], V + 1 < v.length) U += z;
            return U
        };
    hP.exports = function(z) {
        var U = this;
        if (typeof U !== "function" || O96.apply(U) !== q96) throw TypeError(B96 + U);
        var V = H96(arguments, 1),
            N, K = function() {
                if (this instanceof N) {
                    var J = U.apply(this, lP(V, arguments));
                    if (Object(J) === J) return J;
                    return this
                }
                return U.apply(z, lP(V, arguments))
            },
            x = J96(0, U.length - V.length),
            j = [];
        for (var B = 0; B < x; B++) j[B] = "$" + B;
        if (N = Function("binder", "return function (" + D96(j, ",") + "){ return binder.apply(this,arguments); }")(K), U.prototype) {
            var O = function() {};
            O.prototype = U.prototype, N.prototype = new O, O.prototype = null
        }
        return N
    }
});
var UU = _((jF6, nP) => {
    var A96 = pP();
    nP.exports = Function.prototype.bind || A96
});
var Kx = _((BF6, QP) => {
    QP.exports = Function.prototype.call
});
var AD = _((OF6, dP) => {
    dP.exports = Function.prototype.apply
});
var rP = _((JF6, oP) => {
    oP.exports = typeof Reflect < "u" && Reflect && Reflect.apply
});
var tP = _((qF6, aP) => {
    var $96 = UU(),
        w96 = AD(),
        Z96 = Kx(),
        L96 = rP();
    aP.exports = L96 || $96.call(Z96, w96)
});
var eP = _((HF6, sP) => {
    var F96 = UU(),
        G96 = Ux(),
        I96 = Kx(),
        M96 = tP();
    sP.exports = function(z) {
        if (z.length < 1 || typeof z[0] !== "function") throw new G96("a function is required");
        return M96(F96, I96, z)
    }
});
var K_ = _((DF6, N_) => {
    var b96 = eP(),
        v_ = JD(),
        U_;
    try {
        U_ = [].__proto__ === Array.prototype
    } catch (v) {
        if (!v || typeof v !== "object" || !("code" in v) || v.code !== "ERR_PROTO_ACCESS") throw v
    }
    var $D = !!U_ && v_ && v_(Object.prototype, "__proto__"),
        V_ = Object,
        z_ = V_.getPrototypeOf;
    N_.exports = $D && typeof $D.get === "function" ? b96([$D.get]) : typeof z_ === "function" ? function(z) {
        return z_(z == null ? z : V_(z))
    } : !1
});
var J_ = _((AF6, O_) => {
    var x_ = HD(),
        j_ = DD(),
        B_ = K_();
    O_.exports = x_ ? function(z) {
        return x_(z)
    } : j_ ? function(z) {
        if (!z || typeof z !== "object" && typeof z !== "function") throw TypeError("getProto: not an object");
        return j_(z)
    } : B_ ? function(z) {
        return B_(z)
    } : null
});
var wD = _(($F6, q_) => {
    var R96 = Function.prototype.call,
        W96 = Object.prototype.hasOwnProperty,
        E96 = UU();
    q_.exports = E96.call(R96, W96)
});
var Z_ = _((wF6, w_) => {
    var j0, S96 = OD(),
        P96 = VP(),
        _96 = KP(),
        C96 = jP(),
        f96 = OP(),
        _v = qP(),
        Pv = Ux(),
        T96 = AP(),
        Y96 = wP(),
        u96 = LP(),
        y96 = GP(),
        k96 = MP(),
        m96 = RP(),
        X96 = EP(),
        g96 = CP(),
        A_ = Function,
        ZD = function(v) {
            try {
                return A_('"use strict"; return (' + v + ").constructor;")()
            } catch (z) {}
        },
        VU = JD(),
        c96 = yP(),
        LD = function() {
            throw new Pv
        },
        i96 = VU ? function() {
            try {
                return arguments.callee, LD
            } catch (v) {
                try {
                    return VU(arguments, "callee").get
                } catch (z) {
                    return LD
                }
            }
        }() : LD,
        Ev = gP()(),
        G4 = J_(),
        l96 = DD(),
        h96 = HD(),
        $_ = AD(),
        NU = Kx(),
        Sv = {},
        p96 = typeof Uint8Array > "u" || !G4 ? j0 : G4(Uint8Array),
        t5 = {
            __proto__: null,
            "%AggregateError%": typeof AggregateError > "u" ? j0 : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer > "u" ? j0 : ArrayBuffer,
            "%ArrayIteratorPrototype%": Ev && G4 ? G4([][Symbol.iterator]()) : j0,
            "%AsyncFromSyncIteratorPrototype%": j0,
            "%AsyncFunction%": Sv,
            "%AsyncGenerator%": Sv,
            "%AsyncGeneratorFunction%": Sv,
            "%AsyncIteratorPrototype%": Sv,
            "%Atomics%": typeof Atomics > "u" ? j0 : Atomics,
            "%BigInt%": typeof BigInt > "u" ? j0 : BigInt,
            "%BigInt64Array%": typeof BigInt64Array > "u" ? j0 : BigInt64Array,
            "%BigUint64Array%": typeof BigUint64Array > "u" ? j0 : BigUint64Array,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView > "u" ? j0 : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": P96,
            "%eval%": eval,
            "%EvalError%": _96,
            "%Float16Array%": typeof Float16Array > "u" ? j0 : Float16Array,
            "%Float32Array%": typeof Float32Array > "u" ? j0 : Float32Array,
            "%Float64Array%": typeof Float64Array > "u" ? j0 : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? j0 : FinalizationRegistry,
            "%Function%": A_,
            "%GeneratorFunction%": Sv,
            "%Int8Array%": typeof Int8Array > "u" ? j0 : Int8Array,
            "%Int16Array%": typeof Int16Array > "u" ? j0 : Int16Array,
            "%Int32Array%": typeof Int32Array > "u" ? j0 : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": Ev && G4 ? G4(G4([][Symbol.iterator]())) : j0,
            "%JSON%": typeof JSON === "object" ? JSON : j0,
            "%Map%": typeof Map > "u" ? j0 : Map,
            "%MapIteratorPrototype%": typeof Map > "u" || !Ev || !G4 ? j0 : G4(new Map()[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": S96,
            "%Object.getOwnPropertyDescriptor%": VU,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise > "u" ? j0 : Promise,
            "%Proxy%": typeof Proxy > "u" ? j0 : Proxy,
            "%RangeError%": C96,
            "%ReferenceError%": f96,
            "%Reflect%": typeof Reflect > "u" ? j0 : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set > "u" ? j0 : Set,
            "%SetIteratorPrototype%": typeof Set > "u" || !Ev || !G4 ? j0 : G4(new Set()[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? j0 : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": Ev && G4 ? G4("" [Symbol.iterator]()) : j0,
            "%Symbol%": Ev ? Symbol : j0,
            "%SyntaxError%": _v,
            "%ThrowTypeError%": i96,
            "%TypedArray%": p96,
            "%TypeError%": Pv,
            "%Uint8Array%": typeof Uint8Array > "u" ? j0 : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? j0 : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array > "u" ? j0 : Uint16Array,
            "%Uint32Array%": typeof Uint32Array > "u" ? j0 : Uint32Array,
            "%URIError%": T96,
            "%WeakMap%": typeof WeakMap > "u" ? j0 : WeakMap,
            "%WeakRef%": typeof WeakRef > "u" ? j0 : WeakRef,
            "%WeakSet%": typeof WeakSet > "u" ? j0 : WeakSet,
            "%Function.prototype.call%": NU,
            "%Function.prototype.apply%": $_,
            "%Object.defineProperty%": c96,
            "%Object.getPrototypeOf%": l96,
            "%Math.abs%": Y96,
            "%Math.floor%": u96,
            "%Math.max%": y96,
            "%Math.min%": k96,
            "%Math.pow%": m96,
            "%Math.round%": X96,
            "%Math.sign%": g96,
            "%Reflect.getPrototypeOf%": h96
        };
    if (G4) try {
        null.error
    } catch (v) {
        FD = G4(G4(v)), t5["%Error.prototype%"] = FD
    }
    var FD, n96 = function v(z) {
            var U;
            if (z === "%AsyncFunction%") U = ZD("async function () {}");
            else if (z === "%GeneratorFunction%") U = ZD("function* () {}");
            else if (z === "%AsyncGeneratorFunction%") U = ZD("async function* () {}");
            else if (z === "%AsyncGenerator%") {
                var V = v("%AsyncGeneratorFunction%");
                if (V) U = V.prototype
            } else if (z === "%AsyncIteratorPrototype%") {
                var N = v("%AsyncGenerator%");
                if (N && G4) U = G4(N.prototype)
            }
            return t5[z] = U, U
        },
        H_ = {
            __proto__: null,
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
        },
        KU = UU(),
        xx = wD(),
        Q96 = KU.call(NU, Array.prototype.concat),
        d96 = KU.call($_, Array.prototype.splice),
        D_ = KU.call(NU, String.prototype.replace),
        jx = KU.call(NU, String.prototype.slice),
        o96 = KU.call(NU, RegExp.prototype.exec),
        r96 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        a96 = /\\(\\)?/g,
        t96 = function(z) {
            var U = jx(z, 0, 1),
                V = jx(z, -1);
            if (U === "%" && V !== "%") throw new _v("invalid intrinsic syntax, expected closing `%`");
            else if (V === "%" && U !== "%") throw new _v("invalid intrinsic syntax, expected opening `%`");
            var N = [];
            return D_(z, r96, function(K, x, j, B) {
                N[N.length] = j ? D_(B, a96, "$1") : x || K
            }), N
        },
        s96 = function(z, U) {
            var V = z,
                N;
            if (xx(H_, V)) N = H_[V], V = "%" + N[0] + "%";
            if (xx(t5, V)) {
                var K = t5[V];
                if (K === Sv) K = n96(V);
                if (typeof K > "u" && !U) throw new Pv("intrinsic " + z + " exists, but is not available. Please file an issue!");
                return {
                    alias: N,
                    name: V,
                    value: K
                }
            }
            throw new _v("intrinsic " + z + " does not exist!")
        };
    w_.exports = function(z, U) {
        if (typeof z !== "string" || z.length === 0) throw new Pv("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof U !== "boolean") throw new Pv('"allowMissing" argument must be a boolean');
        if (o96(/^%?[^%]*%?$/, z) === null) throw new _v("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var V = t96(z),
            N = V.length > 0 ? V[0] : "",
            K = s96("%" + N + "%", U),
            x = K.name,
            j = K.value,
            B = !1,
            O = K.alias;
        if (O) N = O[0], d96(V, Q96([0, 1], O));
        for (var J = 1, q = !0; J < V.length; J += 1) {
            var H = V[J],
                D = jx(H, 0, 1),
                A = jx(H, -1);
            if ((D === '"' || D === "'" || D === "`" || (A === '"' || A === "'" || A === "`")) && D !== A) throw new _v("property names with quotes must have matching quotes");
            if (H === "constructor" || !q) B = !0;
            if (N += "." + H, x = "%" + N + "%", xx(t5, x)) j = t5[x];
            else if (j != null) {
                if (!(H in j)) {
                    if (!U) throw new Pv("base intrinsic for " + z + " exists, but the property is not available.");
                    return
                }
                if (VU && J + 1 >= V.length) {
                    var w = VU(j, H);
                    if (q = !!w, q && "get" in w && !("originalValue" in w.get)) j = w.get;
                    else j = j[H]
                } else q = xx(j, H), j = j[H];
                if (q && !B) t5[x] = j
            }
        }
        return j
    }
});
var F_ = _((ZF6, L_) => {
    var e96 = qD();
    L_.exports = function() {
        return e96() && !!Symbol.toStringTag
    }
});
var M_ = _((LF6, I_) => {
    var v56 = Z_(),
        G_ = v56("%Object.defineProperty%", !0),
        z56 = F_()(),
        U56 = wD(),
        V56 = Ux(),
        Bx = z56 ? Symbol.toStringTag : null;
    I_.exports = function(z, U) {
        var V = arguments.length > 2 && !!arguments[2] && arguments[2].force,
            N = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
        if (typeof V < "u" && typeof V !== "boolean" || typeof N < "u" && typeof N !== "boolean") throw new V56("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
        if (Bx && (V || !U56(z, Bx)))
            if (G_) G_(z, Bx, {
                configurable: !N,
                enumerable: !1,
                value: U,
                writable: !1
            });
            else z[Bx] = U
    }
});
var R_ = _((FF6, b_) => {
    b_.exports = function(v, z) {
        return Object.keys(z).forEach(function(U) {
            v[U] = v[U] || z[U]
        }), v
    }
});
var E_ = _((GF6, W_) => {
    var bD = fS(),
        N56 = require("util"),
        GD = require("path"),
        K56 = require("http"),
        x56 = require("https"),
        j56 = require("url").parse,
        B56 = require("fs"),
        O56 = require("stream").Stream,
        ID = mS(),
        J56 = vP(),
        q56 = M_(),
        MD = R_();
    W_.exports = H0;
    N56.inherits(H0, bD);

    function H0(v) {
        if (!(this instanceof H0)) return new H0(v);
        this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], bD.call(this), v = v || {};
        for (var z in v) this[z] = v[z]
    }
    H0.LINE_BREAK = `\r
`;
    H0.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    H0.prototype.append = function(v, z, U) {
        if (U = U || {}, typeof U == "string") U = {
            filename: U
        };
        var V = bD.prototype.append.bind(this);
        if (typeof z == "number") z = "" + z;
        if (Array.isArray(z)) {
            this._error(Error("Arrays are not supported."));
            return
        }
        var N = this._multiPartHeader(v, z, U),
            K = this._multiPartFooter();
        V(N), V(z), V(K), this._trackLength(N, z, U)
    };
    H0.prototype._trackLength = function(v, z, U) {
        var V = 0;
        if (U.knownLength != null) V += +U.knownLength;
        else if (Buffer.isBuffer(z)) V = z.length;
        else if (typeof z === "string") V = Buffer.byteLength(z);
        if (this._valueLength += V, this._overheadLength += Buffer.byteLength(v) + H0.LINE_BREAK.length, !z || !z.path && !(z.readable && Object.prototype.hasOwnProperty.call(z, "httpVersion")) && !(z instanceof O56)) return;
        if (!U.knownLength) this._valuesToMeasure.push(z)
    };
    H0.prototype._lengthRetriever = function(v, z) {
        if (Object.prototype.hasOwnProperty.call(v, "fd"))
            if (v.end != null && v.end != 1 / 0 && v.start != null) z(null, v.end + 1 - (v.start ? v.start : 0));
            else B56.stat(v.path, function(U, V) {
                var N;
                if (U) {
                    z(U);
                    return
                }
                N = V.size - (v.start ? v.start : 0), z(null, N)
            });
        else if (Object.prototype.hasOwnProperty.call(v, "httpVersion")) z(null, +v.headers["content-length"]);
        else if (Object.prototype.hasOwnProperty.call(v, "httpModule")) v.on("response", function(U) {
            v.pause(), z(null, +U.headers["content-length"])
        }), v.resume();
        else z("Unknown stream")
    };
    H0.prototype._multiPartHeader = function(v, z, U) {
        if (typeof U.header == "string") return U.header;
        var V = this._getContentDisposition(z, U),
            N = this._getContentType(z, U),
            K = "",
            x = {
                "Content-Disposition": ["form-data", 'name="' + v + '"'].concat(V || []),
                "Content-Type": [].concat(N || [])
            };
        if (typeof U.header == "object") MD(x, U.header);
        var j;
        for (var B in x)
            if (Object.prototype.hasOwnProperty.call(x, B)) {
                if (j = x[B], j == null) continue;
                if (!Array.isArray(j)) j = [j];
                if (j.length) K += B + ": " + j.join("; ") + H0.LINE_BREAK
            } return "--" + this.getBoundary() + H0.LINE_BREAK + K + H0.LINE_BREAK
    };
    H0.prototype._getContentDisposition = function(v, z) {
        var U, V;
        if (typeof z.filepath === "string") U = GD.normalize(z.filepath).replace(/\\/g, "/");
        else if (z.filename || v.name || v.path) U = GD.basename(z.filename || v.name || v.path);
        else if (v.readable && Object.prototype.hasOwnProperty.call(v, "httpVersion")) U = GD.basename(v.client._httpMessage.path || "");
        if (U) V = 'filename="' + U + '"';
        return V
    };
    H0.prototype._getContentType = function(v, z) {
        var U = z.contentType;
        if (!U && v.name) U = ID.lookup(v.name);
        if (!U && v.path) U = ID.lookup(v.path);
        if (!U && v.readable && Object.prototype.hasOwnProperty.call(v, "httpVersion")) U = v.headers["content-type"];
        if (!U && (z.filepath || z.filename)) U = ID.lookup(z.filepath || z.filename);
        if (!U && typeof v == "object") U = H0.DEFAULT_CONTENT_TYPE;
        return U
    };
    H0.prototype._multiPartFooter = function() {
        return function(v) {
            var z = H0.LINE_BREAK,
                U = this._streams.length === 0;
            if (U) z += this._lastBoundary();
            v(z)
        }.bind(this)
    };
    H0.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + H0.LINE_BREAK
    };
    H0.prototype.getHeaders = function(v) {
        var z, U = {
            "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (z in v)
            if (Object.prototype.hasOwnProperty.call(v, z)) U[z.toLowerCase()] = v[z];
        return U
    };
    H0.prototype.setBoundary = function(v) {
        this._boundary = v
    };
    H0.prototype.getBoundary = function() {
        if (!this._boundary) this._generateBoundary();
        return this._boundary
    };
    H0.prototype.getBuffer = function() {
        var v = new Buffer.alloc(0),
            z = this.getBoundary();
        for (var U = 0, V = this._streams.length; U < V; U++)
            if (typeof this._streams[U] !== "function") {
                if (Buffer.isBuffer(this._streams[U])) v = Buffer.concat([v, this._streams[U]]);
                else v = Buffer.concat([v, Buffer.from(this._streams[U])]);
                if (typeof this._streams[U] !== "string" || this._streams[U].substring(2, z.length + 2) !== z) v = Buffer.concat([v, Buffer.from(H0.LINE_BREAK)])
            } return Buffer.concat([v, Buffer.from(this._lastBoundary())])
    };
    H0.prototype._generateBoundary = function() {
        var v = "--------------------------";
        for (var z = 0; z < 24; z++) v += Math.floor(Math.random() * 10).toString(16);
        this._boundary = v
    };
    H0.prototype.getLengthSync = function() {
        var v = this._overheadLength + this._valueLength;
        if (this._streams.length) v += this._lastBoundary().length;
        if (!this.hasKnownLength()) this._error(Error("Cannot calculate proper length in synchronous way."));
        return v
    };
    H0.prototype.hasKnownLength = function() {
        var v = !0;
        if (this._valuesToMeasure.length) v = !1;
        return v
    };
    H0.prototype.getLength = function(v) {
        var z = this._overheadLength + this._valueLength;
        if (this._streams.length) z += this._lastBoundary().length;
        if (!this._valuesToMeasure.length) {
            process.nextTick(v.bind(this, null, z));
            return
        }
        J56.parallel(this._valuesToMeasure, this._lengthRetriever, function(U, V) {
            if (U) {
                v(U);
                return
            }
            V.forEach(function(N) {
                z += N
            }), v(null, z)
        })
    };
    H0.prototype.submit = function(v, z) {
        var U, V, N = {
            method: "post"
        };
        if (typeof v == "string") v = j56(v), V = MD({
            port: v.port,
            path: v.pathname,
            host: v.hostname,
            protocol: v.protocol
        }, N);
        else if (V = MD(v, N), !V.port) V.port = V.protocol == "https:" ? 443 : 80;
        if (V.headers = this.getHeaders(v.headers), V.protocol == "https:") U = x56.request(V);
        else U = K56.request(V);
        return this.getLength(function(K, x) {
            if (K && K !== "Unknown stream") {
                this._error(K);
                return
            }
            if (x) U.setHeader("Content-Length", x);
            if (this.pipe(U), z) {
                var j, B = function(O, J) {
                    return U.removeListener("error", B), U.removeListener("response", j), z.call(this, O, J)
                };
                j = B.bind(this, null), U.on("error", B), U.on("response", j)
            }
        }.bind(this)), U
    };
    H0.prototype._error = function(v) {
        if (!this.error) this.error = v, this.pause(), this.emit("error", v)
    };
    H0.prototype.toString = function() {
        return "[object FormData]"
    };
    q56(H0, "FormData")
});
var n_ = _((p_) => {
    var _56 = require("url").parse,
        C56 = {
            ftp: 21,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        },
        f56 = String.prototype.endsWith || function(v) {
            return v.length <= this.length && this.indexOf(v, this.length - v.length) !== -1
        };

    function T56(v) {
        var z = typeof v === "string" ? _56(v) : v || {},
            U = z.protocol,
            V = z.host,
            N = z.port;
        if (typeof V !== "string" || !V || typeof U !== "string") return "";
        if (U = U.split(":", 1)[0], V = V.replace(/:\d*$/, ""), N = parseInt(N) || C56[U] || 0, !Y56(V, N)) return "";
        var K = Tv("npm_config_" + U + "_proxy") || Tv(U + "_proxy") || Tv("npm_config_proxy") || Tv("all_proxy");
        if (K && K.indexOf("://") === -1) K = U + "://" + K;
        return K
    }

    function Y56(v, z) {
        var U = (Tv("npm_config_no_proxy") || Tv("no_proxy")).toLowerCase();
        if (!U) return !0;
        if (U === "*") return !1;
        return U.split(/[,\s]/).every(function(V) {
            if (!V) return !0;
            var N = V.match(/^(.+):(\d+)$/),
                K = N ? N[1] : V,
                x = N ? parseInt(N[2]) : 0;
            if (x && x !== z) return !0;
            if (!/^[.*]/.test(K)) return v !== K;
            if (K.charAt(0) === "*") K = K.slice(1);
            return !f56.call(v, K)
        })
    }

    function Tv(v) {
        return process.env[v.toLowerCase()] || process.env[v.toUpperCase()] || ""
    }
    p_.getProxyForUrl = T56
});
var d_ = _((IG6, Q_) => {
    var Yv = 1000,
        uv = Yv * 60,
        yv = uv * 60,
        v7 = yv * 24,
        u56 = v7 * 7,
        y56 = v7 * 365.25;
    Q_.exports = function(v, z) {
        z = z || {};
        var U = typeof v;
        if (U === "string" && v.length > 0) return k56(v);
        else if (U === "number" && isFinite(v)) return z.long ? X56(v) : m56(v);
        throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(v))
    };

    function k56(v) {
        if (v = String(v), v.length > 100) return;
        var z = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(v);
        if (!z) return;
        var U = parseFloat(z[1]),
            V = (z[2] || "ms").toLowerCase();
        switch (V) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
                return U * y56;
            case "weeks":
            case "week":
            case "w":
                return U * u56;
            case "days":
            case "day":
            case "d":
                return U * v7;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
                return U * yv;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
                return U * uv;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
                return U * Yv;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
                return U;
            default:
                return
        }
    }

    function m56(v) {
        var z = Math.abs(v);
        if (z >= v7) return Math.round(v / v7) + "d";
        if (z >= yv) return Math.round(v / yv) + "h";
        if (z >= uv) return Math.round(v / uv) + "m";
        if (z >= Yv) return Math.round(v / Yv) + "s";
        return v + "ms"
    }

    function X56(v) {
        var z = Math.abs(v);
        if (z >= v7) return Hx(v, z, v7, "day");
        if (z >= yv) return Hx(v, z, yv, "hour");
        if (z >= uv) return Hx(v, z, uv, "minute");
        if (z >= Yv) return Hx(v, z, Yv, "second");
        return v + " ms"
    }

    function Hx(v, z, U, V) {
        var N = z >= U * 1.5;
        return Math.round(v / U) + " " + V + (N ? "s" : "")
    }
});
var yD = _((MG6, o_) => {
    function g56(v) {
        U.debug = U, U.default = U, U.coerce = B, U.disable = x, U.enable = N, U.enabled = j, U.humanize = d_(), U.destroy = O, Object.keys(v).forEach((J) => {
            U[J] = v[J]
        }), U.names = [], U.skips = [], U.formatters = {};

        function z(J) {
            let q = 0;
            for (let H = 0; H < J.length; H++) q = (q << 5) - q + J.charCodeAt(H), q |= 0;
            return U.colors[Math.abs(q) % U.colors.length]
        }
        U.selectColor = z;

        function U(J) {
            let q, H = null,
                D, A;

            function w(...Z) {
                if (!w.enabled) return;
                let $ = w,
                    F = Number(new Date),
                    L = F - (q || F);
                if ($.diff = L, $.prev = q, $.curr = F, q = F, Z[0] = U.coerce(Z[0]), typeof Z[0] !== "string") Z.unshift("%O");
                let G = 0;
                Z[0] = Z[0].replace(/%([a-zA-Z%])/g, (M, b) => {
                    if (M === "%%") return "%";
                    G++;
                    let W = U.formatters[b];
                    if (typeof W === "function") {
                        let E = Z[G];
                        M = W.call($, E), Z.splice(G, 1), G--
                    }
                    return M
                }), U.formatArgs.call($, Z), ($.log || U.log).apply($, Z)
            }
            if (w.namespace = J, w.useColors = U.useColors(), w.color = U.selectColor(J), w.extend = V, w.destroy = U.destroy, Object.defineProperty(w, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => {
                        if (H !== null) return H;
                        if (D !== U.namespaces) D = U.namespaces, A = U.enabled(J);
                        return A
                    },
                    set: (Z) => {
                        H = Z
                    }
                }), typeof U.init === "function") U.init(w);
            return w
        }

        function V(J, q) {
            let H = U(this.namespace + (typeof q > "u" ? ":" : q) + J);
            return H.log = this.log, H
        }

        function N(J) {
            U.save(J), U.namespaces = J, U.names = [], U.skips = [];
            let q = (typeof J === "string" ? J : "").trim().replace(" ", ",").split(",").filter(Boolean);
            for (let H of q)
                if (H[0] === "-") U.skips.push(H.slice(1));
                else U.names.push(H)
        }

        function K(J, q) {
            let H = 0,
                D = 0,
                A = -1,
                w = 0;
            while (H < J.length)
                if (D < q.length && (q[D] === J[H] || q[D] === "*"))
                    if (q[D] === "*") A = D, w = H, D++;
                    else H++, D++;
            else if (A !== -1) D = A + 1, w++, H = w;
            else return !1;
            while (D < q.length && q[D] === "*") D++;
            return D === q.length
        }

        function x() {
            let J = [...U.names, ...U.skips.map((q) => "-" + q)].join(",");
            return U.enable(""), J
        }

        function j(J) {
            for (let q of U.skips)
                if (K(J, q)) return !1;
            for (let q of U.names)
                if (K(J, q)) return !0;
            return !1
        }

        function B(J) {
            if (J instanceof Error) return J.stack || J.message;
            return J
        }

        function O() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
        return U.enable(U.load()), U
    }
    o_.exports = g56
});
var r_ = _((C3, Dx) => {
    C3.formatArgs = i56;
    C3.save = l56;
    C3.load = h56;
    C3.useColors = c56;
    C3.storage = p56();
    C3.destroy = (() => {
        let v = !1;
        return () => {
            if (!v) v = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
    })();
    C3.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

    function c56() {
        if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
        if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
        let v;
        return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (v = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(v[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }

    function i56(v) {
        if (v[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + v[0] + (this.useColors ? "%c " : " ") + "+" + Dx.exports.humanize(this.diff), !this.useColors) return;
        let z = "color: " + this.color;
        v.splice(1, 0, z, "color: inherit");
        let U = 0,
            V = 0;
        v[0].replace(/%[a-zA-Z%]/g, (N) => {
            if (N === "%%") return;
            if (U++, N === "%c") V = U
        }), v.splice(V, 0, z)
    }
    C3.log = console.debug || console.log || (() => {});

    function l56(v) {
        try {
            if (v) C3.storage.setItem("debug", v);
            else C3.storage.removeItem("debug")
        } catch (z) {}
    }

    function h56() {
        let v;
        try {
            v = C3.storage.getItem("debug")
        } catch (z) {}
        if (!v && typeof process < "u" && "env" in process) v = process.env.DEBUG;
        return v
    }

    function p56() {
        try {
            return localStorage
        } catch (v) {}
    }
    Dx.exports = yD()(C3);
    var {
        formatters: n56
    } = Dx.exports;
    n56.j = function(v) {
        try {
            return JSON.stringify(v)
        } catch (z) {
            return "[UnexpectedJSONParseError]: " + z.message
        }
    }
});
var t_ = _((bG6, a_) => {
    a_.exports = (v, z = process.argv) => {
        let U = v.startsWith("-") ? "" : v.length === 1 ? "-" : "--",
            V = z.indexOf(U + v),
            N = z.indexOf("--");
        return V !== -1 && (N === -1 || V < N)
    }
});
var vC = _((RG6, e_) => {
    var Q56 = require("os"),
        s_ = require("tty"),
        l3 = t_(),
        {
            env: I4
        } = process,
        Ax;
    if (l3("no-color") || l3("no-colors") || l3("color=false") || l3("color=never")) Ax = 0;
    else if (l3("color") || l3("colors") || l3("color=true") || l3("color=always")) Ax = 1;

    function d56() {
        if ("FORCE_COLOR" in I4) {
            if (I4.FORCE_COLOR === "true") return 1;
            if (I4.FORCE_COLOR === "false") return 0;
            return I4.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(I4.FORCE_COLOR, 10), 3)
        }
    }

    function o56(v) {
        if (v === 0) return !1;
        return {
            level: v,
            hasBasic: !0,
            has256: v >= 2,
            has16m: v >= 3
        }
    }

    function r56(v, {
        streamIsTTY: z,
        sniffFlags: U = !0
    } = {}) {
        let V = d56();
        if (V !== void 0) Ax = V;
        let N = U ? Ax : V;
        if (N === 0) return 0;
        if (U) {
            if (l3("color=16m") || l3("color=full") || l3("color=truecolor")) return 3;
            if (l3("color=256")) return 2
        }
        if (v && !z && N === void 0) return 0;
        let K = N || 0;
        if (I4.TERM === "dumb") return K;
        if (process.platform === "win32") {
            let x = Q56.release().split(".");
            if (Number(x[0]) >= 10 && Number(x[2]) >= 10586) return Number(x[2]) >= 14931 ? 3 : 2;
            return 1
        }
        if ("CI" in I4) {
            if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((x) => (x in I4)) || I4.CI_NAME === "codeship") return 1;
            return K
        }
        if ("TEAMCITY_VERSION" in I4) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(I4.TEAMCITY_VERSION) ? 1 : 0;
        if (I4.COLORTERM === "truecolor") return 3;
        if ("TERM_PROGRAM" in I4) {
            let x = Number.parseInt((I4.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (I4.TERM_PROGRAM) {
                case "iTerm.app":
                    return x >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2
            }
        }
        if (/-256(color)?$/i.test(I4.TERM)) return 2;
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(I4.TERM)) return 1;
        if ("COLORTERM" in I4) return 1;
        return K
    }

    function kD(v, z = {}) {
        let U = r56(v, {
            streamIsTTY: v && v.isTTY,
            ...z
        });
        return o56(U)
    }
    e_.exports = {
        supportsColor: kD,
        stdout: kD({
            isTTY: s_.isatty(1)
        }),
        stderr: kD({
            isTTY: s_.isatty(2)
        })
    }
});
var UC = _((M4, wx) => {
    var a56 = require("tty"),
        $x = require("util");
    M4.init = V76;
    M4.log = v76;
    M4.formatArgs = s56;
    M4.save = z76;
    M4.load = U76;
    M4.useColors = t56;
    M4.destroy = $x.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    M4.colors = [6, 2, 3, 4, 5, 1];
    try {
        let v = vC();
        if (v && (v.stderr || v).level >= 2) M4.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]
    } catch (v) {}
    M4.inspectOpts = Object.keys(process.env).filter((v) => {
        return /^debug_/i.test(v)
    }).reduce((v, z) => {
        let U = z.substring(6).toLowerCase().replace(/_([a-z])/g, (N, K) => {
                return K.toUpperCase()
            }),
            V = process.env[z];
        if (/^(yes|on|true|enabled)$/i.test(V)) V = !0;
        else if (/^(no|off|false|disabled)$/i.test(V)) V = !1;
        else if (V === "null") V = null;
        else V = Number(V);
        return v[U] = V, v
    }, {});

    function t56() {
        return "colors" in M4.inspectOpts ? Boolean(M4.inspectOpts.colors) : a56.isatty(process.stderr.fd)
    }

    function s56(v) {
        let {
            namespace: z,
            useColors: U
        } = this;
        if (U) {
            let V = this.color,
                N = "\x1B[3" + (V < 8 ? V : "8;5;" + V),
                K = `  ${N};1m${z} \x1B[0m`;
            v[0] = K + v[0].split(`
`).join(`
` + K), v.push(N + "m+" + wx.exports.humanize(this.diff) + "\x1B[0m")
        } else v[0] = e56() + z + " " + v[0]
    }

    function e56() {
        if (M4.inspectOpts.hideDate) return "";
        return new Date().toISOString() + " "
    }

    function v76(...v) {
        return process.stderr.write($x.formatWithOptions(M4.inspectOpts, ...v) + `
`)
    }

    function z76(v) {
        if (v) process.env.DEBUG = v;
        else delete process.env.DEBUG
    }

    function U76() {
        return process.env.DEBUG
    }

    function V76(v) {
        v.inspectOpts = {};
        let z = Object.keys(M4.inspectOpts);
        for (let U = 0; U < z.length; U++) v.inspectOpts[z[U]] = M4.inspectOpts[z[U]]
    }
    wx.exports = yD()(M4);
    var {
        formatters: zC
    } = wx.exports;
    zC.o = function(v) {
        return this.inspectOpts.colors = this.useColors, $x.inspect(v, this.inspectOpts).split(`
`).map((z) => z.trim()).join(" ")
    };
    zC.O = function(v) {
        return this.inspectOpts.colors = this.useColors, $x.inspect(v, this.inspectOpts)
    }
});
var VC = _((WG6, mD) => {
    if (typeof process > "u" || process.type === "renderer" || !1 || process.__nwjs) mD.exports = r_();
    else mD.exports = UC()
});
var KC = _((EG6, NC) => {
    var JU;
    NC.exports = function() {
        if (!JU) {
            try {
                JU = VC()("follow-redirects")
            } catch (v) {}
            if (typeof JU !== "function") JU = function() {}
        }
        JU.apply(null, arguments)
    }
});
var JC = _((SG6, rD) => {
    var HU = require("url"),
        qU = HU.URL,
        N76 = require("http"),
        K76 = require("https"),
        lD = require("stream").Writable,
        hD = require("assert"),
        xC = KC();
    (function() {
        var z = typeof process < "u",
            U = typeof window < "u" && typeof document < "u",
            V = U7(Error.captureStackTrace);
        if (!z && (U || !V)) console.warn("The follow-redirects package should be excluded from browser builds.")
    })();
    var pD = !1;
    try {
        hD(new qU(""))
    } catch (v) {
        pD = v.code === "ERR_INVALID_URL"
    }
    var x76 = ["auth", "host", "hostname", "href", "path", "pathname", "port", "protocol", "query", "search", "hash"],
        nD = ["abort", "aborted", "connect", "error", "socket", "timeout"],
        QD = Object.create(null);
    nD.forEach(function(v) {
        QD[v] = function(z, U, V) {
            this._redirectable.emit(v, z, U, V)
        }
    });
    var gD = DU("ERR_INVALID_URL", "Invalid URL", TypeError),
        cD = DU("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed"),
        j76 = DU("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", cD),
        B76 = DU("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit"),
        O76 = DU("ERR_STREAM_WRITE_AFTER_END", "write after end"),
        J76 = lD.prototype.destroy || BC;

    function $3(v, z) {
        if (lD.call(this), this._sanitizeOptions(v), this._options = v, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], z) this.on("response", z);
        var U = this;
        this._onNativeResponse = function(V) {
            try {
                U._processResponse(V)
            } catch (N) {
                U.emit("error", N instanceof cD ? N : new cD({
                    cause: N
                }))
            }
        }, this._performRequest()
    }
    $3.prototype = Object.create(lD.prototype);
    $3.prototype.abort = function() {
        oD(this._currentRequest), this._currentRequest.abort(), this.emit("abort")
    };
    $3.prototype.destroy = function(v) {
        return oD(this._currentRequest, v), J76.call(this, v), this
    };
    $3.prototype.write = function(v, z, U) {
        if (this._ending) throw new O76;
        if (!z7(v) && !D76(v)) throw TypeError("data should be a string, Buffer or Uint8Array");
        if (U7(z)) U = z, z = null;
        if (v.length === 0) {
            if (U) U();
            return
        }
        if (this._requestBodyLength + v.length <= this._options.maxBodyLength) this._requestBodyLength += v.length, this._requestBodyBuffers.push({
            data: v,
            encoding: z
        }), this._currentRequest.write(v, z, U);
        else this.emit("error", new B76), this.abort()
    };
    $3.prototype.end = function(v, z, U) {
        if (U7(v)) U = v, v = z = null;
        else if (U7(z)) U = z, z = null;
        if (!v) this._ended = this._ending = !0, this._currentRequest.end(null, null, U);
        else {
            var V = this,
                N = this._currentRequest;
            this.write(v, z, function() {
                V._ended = !0, N.end(null, null, U)
            }), this._ending = !0
        }
    };
    $3.prototype.setHeader = function(v, z) {
        this._options.headers[v] = z, this._currentRequest.setHeader(v, z)
    };
    $3.prototype.removeHeader = function(v) {
        delete this._options.headers[v], this._currentRequest.removeHeader(v)
    };
    $3.prototype.setTimeout = function(v, z) {
        var U = this;

        function V(x) {
            x.setTimeout(v), x.removeListener("timeout", x.destroy), x.addListener("timeout", x.destroy)
        }

        function N(x) {
            if (U._timeout) clearTimeout(U._timeout);
            U._timeout = setTimeout(function() {
                U.emit("timeout"), K()
            }, v), V(x)
        }

        function K() {
            if (U._timeout) clearTimeout(U._timeout), U._timeout = null;
            if (U.removeListener("abort", K), U.removeListener("error", K), U.removeListener("response", K), U.removeListener("close", K), z) U.removeListener("timeout", z);
            if (!U.socket) U._currentRequest.removeListener("socket", N)
        }
        if (z) this.on("timeout", z);
        if (this.socket) N(this.socket);
        else this._currentRequest.once("socket", N);
        return this.on("socket", V), this.on("abort", K), this.on("error", K), this.on("response", K), this.on("close", K), this
    };
    ["flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive"].forEach(function(v) {
        $3.prototype[v] = function(z, U) {
            return this._currentRequest[v](z, U)
        }
    });
    ["aborted", "connection", "socket"].forEach(function(v) {
        Object.defineProperty($3.prototype, v, {
            get: function() {
                return this._currentRequest[v]
            }
        })
    });
    $3.prototype._sanitizeOptions = function(v) {
        if (!v.headers) v.headers = {};
        if (v.host) {
            if (!v.hostname) v.hostname = v.host;
            delete v.host
        }
        if (!v.pathname && v.path) {
            var z = v.path.indexOf("?");
            if (z < 0) v.pathname = v.path;
            else v.pathname = v.path.substring(0, z), v.search = v.path.substring(z)
        }
    };
    $3.prototype._performRequest = function() {
        var v = this._options.protocol,
            z = this._options.nativeProtocols[v];
        if (!z) throw TypeError("Unsupported protocol " + v);
        if (this._options.agents) {
            var U = v.slice(0, -1);
            this._options.agent = this._options.agents[U]
        }
        var V = this._currentRequest = z.request(this._options, this._onNativeResponse);
        V._redirectable = this;
        for (var N of nD) V.on(N, QD[N]);
        if (this._currentUrl = /^\//.test(this._options.path) ? HU.format(this._options) : this._options.path, this._isRedirect) {
            var K = 0,
                x = this,
                j = this._requestBodyBuffers;
            (function B(O) {
                if (V === x._currentRequest) {
                    if (O) x.emit("error", O);
                    else if (K < j.length) {
                        var J = j[K++];
                        if (!V.finished) V.write(J.data, J.encoding, B)
                    } else if (x._ended) V.end()
                }
            })()
        }
    };
    $3.prototype._processResponse = function(v) {
        var z = v.statusCode;
        if (this._options.trackRedirects) this._redirects.push({
            url: this._currentUrl,
            headers: v.headers,
            statusCode: z
        });
        var U = v.headers.location;
        if (!U || this._options.followRedirects === !1 || z < 300 || z >= 400) {
            v.responseUrl = this._currentUrl, v.redirects = this._redirects, this.emit("response", v), this._requestBodyBuffers = [];
            return
        }
        if (oD(this._currentRequest), v.destroy(), ++this._redirectCount > this._options.maxRedirects) throw new j76;
        var V, N = this._options.beforeRedirect;
        if (N) V = Object.assign({
            Host: v.req.getHeader("host")
        }, this._options.headers);
        var K = this._options.method;
        if ((z === 301 || z === 302) && this._options.method === "POST" || z === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) this._options.method = "GET", this._requestBodyBuffers = [], XD(/^content-/i, this._options.headers);
        var x = XD(/^host$/i, this._options.headers),
            j = dD(this._currentUrl),
            B = x || j.host,
            O = /^\w+:/.test(U) ? this._currentUrl : HU.format(Object.assign(j, {
                host: B
            })),
            J = q76(U, O);
        if (xC("redirecting to", J.href), this._isRedirect = !0, iD(J, this._options), J.protocol !== j.protocol && J.protocol !== "https:" || J.host !== B && !H76(J.host, B)) XD(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
        if (U7(N)) {
            var q = {
                    headers: v.headers,
                    statusCode: z
                },
                H = {
                    url: O,
                    method: K,
                    headers: V
                };
            N(this._options, q, H), this._sanitizeOptions(this._options)
        }
        this._performRequest()
    };

    function jC(v) {
        var z = {
                maxRedirects: 21,
                maxBodyLength: 10485760
            },
            U = {};
        return Object.keys(v).forEach(function(V) {
            var N = V + ":",
                K = U[N] = v[V],
                x = z[V] = Object.create(K);

            function j(O, J, q) {
                if (A76(O)) O = iD(O);
                else if (z7(O)) O = iD(dD(O));
                else q = J, J = OC(O), O = {
                    protocol: N
                };
                if (U7(J)) q = J, J = null;
                if (J = Object.assign({
                        maxRedirects: z.maxRedirects,
                        maxBodyLength: z.maxBodyLength
                    }, O, J), J.nativeProtocols = U, !z7(J.host) && !z7(J.hostname)) J.hostname = "::1";
                return hD.equal(J.protocol, N, "protocol mismatch"), xC("options", J), new $3(J, q)
            }

            function B(O, J, q) {
                var H = x.request(O, J, q);
                return H.end(), H
            }
            Object.defineProperties(x, {
                request: {
                    value: j,
                    configurable: !0,
                    enumerable: !0,
                    writable: !0
                },
                get: {
                    value: B,
                    configurable: !0,
                    enumerable: !0,
                    writable: !0
                }
            })
        }), z
    }

    function BC() {}

    function dD(v) {
        var z;
        if (pD) z = new qU(v);
        else if (z = OC(HU.parse(v)), !z7(z.protocol)) throw new gD({
            input: v
        });
        return z
    }

    function q76(v, z) {
        return pD ? new qU(v, z) : dD(HU.resolve(z, v))
    }

    function OC(v) {
        if (/^\[/.test(v.hostname) && !/^\[[:0-9a-f]+\]$/i.test(v.hostname)) throw new gD({
            input: v.href || v
        });
        if (/^\[/.test(v.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(v.host)) throw new gD({
            input: v.href || v
        });
        return v
    }

    function iD(v, z) {
        var U = z || {};
        for (var V of x76) U[V] = v[V];
        if (U.hostname.startsWith("[")) U.hostname = U.hostname.slice(1, -1);
        if (U.port !== "") U.port = Number(U.port);
        return U.path = U.search ? U.pathname + U.search : U.pathname, U
    }

    function XD(v, z) {
        var U;
        for (var V in z)
            if (v.test(V)) U = z[V], delete z[V];
        return U === null || typeof U > "u" ? void 0 : String(U).trim()
    }

    function DU(v, z, U) {
        function V(N) {
            if (U7(Error.captureStackTrace)) Error.captureStackTrace(this, this.constructor);
            Object.assign(this, N || {}), this.code = v, this.message = this.cause ? z + ": " + this.cause.message : z
        }
        return V.prototype = Object.create((U || Error).prototype), Object.defineProperties(V.prototype, {
            constructor: {
                value: V,
                enumerable: !1
            },
            name: {
                value: "Error [" + v + "]",
                enumerable: !1
            }
        }), V
    }

    function oD(v, z) {
        for (var U of nD) v.removeListener(U, QD[U]);
        v.on("error", BC), v.destroy(z)
    }

    function H76(v, z) {
        hD(z7(v) && z7(z));
        var U = v.length - z.length - 1;
        return U > 0 && v[U] === "." && v.endsWith(z)
    }

    function z7(v) {
        return typeof v === "string" || v instanceof String
    }

    function U7(v) {
        return typeof v === "function"
    }

    function D76(v) {
        return typeof v === "object" && "length" in v
    }

    function A76(v) {
        return qU && v instanceof qU
    }
    rD.exports = jC({
        http: N76,
        https: K76
    });
    rD.exports.wrap = jC
});
var uT = _((uS6, YT) => {
    YT.exports = function(z) {
        return z.map(function(U) {
            if (U === "") return "''";
            if (U && typeof U === "object") return U.op.replace(/(.)/g, "\\$1");
            if (/["\s\\]/.test(U) && !/'/.test(U)) return "'" + U.replace(/(['])/g, "\\$1") + "'";
            if (/["'\s]/.test(U)) return '"' + U.replace(/(["\\$`!])/g, "\\$1") + '"';
            return String(U).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2")
        }).join(" ")
    }
});
var iT = _((yS6, cT) => {
    var gT = "(?:" + ["\\|\\|", "\\&\\&", ";;", "\\|\\&", "\\<\\(", "\\<\\<\\<", ">>", ">\\&", "<\\&", "[&;()|<>]"].join("|") + ")",
        yT = new RegExp("^" + gT + "$"),
        kT = "|&;()<> \\t",
        Sz6 = '"((\\\\"|[^"])*?)"',
        Pz6 = "'((\\\\'|[^'])*?)'",
        _z6 = /^#$/,
        mT = "'",
        XT = '"',
        h2 = "$",
        B7 = "",
        Cz6 = 4294967296;
    for (ix = 0; ix < 4; ix++) B7 += (Cz6 * Math.random()).toString(16);
    var ix, fz6 = new RegExp("^" + B7);

    function Tz6(v, z) {
        var U = z.lastIndex,
            V = [],
            N;
        while (N = z.exec(v))
            if (V.push(N), z.lastIndex === N.index) z.lastIndex += 1;
        return z.lastIndex = U, V
    }

    function Yz6(v, z, U) {
        var V = typeof v === "function" ? v(U) : v[U];
        if (typeof V > "u" && U != "") V = "";
        else if (typeof V > "u") V = "$";
        if (typeof V === "object") return z + B7 + JSON.stringify(V) + B7;
        return z + V
    }

    function uz6(v, z, U) {
        if (!U) U = {};
        var V = U.escape || "\\",
            N = "(\\" + V + `['"` + kT + `]|[^\\s'"` + kT + "])+",
            K = new RegExp(["(" + gT + ")", "(" + N + "|" + Sz6 + "|" + Pz6 + ")+"].join("|"), "g"),
            x = Tz6(v, K);
        if (x.length === 0) return [];
        if (!z) z = {};
        var j = !1;
        return x.map(function(B) {
            var O = B[0];
            if (!O || j) return;
            if (yT.test(O)) return {
                op: O
            };
            var J = !1,
                q = !1,
                H = "",
                D = !1,
                A;

            function w() {
                A += 1;
                var F, L, G = O.charAt(A);
                if (G === "{") {
                    if (A += 1, O.charAt(A) === "}") throw Error("Bad substitution: " + O.slice(A - 2, A + 1));
                    if (F = O.indexOf("}", A), F < 0) throw Error("Bad substitution: " + O.slice(A));
                    L = O.slice(A, F), A = F
                } else if (/[*@#?$!_-]/.test(G)) L = G, A += 1;
                else {
                    var I = O.slice(A);
                    if (F = I.match(/[^\w\d_]/), !F) L = I, A = O.length;
                    else L = I.slice(0, F.index), A += F.index - 1
                }
                return Yz6(z, "", L)
            }
            for (A = 0; A < O.length; A++) {
                var Z = O.charAt(A);
                if (D = D || !J && (Z === "*" || Z === "?"), q) H += Z, q = !1;
                else if (J)
                    if (Z === J) J = !1;
                    else if (J == mT) H += Z;
                else if (Z === V)
                    if (A += 1, Z = O.charAt(A), Z === XT || Z === V || Z === h2) H += Z;
                    else H += V + Z;
                else if (Z === h2) H += w();
                else H += Z;
                else if (Z === XT || Z === mT) J = Z;
                else if (yT.test(Z)) return {
                    op: O
                };
                else if (_z6.test(Z)) {
                    j = !0;
                    var $ = {
                        comment: v.slice(B.index + A + 1)
                    };
                    if (H.length) return [H, $];
                    return [$]
                } else if (Z === V) q = !0;
                else if (Z === h2) H += w();
                else H += Z
            }
            if (D) return {
                op: "glob",
                pattern: H
            };
            return H
        }).reduce(function(B, O) {
            return typeof O > "u" ? B : B.concat(O)
        }, [])
    }
    cT.exports = function(z, U, V) {
        var N = uz6(z, U, V);
        if (typeof U !== "function") return N;
        return N.reduce(function(K, x) {
            if (typeof x === "object") return K.concat(x);
            var j = x.split(RegExp("(" + B7 + ".*?" + B7 + ")", "g"));
            if (j.length === 1) return K.concat(j[0]);
            return K.concat(j.filter(Boolean).map(function(B) {
                if (fz6.test(B)) return JSON.parse(B.split(B7)[1]);
                return B
            }))
        }, [])
    }
});
var n2 = _((p2) => {
    p2.quote = uT();
    p2.parse = iT()
});
var rV = _(($0) => {
    Object.defineProperty($0, "__esModule", {
        value: !0
    });
    $0.regexpCode = $0.getEsmExportName = $0.getProperty = $0.safeStringify = $0.stringify = $0.strConcat = $0.addCodeArg = $0.str = $0._ = $0.nil = $0._Code = $0.Name = $0.IDENTIFIER = $0._CodeOrName = void 0;
    class TO {}
    $0._CodeOrName = TO;
    $0.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class W1 extends TO {
        constructor(v) {
            super();
            if (!$0.IDENTIFIER.test(v)) throw Error("CodeGen: name must be a valid identifier");
            this.str = v
        }
        toString() {
            return this.str
        }
        emptyStr() {
            return !1
        }
        get names() {
            return {
                [this.str]: 1
            }
        }
    }
    $0.Name = W1;
    class F8 extends TO {
        constructor(v) {
            super();
            this._items = typeof v === "string" ? [v] : v
        }
        toString() {
            return this.str
        }
        emptyStr() {
            if (this._items.length > 1) return !1;
            let v = this._items[0];
            return v === "" || v === '""'
        }
        get str() {
            var v;
            return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((z, U) => `${z}${U}`, "")
        }
        get names() {
            var v;
            return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((z, U) => {
                if (U instanceof W1) z[U.str] = (z[U.str] || 0) + 1;
                return z
            }, {})
        }
    }
    $0._Code = F8;
    $0.nil = new F8("");

    function oy(v, ...z) {
        let U = [v[0]],
            V = 0;
        while (V < z.length) kZ(U, z[V]), U.push(v[++V]);
        return new F8(U)
    }
    $0._ = oy;
    var yZ = new F8("+");

    function ry(v, ...z) {
        let U = [oV(v[0])],
            V = 0;
        while (V < z.length) U.push(yZ), kZ(U, z[V]), U.push(yZ, oV(v[++V]));
        return Oj6(U), new F8(U)
    }
    $0.str = ry;

    function kZ(v, z) {
        if (z instanceof F8) v.push(...z._items);
        else if (z instanceof W1) v.push(z);
        else v.push(Hj6(z))
    }
    $0.addCodeArg = kZ;

    function Oj6(v) {
        let z = 1;
        while (z < v.length - 1) {
            if (v[z] === yZ) {
                let U = Jj6(v[z - 1], v[z + 1]);
                if (U !== void 0) {
                    v.splice(z - 1, 3, U);
                    continue
                }
                v[z++] = "+"
            }
            z++
        }
    }

    function Jj6(v, z) {
        if (z === '""') return v;
        if (v === '""') return z;
        if (typeof v == "string") {
            if (z instanceof W1 || v[v.length - 1] !== '"') return;
            if (typeof z != "string") return `${v.slice(0,-1)}${z}"`;
            if (z[0] === '"') return v.slice(0, -1) + z.slice(1);
            return
        }
        if (typeof z == "string" && z[0] === '"' && !(v instanceof W1)) return `"${v}${z.slice(1)}`;
        return
    }

    function qj6(v, z) {
        return z.emptyStr() ? v : v.emptyStr() ? z : ry`${v}${z}`
    }
    $0.strConcat = qj6;

    function Hj6(v) {
        return typeof v == "number" || typeof v == "boolean" || v === null ? v : oV(Array.isArray(v) ? v.join(",") : v)
    }

    function Dj6(v) {
        return new F8(oV(v))
    }
    $0.stringify = Dj6;

    function oV(v) {
        return JSON.stringify(v).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
    }
    $0.safeStringify = oV;

    function Aj6(v) {
        return typeof v == "string" && $0.IDENTIFIER.test(v) ? new F8(`.${v}`) : oy`[${v}]`
    }
    $0.getProperty = Aj6;

    function $j6(v) {
        if (typeof v == "string" && $0.IDENTIFIER.test(v)) return new F8(`${v}`);
        throw Error(`CodeGen: invalid export name: ${v}, use explicit $id name mapping`)
    }
    $0.getEsmExportName = $j6;

    function wj6(v) {
        return new F8(v.toString())
    }
    $0.regexpCode = wj6
});
var gZ = _((M3) => {
    Object.defineProperty(M3, "__esModule", {
        value: !0
    });
    M3.ValueScope = M3.ValueScopeName = M3.Scope = M3.varKinds = M3.UsedValueState = void 0;
    var I3 = rV();
    class ay extends Error {
        constructor(v) {
            super(`CodeGen: "code" for ${v} not defined`);
            this.value = v.value
        }
    }
    var YO;
    (function(v) {
        v[v.Started = 0] = "Started", v[v.Completed = 1] = "Completed"
    })(YO || (M3.UsedValueState = YO = {}));
    M3.varKinds = {
        const: new I3.Name("const"),
        let: new I3.Name("let"),
        var: new I3.Name("var")
    };
    class mZ {
        constructor({
            prefixes: v,
            parent: z
        } = {}) {
            this._names = {}, this._prefixes = v, this._parent = z
        }
        toName(v) {
            return v instanceof I3.Name ? v : this.name(v)
        }
        name(v) {
            return new I3.Name(this._newName(v))
        }
        _newName(v) {
            let z = this._names[v] || this._nameGroup(v);
            return `${v}${z.index++}`
        }
        _nameGroup(v) {
            var z, U;
            if (((U = (z = this._parent) === null || z === void 0 ? void 0 : z._prefixes) === null || U === void 0 ? void 0 : U.has(v)) || this._prefixes && !this._prefixes.has(v)) throw Error(`CodeGen: prefix "${v}" is not allowed in this scope`);
            return this._names[v] = {
                prefix: v,
                index: 0
            }
        }
    }
    M3.Scope = mZ;
    class XZ extends I3.Name {
        constructor(v, z) {
            super(z);
            this.prefix = v
        }
        setValue(v, {
            property: z,
            itemIndex: U
        }) {
            this.value = v, this.scopePath = I3._`.${new I3.Name(z)}[${U}]`
        }
    }
    M3.ValueScopeName = XZ;
    var Zj6 = I3._`\n`;
    class ty extends mZ {
        constructor(v) {
            super(v);
            this._values = {}, this._scope = v.scope, this.opts = {
                ...v,
                _n: v.lines ? Zj6 : I3.nil
            }
        }
        get() {
            return this._scope
        }
        name(v) {
            return new XZ(v, this._newName(v))
        }
        value(v, z) {
            var U;
            if (z.ref === void 0) throw Error("CodeGen: ref must be passed in value");
            let V = this.toName(v),
                {
                    prefix: N
                } = V,
                K = (U = z.key) !== null && U !== void 0 ? U : z.ref,
                x = this._values[N];
            if (x) {
                let O = x.get(K);
                if (O) return O
            } else x = this._values[N] = new Map;
            x.set(K, V);
            let j = this._scope[N] || (this._scope[N] = []),
                B = j.length;
            return j[B] = z.ref, V.setValue(z, {
                property: N,
                itemIndex: B
            }), V
        }
        getValue(v, z) {
            let U = this._values[v];
            if (!U) return;
            return U.get(z)
        }
        scopeRefs(v, z = this._values) {
            return this._reduceValues(z, (U) => {
                if (U.scopePath === void 0) throw Error(`CodeGen: name "${U}" has no value`);
                return I3._`${v}${U.scopePath}`
            })
        }
        scopeCode(v = this._values, z, U) {
            return this._reduceValues(v, (V) => {
                if (V.value === void 0) throw Error(`CodeGen: name "${V}" has no value`);
                return V.value.code
            }, z, U)
        }
        _reduceValues(v, z, U = {}, V) {
            let N = I3.nil;
            for (let K in v) {
                let x = v[K];
                if (!x) continue;
                let j = U[K] = U[K] || new Map;
                x.forEach((B) => {
                    if (j.has(B)) return;
                    j.set(B, YO.Started);
                    let O = z(B);
                    if (O) {
                        let J = this.opts.es5 ? M3.varKinds.var : M3.varKinds.const;
                        N = I3._`${N}${J} ${B} = ${O};${this.opts._n}`
                    } else if (O = V === null || V === void 0 ? void 0 : V(B)) N = I3._`${N}${O}${this.opts._n}`;
                    else throw new ay(B);
                    j.set(B, YO.Completed)
                })
            }
            return N
        }
    }
    M3.ValueScope = ty
});
var e6 = _((V0) => {
    Object.defineProperty(V0, "__esModule", {
        value: !0
    });
    V0.or = V0.and = V0.not = V0.CodeGen = V0.operators = V0.varKinds = V0.ValueScopeName = V0.ValueScope = V0.Scope = V0.Name = V0.regexpCode = V0.stringify = V0.getProperty = V0.nil = V0.strConcat = V0.str = V0._ = void 0;
    var J0 = rV(),
        G8 = gZ(),
        I5 = rV();
    Object.defineProperty(V0, "_", {
        enumerable: !0,
        get: function() {
            return I5._
        }
    });
    Object.defineProperty(V0, "str", {
        enumerable: !0,
        get: function() {
            return I5.str
        }
    });
    Object.defineProperty(V0, "strConcat", {
        enumerable: !0,
        get: function() {
            return I5.strConcat
        }
    });
    Object.defineProperty(V0, "nil", {
        enumerable: !0,
        get: function() {
            return I5.nil
        }
    });
    Object.defineProperty(V0, "getProperty", {
        enumerable: !0,
        get: function() {
            return I5.getProperty
        }
    });
    Object.defineProperty(V0, "stringify", {
        enumerable: !0,
        get: function() {
            return I5.stringify
        }
    });
    Object.defineProperty(V0, "regexpCode", {
        enumerable: !0,
        get: function() {
            return I5.regexpCode
        }
    });
    Object.defineProperty(V0, "Name", {
        enumerable: !0,
        get: function() {
            return I5.Name
        }
    });
    var gO = gZ();
    Object.defineProperty(V0, "Scope", {
        enumerable: !0,
        get: function() {
            return gO.Scope
        }
    });
    Object.defineProperty(V0, "ValueScope", {
        enumerable: !0,
        get: function() {
            return gO.ValueScope
        }
    });
    Object.defineProperty(V0, "ValueScopeName", {
        enumerable: !0,
        get: function() {
            return gO.ValueScopeName
        }
    });
    Object.defineProperty(V0, "varKinds", {
        enumerable: !0,
        get: function() {
            return gO.varKinds
        }
    });
    V0.operators = {
        GT: new J0._Code(">"),
        GTE: new J0._Code(">="),
        LT: new J0._Code("<"),
        LTE: new J0._Code("<="),
        EQ: new J0._Code("==="),
        NEQ: new J0._Code("!=="),
        NOT: new J0._Code("!"),
        OR: new J0._Code("||"),
        AND: new J0._Code("&&"),
        ADD: new J0._Code("+")
    };
    class M5 {
        optimizeNodes() {
            return this
        }
        optimizeNames(v, z) {
            return this
        }
    }
    class sy extends M5 {
        constructor(v, z, U) {
            super();
            this.varKind = v, this.name = z, this.rhs = U
        }
        render({
            es5: v,
            _n: z
        }) {
            let U = v ? G8.varKinds.var : this.varKind,
                V = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
            return `${U} ${this.name}${V};` + z
        }
        optimizeNames(v, z) {
            if (!v[this.name.str]) return;
            if (this.rhs) this.rhs = S1(this.rhs, v, z);
            return this
        }
        get names() {
            return this.rhs instanceof J0._CodeOrName ? this.rhs.names : {}
        }
    }
    class lZ extends M5 {
        constructor(v, z, U) {
            super();
            this.lhs = v, this.rhs = z, this.sideEffects = U
        }
        render({
            _n: v
        }) {
            return `${this.lhs} = ${this.rhs};` + v
        }
        optimizeNames(v, z) {
            if (this.lhs instanceof J0.Name && !v[this.lhs.str] && !this.sideEffects) return;
            return this.rhs = S1(this.rhs, v, z), this
        }
        get names() {
            let v = this.lhs instanceof J0.Name ? {} : {
                ...this.lhs.names
            };
            return XO(v, this.rhs)
        }
    }
    class ey extends lZ {
        constructor(v, z, U, V) {
            super(v, U, V);
            this.op = z
        }
        render({
            _n: v
        }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + v
        }
    }
    class vk extends M5 {
        constructor(v) {
            super();
            this.label = v, this.names = {}
        }
        render({
            _n: v
        }) {
            return `${this.label}:` + v
        }
    }
    class zk extends M5 {
        constructor(v) {
            super();
            this.label = v, this.names = {}
        }
        render({
            _n: v
        }) {
            return `break${this.label?` ${this.label}`:""};` + v
        }
    }
    class Uk extends M5 {
        constructor(v) {
            super();
            this.error = v
        }
        render({
            _n: v
        }) {
            return `throw ${this.error};` + v
        }
        get names() {
            return this.error.names
        }
    }
    class Vk extends M5 {
        constructor(v) {
            super();
            this.code = v
        }
        render({
            _n: v
        }) {
            return `${this.code};` + v
        }
        optimizeNodes() {
            return `${this.code}` ? this : void 0
        }
        optimizeNames(v, z) {
            return this.code = S1(this.code, v, z), this
        }
        get names() {
            return this.code instanceof J0._CodeOrName ? this.code.names : {}
        }
    }
    class cO extends M5 {
        constructor(v = []) {
            super();
            this.nodes = v
        }
        render(v) {
            return this.nodes.reduce((z, U) => z + U.render(v), "")
        }
        optimizeNodes() {
            let {
                nodes: v
            } = this, z = v.length;
            while (z--) {
                let U = v[z].optimizeNodes();
                if (Array.isArray(U)) v.splice(z, 1, ...U);
                else if (U) v[z] = U;
                else v.splice(z, 1)
            }
            return v.length > 0 ? this : void 0
        }
        optimizeNames(v, z) {
            let {
                nodes: U
            } = this, V = U.length;
            while (V--) {
                let N = U[V];
                if (N.optimizeNames(v, z)) continue;
                Lj6(v, N.names), U.splice(V, 1)
            }
            return U.length > 0 ? this : void 0
        }
        get names() {
            return this.nodes.reduce((v, z) => b7(v, z.names), {})
        }
    }
    class b5 extends cO {
        render(v) {
            return "{" + v._n + super.render(v) + "}" + v._n
        }
    }
    class Nk extends cO {}
    class aV extends b5 {}
    aV.kind = "else";
    class C9 extends b5 {
        constructor(v, z) {
            super(z);
            this.condition = v
        }
        render(v) {
            let z = `if(${this.condition})` + super.render(v);
            if (this.else) z += "else " + this.else.render(v);
            return z
        }
        optimizeNodes() {
            super.optimizeNodes();
            let v = this.condition;
            if (v === !0) return this.nodes;
            let z = this.else;
            if (z) {
                let U = z.optimizeNodes();
                z = this.else = Array.isArray(U) ? new aV(U) : U
            }
            if (z) {
                if (v === !1) return z instanceof C9 ? z : z.nodes;
                if (this.nodes.length) return this;
                return new C9(Ok(v), z instanceof C9 ? [z] : z.nodes)
            }
            if (v === !1 || !this.nodes.length) return;
            return this
        }
        optimizeNames(v, z) {
            var U;
            if (this.else = (U = this.else) === null || U === void 0 ? void 0 : U.optimizeNames(v, z), !(super.optimizeNames(v, z) || this.else)) return;
            return this.condition = S1(this.condition, v, z), this
        }
        get names() {
            let v = super.names;
            if (XO(v, this.condition), this.else) b7(v, this.else.names);
            return v
        }
    }
    C9.kind = "if";
    class E1 extends b5 {}
    E1.kind = "for";
    class Kk extends E1 {
        constructor(v) {
            super();
            this.iteration = v
        }
        render(v) {
            return `for(${this.iteration})` + super.render(v)
        }
        optimizeNames(v, z) {
            if (!super.optimizeNames(v, z)) return;
            return this.iteration = S1(this.iteration, v, z), this
        }
        get names() {
            return b7(super.names, this.iteration.names)
        }
    }
    class xk extends E1 {
        constructor(v, z, U, V) {
            super();
            this.varKind = v, this.name = z, this.from = U, this.to = V
        }
        render(v) {
            let z = v.es5 ? G8.varKinds.var : this.varKind,
                {
                    name: U,
                    from: V,
                    to: N
                } = this;
            return `for(${z} ${U}=${V}; ${U}<${N}; ${U}++)` + super.render(v)
        }
        get names() {
            let v = XO(super.names, this.from);
            return XO(v, this.to)
        }
    }
    class cZ extends E1 {
        constructor(v, z, U, V) {
            super();
            this.loop = v, this.varKind = z, this.name = U, this.iterable = V
        }
        render(v) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(v)
        }
        optimizeNames(v, z) {
            if (!super.optimizeNames(v, z)) return;
            return this.iterable = S1(this.iterable, v, z), this
        }
        get names() {
            return b7(super.names, this.iterable.names)
        }
    }
    class uO extends b5 {
        constructor(v, z, U) {
            super();
            this.name = v, this.args = z, this.async = U
        }
        render(v) {
            return `${this.async?"async ":""}function ${this.name}(${this.args})` + super.render(v)
        }
    }
    uO.kind = "func";
    class yO extends cO {
        render(v) {
            return "return " + super.render(v)
        }
    }
    yO.kind = "return";
    class jk extends b5 {
        render(v) {
            let z = "try" + super.render(v);
            if (this.catch) z += this.catch.render(v);
            if (this.finally) z += this.finally.render(v);
            return z
        }
        optimizeNodes() {
            var v, z;
            return super.optimizeNodes(), (v = this.catch) === null || v === void 0 || v.optimizeNodes(), (z = this.finally) === null || z === void 0 || z.optimizeNodes(), this
        }
        optimizeNames(v, z) {
            var U, V;
            return super.optimizeNames(v, z), (U = this.catch) === null || U === void 0 || U.optimizeNames(v, z), (V = this.finally) === null || V === void 0 || V.optimizeNames(v, z), this
        }
        get names() {
            let v = super.names;
            if (this.catch) b7(v, this.catch.names);
            if (this.finally) b7(v, this.finally.names);
            return v
        }
    }
    class kO extends b5 {
        constructor(v) {
            super();
            this.error = v
        }
        render(v) {
            return `catch(${this.error})` + super.render(v)
        }
    }
    kO.kind = "catch";
    class mO extends b5 {
        render(v) {
            return "finally" + super.render(v)
        }
    }
    mO.kind = "finally";
    class Bk {
        constructor(v, z = {}) {
            this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = {
                ...z,
                _n: z.lines ? `
` : ""
            }, this._extScope = v, this._scope = new G8.Scope({
                parent: v
            }), this._nodes = [new Nk]
        }
        toString() {
            return this._root.render(this.opts)
        }
        name(v) {
            return this._scope.name(v)
        }
        scopeName(v) {
            return this._extScope.name(v)
        }
        scopeValue(v, z) {
            let U = this._extScope.value(v, z);
            return (this._values[U.prefix] || (this._values[U.prefix] = new Set)).add(U), U
        }
        getScopeValue(v, z) {
            return this._extScope.getValue(v, z)
        }
        scopeRefs(v) {
            return this._extScope.scopeRefs(v, this._values)
        }
        scopeCode() {
            return this._extScope.scopeCode(this._values)
        }
        _def(v, z, U, V) {
            let N = this._scope.toName(z);
            if (U !== void 0 && V) this._constants[N.str] = U;
            return this._leafNode(new sy(v, N, U)), N
        }
        const (v, z, U) {
            return this._def(G8.varKinds.const, v, z, U)
        }
        let (v, z, U) {
            return this._def(G8.varKinds.let, v, z, U)
        }
        var (v, z, U) {
            return this._def(G8.varKinds.var, v, z, U)
        }
        assign(v, z, U) {
            return this._leafNode(new lZ(v, z, U))
        }
        add(v, z) {
            return this._leafNode(new ey(v, V0.operators.ADD, z))
        }
        code(v) {
            if (typeof v == "function") v();
            else if (v !== J0.nil) this._leafNode(new Vk(v));
            return this
        }
        object(...v) {
            let z = ["{"];
            for (let [U, V] of v) {
                if (z.length > 1) z.push(",");
                if (z.push(U), U !== V || this.opts.es5) z.push(":"), (0, J0.addCodeArg)(z, V)
            }
            return z.push("}"), new J0._Code(z)
        }
        if (v, z, U) {
            if (this._blockNode(new C9(v)), z && U) this.code(z).else().code(U).endIf();
            else if (z) this.code(z).endIf();
            else if (U) throw Error('CodeGen: "else" body without "then" body');
            return this
        }
        elseIf(v) {
            return this._elseNode(new C9(v))
        } else() {
            return this._elseNode(new aV)
        }
        endIf() {
            return this._endBlockNode(C9, aV)
        }
        _for(v, z) {
            if (this._blockNode(v), z) this.code(z).endFor();
            return this
        }
        for (v, z) {
            return this._for(new Kk(v), z)
        }
        forRange(v, z, U, V, N = this.opts.es5 ? G8.varKinds.var : G8.varKinds.let) {
            let K = this._scope.toName(v);
            return this._for(new xk(N, K, z, U), () => V(K))
        }
        forOf(v, z, U, V = G8.varKinds.const) {
            let N = this._scope.toName(v);
            if (this.opts.es5) {
                let K = z instanceof J0.Name ? z : this.var("_arr", z);
                return this.forRange("_i", 0, J0._`${K}.length`, (x) => {
                    this.var(N, J0._`${K}[${x}]`), U(N)
                })
            }
            return this._for(new cZ("of", V, N, z), () => U(N))
        }
        forIn(v, z, U, V = this.opts.es5 ? G8.varKinds.var : G8.varKinds.const) {
            if (this.opts.ownProperties) return this.forOf(v, J0._`Object.keys(${z})`, U);
            let N = this._scope.toName(v);
            return this._for(new cZ("in", V, N, z), () => U(N))
        }
        endFor() {
            return this._endBlockNode(E1)
        }
        label(v) {
            return this._leafNode(new vk(v))
        }
        break (v) {
            return this._leafNode(new zk(v))
        }
        return (v) {
            let z = new yO;
            if (this._blockNode(z), this.code(v), z.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
            return this._endBlockNode(yO)
        }
        try (v, z, U) {
            if (!z && !U) throw Error('CodeGen: "try" without "catch" and "finally"');
            let V = new jk;
            if (this._blockNode(V), this.code(v), z) {
                let N = this.name("e");
                this._currNode = V.catch = new kO(N), z(N)
            }
            if (U) this._currNode = V.finally = new mO, this.code(U);
            return this._endBlockNode(kO, mO)
        }
        throw (v) {
            return this._leafNode(new Uk(v))
        }
        block(v, z) {
            if (this._blockStarts.push(this._nodes.length), v) this.code(v).endBlock(z);
            return this
        }
        endBlock(v) {
            let z = this._blockStarts.pop();
            if (z === void 0) throw Error("CodeGen: not in self-balancing block");
            let U = this._nodes.length - z;
            if (U < 0 || v !== void 0 && U !== v) throw Error(`CodeGen: wrong number of nodes: ${U} vs ${v} expected`);
            return this._nodes.length = z, this
        }
        func(v, z = J0.nil, U, V) {
            if (this._blockNode(new uO(v, z, U)), V) this.code(V).endFunc();
            return this
        }
        endFunc() {
            return this._endBlockNode(uO)
        }
        optimize(v = 1) {
            while (v-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants)
        }
        _leafNode(v) {
            return this._currNode.nodes.push(v), this
        }
        _blockNode(v) {
            this._currNode.nodes.push(v), this._nodes.push(v)
        }
        _endBlockNode(v, z) {
            let U = this._currNode;
            if (U instanceof v || z && U instanceof z) return this._nodes.pop(), this;
            throw Error(`CodeGen: not in block "${z?`${v.kind}/${z.kind}`:v.kind}"`)
        }
        _elseNode(v) {
            let z = this._currNode;
            if (!(z instanceof C9)) throw Error('CodeGen: "else" without "if"');
            return this._currNode = z.else = v, this
        }
        get _root() {
            return this._nodes[0]
        }
        get _currNode() {
            let v = this._nodes;
            return v[v.length - 1]
        }
        set _currNode(v) {
            let z = this._nodes;
            z[z.length - 1] = v
        }
    }
    V0.CodeGen = Bk;

    function b7(v, z) {
        for (let U in z) v[U] = (v[U] || 0) + (z[U] || 0);
        return v
    }

    function XO(v, z) {
        return z instanceof J0._CodeOrName ? b7(v, z.names) : v
    }

    function S1(v, z, U) {
        if (v instanceof J0.Name) return V(v);
        if (!N(v)) return v;
        return new J0._Code(v._items.reduce((K, x) => {
            if (x instanceof J0.Name) x = V(x);
            if (x instanceof J0._Code) K.push(...x._items);
            else K.push(x);
            return K
        }, []));

        function V(K) {
            let x = U[K.str];
            if (x === void 0 || z[K.str] !== 1) return K;
            return delete z[K.str], x
        }

        function N(K) {
            return K instanceof J0._Code && K._items.some((x) => x instanceof J0.Name && z[x.str] === 1 && U[x.str] !== void 0)
        }
    }

    function Lj6(v, z) {
        for (let U in z) v[U] = (v[U] || 0) - (z[U] || 0)
    }

    function Ok(v) {
        return typeof v == "boolean" || typeof v == "number" || v === null ? !v : J0._`!${iZ(v)}`
    }
    V0.not = Ok;
    var Fj6 = Jk(V0.operators.AND);

    function Gj6(...v) {
        return v.reduce(Fj6)
    }
    V0.and = Gj6;
    var Ij6 = Jk(V0.operators.OR);

    function Mj6(...v) {
        return v.reduce(Ij6)
    }
    V0.or = Mj6;

    function Jk(v) {
        return (z, U) => z === J0.nil ? U : U === J0.nil ? z : J0._`${iZ(z)} ${v} ${iZ(U)}`
    }

    function iZ(v) {
        return v instanceof J0.Name ? v : J0._`(${v})`
    }
});
var w0 = _((K0) => {
    Object.defineProperty(K0, "__esModule", {
        value: !0
    });
    K0.checkStrictMode = K0.getErrorPath = K0.Type = K0.useFunc = K0.setEvaluated = K0.evaluatedPropsToName = K0.mergeEvaluated = K0.eachItem = K0.unescapeJsonPointer = K0.escapeJsonPointer = K0.escapeFragment = K0.unescapeFragment = K0.schemaRefOrVal = K0.schemaHasRulesButRef = K0.schemaHasRules = K0.checkUnknownRules = K0.alwaysValidSchema = K0.toHash = void 0;
    var f0 = e6(),
        bj6 = rV();

    function Rj6(v) {
        let z = {};
        for (let U of v) z[U] = !0;
        return z
    }
    K0.toHash = Rj6;

    function Wj6(v, z) {
        if (typeof z == "boolean") return z;
        if (Object.keys(z).length === 0) return !0;
        return Dk(v, z), !Ak(z, v.self.RULES.all)
    }
    K0.alwaysValidSchema = Wj6;

    function Dk(v, z = v.schema) {
        let {
            opts: U,
            self: V
        } = v;
        if (!U.strictSchema) return;
        if (typeof z === "boolean") return;
        let N = V.RULES.keywords;
        for (let K in z)
            if (!N[K]) Zk(v, `unknown keyword: "${K}"`)
    }
    K0.checkUnknownRules = Dk;

    function Ak(v, z) {
        if (typeof v == "boolean") return !v;
        for (let U in v)
            if (z[U]) return !0;
        return !1
    }
    K0.schemaHasRules = Ak;

    function Ej6(v, z) {
        if (typeof v == "boolean") return !v;
        for (let U in v)
            if (U !== "$ref" && z.all[U]) return !0;
        return !1
    }
    K0.schemaHasRulesButRef = Ej6;

    function Sj6({
        topSchemaRef: v,
        schemaPath: z
    }, U, V, N) {
        if (!N) {
            if (typeof U == "number" || typeof U == "boolean") return U;
            if (typeof U == "string") return f0._`${U}`
        }
        return f0._`${v}${z}${(0,f0.getProperty)(V)}`
    }
    K0.schemaRefOrVal = Sj6;

    function Pj6(v) {
        return $k(decodeURIComponent(v))
    }
    K0.unescapeFragment = Pj6;

    function _j6(v) {
        return encodeURIComponent(pZ(v))
    }
    K0.escapeFragment = _j6;

    function pZ(v) {
        if (typeof v == "number") return `${v}`;
        return v.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    K0.escapeJsonPointer = pZ;

    function $k(v) {
        return v.replace(/~1/g, "/").replace(/~0/g, "~")
    }
    K0.unescapeJsonPointer = $k;

    function Cj6(v, z) {
        if (Array.isArray(v))
            for (let U of v) z(U);
        else z(v)
    }
    K0.eachItem = Cj6;

    function qk({
        mergeNames: v,
        mergeToName: z,
        mergeValues: U,
        resultToName: V
    }) {
        return (N, K, x, j) => {
            let B = x === void 0 ? K : x instanceof f0.Name ? (K instanceof f0.Name ? v(N, K, x) : z(N, K, x), x) : K instanceof f0.Name ? (z(N, x, K), K) : U(K, x);
            return j === f0.Name && !(B instanceof f0.Name) ? V(N, B) : B
        }
    }
    K0.mergeEvaluated = {
        props: qk({
            mergeNames: (v, z, U) => v.if(f0._`${U} !== true && ${z} !== undefined`, () => {
                v.if(f0._`${z} === true`, () => v.assign(U, !0), () => v.assign(U, f0._`${U} || {}`).code(f0._`Object.assign(${U}, ${z})`))
            }),
            mergeToName: (v, z, U) => v.if(f0._`${U} !== true`, () => {
                if (z === !0) v.assign(U, !0);
                else v.assign(U, f0._`${U} || {}`), nZ(v, U, z)
            }),
            mergeValues: (v, z) => v === !0 ? !0 : {
                ...v,
                ...z
            },
            resultToName: wk
        }),
        items: qk({
            mergeNames: (v, z, U) => v.if(f0._`${U} !== true && ${z} !== undefined`, () => v.assign(U, f0._`${z} === true ? true : ${U} > ${z} ? ${U} : ${z}`)),
            mergeToName: (v, z, U) => v.if(f0._`${U} !== true`, () => v.assign(U, z === !0 ? !0 : f0._`${U} > ${z} ? ${U} : ${z}`)),
            mergeValues: (v, z) => v === !0 ? !0 : Math.max(v, z),
            resultToName: (v, z) => v.var("items", z)
        })
    };

    function wk(v, z) {
        if (z === !0) return v.var("props", !0);
        let U = v.var("props", f0._`{}`);
        if (z !== void 0) nZ(v, U, z);
        return U
    }
    K0.evaluatedPropsToName = wk;

    function nZ(v, z, U) {
        Object.keys(U).forEach((V) => v.assign(f0._`${z}${(0,f0.getProperty)(V)}`, !0))
    }
    K0.setEvaluated = nZ;
    var Hk = {};

    function fj6(v, z) {
        return v.scopeValue("func", {
            ref: z,
            code: Hk[z.code] || (Hk[z.code] = new bj6._Code(z.code))
        })
    }
    K0.useFunc = fj6;
    var hZ;
    (function(v) {
        v[v.Num = 0] = "Num", v[v.Str = 1] = "Str"
    })(hZ || (K0.Type = hZ = {}));

    function Tj6(v, z, U) {
        if (v instanceof f0.Name) {
            let V = z === hZ.Num;
            return U ? V ? f0._`"[" + ${v} + "]"` : f0._`"['" + ${v} + "']"` : V ? f0._`"/" + ${v}` : f0._`"/" + ${v}.replace(/~/g, "~0").replace(/\\//g, "~1")`
        }
        return U ? (0, f0.getProperty)(v).toString() : "/" + pZ(v)
    }
    K0.getErrorPath = Tj6;

    function Zk(v, z, U = v.opts.strictSchema) {
        if (!U) return;
        if (z = `strict mode: ${z}`, U === !0) throw Error(z);
        v.self.logger.warn(z)
    }
    K0.checkStrictMode = Zk
});
var f9 = _((QZ) => {
    Object.defineProperty(QZ, "__esModule", {
        value: !0
    });
    var Q4 = e6(),
        Yj6 = {
            data: new Q4.Name("data"),
            valCxt: new Q4.Name("valCxt"),
            instancePath: new Q4.Name("instancePath"),
            parentData: new Q4.Name("parentData"),
            parentDataProperty: new Q4.Name("parentDataProperty"),
            rootData: new Q4.Name("rootData"),
            dynamicAnchors: new Q4.Name("dynamicAnchors"),
            vErrors: new Q4.Name("vErrors"),
            errors: new Q4.Name("errors"),
            this: new Q4.Name("this"),
            self: new Q4.Name("self"),
            scope: new Q4.Name("scope"),
            json: new Q4.Name("json"),
            jsonPos: new Q4.Name("jsonPos"),
            jsonLen: new Q4.Name("jsonLen"),
            jsonPart: new Q4.Name("jsonPart")
        };
    QZ.default = Yj6
});
var tV = _((d4) => {
    Object.defineProperty(d4, "__esModule", {
        value: !0
    });
    d4.extendErrors = d4.resetErrorsCount = d4.reportExtraError = d4.reportError = d4.keyword$DataError = d4.keywordError = void 0;
    var D0 = e6(),
        iO = w0(),
        N3 = f9();
    d4.keywordError = {
        message: ({
            keyword: v
        }) => D0.str`must pass "${v}" keyword validation`
    };
    d4.keyword$DataError = {
        message: ({
            keyword: v,
            schemaType: z
        }) => z ? D0.str`"${v}" keyword must be ${z} ($data)` : D0.str`"${v}" keyword is invalid ($data)`
    };

    function uj6(v, z = d4.keywordError, U, V) {
        let {
            it: N
        } = v, {
            gen: K,
            compositeRule: x,
            allErrors: j
        } = N, B = Gk(v, z, U);
        if (V !== null && V !== void 0 ? V : x || j) Lk(K, B);
        else Fk(N, D0._`[${B}]`)
    }
    d4.reportError = uj6;

    function yj6(v, z = d4.keywordError, U) {
        let {
            it: V
        } = v, {
            gen: N,
            compositeRule: K,
            allErrors: x
        } = V, j = Gk(v, z, U);
        if (Lk(N, j), !(K || x)) Fk(V, N3.default.vErrors)
    }
    d4.reportExtraError = yj6;

    function kj6(v, z) {
        v.assign(N3.default.errors, z), v.if(D0._`${N3.default.vErrors} !== null`, () => v.if(z, () => v.assign(D0._`${N3.default.vErrors}.length`, z), () => v.assign(N3.default.vErrors, null)))
    }
    d4.resetErrorsCount = kj6;

    function mj6({
        gen: v,
        keyword: z,
        schemaValue: U,
        data: V,
        errsCount: N,
        it: K
    }) {
        if (N === void 0) throw Error("ajv implementation error");
        let x = v.name("err");
        v.forRange("i", N, N3.default.errors, (j) => {
            if (v.const(x, D0._`${N3.default.vErrors}[${j}]`), v.if(D0._`${x}.instancePath === undefined`, () => v.assign(D0._`${x}.instancePath`, (0, D0.strConcat)(N3.default.instancePath, K.errorPath))), v.assign(D0._`${x}.schemaPath`, D0.str`${K.errSchemaPath}/${z}`), K.opts.verbose) v.assign(D0._`${x}.schema`, U), v.assign(D0._`${x}.data`, V)
        })
    }
    d4.extendErrors = mj6;

    function Lk(v, z) {
        let U = v.const("err", z);
        v.if(D0._`${N3.default.vErrors} === null`, () => v.assign(N3.default.vErrors, D0._`[${U}]`), D0._`${N3.default.vErrors}.push(${U})`), v.code(D0._`${N3.default.errors}++`)
    }

    function Fk(v, z) {
        let {
            gen: U,
            validateName: V,
            schemaEnv: N
        } = v;
        if (N.$async) U.throw(D0._`new ${v.ValidationError}(${z})`);
        else U.assign(D0._`${V}.errors`, z), U.return(!1)
    }
    var R7 = {
        keyword: new D0.Name("keyword"),
        schemaPath: new D0.Name("schemaPath"),
        params: new D0.Name("params"),
        propertyName: new D0.Name("propertyName"),
        message: new D0.Name("message"),
        schema: new D0.Name("schema"),
        parentSchema: new D0.Name("parentSchema")
    };

    function Gk(v, z, U) {
        let {
            createErrors: V
        } = v.it;
        if (V === !1) return D0._`{}`;
        return Xj6(v, z, U)
    }

    function Xj6(v, z, U = {}) {
        let {
            gen: V,
            it: N
        } = v, K = [gj6(N, U), cj6(v, U)];
        return ij6(v, z, K), V.object(...K)
    }

    function gj6({
        errorPath: v
    }, {
        instancePath: z
    }) {
        let U = z ? D0.str`${v}${(0,iO.getErrorPath)(z,iO.Type.Str)}` : v;
        return [N3.default.instancePath, (0, D0.strConcat)(N3.default.instancePath, U)]
    }

    function cj6({
        keyword: v,
        it: {
            errSchemaPath: z
        }
    }, {
        schemaPath: U,
        parentSchema: V
    }) {
        let N = V ? z : D0.str`${z}/${v}`;
        if (U) N = D0.str`${N}${(0,iO.getErrorPath)(U,iO.Type.Str)}`;
        return [R7.schemaPath, N]
    }

    function ij6(v, {
        params: z,
        message: U
    }, V) {
        let {
            keyword: N,
            data: K,
            schemaValue: x,
            it: j
        } = v, {
            opts: B,
            propertyName: O,
            topSchemaRef: J,
            schemaPath: q
        } = j;
        if (V.push([R7.keyword, N], [R7.params, typeof z == "function" ? z(v) : z || D0._`{}`]), B.messages) V.push([R7.message, typeof U == "function" ? U(v) : U]);
        if (B.verbose) V.push([R7.schema, x], [R7.parentSchema, D0._`${J}${q}`], [N3.default.data, K]);
        if (O) V.push([R7.propertyName, O])
    }
});
var Mk = _((P1) => {
    Object.defineProperty(P1, "__esModule", {
        value: !0
    });
    P1.boolOrEmptySchema = P1.topBoolOrEmptySchema = void 0;
    var lj6 = tV(),
        hj6 = e6(),
        pj6 = f9(),
        nj6 = {
            message: "boolean schema is false"
        };

    function Qj6(v) {
        let {
            gen: z,
            schema: U,
            validateName: V
        } = v;
        if (U === !1) Ik(v, !1);
        else if (typeof U == "object" && U.$async === !0) z.return(pj6.default.data);
        else z.assign(hj6._`${V}.errors`, null), z.return(!0)
    }
    P1.topBoolOrEmptySchema = Qj6;

    function dj6(v, z) {
        let {
            gen: U,
            schema: V
        } = v;
        if (V === !1) U.var(z, !1), Ik(v);
        else U.var(z, !0)
    }
    P1.boolOrEmptySchema = dj6;

    function Ik(v, z) {
        let {
            gen: U,
            data: V
        } = v, N = {
            gen: U,
            keyword: "false schema",
            data: V,
            schema: !1,
            schemaCode: !1,
            schemaValue: !1,
            params: {},
            it: v
        };
        (0, lj6.reportError)(N, nj6, void 0, z)
    }
});
var dZ = _((_1) => {
    Object.defineProperty(_1, "__esModule", {
        value: !0
    });
    _1.getRules = _1.isJSONType = void 0;
    var oj6 = ["string", "number", "integer", "boolean", "null", "object", "array"],
        rj6 = new Set(oj6);

    function aj6(v) {
        return typeof v == "string" && rj6.has(v)
    }
    _1.isJSONType = aj6;

    function tj6() {
        let v = {
            number: {
                type: "number",
                rules: []
            },
            string: {
                type: "string",
                rules: []
            },
            array: {
                type: "array",
                rules: []
            },
            object: {
                type: "object",
                rules: []
            }
        };
        return {
            types: {
                ...v,
                integer: !0,
                boolean: !0,
                null: !0
            },
            rules: [{
                rules: []
            }, v.number, v.string, v.array, v.object],
            post: {
                rules: []
            },
            all: {},
            keywords: {}
        }
    }
    _1.getRules = tj6
});
var oZ = _((R5) => {
    Object.defineProperty(R5, "__esModule", {
        value: !0
    });
    R5.shouldUseRule = R5.shouldUseGroup = R5.schemaHasRulesForType = void 0;

    function sj6({
        schema: v,
        self: z
    }, U) {
        let V = z.RULES.types[U];
        return V && V !== !0 && bk(v, V)
    }
    R5.schemaHasRulesForType = sj6;

    function bk(v, z) {
        return z.rules.some((U) => Rk(v, U))
    }
    R5.shouldUseGroup = bk;

    function Rk(v, z) {
        var U;
        return v[z.keyword] !== void 0 || ((U = z.definition.implements) === null || U === void 0 ? void 0 : U.some((V) => v[V] !== void 0))
    }
    R5.shouldUseRule = Rk
});
var sV = _((o4) => {
    Object.defineProperty(o4, "__esModule", {
        value: !0
    });
    o4.reportTypeError = o4.checkDataTypes = o4.checkDataType = o4.coerceAndCheckDataType = o4.getJSONTypes = o4.getSchemaTypes = o4.DataType = void 0;
    var ej6 = dZ(),
        vB6 = oZ(),
        zB6 = tV(),
        t6 = e6(),
        Wk = w0(),
        C1;
    (function(v) {
        v[v.Correct = 0] = "Correct", v[v.Wrong = 1] = "Wrong"
    })(C1 || (o4.DataType = C1 = {}));

    function UB6(v) {
        let z = Ek(v.type);
        if (z.includes("null")) {
            if (v.nullable === !1) throw Error("type: null contradicts nullable: false")
        } else {
            if (!z.length && v.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
            if (v.nullable === !0) z.push("null")
        }
        return z
    }
    o4.getSchemaTypes = UB6;

    function Ek(v) {
        let z = Array.isArray(v) ? v : v ? [v] : [];
        if (z.every(ej6.isJSONType)) return z;
        throw Error("type must be JSONType or JSONType[]: " + z.join(","))
    }
    o4.getJSONTypes = Ek;

    function VB6(v, z) {
        let {
            gen: U,
            data: V,
            opts: N
        } = v, K = NB6(z, N.coerceTypes), x = z.length > 0 && !(K.length === 0 && z.length === 1 && (0, vB6.schemaHasRulesForType)(v, z[0]));
        if (x) {
            let j = aZ(z, V, N.strictNumbers, C1.Wrong);
            U.if(j, () => {
                if (K.length) KB6(v, z, K);
                else tZ(v)
            })
        }
        return x
    }
    o4.coerceAndCheckDataType = VB6;
    var Sk = new Set(["string", "number", "integer", "boolean", "null"]);

    function NB6(v, z) {
        return z ? v.filter((U) => Sk.has(U) || z === "array" && U === "array") : []
    }

    function KB6(v, z, U) {
        let {
            gen: V,
            data: N,
            opts: K
        } = v, x = V.let("dataType", t6._`typeof ${N}`), j = V.let("coerced", t6._`undefined`);
        if (K.coerceTypes === "array") V.if(t6._`${x} == 'object' && Array.isArray(${N}) && ${N}.length == 1`, () => V.assign(N, t6._`${N}[0]`).assign(x, t6._`typeof ${N}`).if(aZ(z, N, K.strictNumbers), () => V.assign(j, N)));
        V.if(t6._`${j} !== undefined`);
        for (let O of U)
            if (Sk.has(O) || O === "array" && K.coerceTypes === "array") B(O);
        V.else(), tZ(v), V.endIf(), V.if(t6._`${j} !== undefined`, () => {
            V.assign(N, j), xB6(v, j)
        });

        function B(O) {
            switch (O) {
                case "string":
                    V.elseIf(t6._`${x} == "number" || ${x} == "boolean"`).assign(j, t6._`"" + ${N}`).elseIf(t6._`${N} === null`).assign(j, t6._`""`);
                    return;
                case "number":
                    V.elseIf(t6._`${x} == "boolean" || ${N} === null
              || (${x} == "string" && ${N} && ${N} == +${N})`).assign(j, t6._`+${N}`);
                    return;
                case "integer":
                    V.elseIf(t6._`${x} === "boolean" || ${N} === null
              || (${x} === "string" && ${N} && ${N} == +${N} && !(${N} % 1))`).assign(j, t6._`+${N}`);
                    return;
                case "boolean":
                    V.elseIf(t6._`${N} === "false" || ${N} === 0 || ${N} === null`).assign(j, !1).elseIf(t6._`${N} === "true" || ${N} === 1`).assign(j, !0);
                    return;
                case "null":
                    V.elseIf(t6._`${N} === "" || ${N} === 0 || ${N} === false`), V.assign(j, null);
                    return;
                case "array":
                    V.elseIf(t6._`${x} === "string" || ${x} === "number"
              || ${x} === "boolean" || ${N} === null`).assign(j, t6._`[${N}]`)
            }
        }
    }

    function xB6({
        gen: v,
        parentData: z,
        parentDataProperty: U
    }, V) {
        v.if(t6._`${z} !== undefined`, () => v.assign(t6._`${z}[${U}]`, V))
    }

    function rZ(v, z, U, V = C1.Correct) {
        let N = V === C1.Correct ? t6.operators.EQ : t6.operators.NEQ,
            K;
        switch (v) {
            case "null":
                return t6._`${z} ${N} null`;
            case "array":
                K = t6._`Array.isArray(${z})`;
                break;
            case "object":
                K = t6._`${z} && typeof ${z} == "object" && !Array.isArray(${z})`;
                break;
            case "integer":
                K = x(t6._`!(${z} % 1) && !isNaN(${z})`);
                break;
            case "number":
                K = x();
                break;
            default:
                return t6._`typeof ${z} ${N} ${v}`
        }
        return V === C1.Correct ? K : (0, t6.not)(K);

        function x(j = t6.nil) {
            return (0, t6.and)(t6._`typeof ${z} == "number"`, j, U ? t6._`isFinite(${z})` : t6.nil)
        }
    }
    o4.checkDataType = rZ;

    function aZ(v, z, U, V) {
        if (v.length === 1) return rZ(v[0], z, U, V);
        let N, K = (0, Wk.toHash)(v);
        if (K.array && K.object) {
            let x = t6._`typeof ${z} != "object"`;
            N = K.null ? x : t6._`!${z} || ${x}`, delete K.null, delete K.array, delete K.object
        } else N = t6.nil;
        if (K.number) delete K.integer;
        for (let x in K) N = (0, t6.and)(N, rZ(x, z, U, V));
        return N
    }
    o4.checkDataTypes = aZ;
    var jB6 = {
        message: ({
            schema: v
        }) => `must be ${v}`,
        params: ({
            schema: v,
            schemaValue: z
        }) => typeof v == "string" ? t6._`{type: ${v}}` : t6._`{type: ${z}}`
    };

    function tZ(v) {
        let z = BB6(v);
        (0, zB6.reportError)(z, jB6)
    }
    o4.reportTypeError = tZ;

    function BB6(v) {
        let {
            gen: z,
            data: U,
            schema: V
        } = v, N = (0, Wk.schemaRefOrVal)(v, V, "type");
        return {
            gen: z,
            keyword: "type",
            data: U,
            schema: V.type,
            schemaCode: N,
            schemaValue: N,
            parentSchema: V,
            params: {},
            it: v
        }
    }
});
var _k = _((lO) => {
    Object.defineProperty(lO, "__esModule", {
        value: !0
    });
    lO.assignDefaults = void 0;
    var f1 = e6(),
        OB6 = w0();

    function JB6(v, z) {
        let {
            properties: U,
            items: V
        } = v.schema;
        if (z === "object" && U)
            for (let N in U) Pk(v, N, U[N].default);
        else if (z === "array" && Array.isArray(V)) V.forEach((N, K) => Pk(v, K, N.default))
    }
    lO.assignDefaults = JB6;

    function Pk(v, z, U) {
        let {
            gen: V,
            compositeRule: N,
            data: K,
            opts: x
        } = v;
        if (U === void 0) return;
        let j = f1._`${K}${(0,f1.getProperty)(z)}`;
        if (N) {
            (0, OB6.checkStrictMode)(v, `default is ignored for: ${j}`);
            return
        }
        let B = f1._`${j} === undefined`;
        if (x.useDefaults === "empty") B = f1._`${B} || ${j} === null || ${j} === ""`;
        V.if(B, f1._`${j} = ${(0,f1.stringify)(U)}`)
    }
});
var d3 = _((_0) => {
    Object.defineProperty(_0, "__esModule", {
        value: !0
    });
    _0.validateUnion = _0.validateArray = _0.usePattern = _0.callValidateCode = _0.schemaProperties = _0.allSchemaProperties = _0.noPropertyInData = _0.propertyInData = _0.isOwnProperty = _0.hasPropFunc = _0.reportMissingProp = _0.checkMissingProp = _0.checkReportMissingProp = void 0;
    var m0 = e6(),
        sZ = w0(),
        W5 = f9(),
        qB6 = w0();

    function HB6(v, z) {
        let {
            gen: U,
            data: V,
            it: N
        } = v;
        U.if(vL(U, V, z, N.opts.ownProperties), () => {
            v.setParams({
                missingProperty: m0._`${z}`
            }, !0), v.error()
        })
    }
    _0.checkReportMissingProp = HB6;

    function DB6({
        gen: v,
        data: z,
        it: {
            opts: U
        }
    }, V, N) {
        return (0, m0.or)(...V.map((K) => (0, m0.and)(vL(v, z, K, U.ownProperties), m0._`${N} = ${K}`)))
    }
    _0.checkMissingProp = DB6;

    function AB6(v, z) {
        v.setParams({
            missingProperty: z
        }, !0), v.error()
    }
    _0.reportMissingProp = AB6;

    function Ck(v) {
        return v.scopeValue("func", {
            ref: Object.prototype.hasOwnProperty,
            code: m0._`Object.prototype.hasOwnProperty`
        })
    }
    _0.hasPropFunc = Ck;

    function eZ(v, z, U) {
        return m0._`${Ck(v)}.call(${z}, ${U})`
    }
    _0.isOwnProperty = eZ;

    function $B6(v, z, U, V) {
        let N = m0._`${z}${(0,m0.getProperty)(U)} !== undefined`;
        return V ? m0._`${N} && ${eZ(v,z,U)}` : N
    }
    _0.propertyInData = $B6;

    function vL(v, z, U, V) {
        let N = m0._`${z}${(0,m0.getProperty)(U)} === undefined`;
        return V ? (0, m0.or)(N, (0, m0.not)(eZ(v, z, U))) : N
    }
    _0.noPropertyInData = vL;

    function fk(v) {
        return v ? Object.keys(v).filter((z) => z !== "__proto__") : []
    }
    _0.allSchemaProperties = fk;

    function wB6(v, z) {
        return fk(z).filter((U) => !(0, sZ.alwaysValidSchema)(v, z[U]))
    }
    _0.schemaProperties = wB6;

    function ZB6({
        schemaCode: v,
        data: z,
        it: {
            gen: U,
            topSchemaRef: V,
            schemaPath: N,
            errorPath: K
        },
        it: x
    }, j, B, O) {
        let J = O ? m0._`${v}, ${z}, ${V}${N}` : z,
            q = [
                [W5.default.instancePath, (0, m0.strConcat)(W5.default.instancePath, K)],
                [W5.default.parentData, x.parentData],
                [W5.default.parentDataProperty, x.parentDataProperty],
                [W5.default.rootData, W5.default.rootData]
            ];
        if (x.opts.dynamicRef) q.push([W5.default.dynamicAnchors, W5.default.dynamicAnchors]);
        let H = m0._`${J}, ${U.object(...q)}`;
        return B !== m0.nil ? m0._`${j}.call(${B}, ${H})` : m0._`${j}(${H})`
    }
    _0.callValidateCode = ZB6;
    var LB6 = m0._`new RegExp`;

    function FB6({
        gen: v,
        it: {
            opts: z
        }
    }, U) {
        let V = z.unicodeRegExp ? "u" : "",
            {
                regExp: N
            } = z.code,
            K = N(U, V);
        return v.scopeValue("pattern", {
            key: K.toString(),
            ref: K,
            code: m0._`${N.code==="new RegExp"?LB6:(0,qB6.useFunc)(v,N)}(${U}, ${V})`
        })
    }
    _0.usePattern = FB6;

    function GB6(v) {
        let {
            gen: z,
            data: U,
            keyword: V,
            it: N
        } = v, K = z.name("valid");
        if (N.allErrors) {
            let j = z.let("valid", !0);
            return x(() => z.assign(j, !1)), j
        }
        return z.var(K, !0), x(() => z.break()), K;

        function x(j) {
            let B = z.const("len", m0._`${U}.length`);
            z.forRange("i", 0, B, (O) => {
                v.subschema({
                    keyword: V,
                    dataProp: O,
                    dataPropType: sZ.Type.Num
                }, K), z.if((0, m0.not)(K), j)
            })
        }
    }
    _0.validateArray = GB6;

    function IB6(v) {
        let {
            gen: z,
            schema: U,
            keyword: V,
            it: N
        } = v;
        if (!Array.isArray(U)) throw Error("ajv implementation error");
        if (U.some((B) => (0, sZ.alwaysValidSchema)(N, B)) && !N.opts.unevaluated) return;
        let x = z.let("valid", !1),
            j = z.name("_valid");
        z.block(() => U.forEach((B, O) => {
            let J = v.subschema({
                keyword: V,
                schemaProp: O,
                compositeRule: !0
            }, j);
            if (z.assign(x, m0._`${x} || ${j}`), !v.mergeValidEvaluated(J, j)) z.if((0, m0.not)(x))
        })), v.result(x, () => v.reset(), () => v.error(!0))
    }
    _0.validateUnion = IB6
});
var uk = _((n8) => {
    Object.defineProperty(n8, "__esModule", {
        value: !0
    });
    n8.validateKeywordUsage = n8.validSchemaType = n8.funcKeywordCode = n8.macroKeywordCode = void 0;
    var K3 = e6(),
        W7 = f9(),
        MB6 = d3(),
        bB6 = tV();

    function RB6(v, z) {
        let {
            gen: U,
            keyword: V,
            schema: N,
            parentSchema: K,
            it: x
        } = v, j = z.macro.call(x.self, N, K, x), B = Yk(U, V, j);
        if (x.opts.validateSchema !== !1) x.self.validateSchema(j, !0);
        let O = U.name("valid");
        v.subschema({
            schema: j,
            schemaPath: K3.nil,
            errSchemaPath: `${x.errSchemaPath}/${V}`,
            topSchemaRef: B,
            compositeRule: !0
        }, O), v.pass(O, () => v.error(!0))
    }
    n8.macroKeywordCode = RB6;

    function WB6(v, z) {
        var U;
        let {
            gen: V,
            keyword: N,
            schema: K,
            parentSchema: x,
            $data: j,
            it: B
        } = v;
        SB6(B, z);
        let O = !j && z.compile ? z.compile.call(B.self, K, x, B) : z.validate,
            J = Yk(V, N, O),
            q = V.let("valid");
        v.block$data(q, H), v.ok((U = z.valid) !== null && U !== void 0 ? U : q);

        function H() {
            if (z.errors === !1) {
                if (w(), z.modifying) Tk(v);
                Z(() => v.error())
            } else {
                let $ = z.async ? D() : A();
                if (z.modifying) Tk(v);
                Z(() => EB6(v, $))
            }
        }

        function D() {
            let $ = V.let("ruleErrs", null);
            return V.try(() => w(K3._`await `), (F) => V.assign(q, !1).if(K3._`${F} instanceof ${B.ValidationError}`, () => V.assign($, K3._`${F}.errors`), () => V.throw(F))), $
        }

        function A() {
            let $ = K3._`${J}.errors`;
            return V.assign($, null), w(K3.nil), $
        }

        function w($ = z.async ? K3._`await ` : K3.nil) {
            let F = B.opts.passContext ? W7.default.this : W7.default.self,
                L = !(("compile" in z) && !j || z.schema === !1);
            V.assign(q, K3._`${$}${(0,MB6.callValidateCode)(v,J,F,L)}`, z.modifying)
        }

        function Z($) {
            var F;
            V.if((0, K3.not)((F = z.valid) !== null && F !== void 0 ? F : q), $)
        }
    }
    n8.funcKeywordCode = WB6;

    function Tk(v) {
        let {
            gen: z,
            data: U,
            it: V
        } = v;
        z.if(V.parentData, () => z.assign(U, K3._`${V.parentData}[${V.parentDataProperty}]`))
    }

    function EB6(v, z) {
        let {
            gen: U
        } = v;
        U.if(K3._`Array.isArray(${z})`, () => {
            U.assign(W7.default.vErrors, K3._`${W7.default.vErrors} === null ? ${z} : ${W7.default.vErrors}.concat(${z})`).assign(W7.default.errors, K3._`${W7.default.vErrors}.length`), (0, bB6.extendErrors)(v)
        }, () => v.error())
    }

    function SB6({
        schemaEnv: v
    }, z) {
        if (z.async && !v.$async) throw Error("async keyword in sync schema")
    }

    function Yk(v, z, U) {
        if (U === void 0) throw Error(`keyword "${z}" failed to compile`);
        return v.scopeValue("keyword", typeof U == "function" ? {
            ref: U
        } : {
            ref: U,
            code: (0, K3.stringify)(U)
        })
    }

    function PB6(v, z, U = !1) {
        return !z.length || z.some((V) => V === "array" ? Array.isArray(v) : V === "object" ? v && typeof v == "object" && !Array.isArray(v) : typeof v == V || U && typeof v > "u")
    }
    n8.validSchemaType = PB6;

    function _B6({
        schema: v,
        opts: z,
        self: U,
        errSchemaPath: V
    }, N, K) {
        if (Array.isArray(N.keyword) ? !N.keyword.includes(K) : N.keyword !== K) throw Error("ajv implementation error");
        let x = N.dependencies;
        if (x === null || x === void 0 ? void 0 : x.some((j) => !Object.prototype.hasOwnProperty.call(v, j))) throw Error(`parent schema must have dependencies of ${K}: ${x.join(",")}`);
        if (N.validateSchema) {
            if (!N.validateSchema(v[K])) {
                let B = `keyword "${K}" value is invalid at path "${V}": ` + U.errorsText(N.validateSchema.errors);
                if (z.validateSchema === "log") U.logger.error(B);
                else throw Error(B)
            }
        }
    }
    n8.validateKeywordUsage = _B6
});
var kk = _((E5) => {
    Object.defineProperty(E5, "__esModule", {
        value: !0
    });
    E5.extendSubschemaMode = E5.extendSubschemaData = E5.getSubschema = void 0;
    var Q8 = e6(),
        yk = w0();

    function CB6(v, {
        keyword: z,
        schemaProp: U,
        schema: V,
        schemaPath: N,
        errSchemaPath: K,
        topSchemaRef: x
    }) {
        if (z !== void 0 && V !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
        if (z !== void 0) {
            let j = v.schema[z];
            return U === void 0 ? {
                schema: j,
                schemaPath: Q8._`${v.schemaPath}${(0,Q8.getProperty)(z)}`,
                errSchemaPath: `${v.errSchemaPath}/${z}`
            } : {
                schema: j[U],
                schemaPath: Q8._`${v.schemaPath}${(0,Q8.getProperty)(z)}${(0,Q8.getProperty)(U)}`,
                errSchemaPath: `${v.errSchemaPath}/${z}/${(0,yk.escapeFragment)(U)}`
            }
        }
        if (V !== void 0) {
            if (N === void 0 || K === void 0 || x === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            return {
                schema: V,
                schemaPath: N,
                topSchemaRef: x,
                errSchemaPath: K
            }
        }
        throw Error('either "keyword" or "schema" must be passed')
    }
    E5.getSubschema = CB6;

    function fB6(v, z, {
        dataProp: U,
        dataPropType: V,
        data: N,
        dataTypes: K,
        propertyName: x
    }) {
        if (N !== void 0 && U !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
        let {
            gen: j
        } = z;
        if (U !== void 0) {
            let {
                errorPath: O,
                dataPathArr: J,
                opts: q
            } = z, H = j.let("data", Q8._`${z.data}${(0,Q8.getProperty)(U)}`, !0);
            B(H), v.errorPath = Q8.str`${O}${(0,yk.getErrorPath)(U,V,q.jsPropertySyntax)}`, v.parentDataProperty = Q8._`${U}`, v.dataPathArr = [...J, v.parentDataProperty]
        }
        if (N !== void 0) {
            let O = N instanceof Q8.Name ? N : j.let("data", N, !0);
            if (B(O), x !== void 0) v.propertyName = x
        }
        if (K) v.dataTypes = K;

        function B(O) {
            v.data = O, v.dataLevel = z.dataLevel + 1, v.dataTypes = [], z.definedProperties = new Set, v.parentData = z.data, v.dataNames = [...z.dataNames, O]
        }
    }
    E5.extendSubschemaData = fB6;

    function TB6(v, {
        jtdDiscriminator: z,
        jtdMetadata: U,
        compositeRule: V,
        createErrors: N,
        allErrors: K
    }) {
        if (V !== void 0) v.compositeRule = V;
        if (N !== void 0) v.createErrors = N;
        if (K !== void 0) v.allErrors = K;
        v.jtdDiscriminator = z, v.jtdMetadata = U
    }
    E5.extendSubschemaMode = TB6
});
var zL = _((xk6, mk) => {
    mk.exports = function v(z, U) {
        if (z === U) return !0;
        if (z && U && typeof z == "object" && typeof U == "object") {
            if (z.constructor !== U.constructor) return !1;
            var V, N, K;
            if (Array.isArray(z)) {
                if (V = z.length, V != U.length) return !1;
                for (N = V; N-- !== 0;)
                    if (!v(z[N], U[N])) return !1;
                return !0
            }
            if (z.constructor === RegExp) return z.source === U.source && z.flags === U.flags;
            if (z.valueOf !== Object.prototype.valueOf) return z.valueOf() === U.valueOf();
            if (z.toString !== Object.prototype.toString) return z.toString() === U.toString();
            if (K = Object.keys(z), V = K.length, V !== Object.keys(U).length) return !1;
            for (N = V; N-- !== 0;)
                if (!Object.prototype.hasOwnProperty.call(U, K[N])) return !1;
            for (N = V; N-- !== 0;) {
                var x = K[N];
                if (!v(z[x], U[x])) return !1
            }
            return !0
        }
        return z !== z && U !== U
    }
});
var gk = _((jk6, Xk) => {
    var S5 = Xk.exports = function(v, z, U) {
        if (typeof z == "function") U = z, z = {};
        U = z.cb || U;
        var V = typeof U == "function" ? U : U.pre || function() {},
            N = U.post || function() {};
        hO(z, V, N, v, "", v)
    };
    S5.keywords = {
        additionalItems: !0,
        items: !0,
        contains: !0,
        additionalProperties: !0,
        propertyNames: !0,
        not: !0,
        if: !0,
        then: !0,
        else: !0
    };
    S5.arrayKeywords = {
        items: !0,
        allOf: !0,
        anyOf: !0,
        oneOf: !0
    };
    S5.propsKeywords = {
        $defs: !0,
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0
    };
    S5.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0
    };

    function hO(v, z, U, V, N, K, x, j, B, O) {
        if (V && typeof V == "object" && !Array.isArray(V)) {
            z(V, N, K, x, j, B, O);
            for (var J in V) {
                var q = V[J];
                if (Array.isArray(q)) {
                    if (J in S5.arrayKeywords)
                        for (var H = 0; H < q.length; H++) hO(v, z, U, q[H], N + "/" + J + "/" + H, K, N, J, V, H)
                } else if (J in S5.propsKeywords) {
                    if (q && typeof q == "object")
                        for (var D in q) hO(v, z, U, q[D], N + "/" + J + "/" + YB6(D), K, N, J, V, D)
                } else if (J in S5.keywords || v.allKeys && !(J in S5.skipKeywords)) hO(v, z, U, q, N + "/" + J, K, N, J, V)
            }
            U(V, N, K, x, j, B, O)
        }
    }

    function YB6(v) {
        return v.replace(/~/g, "~0").replace(/\//g, "~1")
    }
});
var eV = _((b3) => {
    Object.defineProperty(b3, "__esModule", {
        value: !0
    });
    b3.getSchemaRefs = b3.resolveUrl = b3.normalizeId = b3._getFullPath = b3.getFullPath = b3.inlineRef = void 0;
    var uB6 = w0(),
        yB6 = zL(),
        kB6 = gk(),
        mB6 = new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);

    function XB6(v, z = !0) {
        if (typeof v == "boolean") return !0;
        if (z === !0) return !UL(v);
        if (!z) return !1;
        return ck(v) <= z
    }
    b3.inlineRef = XB6;
    var gB6 = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);

    function UL(v) {
        for (let z in v) {
            if (gB6.has(z)) return !0;
            let U = v[z];
            if (Array.isArray(U) && U.some(UL)) return !0;
            if (typeof U == "object" && UL(U)) return !0
        }
        return !1
    }

    function ck(v) {
        let z = 0;
        for (let U in v) {
            if (U === "$ref") return 1 / 0;
            if (z++, mB6.has(U)) continue;
            if (typeof v[U] == "object")(0, uB6.eachItem)(v[U], (V) => z += ck(V));
            if (z === 1 / 0) return 1 / 0
        }
        return z
    }

    function ik(v, z = "", U) {
        if (U !== !1) z = T1(z);
        let V = v.parse(z);
        return lk(v, V)
    }
    b3.getFullPath = ik;

    function lk(v, z) {
        return v.serialize(z).split("#")[0] + "#"
    }
    b3._getFullPath = lk;
    var cB6 = /#\/?$/;

    function T1(v) {
        return v ? v.replace(cB6, "") : ""
    }
    b3.normalizeId = T1;

    function iB6(v, z, U) {
        return U = T1(U), v.resolve(z, U)
    }
    b3.resolveUrl = iB6;
    var lB6 = /^[a-z_][-a-z0-9._]*$/i;

    function hB6(v, z) {
        if (typeof v == "boolean") return {};
        let {
            schemaId: U,
            uriResolver: V
        } = this.opts, N = T1(v[U] || z), K = {
            "": N
        }, x = ik(V, N, !1), j = {}, B = new Set;
        return kB6(v, {
            allKeys: !0
        }, (q, H, D, A) => {
            if (A === void 0) return;
            let w = x + H,
                Z = K[A];
            if (typeof q[U] == "string") Z = $.call(this, q[U]);
            F.call(this, q.$anchor), F.call(this, q.$dynamicAnchor), K[H] = Z;

            function $(L) {
                let G = this.opts.uriResolver.resolve;
                if (L = T1(Z ? G(Z, L) : L), B.has(L)) throw J(L);
                B.add(L);
                let I = this.refs[L];
                if (typeof I == "string") I = this.refs[I];
                if (typeof I == "object") O(q, I.schema, L);
                else if (L !== T1(w))
                    if (L[0] === "#") O(q, j[L], L), j[L] = q;
                    else this.refs[L] = w;
                return L
            }

            function F(L) {
                if (typeof L == "string") {
                    if (!lB6.test(L)) throw Error(`invalid anchor "${L}"`);
                    $.call(this, `#${L}`)
                }
            }
        }), j;

        function O(q, H, D) {
            if (H !== void 0 && !yB6(q, H)) throw J(D)
        }

        function J(q) {
            return Error(`reference "${q}" resolves to more than one schema`)
        }
    }
    b3.getSchemaRefs = hB6
});
var UN = _((P5) => {
    Object.defineProperty(P5, "__esModule", {
        value: !0
    });
    P5.getData = P5.KeywordCxt = P5.validateFunctionCode = void 0;
    var dk = Mk(),
        hk = sV(),
        NL = oZ(),
        pO = sV(),
        pB6 = _k(),
        zN = uk(),
        VL = kk(),
        R6 = e6(),
        n6 = f9(),
        nB6 = eV(),
        T9 = w0(),
        vN = tV();

    function QB6(v) {
        if (ak(v)) {
            if (tk(v), rk(v)) {
                rB6(v);
                return
            }
        }
        ok(v, () => (0, dk.topBoolOrEmptySchema)(v))
    }
    P5.validateFunctionCode = QB6;

    function ok({
        gen: v,
        validateName: z,
        schema: U,
        schemaEnv: V,
        opts: N
    }, K) {
        if (N.code.es5) v.func(z, R6._`${n6.default.data}, ${n6.default.valCxt}`, V.$async, () => {
            v.code(R6._`"use strict"; ${pk(U,N)}`), oB6(v, N), v.code(K)
        });
        else v.func(z, R6._`${n6.default.data}, ${dB6(N)}`, V.$async, () => v.code(pk(U, N)).code(K))
    }

    function dB6(v) {
        return R6._`{${n6.default.instancePath}="", ${n6.default.parentData}, ${n6.default.parentDataProperty}, ${n6.default.rootData}=${n6.default.data}${v.dynamicRef?R6._`, ${n6.default.dynamicAnchors}={}`:R6.nil}}={}`
    }

    function oB6(v, z) {
        v.if(n6.default.valCxt, () => {
            if (v.var(n6.default.instancePath, R6._`${n6.default.valCxt}.${n6.default.instancePath}`), v.var(n6.default.parentData, R6._`${n6.default.valCxt}.${n6.default.parentData}`), v.var(n6.default.parentDataProperty, R6._`${n6.default.valCxt}.${n6.default.parentDataProperty}`), v.var(n6.default.rootData, R6._`${n6.default.valCxt}.${n6.default.rootData}`), z.dynamicRef) v.var(n6.default.dynamicAnchors, R6._`${n6.default.valCxt}.${n6.default.dynamicAnchors}`)
        }, () => {
            if (v.var(n6.default.instancePath, R6._`""`), v.var(n6.default.parentData, R6._`undefined`), v.var(n6.default.parentDataProperty, R6._`undefined`), v.var(n6.default.rootData, n6.default.data), z.dynamicRef) v.var(n6.default.dynamicAnchors, R6._`{}`)
        })
    }

    function rB6(v) {
        let {
            schema: z,
            opts: U,
            gen: V
        } = v;
        ok(v, () => {
            if (U.$comment && z.$comment) ek(v);
            if (vO6(v), V.let(n6.default.vErrors, null), V.let(n6.default.errors, 0), U.unevaluated) aB6(v);
            sk(v), VO6(v)
        });
        return
    }

    function aB6(v) {
        let {
            gen: z,
            validateName: U
        } = v;
        v.evaluated = z.const("evaluated", R6._`${U}.evaluated`), z.if(R6._`${v.evaluated}.dynamicProps`, () => z.assign(R6._`${v.evaluated}.props`, R6._`undefined`)), z.if(R6._`${v.evaluated}.dynamicItems`, () => z.assign(R6._`${v.evaluated}.items`, R6._`undefined`))
    }

    function pk(v, z) {
        let U = typeof v == "object" && v[z.schemaId];
        return U && (z.code.source || z.code.process) ? R6._`/*# sourceURL=${U} */` : R6.nil
    }

    function tB6(v, z) {
        if (ak(v)) {
            if (tk(v), rk(v)) {
                sB6(v, z);
                return
            }
        }(0, dk.boolOrEmptySchema)(v, z)
    }

    function rk({
        schema: v,
        self: z
    }) {
        if (typeof v == "boolean") return !v;
        for (let U in v)
            if (z.RULES.all[U]) return !0;
        return !1
    }

    function ak(v) {
        return typeof v.schema != "boolean"
    }

    function sB6(v, z) {
        let {
            schema: U,
            gen: V,
            opts: N
        } = v;
        if (N.$comment && U.$comment) ek(v);
        zO6(v), UO6(v);
        let K = V.const("_errs", n6.default.errors);
        sk(v, K), V.var(z, R6._`${K} === ${n6.default.errors}`)
    }

    function tk(v) {
        (0, T9.checkUnknownRules)(v), eB6(v)
    }

    function sk(v, z) {
        if (v.opts.jtd) return nk(v, [], !1, z);
        let U = (0, hk.getSchemaTypes)(v.schema),
            V = (0, hk.coerceAndCheckDataType)(v, U);
        nk(v, U, !V, z)
    }

    function eB6(v) {
        let {
            schema: z,
            errSchemaPath: U,
            opts: V,
            self: N
        } = v;
        if (z.$ref && V.ignoreKeywordsWithRef && (0, T9.schemaHasRulesButRef)(z, N.RULES)) N.logger.warn(`$ref: keywords ignored in schema at path "${U}"`)
    }

    function vO6(v) {
        let {
            schema: z,
            opts: U
        } = v;
        if (z.default !== void 0 && U.useDefaults && U.strictSchema)(0, T9.checkStrictMode)(v, "default is ignored in the schema root")
    }

    function zO6(v) {
        let z = v.schema[v.opts.schemaId];
        if (z) v.baseId = (0, nB6.resolveUrl)(v.opts.uriResolver, v.baseId, z)
    }

    function UO6(v) {
        if (v.schema.$async && !v.schemaEnv.$async) throw Error("async schema in sync schema")
    }

    function ek({
        gen: v,
        schemaEnv: z,
        schema: U,
        errSchemaPath: V,
        opts: N
    }) {
        let K = U.$comment;
        if (N.$comment === !0) v.code(R6._`${n6.default.self}.logger.log(${K})`);
        else if (typeof N.$comment == "function") {
            let x = R6.str`${V}/$comment`,
                j = v.scopeValue("root", {
                    ref: z.root
                });
            v.code(R6._`${n6.default.self}.opts.$comment(${K}, ${x}, ${j}.schema)`)
        }
    }

    function VO6(v) {
        let {
            gen: z,
            schemaEnv: U,
            validateName: V,
            ValidationError: N,
            opts: K
        } = v;
        if (U.$async) z.if(R6._`${n6.default.errors} === 0`, () => z.return(n6.default.data), () => z.throw(R6._`new ${N}(${n6.default.vErrors})`));
        else {
            if (z.assign(R6._`${V}.errors`, n6.default.vErrors), K.unevaluated) NO6(v);
            z.return(R6._`${n6.default.errors} === 0`)
        }
    }

    function NO6({
        gen: v,
        evaluated: z,
        props: U,
        items: V
    }) {
        if (U instanceof R6.Name) v.assign(R6._`${z}.props`, U);
        if (V instanceof R6.Name) v.assign(R6._`${z}.items`, V)
    }

    function nk(v, z, U, V) {
        let {
            gen: N,
            schema: K,
            data: x,
            allErrors: j,
            opts: B,
            self: O
        } = v, {
            RULES: J
        } = O;
        if (K.$ref && (B.ignoreKeywordsWithRef || !(0, T9.schemaHasRulesButRef)(K, J))) {
            N.block(() => zm(v, "$ref", J.all.$ref.definition));
            return
        }
        if (!B.jtd) KO6(v, z);
        N.block(() => {
            for (let H of J.rules) q(H);
            q(J.post)
        });

        function q(H) {
            if (!(0, NL.shouldUseGroup)(K, H)) return;
            if (H.type) {
                if (N.if((0, pO.checkDataType)(H.type, x, B.strictNumbers)), Qk(v, H), z.length === 1 && z[0] === H.type && U) N.else(), (0, pO.reportTypeError)(v);
                N.endIf()
            } else Qk(v, H);
            if (!j) N.if(R6._`${n6.default.errors} === ${V||0}`)
        }
    }

    function Qk(v, z) {
        let {
            gen: U,
            schema: V,
            opts: {
                useDefaults: N
            }
        } = v;
        if (N)(0, pB6.assignDefaults)(v, z.type);
        U.block(() => {
            for (let K of z.rules)
                if ((0, NL.shouldUseRule)(V, K)) zm(v, K.keyword, K.definition, z.type)
        })
    }

    function KO6(v, z) {
        if (v.schemaEnv.meta || !v.opts.strictTypes) return;
        if (xO6(v, z), !v.opts.allowUnionTypes) jO6(v, z);
        BO6(v, v.dataTypes)
    }

    function xO6(v, z) {
        if (!z.length) return;
        if (!v.dataTypes.length) {
            v.dataTypes = z;
            return
        }
        z.forEach((U) => {
            if (!vm(v.dataTypes, U)) KL(v, `type "${U}" not allowed by context "${v.dataTypes.join(",")}"`)
        }), JO6(v, z)
    }

    function jO6(v, z) {
        if (z.length > 1 && !(z.length === 2 && z.includes("null"))) KL(v, "use allowUnionTypes to allow union type keyword")
    }

    function BO6(v, z) {
        let U = v.self.RULES.all;
        for (let V in U) {
            let N = U[V];
            if (typeof N == "object" && (0, NL.shouldUseRule)(v.schema, N)) {
                let {
                    type: K
                } = N.definition;
                if (K.length && !K.some((x) => OO6(z, x))) KL(v, `missing type "${K.join(",")}" for keyword "${V}"`)
            }
        }
    }

    function OO6(v, z) {
        return v.includes(z) || z === "number" && v.includes("integer")
    }

    function vm(v, z) {
        return v.includes(z) || z === "integer" && v.includes("number")
    }

    function JO6(v, z) {
        let U = [];
        for (let V of v.dataTypes)
            if (vm(z, V)) U.push(V);
            else if (z.includes("integer") && V === "number") U.push("integer");
        v.dataTypes = U
    }

    function KL(v, z) {
        let U = v.schemaEnv.baseId + v.errSchemaPath;
        z += ` at "${U}" (strictTypes)`, (0, T9.checkStrictMode)(v, z, v.opts.strictTypes)
    }
    class xL {
        constructor(v, z, U) {
            if ((0, zN.validateKeywordUsage)(v, z, U), this.gen = v.gen, this.allErrors = v.allErrors, this.keyword = U, this.data = v.data, this.schema = v.schema[U], this.$data = z.$data && v.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, T9.schemaRefOrVal)(v, this.schema, U, this.$data), this.schemaType = z.schemaType, this.parentSchema = v.schema, this.params = {}, this.it = v, this.def = z, this.$data) this.schemaCode = v.gen.const("vSchema", Um(this.$data, v));
            else if (this.schemaCode = this.schemaValue, !(0, zN.validSchemaType)(this.schema, z.schemaType, z.allowUndefined)) throw Error(`${U} value must be ${JSON.stringify(z.schemaType)}`);
            if ("code" in z ? z.trackErrors : z.errors !== !1) this.errsCount = v.gen.const("_errs", n6.default.errors)
        }
        result(v, z, U) {
            this.failResult((0, R6.not)(v), z, U)
        }
        failResult(v, z, U) {
            if (this.gen.if(v), U) U();
            else this.error();
            if (z) {
                if (this.gen.else(), z(), this.allErrors) this.gen.endIf()
            } else if (this.allErrors) this.gen.endIf();
            else this.gen.else()
        }
        pass(v, z) {
            this.failResult((0, R6.not)(v), void 0, z)
        }
        fail(v) {
            if (v === void 0) {
                if (this.error(), !this.allErrors) this.gen.if(!1);
                return
            }
            if (this.gen.if(v), this.error(), this.allErrors) this.gen.endIf();
            else this.gen.else()
        }
        fail$data(v) {
            if (!this.$data) return this.fail(v);
            let {
                schemaCode: z
            } = this;
            this.fail(R6._`${z} !== undefined && (${(0,R6.or)(this.invalid$data(),v)})`)
        }
        error(v, z, U) {
            if (z) {
                this.setParams(z), this._error(v, U), this.setParams({});
                return
            }
            this._error(v, U)
        }
        _error(v, z) {
            (v ? vN.reportExtraError : vN.reportError)(this, this.def.error, z)
        }
        $dataError() {
            (0, vN.reportError)(this, this.def.$dataError || vN.keyword$DataError)
        }
        reset() {
            if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
            (0, vN.resetErrorsCount)(this.gen, this.errsCount)
        }
        ok(v) {
            if (!this.allErrors) this.gen.if(v)
        }
        setParams(v, z) {
            if (z) Object.assign(this.params, v);
            else this.params = v
        }
        block$data(v, z, U = R6.nil) {
            this.gen.block(() => {
                this.check$data(v, U), z()
            })
        }
        check$data(v = R6.nil, z = R6.nil) {
            if (!this.$data) return;
            let {
                gen: U,
                schemaCode: V,
                schemaType: N,
                def: K
            } = this;
            if (U.if((0, R6.or)(R6._`${V} === undefined`, z)), v !== R6.nil) U.assign(v, !0);
            if (N.length || K.validateSchema) {
                if (U.elseIf(this.invalid$data()), this.$dataError(), v !== R6.nil) U.assign(v, !1)
            }
            U.else()
        }
        invalid$data() {
            let {
                gen: v,
                schemaCode: z,
                schemaType: U,
                def: V,
                it: N
            } = this;
            return (0, R6.or)(K(), x());

            function K() {
                if (U.length) {
                    if (!(z instanceof R6.Name)) throw Error("ajv implementation error");
                    let j = Array.isArray(U) ? U : [U];
                    return R6._`${(0,pO.checkDataTypes)(j,z,N.opts.strictNumbers,pO.DataType.Wrong)}`
                }
                return R6.nil
            }

            function x() {
                if (V.validateSchema) {
                    let j = v.scopeValue("validate$data", {
                        ref: V.validateSchema
                    });
                    return R6._`!${j}(${z})`
                }
                return R6.nil
            }
        }
        subschema(v, z) {
            let U = (0, VL.getSubschema)(this.it, v);
            (0, VL.extendSubschemaData)(U, this.it, v), (0, VL.extendSubschemaMode)(U, v);
            let V = {
                ...this.it,
                ...U,
                items: void 0,
                props: void 0
            };
            return tB6(V, z), V
        }
        mergeEvaluated(v, z) {
            let {
                it: U,
                gen: V
            } = this;
            if (!U.opts.unevaluated) return;
            if (U.props !== !0 && v.props !== void 0) U.props = T9.mergeEvaluated.props(V, v.props, U.props, z);
            if (U.items !== !0 && v.items !== void 0) U.items = T9.mergeEvaluated.items(V, v.items, U.items, z)
        }
        mergeValidEvaluated(v, z) {
            let {
                it: U,
                gen: V
            } = this;
            if (U.opts.unevaluated && (U.props !== !0 || U.items !== !0)) return V.if(z, () => this.mergeEvaluated(v, R6.Name)), !0
        }
    }
    P5.KeywordCxt = xL;

    function zm(v, z, U, V) {
        let N = new xL(v, U, z);
        if ("code" in U) U.code(N, V);
        else if (N.$data && U.validate)(0, zN.funcKeywordCode)(N, U);
        else if ("macro" in U)(0, zN.macroKeywordCode)(N, U);
        else if (U.compile || U.validate)(0, zN.funcKeywordCode)(N, U)
    }
    var qO6 = /^\/(?:[^~]|~0|~1)*$/,
        HO6 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

    function Um(v, {
        dataLevel: z,
        dataNames: U,
        dataPathArr: V
    }) {
        let N, K;
        if (v === "") return n6.default.rootData;
        if (v[0] === "/") {
            if (!qO6.test(v)) throw Error(`Invalid JSON-pointer: ${v}`);
            N = v, K = n6.default.rootData
        } else {
            let O = HO6.exec(v);
            if (!O) throw Error(`Invalid JSON-pointer: ${v}`);
            let J = +O[1];
            if (N = O[2], N === "#") {
                if (J >= z) throw Error(B("property/index", J));
                return V[z - J]
            }
            if (J > z) throw Error(B("data", J));
            if (K = U[z - J], !N) return K
        }
        let x = K,
            j = N.split("/");
        for (let O of j)
            if (O) K = R6._`${K}${(0,R6.getProperty)((0,T9.unescapeJsonPointer)(O))}`, x = R6._`${x} && ${K}`;
        return x;

        function B(O, J) {
            return `Cannot access ${O} ${J} levels up, current level is ${z}`
        }
    }
    P5.getData = Um
});
var nO = _((jL) => {
    Object.defineProperty(jL, "__esModule", {
        value: !0
    });
    class Vm extends Error {
        constructor(v) {
            super("validation failed");
            this.errors = v, this.ajv = this.validation = !0
        }
    }
    jL.default = Vm
});
var VN = _((OL) => {
    Object.defineProperty(OL, "__esModule", {
        value: !0
    });
    var BL = eV();
    class Nm extends Error {
        constructor(v, z, U, V) {
            super(V || `can't resolve reference ${U} from id ${z}`);
            this.missingRef = (0, BL.resolveUrl)(v, z, U), this.missingSchema = (0, BL.normalizeId)((0, BL.getFullPath)(v, this.missingRef))
        }
    }
    OL.default = Nm
});
var dO = _((o3) => {
    Object.defineProperty(o3, "__esModule", {
        value: !0
    });
    o3.resolveSchema = o3.getCompilingSchema = o3.resolveRef = o3.compileSchema = o3.SchemaEnv = void 0;
    var I8 = e6(),
        DO6 = nO(),
        E7 = f9(),
        M8 = eV(),
        Km = w0(),
        AO6 = UN();
    class NN {
        constructor(v) {
            var z;
            this.refs = {}, this.dynamicAnchors = {};
            let U;
            if (typeof v.schema == "object") U = v.schema;
            this.schema = v.schema, this.schemaId = v.schemaId, this.root = v.root || this, this.baseId = (z = v.baseId) !== null && z !== void 0 ? z : (0, M8.normalizeId)(U === null || U === void 0 ? void 0 : U[v.schemaId || "$id"]), this.schemaPath = v.schemaPath, this.localRefs = v.localRefs, this.meta = v.meta, this.$async = U === null || U === void 0 ? void 0 : U.$async, this.refs = {}
        }
    }
    o3.SchemaEnv = NN;

    function qL(v) {
        let z = xm.call(this, v);
        if (z) return z;
        let U = (0, M8.getFullPath)(this.opts.uriResolver, v.root.baseId),
            {
                es5: V,
                lines: N
            } = this.opts.code,
            {
                ownProperties: K
            } = this.opts,
            x = new I8.CodeGen(this.scope, {
                es5: V,
                lines: N,
                ownProperties: K
            }),
            j;
        if (v.$async) j = x.scopeValue("Error", {
            ref: DO6.default,
            code: I8._`require("ajv/dist/runtime/validation_error").default`
        });
        let B = x.scopeName("validate");
        v.validateName = B;
        let O = {
                gen: x,
                allErrors: this.opts.allErrors,
                data: E7.default.data,
                parentData: E7.default.parentData,
                parentDataProperty: E7.default.parentDataProperty,
                dataNames: [E7.default.data],
                dataPathArr: [I8.nil],
                dataLevel: 0,
                dataTypes: [],
                definedProperties: new Set,
                topSchemaRef: x.scopeValue("schema", this.opts.code.source === !0 ? {
                    ref: v.schema,
                    code: (0, I8.stringify)(v.schema)
                } : {
                    ref: v.schema
                }),
                validateName: B,
                ValidationError: j,
                schema: v.schema,
                schemaEnv: v,
                rootId: U,
                baseId: v.baseId || U,
                schemaPath: I8.nil,
                errSchemaPath: v.schemaPath || (this.opts.jtd ? "" : "#"),
                errorPath: I8._`""`,
                opts: this.opts,
                self: this
            },
            J;
        try {
            this._compilations.add(v), (0, AO6.validateFunctionCode)(O), x.optimize(this.opts.code.optimize);
            let q = x.toString();
            if (J = `${x.scopeRefs(E7.default.scope)}return ${q}`, this.opts.code.process) J = this.opts.code.process(J, v);
            let D = Function(`${E7.default.self}`, `${E7.default.scope}`, J)(this, this.scope.get());
            if (this.scope.value(B, {
                    ref: D
                }), D.errors = null, D.schema = v.schema, D.schemaEnv = v, v.$async) D.$async = !0;
            if (this.opts.code.source === !0) D.source = {
                validateName: B,
                validateCode: q,
                scopeValues: x._values
            };
            if (this.opts.unevaluated) {
                let {
                    props: A,
                    items: w
                } = O;
                if (D.evaluated = {
                        props: A instanceof I8.Name ? void 0 : A,
                        items: w instanceof I8.Name ? void 0 : w,
                        dynamicProps: A instanceof I8.Name,
                        dynamicItems: w instanceof I8.Name
                    }, D.source) D.source.evaluated = (0, I8.stringify)(D.evaluated)
            }
            return v.validate = D, v
        } catch (q) {
            if (delete v.validate, delete v.validateName, J) this.logger.error("Error compiling schema, function code:", J);
            throw q
        } finally {
            this._compilations.delete(v)
        }
    }
    o3.compileSchema = qL;

    function $O6(v, z, U) {
        var V;
        U = (0, M8.resolveUrl)(this.opts.uriResolver, z, U);
        let N = v.refs[U];
        if (N) return N;
        let K = LO6.call(this, v, U);
        if (K === void 0) {
            let x = (V = v.localRefs) === null || V === void 0 ? void 0 : V[U],
                {
                    schemaId: j
                } = this.opts;
            if (x) K = new NN({
                schema: x,
                schemaId: j,
                root: v,
                baseId: z
            })
        }
        if (K === void 0) return;
        return v.refs[U] = wO6.call(this, K)
    }
    o3.resolveRef = $O6;

    function wO6(v) {
        if ((0, M8.inlineRef)(v.schema, this.opts.inlineRefs)) return v.schema;
        return v.validate ? v : qL.call(this, v)
    }

    function xm(v) {
        for (let z of this._compilations)
            if (ZO6(z, v)) return z
    }
    o3.getCompilingSchema = xm;

    function ZO6(v, z) {
        return v.schema === z.schema && v.root === z.root && v.baseId === z.baseId
    }

    function LO6(v, z) {
        let U;
        while (typeof(U = this.refs[z]) == "string") z = U;
        return U || this.schemas[z] || QO.call(this, v, z)
    }

    function QO(v, z) {
        let U = this.opts.uriResolver.parse(z),
            V = (0, M8._getFullPath)(this.opts.uriResolver, U),
            N = (0, M8.getFullPath)(this.opts.uriResolver, v.baseId, void 0);
        if (Object.keys(v.schema).length > 0 && V === N) return JL.call(this, U, v);
        let K = (0, M8.normalizeId)(V),
            x = this.refs[K] || this.schemas[K];
        if (typeof x == "string") {
            let j = QO.call(this, v, x);
            if (typeof(j === null || j === void 0 ? void 0 : j.schema) !== "object") return;
            return JL.call(this, U, j)
        }
        if (typeof(x === null || x === void 0 ? void 0 : x.schema) !== "object") return;
        if (!x.validate) qL.call(this, x);
        if (K === (0, M8.normalizeId)(z)) {
            let {
                schema: j
            } = x, {
                schemaId: B
            } = this.opts, O = j[B];
            if (O) N = (0, M8.resolveUrl)(this.opts.uriResolver, N, O);
            return new NN({
                schema: j,
                schemaId: B,
                root: v,
                baseId: N
            })
        }
        return JL.call(this, U, x)
    }
    o3.resolveSchema = QO;
    var FO6 = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);

    function JL(v, {
        baseId: z,
        schema: U,
        root: V
    }) {
        var N;
        if (((N = v.fragment) === null || N === void 0 ? void 0 : N[0]) !== "/") return;
        for (let j of v.fragment.slice(1).split("/")) {
            if (typeof U === "boolean") return;
            let B = U[(0, Km.unescapeFragment)(j)];
            if (B === void 0) return;
            U = B;
            let O = typeof U === "object" && U[this.opts.schemaId];
            if (!FO6.has(j) && O) z = (0, M8.resolveUrl)(this.opts.uriResolver, z, O)
        }
        let K;
        if (typeof U != "boolean" && U.$ref && !(0, Km.schemaHasRulesButRef)(U, this.RULES)) {
            let j = (0, M8.resolveUrl)(this.opts.uriResolver, z, U.$ref);
            K = QO.call(this, V, j)
        }
        let {
            schemaId: x
        } = this.opts;
        if (K = K || new NN({
                schema: U,
                schemaId: x,
                root: V,
                baseId: z
            }), K.schema !== K.root.schema) return K;
        return
    }
});
var jm = _((Dk6, GO6) => {
    GO6.exports = {
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
            $data: {
                type: "string",
                anyOf: [{
                    format: "relative-json-pointer"
                }, {
                    format: "json-pointer"
                }]
            }
        },
        additionalProperties: !1
    }
});
var Om = _((Ak6, Bm) => {
    var IO6 = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
    };
    Bm.exports = {
        HEX: IO6
    }
});
var Zm = _(($k6, wm) => {
    var {
        HEX: MO6
    } = Om(), bO6 = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;

    function Dm(v) {
        if ($m(v, ".") < 3) return {
            host: v,
            isIPV4: !1
        };
        let z = v.match(bO6) || [],
            [U] = z;
        if (U) return {
            host: WO6(U, "."),
            isIPV4: !0
        };
        else return {
            host: v,
            isIPV4: !1
        }
    }

    function HL(v, z = !1) {
        let U = "",
            V = !0;
        for (let N of v) {
            if (MO6[N] === void 0) return;
            if (N !== "0" && V === !0) V = !1;
            if (!V) U += N
        }
        if (z && U.length === 0) U = "0";
        return U
    }

    function RO6(v) {
        let z = 0,
            U = {
                error: !1,
                address: "",
                zone: ""
            },
            V = [],
            N = [],
            K = !1,
            x = !1,
            j = !1;

        function B() {
            if (N.length) {
                if (K === !1) {
                    let O = HL(N);
                    if (O !== void 0) V.push(O);
                    else return U.error = !0, !1
                }
                N.length = 0
            }
            return !0
        }
        for (let O = 0; O < v.length; O++) {
            let J = v[O];
            if (J === "[" || J === "]") continue;
            if (J === ":") {
                if (x === !0) j = !0;
                if (!B()) break;
                if (z++, V.push(":"), z > 7) {
                    U.error = !0;
                    break
                }
                if (O - 1 >= 0 && v[O - 1] === ":") x = !0;
                continue
            } else if (J === "%") {
                if (!B()) break;
                K = !0
            } else {
                N.push(J);
                continue
            }
        }
        if (N.length)
            if (K) U.zone = N.join("");
            else if (j) V.push(N.join(""));
        else V.push(HL(N));
        return U.address = V.join(""), U
    }

    function Am(v) {
        if ($m(v, ":") < 2) return {
            host: v,
            isIPV6: !1
        };
        let z = RO6(v);
        if (!z.error) {
            let {
                address: U,
                address: V
            } = z;
            if (z.zone) U += "%" + z.zone, V += "%25" + z.zone;
            return {
                host: U,
                escapedHost: V,
                isIPV6: !0
            }
        } else return {
            host: v,
            isIPV6: !1
        }
    }

    function WO6(v, z) {
        let U = "",
            V = !0,
            N = v.length;
        for (let K = 0; K < N; K++) {
            let x = v[K];
            if (x === "0" && V) {
                if (K + 1 <= N && v[K + 1] === z || K + 1 === N) U += x, V = !1
            } else {
                if (x === z) V = !0;
                else V = !1;
                U += x
            }
        }
        return U
    }

    function $m(v, z) {
        let U = 0;
        for (let V = 0; V < v.length; V++)
            if (v[V] === z) U++;
        return U
    }
    var Jm = /^\.\.?\//u,
        qm = /^\/\.(?:\/|$)/u,
        Hm = /^\/\.\.(?:\/|$)/u,
        EO6 = /^\/?(?:.|\n)*?(?=\/|$)/u;

    function SO6(v) {
        let z = [];
        while (v.length)
            if (v.match(Jm)) v = v.replace(Jm, "");
            else if (v.match(qm)) v = v.replace(qm, "/");
        else if (v.match(Hm)) v = v.replace(Hm, "/"), z.pop();
        else if (v === "." || v === "..") v = "";
        else {
            let U = v.match(EO6);
            if (U) {
                let V = U[0];
                v = v.slice(V.length), z.push(V)
            } else throw Error("Unexpected dot segment condition")
        }
        return z.join("")
    }

    function PO6(v, z) {
        let U = z !== !0 ? escape : unescape;
        if (v.scheme !== void 0) v.scheme = U(v.scheme);
        if (v.userinfo !== void 0) v.userinfo = U(v.userinfo);
        if (v.host !== void 0) v.host = U(v.host);
        if (v.path !== void 0) v.path = U(v.path);
        if (v.query !== void 0) v.query = U(v.query);
        if (v.fragment !== void 0) v.fragment = U(v.fragment);
        return v
    }

    function _O6(v) {
        let z = [];
        if (v.userinfo !== void 0) z.push(v.userinfo), z.push("@");
        if (v.host !== void 0) {
            let U = unescape(v.host),
                V = Dm(U);
            if (V.isIPV4) U = V.host;
            else {
                let N = Am(V.host);
                if (N.isIPV6 === !0) U = `[${N.escapedHost}]`;
                else U = v.host
            }
            z.push(U)
        }
        if (typeof v.port === "number" || typeof v.port === "string") z.push(":"), z.push(String(v.port));
        return z.length ? z.join("") : void 0
    }
    wm.exports = {
        recomposeAuthority: _O6,
        normalizeComponentEncoding: PO6,
        removeDotSegments: SO6,
        normalizeIPv4: Dm,
        normalizeIPv6: Am,
        stringArrayToHexStripped: HL
    }
});
var bm = _((wk6, Mm) => {
    var CO6 = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu,
        fO6 = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

    function Lm(v) {
        return typeof v.secure === "boolean" ? v.secure : String(v.scheme).toLowerCase() === "wss"
    }

    function Fm(v) {
        if (!v.host) v.error = v.error || "HTTP URIs must have a host.";
        return v
    }

    function Gm(v) {
        let z = String(v.scheme).toLowerCase() === "https";
        if (v.port === (z ? 443 : 80) || v.port === "") v.port = void 0;
        if (!v.path) v.path = "/";
        return v
    }

    function TO6(v) {
        return v.secure = Lm(v), v.resourceName = (v.path || "/") + (v.query ? "?" + v.query : ""), v.path = void 0, v.query = void 0, v
    }

    function YO6(v) {
        if (v.port === (Lm(v) ? 443 : 80) || v.port === "") v.port = void 0;
        if (typeof v.secure === "boolean") v.scheme = v.secure ? "wss" : "ws", v.secure = void 0;
        if (v.resourceName) {
            let [z, U] = v.resourceName.split("?");
            v.path = z && z !== "/" ? z : void 0, v.query = U, v.resourceName = void 0
        }
        return v.fragment = void 0, v
    }

    function uO6(v, z) {
        if (!v.path) return v.error = "URN can not be parsed", v;
        let U = v.path.match(fO6);
        if (U) {
            let V = z.scheme || v.scheme || "urn";
            v.nid = U[1].toLowerCase(), v.nss = U[2];
            let N = `${V}:${z.nid||v.nid}`,
                K = DL[N];
            if (v.path = void 0, K) v = K.parse(v, z)
        } else v.error = v.error || "URN can not be parsed.";
        return v
    }

    function yO6(v, z) {
        let U = z.scheme || v.scheme || "urn",
            V = v.nid.toLowerCase(),
            N = `${U}:${z.nid||V}`,
            K = DL[N];
        if (K) v = K.serialize(v, z);
        let x = v,
            j = v.nss;
        return x.path = `${V||z.nid}:${j}`, z.skipEscape = !0, x
    }

    function kO6(v, z) {
        let U = v;
        if (U.uuid = U.nss, U.nss = void 0, !z.tolerant && (!U.uuid || !CO6.test(U.uuid))) U.error = U.error || "UUID is not valid.";
        return U
    }

    function mO6(v) {
        let z = v;
        return z.nss = (v.uuid || "").toLowerCase(), z
    }
    var Im = {
            scheme: "http",
            domainHost: !0,
            parse: Fm,
            serialize: Gm
        },
        XO6 = {
            scheme: "https",
            domainHost: Im.domainHost,
            parse: Fm,
            serialize: Gm
        },
        oO = {
            scheme: "ws",
            domainHost: !0,
            parse: TO6,
            serialize: YO6
        },
        gO6 = {
            scheme: "wss",
            domainHost: oO.domainHost,
            parse: oO.parse,
            serialize: oO.serialize
        },
        cO6 = {
            scheme: "urn",
            parse: uO6,
            serialize: yO6,
            skipNormalize: !0
        },
        iO6 = {
            scheme: "urn:uuid",
            parse: kO6,
            serialize: mO6,
            skipNormalize: !0
        },
        DL = {
            http: Im,
            https: XO6,
            ws: oO,
            wss: gO6,
            urn: cO6,
            "urn:uuid": iO6
        };
    Mm.exports = DL
});
var Wm = _((Zk6, aO) => {
    var {
        normalizeIPv6: lO6,
        normalizeIPv4: hO6,
        removeDotSegments: KN,
        recomposeAuthority: pO6,
        normalizeComponentEncoding: rO
    } = Zm(), AL = bm();

    function nO6(v, z) {
        if (typeof v === "string") v = d8(Y9(v, z), z);
        else if (typeof v === "object") v = Y9(d8(v, z), z);
        return v
    }

    function QO6(v, z, U) {
        let V = Object.assign({
                scheme: "null"
            }, U),
            N = Rm(Y9(v, V), Y9(z, V), V, !0);
        return d8(N, {
            ...V,
            skipEscape: !0
        })
    }

    function Rm(v, z, U, V) {
        let N = {};
        if (!V) v = Y9(d8(v, U), U), z = Y9(d8(z, U), U);
        if (U = U || {}, !U.tolerant && z.scheme) N.scheme = z.scheme, N.userinfo = z.userinfo, N.host = z.host, N.port = z.port, N.path = KN(z.path || ""), N.query = z.query;
        else {
            if (z.userinfo !== void 0 || z.host !== void 0 || z.port !== void 0) N.userinfo = z.userinfo, N.host = z.host, N.port = z.port, N.path = KN(z.path || ""), N.query = z.query;
            else {
                if (!z.path)
                    if (N.path = v.path, z.query !== void 0) N.query = z.query;
                    else N.query = v.query;
                else {
                    if (z.path.charAt(0) === "/") N.path = KN(z.path);
                    else {
                        if ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path) N.path = "/" + z.path;
                        else if (!v.path) N.path = z.path;
                        else N.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + z.path;
                        N.path = KN(N.path)
                    }
                    N.query = z.query
                }
                N.userinfo = v.userinfo, N.host = v.host, N.port = v.port
            }
            N.scheme = v.scheme
        }
        return N.fragment = z.fragment, N
    }

    function dO6(v, z, U) {
        if (typeof v === "string") v = unescape(v), v = d8(rO(Y9(v, U), !0), {
            ...U,
            skipEscape: !0
        });
        else if (typeof v === "object") v = d8(rO(v, !0), {
            ...U,
            skipEscape: !0
        });
        if (typeof z === "string") z = unescape(z), z = d8(rO(Y9(z, U), !0), {
            ...U,
            skipEscape: !0
        });
        else if (typeof z === "object") z = d8(rO(z, !0), {
            ...U,
            skipEscape: !0
        });
        return v.toLowerCase() === z.toLowerCase()
    }

    function d8(v, z) {
        let U = {
                host: v.host,
                scheme: v.scheme,
                userinfo: v.userinfo,
                port: v.port,
                path: v.path,
                query: v.query,
                nid: v.nid,
                nss: v.nss,
                uuid: v.uuid,
                fragment: v.fragment,
                reference: v.reference,
                resourceName: v.resourceName,
                secure: v.secure,
                error: ""
            },
            V = Object.assign({}, z),
            N = [],
            K = AL[(V.scheme || U.scheme || "").toLowerCase()];
        if (K && K.serialize) K.serialize(U, V);
        if (U.path !== void 0)
            if (!V.skipEscape) {
                if (U.path = escape(U.path), U.scheme !== void 0) U.path = U.path.split("%3A").join(":")
            } else U.path = unescape(U.path);
        if (V.reference !== "suffix" && U.scheme) N.push(U.scheme, ":");
        let x = pO6(U);
        if (x !== void 0) {
            if (V.reference !== "suffix") N.push("//");
            if (N.push(x), U.path && U.path.charAt(0) !== "/") N.push("/")
        }
        if (U.path !== void 0) {
            let j = U.path;
            if (!V.absolutePath && (!K || !K.absolutePath)) j = KN(j);
            if (x === void 0) j = j.replace(/^\/\//u, "/%2F");
            N.push(j)
        }
        if (U.query !== void 0) N.push("?", U.query);
        if (U.fragment !== void 0) N.push("#", U.fragment);
        return N.join("")
    }
    var oO6 = Array.from({
        length: 127
    }, (v, z) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(z)));

    function rO6(v) {
        let z = 0;
        for (let U = 0, V = v.length; U < V; ++U)
            if (z = v.charCodeAt(U), z > 126 || oO6[z]) return !0;
        return !1
    }
    var aO6 = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

    function Y9(v, z) {
        let U = Object.assign({}, z),
            V = {
                scheme: void 0,
                userinfo: void 0,
                host: "",
                port: void 0,
                path: "",
                query: void 0,
                fragment: void 0
            },
            N = v.indexOf("%") !== -1,
            K = !1;
        if (U.reference === "suffix") v = (U.scheme ? U.scheme + ":" : "") + "//" + v;
        let x = v.match(aO6);
        if (x) {
            if (V.scheme = x[1], V.userinfo = x[3], V.host = x[4], V.port = parseInt(x[5], 10), V.path = x[6] || "", V.query = x[7], V.fragment = x[8], isNaN(V.port)) V.port = x[5];
            if (V.host) {
                let B = hO6(V.host);
                if (B.isIPV4 === !1) {
                    let O = lO6(B.host);
                    V.host = O.host.toLowerCase(), K = O.isIPV6
                } else V.host = B.host, K = !0
            }
            if (V.scheme === void 0 && V.userinfo === void 0 && V.host === void 0 && V.port === void 0 && V.query === void 0 && !V.path) V.reference = "same-document";
            else if (V.scheme === void 0) V.reference = "relative";
            else if (V.fragment === void 0) V.reference = "absolute";
            else V.reference = "uri";
            if (U.reference && U.reference !== "suffix" && U.reference !== V.reference) V.error = V.error || "URI is not a " + U.reference + " reference.";
            let j = AL[(U.scheme || V.scheme || "").toLowerCase()];
            if (!U.unicodeSupport && (!j || !j.unicodeSupport)) {
                if (V.host && (U.domainHost || j && j.domainHost) && K === !1 && rO6(V.host)) try {
                    V.host = URL.domainToASCII(V.host.toLowerCase())
                } catch (B) {
                    V.error = V.error || "Host's domain name can not be converted to ASCII: " + B
                }
            }
            if (!j || j && !j.skipNormalize) {
                if (N && V.scheme !== void 0) V.scheme = unescape(V.scheme);
                if (N && V.host !== void 0) V.host = unescape(V.host);
                if (V.path) V.path = escape(unescape(V.path));
                if (V.fragment) V.fragment = encodeURI(decodeURIComponent(V.fragment))
            }
            if (j && j.parse) j.parse(V, U)
        } else V.error = V.error || "URI can not be parsed.";
        return V
    }
    var $L = {
        SCHEMES: AL,
        normalize: nO6,
        resolve: QO6,
        resolveComponents: Rm,
        equal: dO6,
        serialize: d8,
        parse: Y9
    };
    aO.exports = $L;
    aO.exports.default = $L;
    aO.exports.fastUri = $L
});
var Sm = _((wL) => {
    Object.defineProperty(wL, "__esModule", {
        value: !0
    });
    var Em = Wm();
    Em.code = 'require("ajv/dist/runtime/uri").default';
    wL.default = Em
});
var ym = _((y4) => {
    Object.defineProperty(y4, "__esModule", {
        value: !0
    });
    y4.CodeGen = y4.Name = y4.nil = y4.stringify = y4.str = y4._ = y4.KeywordCxt = void 0;
    var tO6 = UN();
    Object.defineProperty(y4, "KeywordCxt", {
        enumerable: !0,
        get: function() {
            return tO6.KeywordCxt
        }
    });
    var Y1 = e6();
    Object.defineProperty(y4, "_", {
        enumerable: !0,
        get: function() {
            return Y1._
        }
    });
    Object.defineProperty(y4, "str", {
        enumerable: !0,
        get: function() {
            return Y1.str
        }
    });
    Object.defineProperty(y4, "stringify", {
        enumerable: !0,
        get: function() {
            return Y1.stringify
        }
    });
    Object.defineProperty(y4, "nil", {
        enumerable: !0,
        get: function() {
            return Y1.nil
        }
    });
    Object.defineProperty(y4, "Name", {
        enumerable: !0,
        get: function() {
            return Y1.Name
        }
    });
    Object.defineProperty(y4, "CodeGen", {
        enumerable: !0,
        get: function() {
            return Y1.CodeGen
        }
    });
    var sO6 = nO(),
        Tm = VN(),
        eO6 = dZ(),
        xN = dO(),
        vJ6 = e6(),
        jN = eV(),
        tO = sV(),
        LL = w0(),
        Pm = jm(),
        zJ6 = Sm(),
        Ym = (v, z) => new RegExp(v, z);
    Ym.code = "new RegExp";
    var UJ6 = ["removeAdditional", "useDefaults", "coerceTypes"],
        VJ6 = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]),
        NJ6 = {
            errorDataPath: "",
            format: "`validateFormats: false` can be used instead.",
            nullable: '"nullable" keyword is supported by default.',
            jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
            extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
            missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
            processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
            sourceCode: "Use option `code: {source: true}`",
            strictDefaults: "It is default now, see option `strict`.",
            strictKeywords: "It is default now, see option `strict`.",
            uniqueItems: '"uniqueItems" keyword is always validated.',
            unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
            cache: "Map is used as cache, schema object as key.",
            serialize: "Map is used as cache, schema object as key.",
            ajvErrors: "It is default now."
        },
        KJ6 = {
            ignoreKeywordsWithRef: "",
            jsPropertySyntax: "",
            unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        },
        _m = 200;

    function xJ6(v) {
        var z, U, V, N, K, x, j, B, O, J, q, H, D, A, w, Z, $, F, L, G, I, M, b, W, E;
        let y = v.strict,
            T = (z = v.code) === null || z === void 0 ? void 0 : z.optimize,
            X = T === !0 || T === void 0 ? 1 : T || 0,
            Q = (V = (U = v.code) === null || U === void 0 ? void 0 : U.regExp) !== null && V !== void 0 ? V : Ym,
            m = (N = v.uriResolver) !== null && N !== void 0 ? N : zJ6.default;
        return {
            strictSchema: (x = (K = v.strictSchema) !== null && K !== void 0 ? K : y) !== null && x !== void 0 ? x : !0,
            strictNumbers: (B = (j = v.strictNumbers) !== null && j !== void 0 ? j : y) !== null && B !== void 0 ? B : !0,
            strictTypes: (J = (O = v.strictTypes) !== null && O !== void 0 ? O : y) !== null && J !== void 0 ? J : "log",
            strictTuples: (H = (q = v.strictTuples) !== null && q !== void 0 ? q : y) !== null && H !== void 0 ? H : "log",
            strictRequired: (A = (D = v.strictRequired) !== null && D !== void 0 ? D : y) !== null && A !== void 0 ? A : !1,
            code: v.code ? {
                ...v.code,
                optimize: X,
                regExp: Q
            } : {
                optimize: X,
                regExp: Q
            },
            loopRequired: (w = v.loopRequired) !== null && w !== void 0 ? w : _m,
            loopEnum: (Z = v.loopEnum) !== null && Z !== void 0 ? Z : _m,
            meta: ($ = v.meta) !== null && $ !== void 0 ? $ : !0,
            messages: (F = v.messages) !== null && F !== void 0 ? F : !0,
            inlineRefs: (L = v.inlineRefs) !== null && L !== void 0 ? L : !0,
            schemaId: (G = v.schemaId) !== null && G !== void 0 ? G : "$id",
            addUsedSchema: (I = v.addUsedSchema) !== null && I !== void 0 ? I : !0,
            validateSchema: (M = v.validateSchema) !== null && M !== void 0 ? M : !0,
            validateFormats: (b = v.validateFormats) !== null && b !== void 0 ? b : !0,
            unicodeRegExp: (W = v.unicodeRegExp) !== null && W !== void 0 ? W : !0,
            int32range: (E = v.int32range) !== null && E !== void 0 ? E : !0,
            uriResolver: m
        }
    }
    class sO {
        constructor(v = {}) {
            this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = new Set, this._loading = {}, this._cache = new Map, v = this.opts = {
                ...v,
                ...xJ6(v)
            };
            let {
                es5: z,
                lines: U
            } = this.opts.code;
            this.scope = new vJ6.ValueScope({
                scope: {},
                prefixes: VJ6,
                es5: z,
                lines: U
            }), this.logger = HJ6(v.logger);
            let V = v.validateFormats;
            if (v.validateFormats = !1, this.RULES = (0, eO6.getRules)(), Cm.call(this, NJ6, v, "NOT SUPPORTED"), Cm.call(this, KJ6, v, "DEPRECATED", "warn"), this._metaOpts = JJ6.call(this), v.formats) BJ6.call(this);
            if (this._addVocabularies(), this._addDefaultMetaSchema(), v.keywords) OJ6.call(this, v.keywords);
            if (typeof v.meta == "object") this.addMetaSchema(v.meta);
            jJ6.call(this), v.validateFormats = V
        }
        _addVocabularies() {
            this.addKeyword("$async")
        }
        _addDefaultMetaSchema() {
            let {
                $data: v,
                meta: z,
                schemaId: U
            } = this.opts, V = Pm;
            if (U === "id") V = {
                ...Pm
            }, V.id = V.$id, delete V.$id;
            if (z && v) this.addMetaSchema(V, V[U], !1)
        }
        defaultMeta() {
            let {
                meta: v,
                schemaId: z
            } = this.opts;
            return this.opts.defaultMeta = typeof v == "object" ? v[z] || v : void 0
        }
        validate(v, z) {
            let U;
            if (typeof v == "string") {
                if (U = this.getSchema(v), !U) throw Error(`no schema with key or ref "${v}"`)
            } else U = this.compile(v);
            let V = U(z);
            if (!("$async" in U)) this.errors = U.errors;
            return V
        }
        compile(v, z) {
            let U = this._addSchema(v, z);
            return U.validate || this._compileSchemaEnv(U)
        }
        compileAsync(v, z) {
            if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
            let {
                loadSchema: U
            } = this.opts;
            return V.call(this, v, z);
            async function V(O, J) {
                await N.call(this, O.$schema);
                let q = this._addSchema(O, J);
                return q.validate || K.call(this, q)
            }
            async function N(O) {
                if (O && !this.getSchema(O)) await V.call(this, {
                    $ref: O
                }, !0)
            }
            async function K(O) {
                try {
                    return this._compileSchemaEnv(O)
                } catch (J) {
                    if (!(J instanceof Tm.default)) throw J;
                    return x.call(this, J), await j.call(this, J.missingSchema), K.call(this, O)
                }
            }

            function x({
                missingSchema: O,
                missingRef: J
            }) {
                if (this.refs[O]) throw Error(`AnySchema ${O} is loaded but ${J} cannot be resolved`)
            }
            async function j(O) {
                let J = await B.call(this, O);
                if (!this.refs[O]) await N.call(this, J.$schema);
                if (!this.refs[O]) this.addSchema(J, O, z)
            }
            async function B(O) {
                let J = this._loading[O];
                if (J) return J;
                try {
                    return await (this._loading[O] = U(O))
                } finally {
                    delete this._loading[O]
                }
            }
        }
        addSchema(v, z, U, V = this.opts.validateSchema) {
            if (Array.isArray(v)) {
                for (let K of v) this.addSchema(K, void 0, U, V);
                return this
            }
            let N;
            if (typeof v === "object") {
                let {
                    schemaId: K
                } = this.opts;
                if (N = v[K], N !== void 0 && typeof N != "string") throw Error(`schema ${K} must be string`)
            }
            return z = (0, jN.normalizeId)(z || N), this._checkUnique(z), this.schemas[z] = this._addSchema(v, U, z, V, !0), this
        }
        addMetaSchema(v, z, U = this.opts.validateSchema) {
            return this.addSchema(v, z, !0, U), this
        }
        validateSchema(v, z) {
            if (typeof v == "boolean") return !0;
            let U;
            if (U = v.$schema, U !== void 0 && typeof U != "string") throw Error("$schema must be a string");
            if (U = U || this.opts.defaultMeta || this.defaultMeta(), !U) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
            let V = this.validate(U, v);
            if (!V && z) {
                let N = "schema is invalid: " + this.errorsText();
                if (this.opts.validateSchema === "log") this.logger.error(N);
                else throw Error(N)
            }
            return V
        }
        getSchema(v) {
            let z;
            while (typeof(z = fm.call(this, v)) == "string") v = z;
            if (z === void 0) {
                let {
                    schemaId: U
                } = this.opts, V = new xN.SchemaEnv({
                    schema: {},
                    schemaId: U
                });
                if (z = xN.resolveSchema.call(this, V, v), !z) return;
                this.refs[v] = z
            }
            return z.validate || this._compileSchemaEnv(z)
        }
        removeSchema(v) {
            if (v instanceof RegExp) return this._removeAllSchemas(this.schemas, v), this._removeAllSchemas(this.refs, v), this;
            switch (typeof v) {
                case "undefined":
                    return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
                case "string": {
                    let z = fm.call(this, v);
                    if (typeof z == "object") this._cache.delete(z.schema);
                    return delete this.schemas[v], delete this.refs[v], this
                }
                case "object": {
                    let z = v;
                    this._cache.delete(z);
                    let U = v[this.opts.schemaId];
                    if (U) U = (0, jN.normalizeId)(U), delete this.schemas[U], delete this.refs[U];
                    return this
                }
                default:
                    throw Error("ajv.removeSchema: invalid parameter")
            }
        }
        addVocabulary(v) {
            for (let z of v) this.addKeyword(z);
            return this
        }
        addKeyword(v, z) {
            let U;
            if (typeof v == "string") {
                if (U = v, typeof z == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), z.keyword = U
            } else if (typeof v == "object" && z === void 0) {
                if (z = v, U = z.keyword, Array.isArray(U) && !U.length) throw Error("addKeywords: keyword must be string or non-empty array")
            } else throw Error("invalid addKeywords parameters");
            if (AJ6.call(this, U, z), !z) return (0, LL.eachItem)(U, (N) => ZL.call(this, N)), this;
            wJ6.call(this, z);
            let V = {
                ...z,
                type: (0, tO.getJSONTypes)(z.type),
                schemaType: (0, tO.getJSONTypes)(z.schemaType)
            };
            return (0, LL.eachItem)(U, V.type.length === 0 ? (N) => ZL.call(this, N, V) : (N) => V.type.forEach((K) => ZL.call(this, N, V, K))), this
        }
        getKeyword(v) {
            let z = this.RULES.all[v];
            return typeof z == "object" ? z.definition : !!z
        }
        removeKeyword(v) {
            let {
                RULES: z
            } = this;
            delete z.keywords[v], delete z.all[v];
            for (let U of z.rules) {
                let V = U.rules.findIndex((N) => N.keyword === v);
                if (V >= 0) U.rules.splice(V, 1)
            }
            return this
        }
        addFormat(v, z) {
            if (typeof z == "string") z = new RegExp(z);
            return this.formats[v] = z, this
        }
        errorsText(v = this.errors, {
            separator: z = ", ",
            dataVar: U = "data"
        } = {}) {
            if (!v || v.length === 0) return "No errors";
            return v.map((V) => `${U}${V.instancePath} ${V.message}`).reduce((V, N) => V + z + N)
        }
        $dataMetaSchema(v, z) {
            let U = this.RULES.all;
            v = JSON.parse(JSON.stringify(v));
            for (let V of z) {
                let N = V.split("/").slice(1),
                    K = v;
                for (let x of N) K = K[x];
                for (let x in U) {
                    let j = U[x];
                    if (typeof j != "object") continue;
                    let {
                        $data: B
                    } = j.definition, O = K[x];
                    if (B && O) K[x] = um(O)
                }
            }
            return v
        }
        _removeAllSchemas(v, z) {
            for (let U in v) {
                let V = v[U];
                if (!z || z.test(U)) {
                    if (typeof V == "string") delete v[U];
                    else if (V && !V.meta) this._cache.delete(V.schema), delete v[U]
                }
            }
        }
        _addSchema(v, z, U, V = this.opts.validateSchema, N = this.opts.addUsedSchema) {
            let K, {
                schemaId: x
            } = this.opts;
            if (typeof v == "object") K = v[x];
            else if (this.opts.jtd) throw Error("schema must be object");
            else if (typeof v != "boolean") throw Error("schema must be object or boolean");
            let j = this._cache.get(v);
            if (j !== void 0) return j;
            U = (0, jN.normalizeId)(K || U);
            let B = jN.getSchemaRefs.call(this, v, U);
            if (j = new xN.SchemaEnv({
                    schema: v,
                    schemaId: x,
                    meta: z,
                    baseId: U,
                    localRefs: B
                }), this._cache.set(j.schema, j), N && !U.startsWith("#")) {
                if (U) this._checkUnique(U);
                this.refs[U] = j
            }
            if (V) this.validateSchema(v, !0);
            return j
        }
        _checkUnique(v) {
            if (this.schemas[v] || this.refs[v]) throw Error(`schema with key or id "${v}" already exists`)
        }
        _compileSchemaEnv(v) {
            if (v.meta) this._compileMetaSchema(v);
            else xN.compileSchema.call(this, v);
            if (!v.validate) throw Error("ajv implementation error");
            return v.validate
        }
        _compileMetaSchema(v) {
            let z = this.opts;
            this.opts = this._metaOpts;
            try {
                xN.compileSchema.call(this, v)
            } finally {
                this.opts = z
            }
        }
    }
    sO.ValidationError = sO6.default;
    sO.MissingRefError = Tm.default;
    y4.default = sO;

    function Cm(v, z, U, V = "error") {
        for (let N in v) {
            let K = N;
            if (K in z) this.logger[V](`${U}: option ${N}. ${v[K]}`)
        }
    }

    function fm(v) {
        return v = (0, jN.normalizeId)(v), this.schemas[v] || this.refs[v]
    }

    function jJ6() {
        let v = this.opts.schemas;
        if (!v) return;
        if (Array.isArray(v)) this.addSchema(v);
        else
            for (let z in v) this.addSchema(v[z], z)
    }

    function BJ6() {
        for (let v in this.opts.formats) {
            let z = this.opts.formats[v];
            if (z) this.addFormat(v, z)
        }
    }

    function OJ6(v) {
        if (Array.isArray(v)) {
            this.addVocabulary(v);
            return
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (let z in v) {
            let U = v[z];
            if (!U.keyword) U.keyword = z;
            this.addKeyword(U)
        }
    }

    function JJ6() {
        let v = {
            ...this.opts
        };
        for (let z of UJ6) delete v[z];
        return v
    }
    var qJ6 = {
        log() {},
        warn() {},
        error() {}
    };

    function HJ6(v) {
        if (v === !1) return qJ6;
        if (v === void 0) return console;
        if (v.log && v.warn && v.error) return v;
        throw Error("logger must implement log, warn and error methods")
    }
    var DJ6 = /^[a-z_$][a-z0-9_$:-]*$/i;

    function AJ6(v, z) {
        let {
            RULES: U
        } = this;
        if ((0, LL.eachItem)(v, (V) => {
                if (U.keywords[V]) throw Error(`Keyword ${V} is already defined`);
                if (!DJ6.test(V)) throw Error(`Keyword ${V} has invalid name`)
            }), !z) return;
        if (z.$data && !(("code" in z) || ("validate" in z))) throw Error('$data keyword must have "code" or "validate" function')
    }

    function ZL(v, z, U) {
        var V;
        let N = z === null || z === void 0 ? void 0 : z.post;
        if (U && N) throw Error('keyword with "post" flag cannot have "type"');
        let {
            RULES: K
        } = this, x = N ? K.post : K.rules.find(({
            type: B
        }) => B === U);
        if (!x) x = {
            type: U,
            rules: []
        }, K.rules.push(x);
        if (K.keywords[v] = !0, !z) return;
        let j = {
            keyword: v,
            definition: {
                ...z,
                type: (0, tO.getJSONTypes)(z.type),
                schemaType: (0, tO.getJSONTypes)(z.schemaType)
            }
        };
        if (z.before) $J6.call(this, x, j, z.before);
        else x.rules.push(j);
        K.all[v] = j, (V = z.implements) === null || V === void 0 || V.forEach((B) => this.addKeyword(B))
    }

    function $J6(v, z, U) {
        let V = v.rules.findIndex((N) => N.keyword === U);
        if (V >= 0) v.rules.splice(V, 0, z);
        else v.rules.push(z), this.logger.warn(`rule ${U} is not defined`)
    }

    function wJ6(v) {
        let {
            metaSchema: z
        } = v;
        if (z === void 0) return;
        if (v.$data && this.opts.$data) z = um(z);
        v.validateSchema = this.compile(z, !0)
    }
    var ZJ6 = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };

    function um(v) {
        return {
            anyOf: [v, ZJ6]
        }
    }
});
var km = _((FL) => {
    Object.defineProperty(FL, "__esModule", {
        value: !0
    });
    var LJ6 = {
        keyword: "id",
        code() {
            throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID')
        }
    };
    FL.default = LJ6
});
var cm = _((S7) => {
    Object.defineProperty(S7, "__esModule", {
        value: !0
    });
    S7.callRef = S7.getValidate = void 0;
    var FJ6 = VN(),
        mm = d3(),
        R3 = e6(),
        u1 = f9(),
        Xm = dO(),
        eO = w0(),
        GJ6 = {
            keyword: "$ref",
            schemaType: "string",
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    it: V
                } = v, {
                    baseId: N,
                    schemaEnv: K,
                    validateName: x,
                    opts: j,
                    self: B
                } = V, {
                    root: O
                } = K;
                if ((U === "#" || U === "#/") && N === O.baseId) return q();
                let J = Xm.resolveRef.call(B, O, N, U);
                if (J === void 0) throw new FJ6.default(V.opts.uriResolver, N, U);
                if (J instanceof Xm.SchemaEnv) return H(J);
                return D(J);

                function q() {
                    if (K === O) return vJ(v, x, K, K.$async);
                    let A = z.scopeValue("root", {
                        ref: O
                    });
                    return vJ(v, R3._`${A}.validate`, O, O.$async)
                }

                function H(A) {
                    let w = gm(v, A);
                    vJ(v, w, A, A.$async)
                }

                function D(A) {
                    let w = z.scopeValue("schema", j.code.source === !0 ? {
                            ref: A,
                            code: (0, R3.stringify)(A)
                        } : {
                            ref: A
                        }),
                        Z = z.name("valid"),
                        $ = v.subschema({
                            schema: A,
                            dataTypes: [],
                            schemaPath: R3.nil,
                            topSchemaRef: w,
                            errSchemaPath: U
                        }, Z);
                    v.mergeEvaluated($), v.ok(Z)
                }
            }
        };

    function gm(v, z) {
        let {
            gen: U
        } = v;
        return z.validate ? U.scopeValue("validate", {
            ref: z.validate
        }) : R3._`${U.scopeValue("wrapper",{ref:z})}.validate`
    }
    S7.getValidate = gm;

    function vJ(v, z, U, V) {
        let {
            gen: N,
            it: K
        } = v, {
            allErrors: x,
            schemaEnv: j,
            opts: B
        } = K, O = B.passContext ? u1.default.this : R3.nil;
        if (V) J();
        else q();

        function J() {
            if (!j.$async) throw Error("async schema referenced by sync schema");
            let A = N.let("valid");
            N.try(() => {
                if (N.code(R3._`await ${(0,mm.callValidateCode)(v,z,O)}`), D(z), !x) N.assign(A, !0)
            }, (w) => {
                if (N.if(R3._`!(${w} instanceof ${K.ValidationError})`, () => N.throw(w)), H(w), !x) N.assign(A, !1)
            }), v.ok(A)
        }

        function q() {
            v.result((0, mm.callValidateCode)(v, z, O), () => D(z), () => H(z))
        }

        function H(A) {
            let w = R3._`${A}.errors`;
            N.assign(u1.default.vErrors, R3._`${u1.default.vErrors} === null ? ${w} : ${u1.default.vErrors}.concat(${w})`), N.assign(u1.default.errors, R3._`${u1.default.vErrors}.length`)
        }

        function D(A) {
            var w;
            if (!K.opts.unevaluated) return;
            let Z = (w = U === null || U === void 0 ? void 0 : U.validate) === null || w === void 0 ? void 0 : w.evaluated;
            if (K.props !== !0)
                if (Z && !Z.dynamicProps) {
                    if (Z.props !== void 0) K.props = eO.mergeEvaluated.props(N, Z.props, K.props)
                } else {
                    let $ = N.var("props", R3._`${A}.evaluated.props`);
                    K.props = eO.mergeEvaluated.props(N, $, K.props, R3.Name)
                } if (K.items !== !0)
                if (Z && !Z.dynamicItems) {
                    if (Z.items !== void 0) K.items = eO.mergeEvaluated.items(N, Z.items, K.items)
                } else {
                    let $ = N.var("items", R3._`${A}.evaluated.items`);
                    K.items = eO.mergeEvaluated.items(N, $, K.items, R3.Name)
                }
        }
    }
    S7.callRef = vJ;
    S7.default = GJ6
});
var im = _((GL) => {
    Object.defineProperty(GL, "__esModule", {
        value: !0
    });
    var IJ6 = km(),
        MJ6 = cm(),
        bJ6 = ["$schema", "$id", "$defs", "$vocabulary", {
            keyword: "$comment"
        }, "definitions", IJ6.default, MJ6.default];
    GL.default = bJ6
});
var lm = _((IL) => {
    Object.defineProperty(IL, "__esModule", {
        value: !0
    });
    var zJ = e6(),
        _5 = zJ.operators,
        UJ = {
            maximum: {
                okStr: "<=",
                ok: _5.LTE,
                fail: _5.GT
            },
            minimum: {
                okStr: ">=",
                ok: _5.GTE,
                fail: _5.LT
            },
            exclusiveMaximum: {
                okStr: "<",
                ok: _5.LT,
                fail: _5.GTE
            },
            exclusiveMinimum: {
                okStr: ">",
                ok: _5.GT,
                fail: _5.LTE
            }
        },
        RJ6 = {
            message: ({
                keyword: v,
                schemaCode: z
            }) => zJ.str`must be ${UJ[v].okStr} ${z}`,
            params: ({
                keyword: v,
                schemaCode: z
            }) => zJ._`{comparison: ${UJ[v].okStr}, limit: ${z}}`
        },
        WJ6 = {
            keyword: Object.keys(UJ),
            type: "number",
            schemaType: "number",
            $data: !0,
            error: RJ6,
            code(v) {
                let {
                    keyword: z,
                    data: U,
                    schemaCode: V
                } = v;
                v.fail$data(zJ._`${U} ${UJ[z].fail} ${V} || isNaN(${U})`)
            }
        };
    IL.default = WJ6
});
var hm = _((ML) => {
    Object.defineProperty(ML, "__esModule", {
        value: !0
    });
    var BN = e6(),
        EJ6 = {
            message: ({
                schemaCode: v
            }) => BN.str`must be multiple of ${v}`,
            params: ({
                schemaCode: v
            }) => BN._`{multipleOf: ${v}}`
        },
        SJ6 = {
            keyword: "multipleOf",
            type: "number",
            schemaType: "number",
            $data: !0,
            error: EJ6,
            code(v) {
                let {
                    gen: z,
                    data: U,
                    schemaCode: V,
                    it: N
                } = v, K = N.opts.multipleOfPrecision, x = z.let("res"), j = K ? BN._`Math.abs(Math.round(${x}) - ${x}) > 1e-${K}` : BN._`${x} !== parseInt(${x})`;
                v.fail$data(BN._`(${V} === 0 || (${x} = ${U}/${V}, ${j}))`)
            }
        };
    ML.default = SJ6
});
var nm = _((bL) => {
    Object.defineProperty(bL, "__esModule", {
        value: !0
    });

    function pm(v) {
        let z = v.length,
            U = 0,
            V = 0,
            N;
        while (V < z)
            if (U++, N = v.charCodeAt(V++), N >= 55296 && N <= 56319 && V < z) {
                if (N = v.charCodeAt(V), (N & 64512) === 56320) V++
            } return U
    }
    bL.default = pm;
    pm.code = 'require("ajv/dist/runtime/ucs2length").default'
});
var Qm = _((RL) => {
    Object.defineProperty(RL, "__esModule", {
        value: !0
    });
    var P7 = e6(),
        PJ6 = w0(),
        _J6 = nm(),
        CJ6 = {
            message({
                keyword: v,
                schemaCode: z
            }) {
                let U = v === "maxLength" ? "more" : "fewer";
                return P7.str`must NOT have ${U} than ${z} characters`
            },
            params: ({
                schemaCode: v
            }) => P7._`{limit: ${v}}`
        },
        fJ6 = {
            keyword: ["maxLength", "minLength"],
            type: "string",
            schemaType: "number",
            $data: !0,
            error: CJ6,
            code(v) {
                let {
                    keyword: z,
                    data: U,
                    schemaCode: V,
                    it: N
                } = v, K = z === "maxLength" ? P7.operators.GT : P7.operators.LT, x = N.opts.unicode === !1 ? P7._`${U}.length` : P7._`${(0,PJ6.useFunc)(v.gen,_J6.default)}(${U})`;
                v.fail$data(P7._`${x} ${K} ${V}`)
            }
        };
    RL.default = fJ6
});
var dm = _((WL) => {
    Object.defineProperty(WL, "__esModule", {
        value: !0
    });
    var TJ6 = d3(),
        VJ = e6(),
        YJ6 = {
            message: ({
                schemaCode: v
            }) => VJ.str`must match pattern "${v}"`,
            params: ({
                schemaCode: v
            }) => VJ._`{pattern: ${v}}`
        },
        uJ6 = {
            keyword: "pattern",
            type: "string",
            schemaType: "string",
            $data: !0,
            error: YJ6,
            code(v) {
                let {
                    data: z,
                    $data: U,
                    schema: V,
                    schemaCode: N,
                    it: K
                } = v, x = K.opts.unicodeRegExp ? "u" : "", j = U ? VJ._`(new RegExp(${N}, ${x}))` : (0, TJ6.usePattern)(v, V);
                v.fail$data(VJ._`!${j}.test(${z})`)
            }
        };
    WL.default = uJ6
});
var om = _((EL) => {
    Object.defineProperty(EL, "__esModule", {
        value: !0
    });
    var ON = e6(),
        yJ6 = {
            message({
                keyword: v,
                schemaCode: z
            }) {
                let U = v === "maxProperties" ? "more" : "fewer";
                return ON.str`must NOT have ${U} than ${z} properties`
            },
            params: ({
                schemaCode: v
            }) => ON._`{limit: ${v}}`
        },
        kJ6 = {
            keyword: ["maxProperties", "minProperties"],
            type: "object",
            schemaType: "number",
            $data: !0,
            error: yJ6,
            code(v) {
                let {
                    keyword: z,
                    data: U,
                    schemaCode: V
                } = v, N = z === "maxProperties" ? ON.operators.GT : ON.operators.LT;
                v.fail$data(ON._`Object.keys(${U}).length ${N} ${V}`)
            }
        };
    EL.default = kJ6
});
var rm = _((SL) => {
    Object.defineProperty(SL, "__esModule", {
        value: !0
    });
    var JN = d3(),
        qN = e6(),
        mJ6 = w0(),
        XJ6 = {
            message: ({
                params: {
                    missingProperty: v
                }
            }) => qN.str`must have required property '${v}'`,
            params: ({
                params: {
                    missingProperty: v
                }
            }) => qN._`{missingProperty: ${v}}`
        },
        gJ6 = {
            keyword: "required",
            type: "object",
            schemaType: "array",
            $data: !0,
            error: XJ6,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    schemaCode: V,
                    data: N,
                    $data: K,
                    it: x
                } = v, {
                    opts: j
                } = x;
                if (!K && U.length === 0) return;
                let B = U.length >= j.loopRequired;
                if (x.allErrors) O();
                else J();
                if (j.strictRequired) {
                    let D = v.parentSchema.properties,
                        {
                            definedProperties: A
                        } = v.it;
                    for (let w of U)
                        if ((D === null || D === void 0 ? void 0 : D[w]) === void 0 && !A.has(w)) {
                            let Z = x.schemaEnv.baseId + x.errSchemaPath,
                                $ = `required property "${w}" is not defined at "${Z}" (strictRequired)`;
                            (0, mJ6.checkStrictMode)(x, $, x.opts.strictRequired)
                        }
                }

                function O() {
                    if (B || K) v.block$data(qN.nil, q);
                    else
                        for (let D of U)(0, JN.checkReportMissingProp)(v, D)
                }

                function J() {
                    let D = z.let("missing");
                    if (B || K) {
                        let A = z.let("valid", !0);
                        v.block$data(A, () => H(D, A)), v.ok(A)
                    } else z.if((0, JN.checkMissingProp)(v, U, D)), (0, JN.reportMissingProp)(v, D), z.else()
                }

                function q() {
                    z.forOf("prop", V, (D) => {
                        v.setParams({
                            missingProperty: D
                        }), z.if((0, JN.noPropertyInData)(z, N, D, j.ownProperties), () => v.error())
                    })
                }

                function H(D, A) {
                    v.setParams({
                        missingProperty: D
                    }), z.forOf(D, V, () => {
                        z.assign(A, (0, JN.propertyInData)(z, N, D, j.ownProperties)), z.if((0, qN.not)(A), () => {
                            v.error(), z.break()
                        })
                    }, qN.nil)
                }
            }
        };
    SL.default = gJ6
});
var am = _((PL) => {
    Object.defineProperty(PL, "__esModule", {
        value: !0
    });
    var HN = e6(),
        cJ6 = {
            message({
                keyword: v,
                schemaCode: z
            }) {
                let U = v === "maxItems" ? "more" : "fewer";
                return HN.str`must NOT have ${U} than ${z} items`
            },
            params: ({
                schemaCode: v
            }) => HN._`{limit: ${v}}`
        },
        iJ6 = {
            keyword: ["maxItems", "minItems"],
            type: "array",
            schemaType: "number",
            $data: !0,
            error: cJ6,
            code(v) {
                let {
                    keyword: z,
                    data: U,
                    schemaCode: V
                } = v, N = z === "maxItems" ? HN.operators.GT : HN.operators.LT;
                v.fail$data(HN._`${U}.length ${N} ${V}`)
            }
        };
    PL.default = iJ6
});
var NJ = _((_L) => {
    Object.defineProperty(_L, "__esModule", {
        value: !0
    });
    var tm = zL();
    tm.code = 'require("ajv/dist/runtime/equal").default';
    _L.default = tm
});
var sm = _((fL) => {
    Object.defineProperty(fL, "__esModule", {
        value: !0
    });
    var CL = sV(),
        k4 = e6(),
        lJ6 = w0(),
        hJ6 = NJ(),
        pJ6 = {
            message: ({
                params: {
                    i: v,
                    j: z
                }
            }) => k4.str`must NOT have duplicate items (items ## ${z} and ${v} are identical)`,
            params: ({
                params: {
                    i: v,
                    j: z
                }
            }) => k4._`{i: ${v}, j: ${z}}`
        },
        nJ6 = {
            keyword: "uniqueItems",
            type: "array",
            schemaType: "boolean",
            $data: !0,
            error: pJ6,
            code(v) {
                let {
                    gen: z,
                    data: U,
                    $data: V,
                    schema: N,
                    parentSchema: K,
                    schemaCode: x,
                    it: j
                } = v;
                if (!V && !N) return;
                let B = z.let("valid"),
                    O = K.items ? (0, CL.getSchemaTypes)(K.items) : [];
                v.block$data(B, J, k4._`${x} === false`), v.ok(B);

                function J() {
                    let A = z.let("i", k4._`${U}.length`),
                        w = z.let("j");
                    v.setParams({
                        i: A,
                        j: w
                    }), z.assign(B, !0), z.if(k4._`${A} > 1`, () => (q() ? H : D)(A, w))
                }

                function q() {
                    return O.length > 0 && !O.some((A) => A === "object" || A === "array")
                }

                function H(A, w) {
                    let Z = z.name("item"),
                        $ = (0, CL.checkDataTypes)(O, Z, j.opts.strictNumbers, CL.DataType.Wrong),
                        F = z.const("indices", k4._`{}`);
                    z.for(k4._`;${A}--;`, () => {
                        if (z.let(Z, k4._`${U}[${A}]`), z.if($, k4._`continue`), O.length > 1) z.if(k4._`typeof ${Z} == "string"`, k4._`${Z} += "_"`);
                        z.if(k4._`typeof ${F}[${Z}] == "number"`, () => {
                            z.assign(w, k4._`${F}[${Z}]`), v.error(), z.assign(B, !1).break()
                        }).code(k4._`${F}[${Z}] = ${A}`)
                    })
                }

                function D(A, w) {
                    let Z = (0, lJ6.useFunc)(z, hJ6.default),
                        $ = z.name("outer");
                    z.label($).for(k4._`;${A}--;`, () => z.for(k4._`${w} = ${A}; ${w}--;`, () => z.if(k4._`${Z}(${U}[${A}], ${U}[${w}])`, () => {
                        v.error(), z.assign(B, !1).break($)
                    })))
                }
            }
        };
    fL.default = nJ6
});
var em = _((YL) => {
    Object.defineProperty(YL, "__esModule", {
        value: !0
    });
    var TL = e6(),
        QJ6 = w0(),
        dJ6 = NJ(),
        oJ6 = {
            message: "must be equal to constant",
            params: ({
                schemaCode: v
            }) => TL._`{allowedValue: ${v}}`
        },
        rJ6 = {
            keyword: "const",
            $data: !0,
            error: oJ6,
            code(v) {
                let {
                    gen: z,
                    data: U,
                    $data: V,
                    schemaCode: N,
                    schema: K
                } = v;
                if (V || K && typeof K == "object") v.fail$data(TL._`!${(0,QJ6.useFunc)(z,dJ6.default)}(${U}, ${N})`);
                else v.fail(TL._`${K} !== ${U}`)
            }
        };
    YL.default = rJ6
});
var vX = _((uL) => {
    Object.defineProperty(uL, "__esModule", {
        value: !0
    });
    var DN = e6(),
        aJ6 = w0(),
        tJ6 = NJ(),
        sJ6 = {
            message: "must be equal to one of the allowed values",
            params: ({
                schemaCode: v
            }) => DN._`{allowedValues: ${v}}`
        },
        eJ6 = {
            keyword: "enum",
            schemaType: "array",
            $data: !0,
            error: sJ6,
            code(v) {
                let {
                    gen: z,
                    data: U,
                    $data: V,
                    schema: N,
                    schemaCode: K,
                    it: x
                } = v;
                if (!V && N.length === 0) throw Error("enum must have non-empty array");
                let j = N.length >= x.opts.loopEnum,
                    B, O = () => B !== null && B !== void 0 ? B : B = (0, aJ6.useFunc)(z, tJ6.default),
                    J;
                if (j || V) J = z.let("valid"), v.block$data(J, q);
                else {
                    if (!Array.isArray(N)) throw Error("ajv implementation error");
                    let D = z.const("vSchema", K);
                    J = (0, DN.or)(...N.map((A, w) => H(D, w)))
                }
                v.pass(J);

                function q() {
                    z.assign(J, !1), z.forOf("v", K, (D) => z.if(DN._`${O()}(${U}, ${D})`, () => z.assign(J, !0).break()))
                }

                function H(D, A) {
                    let w = N[A];
                    return typeof w === "object" && w !== null ? DN._`${O()}(${U}, ${D}[${A}])` : DN._`${U} === ${w}`
                }
            }
        };
    uL.default = eJ6
});
var zX = _((yL) => {
    Object.defineProperty(yL, "__esModule", {
        value: !0
    });
    var vq6 = lm(),
        zq6 = hm(),
        Uq6 = Qm(),
        Vq6 = dm(),
        Nq6 = om(),
        Kq6 = rm(),
        xq6 = am(),
        jq6 = sm(),
        Bq6 = em(),
        Oq6 = vX(),
        Jq6 = [vq6.default, zq6.default, Uq6.default, Vq6.default, Nq6.default, Kq6.default, xq6.default, jq6.default, {
            keyword: "type",
            schemaType: ["string", "array"]
        }, {
            keyword: "nullable",
            schemaType: "boolean"
        }, Bq6.default, Oq6.default];
    yL.default = Jq6
});
var mL = _((AN) => {
    Object.defineProperty(AN, "__esModule", {
        value: !0
    });
    AN.validateAdditionalItems = void 0;
    var _7 = e6(),
        kL = w0(),
        qq6 = {
            message: ({
                params: {
                    len: v
                }
            }) => _7.str`must NOT have more than ${v} items`,
            params: ({
                params: {
                    len: v
                }
            }) => _7._`{limit: ${v}}`
        },
        Hq6 = {
            keyword: "additionalItems",
            type: "array",
            schemaType: ["boolean", "object"],
            before: "uniqueItems",
            error: qq6,
            code(v) {
                let {
                    parentSchema: z,
                    it: U
                } = v, {
                    items: V
                } = z;
                if (!Array.isArray(V)) {
                    (0, kL.checkStrictMode)(U, '"additionalItems" is ignored when "items" is not an array of schemas');
                    return
                }
                UX(v, V)
            }
        };

    function UX(v, z) {
        let {
            gen: U,
            schema: V,
            data: N,
            keyword: K,
            it: x
        } = v;
        x.items = !0;
        let j = U.const("len", _7._`${N}.length`);
        if (V === !1) v.setParams({
            len: z.length
        }), v.pass(_7._`${j} <= ${z.length}`);
        else if (typeof V == "object" && !(0, kL.alwaysValidSchema)(x, V)) {
            let O = U.var("valid", _7._`${j} <= ${z.length}`);
            U.if((0, _7.not)(O), () => B(O)), v.ok(O)
        }

        function B(O) {
            U.forRange("i", z.length, j, (J) => {
                if (v.subschema({
                        keyword: K,
                        dataProp: J,
                        dataPropType: kL.Type.Num
                    }, O), !x.allErrors) U.if((0, _7.not)(O), () => U.break())
            })
        }
    }
    AN.validateAdditionalItems = UX;
    AN.default = Hq6
});
var XL = _(($N) => {
    Object.defineProperty($N, "__esModule", {
        value: !0
    });
    $N.validateTuple = void 0;
    var VX = e6(),
        KJ = w0(),
        Dq6 = d3(),
        Aq6 = {
            keyword: "items",
            type: "array",
            schemaType: ["object", "array", "boolean"],
            before: "uniqueItems",
            code(v) {
                let {
                    schema: z,
                    it: U
                } = v;
                if (Array.isArray(z)) return NX(v, "additionalItems", z);
                if (U.items = !0, (0, KJ.alwaysValidSchema)(U, z)) return;
                v.ok((0, Dq6.validateArray)(v))
            }
        };

    function NX(v, z, U = v.schema) {
        let {
            gen: V,
            parentSchema: N,
            data: K,
            keyword: x,
            it: j
        } = v;
        if (J(N), j.opts.unevaluated && U.length && j.items !== !0) j.items = KJ.mergeEvaluated.items(V, U.length, j.items);
        let B = V.name("valid"),
            O = V.const("len", VX._`${K}.length`);
        U.forEach((q, H) => {
            if ((0, KJ.alwaysValidSchema)(j, q)) return;
            V.if(VX._`${O} > ${H}`, () => v.subschema({
                keyword: x,
                schemaProp: H,
                dataProp: H
            }, B)), v.ok(B)
        });

        function J(q) {
            let {
                opts: H,
                errSchemaPath: D
            } = j, A = U.length, w = A === q.minItems && (A === q.maxItems || q[z] === !1);
            if (H.strictTuples && !w) {
                let Z = `"${x}" is ${A}-tuple, but minItems or maxItems/${z} are not specified or different at path "${D}"`;
                (0, KJ.checkStrictMode)(j, Z, H.strictTuples)
            }
        }
    }
    $N.validateTuple = NX;
    $N.default = Aq6
});
var KX = _((gL) => {
    Object.defineProperty(gL, "__esModule", {
        value: !0
    });
    var $q6 = XL(),
        wq6 = {
            keyword: "prefixItems",
            type: "array",
            schemaType: ["array"],
            before: "uniqueItems",
            code: (v) => (0, $q6.validateTuple)(v, "items")
        };
    gL.default = wq6
});
var jX = _((cL) => {
    Object.defineProperty(cL, "__esModule", {
        value: !0
    });
    var xX = e6(),
        Zq6 = w0(),
        Lq6 = d3(),
        Fq6 = mL(),
        Gq6 = {
            message: ({
                params: {
                    len: v
                }
            }) => xX.str`must NOT have more than ${v} items`,
            params: ({
                params: {
                    len: v
                }
            }) => xX._`{limit: ${v}}`
        },
        Iq6 = {
            keyword: "items",
            type: "array",
            schemaType: ["object", "boolean"],
            before: "uniqueItems",
            error: Gq6,
            code(v) {
                let {
                    schema: z,
                    parentSchema: U,
                    it: V
                } = v, {
                    prefixItems: N
                } = U;
                if (V.items = !0, (0, Zq6.alwaysValidSchema)(V, z)) return;
                if (N)(0, Fq6.validateAdditionalItems)(v, N);
                else v.ok((0, Lq6.validateArray)(v))
            }
        };
    cL.default = Iq6
});
var BX = _((iL) => {
    Object.defineProperty(iL, "__esModule", {
        value: !0
    });
    var r3 = e6(),
        xJ = w0(),
        Mq6 = {
            message: ({
                params: {
                    min: v,
                    max: z
                }
            }) => z === void 0 ? r3.str`must contain at least ${v} valid item(s)` : r3.str`must contain at least ${v} and no more than ${z} valid item(s)`,
            params: ({
                params: {
                    min: v,
                    max: z
                }
            }) => z === void 0 ? r3._`{minContains: ${v}}` : r3._`{minContains: ${v}, maxContains: ${z}}`
        },
        bq6 = {
            keyword: "contains",
            type: "array",
            schemaType: ["object", "boolean"],
            before: "uniqueItems",
            trackErrors: !0,
            error: Mq6,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    parentSchema: V,
                    data: N,
                    it: K
                } = v, x, j, {
                    minContains: B,
                    maxContains: O
                } = V;
                if (K.opts.next) x = B === void 0 ? 1 : B, j = O;
                else x = 1;
                let J = z.const("len", r3._`${N}.length`);
                if (v.setParams({
                        min: x,
                        max: j
                    }), j === void 0 && x === 0) {
                    (0, xJ.checkStrictMode)(K, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                    return
                }
                if (j !== void 0 && x > j) {
                    (0, xJ.checkStrictMode)(K, '"minContains" > "maxContains" is always invalid'), v.fail();
                    return
                }
                if ((0, xJ.alwaysValidSchema)(K, U)) {
                    let w = r3._`${J} >= ${x}`;
                    if (j !== void 0) w = r3._`${w} && ${J} <= ${j}`;
                    v.pass(w);
                    return
                }
                K.items = !0;
                let q = z.name("valid");
                if (j === void 0 && x === 1) D(q, () => z.if(q, () => z.break()));
                else if (x === 0) {
                    if (z.let(q, !0), j !== void 0) z.if(r3._`${N}.length > 0`, H)
                } else z.let(q, !1), H();
                v.result(q, () => v.reset());

                function H() {
                    let w = z.name("_valid"),
                        Z = z.let("count", 0);
                    D(w, () => z.if(w, () => A(Z)))
                }

                function D(w, Z) {
                    z.forRange("i", 0, J, ($) => {
                        v.subschema({
                            keyword: "contains",
                            dataProp: $,
                            dataPropType: xJ.Type.Num,
                            compositeRule: !0
                        }, w), Z()
                    })
                }

                function A(w) {
                    if (z.code(r3._`${w}++`), j === void 0) z.if(r3._`${w} >= ${x}`, () => z.assign(q, !0).break());
                    else if (z.if(r3._`${w} > ${j}`, () => z.assign(q, !1).break()), x === 1) z.assign(q, !0);
                    else z.if(r3._`${w} >= ${x}`, () => z.assign(q, !0))
                }
            }
        };
    iL.default = bq6
});
var qX = _((o8) => {
    Object.defineProperty(o8, "__esModule", {
        value: !0
    });
    o8.validateSchemaDeps = o8.validatePropertyDeps = o8.error = void 0;
    var lL = e6(),
        Rq6 = w0(),
        wN = d3();
    o8.error = {
        message: ({
            params: {
                property: v,
                depsCount: z,
                deps: U
            }
        }) => {
            let V = z === 1 ? "property" : "properties";
            return lL.str`must have ${V} ${U} when property ${v} is present`
        },
        params: ({
            params: {
                property: v,
                depsCount: z,
                deps: U,
                missingProperty: V
            }
        }) => lL._`{property: ${v},
    missingProperty: ${V},
    depsCount: ${z},
    deps: ${U}}`
    };
    var Wq6 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: o8.error,
        code(v) {
            let [z, U] = Eq6(v);
            OX(v, z), JX(v, U)
        }
    };

    function Eq6({
        schema: v
    }) {
        let z = {},
            U = {};
        for (let V in v) {
            if (V === "__proto__") continue;
            let N = Array.isArray(v[V]) ? z : U;
            N[V] = v[V]
        }
        return [z, U]
    }

    function OX(v, z = v.schema) {
        let {
            gen: U,
            data: V,
            it: N
        } = v;
        if (Object.keys(z).length === 0) return;
        let K = U.let("missing");
        for (let x in z) {
            let j = z[x];
            if (j.length === 0) continue;
            let B = (0, wN.propertyInData)(U, V, x, N.opts.ownProperties);
            if (v.setParams({
                    property: x,
                    depsCount: j.length,
                    deps: j.join(", ")
                }), N.allErrors) U.if(B, () => {
                for (let O of j)(0, wN.checkReportMissingProp)(v, O)
            });
            else U.if(lL._`${B} && (${(0,wN.checkMissingProp)(v,j,K)})`), (0, wN.reportMissingProp)(v, K), U.else()
        }
    }
    o8.validatePropertyDeps = OX;

    function JX(v, z = v.schema) {
        let {
            gen: U,
            data: V,
            keyword: N,
            it: K
        } = v, x = U.name("valid");
        for (let j in z) {
            if ((0, Rq6.alwaysValidSchema)(K, z[j])) continue;
            U.if((0, wN.propertyInData)(U, V, j, K.opts.ownProperties), () => {
                let B = v.subschema({
                    keyword: N,
                    schemaProp: j
                }, x);
                v.mergeValidEvaluated(B, x)
            }, () => U.var(x, !0)), v.ok(x)
        }
    }
    o8.validateSchemaDeps = JX;
    o8.default = Wq6
});
var DX = _((hL) => {
    Object.defineProperty(hL, "__esModule", {
        value: !0
    });
    var HX = e6(),
        Sq6 = w0(),
        Pq6 = {
            message: "property name must be valid",
            params: ({
                params: v
            }) => HX._`{propertyName: ${v.propertyName}}`
        },
        _q6 = {
            keyword: "propertyNames",
            type: "object",
            schemaType: ["object", "boolean"],
            error: Pq6,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    data: V,
                    it: N
                } = v;
                if ((0, Sq6.alwaysValidSchema)(N, U)) return;
                let K = z.name("valid");
                z.forIn("key", V, (x) => {
                    v.setParams({
                        propertyName: x
                    }), v.subschema({
                        keyword: "propertyNames",
                        data: x,
                        dataTypes: ["string"],
                        propertyName: x,
                        compositeRule: !0
                    }, K), z.if((0, HX.not)(K), () => {
                        if (v.error(!0), !N.allErrors) z.break()
                    })
                }), v.ok(K)
            }
        };
    hL.default = _q6
});
var nL = _((pL) => {
    Object.defineProperty(pL, "__esModule", {
        value: !0
    });
    var jJ = d3(),
        b8 = e6(),
        Cq6 = f9(),
        BJ = w0(),
        fq6 = {
            message: "must NOT have additional properties",
            params: ({
                params: v
            }) => b8._`{additionalProperty: ${v.additionalProperty}}`
        },
        Tq6 = {
            keyword: "additionalProperties",
            type: ["object"],
            schemaType: ["boolean", "object"],
            allowUndefined: !0,
            trackErrors: !0,
            error: fq6,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    parentSchema: V,
                    data: N,
                    errsCount: K,
                    it: x
                } = v;
                if (!K) throw Error("ajv implementation error");
                let {
                    allErrors: j,
                    opts: B
                } = x;
                if (x.props = !0, B.removeAdditional !== "all" && (0, BJ.alwaysValidSchema)(x, U)) return;
                let O = (0, jJ.allSchemaProperties)(V.properties),
                    J = (0, jJ.allSchemaProperties)(V.patternProperties);
                q(), v.ok(b8._`${K} === ${Cq6.default.errors}`);

                function q() {
                    z.forIn("key", N, (Z) => {
                        if (!O.length && !J.length) A(Z);
                        else z.if(H(Z), () => A(Z))
                    })
                }

                function H(Z) {
                    let $;
                    if (O.length > 8) {
                        let F = (0, BJ.schemaRefOrVal)(x, V.properties, "properties");
                        $ = (0, jJ.isOwnProperty)(z, F, Z)
                    } else if (O.length) $ = (0, b8.or)(...O.map((F) => b8._`${Z} === ${F}`));
                    else $ = b8.nil;
                    if (J.length) $ = (0, b8.or)($, ...J.map((F) => b8._`${(0,jJ.usePattern)(v,F)}.test(${Z})`));
                    return (0, b8.not)($)
                }

                function D(Z) {
                    z.code(b8._`delete ${N}[${Z}]`)
                }

                function A(Z) {
                    if (B.removeAdditional === "all" || B.removeAdditional && U === !1) {
                        D(Z);
                        return
                    }
                    if (U === !1) {
                        if (v.setParams({
                                additionalProperty: Z
                            }), v.error(), !j) z.break();
                        return
                    }
                    if (typeof U == "object" && !(0, BJ.alwaysValidSchema)(x, U)) {
                        let $ = z.name("valid");
                        if (B.removeAdditional === "failing") w(Z, $, !1), z.if((0, b8.not)($), () => {
                            v.reset(), D(Z)
                        });
                        else if (w(Z, $), !j) z.if((0, b8.not)($), () => z.break())
                    }
                }

                function w(Z, $, F) {
                    let L = {
                        keyword: "additionalProperties",
                        dataProp: Z,
                        dataPropType: BJ.Type.Str
                    };
                    if (F === !1) Object.assign(L, {
                        compositeRule: !0,
                        createErrors: !1,
                        allErrors: !1
                    });
                    v.subschema(L, $)
                }
            }
        };
    pL.default = Tq6
});
var wX = _((dL) => {
    Object.defineProperty(dL, "__esModule", {
        value: !0
    });
    var Yq6 = UN(),
        AX = d3(),
        QL = w0(),
        $X = nL(),
        uq6 = {
            keyword: "properties",
            type: "object",
            schemaType: "object",
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    parentSchema: V,
                    data: N,
                    it: K
                } = v;
                if (K.opts.removeAdditional === "all" && V.additionalProperties === void 0) $X.default.code(new Yq6.KeywordCxt(K, $X.default, "additionalProperties"));
                let x = (0, AX.allSchemaProperties)(U);
                for (let q of x) K.definedProperties.add(q);
                if (K.opts.unevaluated && x.length && K.props !== !0) K.props = QL.mergeEvaluated.props(z, (0, QL.toHash)(x), K.props);
                let j = x.filter((q) => !(0, QL.alwaysValidSchema)(K, U[q]));
                if (j.length === 0) return;
                let B = z.name("valid");
                for (let q of j) {
                    if (O(q)) J(q);
                    else {
                        if (z.if((0, AX.propertyInData)(z, N, q, K.opts.ownProperties)), J(q), !K.allErrors) z.else().var(B, !0);
                        z.endIf()
                    }
                    v.it.definedProperties.add(q), v.ok(B)
                }

                function O(q) {
                    return K.opts.useDefaults && !K.compositeRule && U[q].default !== void 0
                }

                function J(q) {
                    v.subschema({
                        keyword: "properties",
                        schemaProp: q,
                        dataProp: q
                    }, B)
                }
            }
        };
    dL.default = uq6
});
var GX = _((oL) => {
    Object.defineProperty(oL, "__esModule", {
        value: !0
    });
    var ZX = d3(),
        OJ = e6(),
        LX = w0(),
        FX = w0(),
        yq6 = {
            keyword: "patternProperties",
            type: "object",
            schemaType: "object",
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    data: V,
                    parentSchema: N,
                    it: K
                } = v, {
                    opts: x
                } = K, j = (0, ZX.allSchemaProperties)(U), B = j.filter((w) => (0, LX.alwaysValidSchema)(K, U[w]));
                if (j.length === 0 || B.length === j.length && (!K.opts.unevaluated || K.props === !0)) return;
                let O = x.strictSchema && !x.allowMatchingProperties && N.properties,
                    J = z.name("valid");
                if (K.props !== !0 && !(K.props instanceof OJ.Name)) K.props = (0, FX.evaluatedPropsToName)(z, K.props);
                let {
                    props: q
                } = K;
                H();

                function H() {
                    for (let w of j) {
                        if (O) D(w);
                        if (K.allErrors) A(w);
                        else z.var(J, !0), A(w), z.if(J)
                    }
                }

                function D(w) {
                    for (let Z in O)
                        if (new RegExp(w).test(Z))(0, LX.checkStrictMode)(K, `property ${Z} matches pattern ${w} (use allowMatchingProperties)`)
                }

                function A(w) {
                    z.forIn("key", V, (Z) => {
                        z.if(OJ._`${(0,ZX.usePattern)(v,w)}.test(${Z})`, () => {
                            let $ = B.includes(w);
                            if (!$) v.subschema({
                                keyword: "patternProperties",
                                schemaProp: w,
                                dataProp: Z,
                                dataPropType: FX.Type.Str
                            }, J);
                            if (K.opts.unevaluated && q !== !0) z.assign(OJ._`${q}[${Z}]`, !0);
                            else if (!$ && !K.allErrors) z.if((0, OJ.not)(J), () => z.break())
                        })
                    })
                }
            }
        };
    oL.default = yq6
});
var IX = _((rL) => {
    Object.defineProperty(rL, "__esModule", {
        value: !0
    });
    var kq6 = w0(),
        mq6 = {
            keyword: "not",
            schemaType: ["object", "boolean"],
            trackErrors: !0,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    it: V
                } = v;
                if ((0, kq6.alwaysValidSchema)(V, U)) {
                    v.fail();
                    return
                }
                let N = z.name("valid");
                v.subschema({
                    keyword: "not",
                    compositeRule: !0,
                    createErrors: !1,
                    allErrors: !1
                }, N), v.failResult(N, () => v.reset(), () => v.error())
            },
            error: {
                message: "must NOT be valid"
            }
        };
    rL.default = mq6
});
var MX = _((aL) => {
    Object.defineProperty(aL, "__esModule", {
        value: !0
    });
    var Xq6 = d3(),
        gq6 = {
            keyword: "anyOf",
            schemaType: "array",
            trackErrors: !0,
            code: Xq6.validateUnion,
            error: {
                message: "must match a schema in anyOf"
            }
        };
    aL.default = gq6
});
var bX = _((tL) => {
    Object.defineProperty(tL, "__esModule", {
        value: !0
    });
    var JJ = e6(),
        cq6 = w0(),
        iq6 = {
            message: "must match exactly one schema in oneOf",
            params: ({
                params: v
            }) => JJ._`{passingSchemas: ${v.passing}}`
        },
        lq6 = {
            keyword: "oneOf",
            schemaType: "array",
            trackErrors: !0,
            error: iq6,
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    parentSchema: V,
                    it: N
                } = v;
                if (!Array.isArray(U)) throw Error("ajv implementation error");
                if (N.opts.discriminator && V.discriminator) return;
                let K = U,
                    x = z.let("valid", !1),
                    j = z.let("passing", null),
                    B = z.name("_valid");
                v.setParams({
                    passing: j
                }), z.block(O), v.result(x, () => v.reset(), () => v.error(!0));

                function O() {
                    K.forEach((J, q) => {
                        let H;
                        if ((0, cq6.alwaysValidSchema)(N, J)) z.var(B, !0);
                        else H = v.subschema({
                            keyword: "oneOf",
                            schemaProp: q,
                            compositeRule: !0
                        }, B);
                        if (q > 0) z.if(JJ._`${B} && ${x}`).assign(x, !1).assign(j, JJ._`[${j}, ${q}]`).else();
                        z.if(B, () => {
                            if (z.assign(x, !0), z.assign(j, q), H) v.mergeEvaluated(H, JJ.Name)
                        })
                    })
                }
            }
        };
    tL.default = lq6
});
var RX = _((sL) => {
    Object.defineProperty(sL, "__esModule", {
        value: !0
    });
    var hq6 = w0(),
        pq6 = {
            keyword: "allOf",
            schemaType: "array",
            code(v) {
                let {
                    gen: z,
                    schema: U,
                    it: V
                } = v;
                if (!Array.isArray(U)) throw Error("ajv implementation error");
                let N = z.name("valid");
                U.forEach((K, x) => {
                    if ((0, hq6.alwaysValidSchema)(V, K)) return;
                    let j = v.subschema({
                        keyword: "allOf",
                        schemaProp: x
                    }, N);
                    v.ok(N), v.mergeEvaluated(j)
                })
            }
        };
    sL.default = pq6
});
var SX = _((eL) => {
    Object.defineProperty(eL, "__esModule", {
        value: !0
    });
    var qJ = e6(),
        EX = w0(),
        nq6 = {
            message: ({
                params: v
            }) => qJ.str`must match "${v.ifClause}" schema`,
            params: ({
                params: v
            }) => qJ._`{failingKeyword: ${v.ifClause}}`
        },
        Qq6 = {
            keyword: "if",
            schemaType: ["object", "boolean"],
            trackErrors: !0,
            error: nq6,
            code(v) {
                let {
                    gen: z,
                    parentSchema: U,
                    it: V
                } = v;
                if (U.then === void 0 && U.else === void 0)(0, EX.checkStrictMode)(V, '"if" without "then" and "else" is ignored');
                let N = WX(V, "then"),
                    K = WX(V, "else");
                if (!N && !K) return;
                let x = z.let("valid", !0),
                    j = z.name("_valid");
                if (B(), v.reset(), N && K) {
                    let J = z.let("ifClause");
                    v.setParams({
                        ifClause: J
                    }), z.if(j, O("then", J), O("else", J))
                } else if (N) z.if(j, O("then"));
                else z.if((0, qJ.not)(j), O("else"));
                v.pass(x, () => v.error(!0));

                function B() {
                    let J = v.subschema({
                        keyword: "if",
                        compositeRule: !0,
                        createErrors: !1,
                        allErrors: !1
                    }, j);
                    v.mergeEvaluated(J)
                }

                function O(J, q) {
                    return () => {
                        let H = v.subschema({
                            keyword: J
                        }, j);
                        if (z.assign(x, j), v.mergeValidEvaluated(H, x), q) z.assign(q, qJ._`${J}`);
                        else v.setParams({
                            ifClause: J
                        })
                    }
                }
            }
        };

    function WX(v, z) {
        let U = v.schema[z];
        return U !== void 0 && !(0, EX.alwaysValidSchema)(v, U)
    }
    eL.default = Qq6
});
var PX = _((vF) => {
    Object.defineProperty(vF, "__esModule", {
        value: !0
    });
    var dq6 = w0(),
        oq6 = {
            keyword: ["then", "else"],
            schemaType: ["object", "boolean"],
            code({
                keyword: v,
                parentSchema: z,
                it: U
            }) {
                if (z.if === void 0)(0, dq6.checkStrictMode)(U, `"${v}" without "if" is ignored`)
            }
        };
    vF.default = oq6
});
var _X = _((zF) => {
    Object.defineProperty(zF, "__esModule", {
        value: !0
    });
    var rq6 = mL(),
        aq6 = KX(),
        tq6 = XL(),
        sq6 = jX(),
        eq6 = BX(),
        vH6 = qX(),
        zH6 = DX(),
        UH6 = nL(),
        VH6 = wX(),
        NH6 = GX(),
        KH6 = IX(),
        xH6 = MX(),
        jH6 = bX(),
        BH6 = RX(),
        OH6 = SX(),
        JH6 = PX();

    function qH6(v = !1) {
        let z = [KH6.default, xH6.default, jH6.default, BH6.default, OH6.default, JH6.default, zH6.default, UH6.default, vH6.default, VH6.default, NH6.default];
        if (v) z.push(aq6.default, sq6.default);
        else z.push(rq6.default, tq6.default);
        return z.push(eq6.default), z
    }
    zF.default = qH6
});
var CX = _((UF) => {
    Object.defineProperty(UF, "__esModule", {
        value: !0
    });
    var K4 = e6(),
        HH6 = {
            message: ({
                schemaCode: v
            }) => K4.str`must match format "${v}"`,
            params: ({
                schemaCode: v
            }) => K4._`{format: ${v}}`
        },
        DH6 = {
            keyword: "format",
            type: ["number", "string"],
            schemaType: "string",
            $data: !0,
            error: HH6,
            code(v, z) {
                let {
                    gen: U,
                    data: V,
                    $data: N,
                    schema: K,
                    schemaCode: x,
                    it: j
                } = v, {
                    opts: B,
                    errSchemaPath: O,
                    schemaEnv: J,
                    self: q
                } = j;
                if (!B.validateFormats) return;
                if (N) H();
                else D();

                function H() {
                    let A = U.scopeValue("formats", {
                            ref: q.formats,
                            code: B.code.formats
                        }),
                        w = U.const("fDef", K4._`${A}[${x}]`),
                        Z = U.let("fType"),
                        $ = U.let("format");
                    U.if(K4._`typeof ${w} == "object" && !(${w} instanceof RegExp)`, () => U.assign(Z, K4._`${w}.type || "string"`).assign($, K4._`${w}.validate`), () => U.assign(Z, K4._`"string"`).assign($, w)), v.fail$data((0, K4.or)(F(), L()));

                    function F() {
                        if (B.strictSchema === !1) return K4.nil;
                        return K4._`${x} && !${$}`
                    }

                    function L() {
                        let G = J.$async ? K4._`(${w}.async ? await ${$}(${V}) : ${$}(${V}))` : K4._`${$}(${V})`,
                            I = K4._`(typeof ${$} == "function" ? ${G} : ${$}.test(${V}))`;
                        return K4._`${$} && ${$} !== true && ${Z} === ${z} && !${I}`
                    }
                }

                function D() {
                    let A = q.formats[K];
                    if (!A) {
                        F();
                        return
                    }
                    if (A === !0) return;
                    let [w, Z, $] = L(A);
                    if (w === z) v.pass(G());

                    function F() {
                        if (B.strictSchema === !1) {
                            q.logger.warn(I());
                            return
                        }
                        throw Error(I());

                        function I() {
                            return `unknown format "${K}" ignored in schema at path "${O}"`
                        }
                    }

                    function L(I) {
                        let M = I instanceof RegExp ? (0, K4.regexpCode)(I) : B.code.formats ? K4._`${B.code.formats}${(0,K4.getProperty)(K)}` : void 0,
                            b = U.scopeValue("formats", {
                                key: K,
                                ref: I,
                                code: M
                            });
                        if (typeof I == "object" && !(I instanceof RegExp)) return [I.type || "string", I.validate, K4._`${b}.validate`];
                        return ["string", I, b]
                    }

                    function G() {
                        if (typeof A == "object" && !(A instanceof RegExp) && A.async) {
                            if (!J.$async) throw Error("async format in sync schema");
                            return K4._`await ${$}(${V})`
                        }
                        return typeof Z == "function" ? K4._`${$}(${V})` : K4._`${$}.test(${V})`
                    }
                }
            }
        };
    UF.default = DH6
});
var fX = _((VF) => {
    Object.defineProperty(VF, "__esModule", {
        value: !0
    });
    var AH6 = CX(),
        $H6 = [AH6.default];
    VF.default = $H6
});
var TX = _((y1) => {
    Object.defineProperty(y1, "__esModule", {
        value: !0
    });
    y1.contentVocabulary = y1.metadataVocabulary = void 0;
    y1.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
    y1.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"]
});
var uX = _((NF) => {
    Object.defineProperty(NF, "__esModule", {
        value: !0
    });
    var wH6 = im(),
        ZH6 = zX(),
        LH6 = _X(),
        FH6 = fX(),
        YX = TX(),
        GH6 = [wH6.default, ZH6.default, (0, LH6.default)(), FH6.default, YX.metadataVocabulary, YX.contentVocabulary];
    NF.default = GH6
});
var kX = _((HJ) => {
    Object.defineProperty(HJ, "__esModule", {
        value: !0
    });
    HJ.DiscrError = void 0;
    var yX;
    (function(v) {
        v.Tag = "tag", v.Mapping = "mapping"
    })(yX || (HJ.DiscrError = yX = {}))
});
var XX = _((xF) => {
    Object.defineProperty(xF, "__esModule", {
        value: !0
    });
    var k1 = e6(),
        KF = kX(),
        mX = dO(),
        IH6 = VN(),
        MH6 = w0(),
        bH6 = {
            message: ({
                params: {
                    discrError: v,
                    tagName: z
                }
            }) => v === KF.DiscrError.Tag ? `tag "${z}" must be string` : `value of tag "${z}" must be in oneOf`,
            params: ({
                params: {
                    discrError: v,
                    tag: z,
                    tagName: U
                }
            }) => k1._`{error: ${v}, tag: ${U}, tagValue: ${z}}`
        },
        RH6 = {
            keyword: "discriminator",
            type: "object",
            schemaType: "object",
            error: bH6,
            code(v) {
                let {
                    gen: z,
                    data: U,
                    schema: V,
                    parentSchema: N,
                    it: K
                } = v, {
                    oneOf: x
                } = N;
                if (!K.opts.discriminator) throw Error("discriminator: requires discriminator option");
                let j = V.propertyName;
                if (typeof j != "string") throw Error("discriminator: requires propertyName");
                if (V.mapping) throw Error("discriminator: mapping is not supported");
                if (!x) throw Error("discriminator: requires oneOf keyword");
                let B = z.let("valid", !1),
                    O = z.const("tag", k1._`${U}${(0,k1.getProperty)(j)}`);
                z.if(k1._`typeof ${O} == "string"`, () => J(), () => v.error(!1, {
                    discrError: KF.DiscrError.Tag,
                    tag: O,
                    tagName: j
                })), v.ok(B);

                function J() {
                    let D = H();
                    z.if(!1);
                    for (let A in D) z.elseIf(k1._`${O} === ${A}`), z.assign(B, q(D[A]));
                    z.else(), v.error(!1, {
                        discrError: KF.DiscrError.Mapping,
                        tag: O,
                        tagName: j
                    }), z.endIf()
                }

                function q(D) {
                    let A = z.name("valid"),
                        w = v.subschema({
                            keyword: "oneOf",
                            schemaProp: D
                        }, A);
                    return v.mergeEvaluated(w, k1.Name), A
                }

                function H() {
                    var D;
                    let A = {},
                        w = $(N),
                        Z = !0;
                    for (let G = 0; G < x.length; G++) {
                        let I = x[G];
                        if ((I === null || I === void 0 ? void 0 : I.$ref) && !(0, MH6.schemaHasRulesButRef)(I, K.self.RULES)) {
                            let b = I.$ref;
                            if (I = mX.resolveRef.call(K.self, K.schemaEnv.root, K.baseId, b), I instanceof mX.SchemaEnv) I = I.schema;
                            if (I === void 0) throw new IH6.default(K.opts.uriResolver, K.baseId, b)
                        }
                        let M = (D = I === null || I === void 0 ? void 0 : I.properties) === null || D === void 0 ? void 0 : D[j];
                        if (typeof M != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${j}"`);
                        Z = Z && (w || $(I)), F(M, G)
                    }
                    if (!Z) throw Error(`discriminator: "${j}" must be required`);
                    return A;

                    function $({
                        required: G
                    }) {
                        return Array.isArray(G) && G.includes(j)
                    }

                    function F(G, I) {
                        if (G.const) L(G.const, I);
                        else if (G.enum)
                            for (let M of G.enum) L(M, I);
                        else throw Error(`discriminator: "properties/${j}" must have "const" or "enum"`)
                    }

                    function L(G, I) {
                        if (typeof G != "string" || G in A) throw Error(`discriminator: "${j}" values must be unique strings`);
                        A[G] = I
                    }
                }
            }
        };
    xF.default = RH6
});
var gX = _((Km6, WH6) => {
    WH6.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
            schemaArray: {
                type: "array",
                minItems: 1,
                items: {
                    $ref: "#"
                }
            },
            nonNegativeInteger: {
                type: "integer",
                minimum: 0
            },
            nonNegativeIntegerDefault0: {
                allOf: [{
                    $ref: "#/definitions/nonNegativeInteger"
                }, {
                    default: 0
                }]
            },
            simpleTypes: {
                enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
            },
            stringArray: {
                type: "array",
                items: {
                    type: "string"
                },
                uniqueItems: !0,
                default: []
            }
        },
        type: ["object", "boolean"],
        properties: {
            $id: {
                type: "string",
                format: "uri-reference"
            },
            $schema: {
                type: "string",
                format: "uri"
            },
            $ref: {
                type: "string",
                format: "uri-reference"
            },
            $comment: {
                type: "string"
            },
            title: {
                type: "string"
            },
            description: {
                type: "string"
            },
            default: !0,
            readOnly: {
                type: "boolean",
                default: !1
            },
            examples: {
                type: "array",
                items: !0
            },
            multipleOf: {
                type: "number",
                exclusiveMinimum: 0
            },
            maximum: {
                type: "number"
            },
            exclusiveMaximum: {
                type: "number"
            },
            minimum: {
                type: "number"
            },
            exclusiveMinimum: {
                type: "number"
            },
            maxLength: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minLength: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            pattern: {
                type: "string",
                format: "regex"
            },
            additionalItems: {
                $ref: "#"
            },
            items: {
                anyOf: [{
                    $ref: "#"
                }, {
                    $ref: "#/definitions/schemaArray"
                }],
                default: !0
            },
            maxItems: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minItems: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            uniqueItems: {
                type: "boolean",
                default: !1
            },
            contains: {
                $ref: "#"
            },
            maxProperties: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minProperties: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            required: {
                $ref: "#/definitions/stringArray"
            },
            additionalProperties: {
                $ref: "#"
            },
            definitions: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                default: {}
            },
            properties: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                default: {}
            },
            patternProperties: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                propertyNames: {
                    format: "regex"
                },
                default: {}
            },
            dependencies: {
                type: "object",
                additionalProperties: {
                    anyOf: [{
                        $ref: "#"
                    }, {
                        $ref: "#/definitions/stringArray"
                    }]
                }
            },
            propertyNames: {
                $ref: "#"
            },
            const: !0,
            enum: {
                type: "array",
                items: !0,
                minItems: 1,
                uniqueItems: !0
            },
            type: {
                anyOf: [{
                    $ref: "#/definitions/simpleTypes"
                }, {
                    type: "array",
                    items: {
                        $ref: "#/definitions/simpleTypes"
                    },
                    minItems: 1,
                    uniqueItems: !0
                }]
            },
            format: {
                type: "string"
            },
            contentMediaType: {
                type: "string"
            },
            contentEncoding: {
                type: "string"
            },
            if: {
                $ref: "#"
            },
            then: {
                $ref: "#"
            },
            else: {
                $ref: "#"
            },
            allOf: {
                $ref: "#/definitions/schemaArray"
            },
            anyOf: {
                $ref: "#/definitions/schemaArray"
            },
            oneOf: {
                $ref: "#/definitions/schemaArray"
            },
            not: {
                $ref: "#"
            }
        },
        default: !0
    }
});
var BF = _((X0, jF) => {
    Object.defineProperty(X0, "__esModule", {
        value: !0
    });
    X0.MissingRefError = X0.ValidationError = X0.CodeGen = X0.Name = X0.nil = X0.stringify = X0.str = X0._ = X0.KeywordCxt = X0.Ajv = void 0;
    var EH6 = ym(),
        SH6 = uX(),
        PH6 = XX(),
        cX = gX(),
        _H6 = ["/properties"],
        DJ = "http://json-schema.org/draft-07/schema";
    class ZN extends EH6.default {
        _addVocabularies() {
            if (super._addVocabularies(), SH6.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator) this.addKeyword(PH6.default)
        }
        _addDefaultMetaSchema() {
            if (super._addDefaultMetaSchema(), !this.opts.meta) return;
            let v = this.opts.$data ? this.$dataMetaSchema(cX, _H6) : cX;
            this.addMetaSchema(v, DJ, !1), this.refs["http://json-schema.org/schema"] = DJ
        }
        defaultMeta() {
            return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(DJ) ? DJ : void 0)
        }
    }
    X0.Ajv = ZN;
    jF.exports = X0 = ZN;
    jF.exports.Ajv = ZN;
    Object.defineProperty(X0, "__esModule", {
        value: !0
    });
    X0.default = ZN;
    var CH6 = UN();
    Object.defineProperty(X0, "KeywordCxt", {
        enumerable: !0,
        get: function() {
            return CH6.KeywordCxt
        }
    });
    var m1 = e6();
    Object.defineProperty(X0, "_", {
        enumerable: !0,
        get: function() {
            return m1._
        }
    });
    Object.defineProperty(X0, "str", {
        enumerable: !0,
        get: function() {
            return m1.str
        }
    });
    Object.defineProperty(X0, "stringify", {
        enumerable: !0,
        get: function() {
            return m1.stringify
        }
    });
    Object.defineProperty(X0, "nil", {
        enumerable: !0,
        get: function() {
            return m1.nil
        }
    });
    Object.defineProperty(X0, "Name", {
        enumerable: !0,
        get: function() {
            return m1.Name
        }
    });
    Object.defineProperty(X0, "CodeGen", {
        enumerable: !0,
        get: function() {
            return m1.CodeGen
        }
    });
    var fH6 = nO();
    Object.defineProperty(X0, "ValidationError", {
        enumerable: !0,
        get: function() {
            return fH6.default
        }
    });
    var TH6 = VN();
    Object.defineProperty(X0, "MissingRefError", {
        enumerable: !0,
        get: function() {
            return TH6.default
        }
    })
});
var oX = _((a8) => {
    Object.defineProperty(a8, "__esModule", {
        value: !0
    });
    a8.formatNames = a8.fastFormats = a8.fullFormats = void 0;

    function r8(v, z) {
        return {
            validate: v,
            compare: z
        }
    }
    a8.fullFormats = {
        date: r8(pX, HF),
        time: r8(JF(!0), DF),
        "date-time": r8(iX(!0), QX),
        "iso-time": r8(JF(), nX),
        "iso-date-time": r8(iX(), dX),
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: XH6,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: nH6,
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        byte: gH6,
        int32: {
            type: "number",
            validate: lH6
        },
        int64: {
            type: "number",
            validate: hH6
        },
        float: {
            type: "number",
            validate: hX
        },
        double: {
            type: "number",
            validate: hX
        },
        password: !0,
        binary: !0
    };
    a8.fastFormats = {
        ...a8.fullFormats,
        date: r8(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, HF),
        time: r8(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, DF),
        "date-time": r8(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, QX),
        "iso-time": r8(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, nX),
        "iso-date-time": r8(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, dX),
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    a8.formatNames = Object.keys(a8.fullFormats);

    function YH6(v) {
        return v % 4 === 0 && (v % 100 !== 0 || v % 400 === 0)
    }
    var uH6 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
        yH6 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    function pX(v) {
        let z = uH6.exec(v);
        if (!z) return !1;
        let U = +z[1],
            V = +z[2],
            N = +z[3];
        return V >= 1 && V <= 12 && N >= 1 && N <= (V === 2 && YH6(U) ? 29 : yH6[V])
    }

    function HF(v, z) {
        if (!(v && z)) return;
        if (v > z) return 1;
        if (v < z) return -1;
        return 0
    }
    var OF = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;

    function JF(v) {
        return function(U) {
            let V = OF.exec(U);
            if (!V) return !1;
            let N = +V[1],
                K = +V[2],
                x = +V[3],
                j = V[4],
                B = V[5] === "-" ? -1 : 1,
                O = +(V[6] || 0),
                J = +(V[7] || 0);
            if (O > 23 || J > 59 || v && !j) return !1;
            if (N <= 23 && K <= 59 && x < 60) return !0;
            let q = K - J * B,
                H = N - O * B - (q < 0 ? 1 : 0);
            return (H === 23 || H === -1) && (q === 59 || q === -1) && x < 61
        }
    }

    function DF(v, z) {
        if (!(v && z)) return;
        let U = new Date("2020-01-01T" + v).valueOf(),
            V = new Date("2020-01-01T" + z).valueOf();
        if (!(U && V)) return;
        return U - V
    }

    function nX(v, z) {
        if (!(v && z)) return;
        let U = OF.exec(v),
            V = OF.exec(z);
        if (!(U && V)) return;
        if (v = U[1] + U[2] + U[3], z = V[1] + V[2] + V[3], v > z) return 1;
        if (v < z) return -1;
        return 0
    }
    var qF = /t|\s/i;

    function iX(v) {
        let z = JF(v);
        return function(V) {
            let N = V.split(qF);
            return N.length === 2 && pX(N[0]) && z(N[1])
        }
    }

    function QX(v, z) {
        if (!(v && z)) return;
        let U = new Date(v).valueOf(),
            V = new Date(z).valueOf();
        if (!(U && V)) return;
        return U - V
    }

    function dX(v, z) {
        if (!(v && z)) return;
        let [U, V] = v.split(qF), [N, K] = z.split(qF), x = HF(U, N);
        if (x === void 0) return;
        return x || DF(V, K)
    }
    var kH6 = /\/|:/,
        mH6 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;

    function XH6(v) {
        return kH6.test(v) && mH6.test(v)
    }
    var lX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;

    function gH6(v) {
        return lX.lastIndex = 0, lX.test(v)
    }
    var cH6 = -2147483648,
        iH6 = 2147483647;

    function lH6(v) {
        return Number.isInteger(v) && v <= iH6 && v >= cH6
    }

    function hH6(v) {
        return Number.isInteger(v)
    }

    function hX() {
        return !0
    }
    var pH6 = /[^\\]\\Z/;

    function nH6(v) {
        if (pH6.test(v)) return !1;
        try {
            return new RegExp(v), !0
        } catch (z) {
            return !1
        }
    }
});
var rX = _((X1) => {
    Object.defineProperty(X1, "__esModule", {
        value: !0
    });
    X1.formatLimitDefinition = void 0;
    var QH6 = BF(),
        R8 = e6(),
        C5 = R8.operators,
        AJ = {
            formatMaximum: {
                okStr: "<=",
                ok: C5.LTE,
                fail: C5.GT
            },
            formatMinimum: {
                okStr: ">=",
                ok: C5.GTE,
                fail: C5.LT
            },
            formatExclusiveMaximum: {
                okStr: "<",
                ok: C5.LT,
                fail: C5.GTE
            },
            formatExclusiveMinimum: {
                okStr: ">",
                ok: C5.GT,
                fail: C5.LTE
            }
        },
        dH6 = {
            message: ({
                keyword: v,
                schemaCode: z
            }) => R8.str`should be ${AJ[v].okStr} ${z}`,
            params: ({
                keyword: v,
                schemaCode: z
            }) => R8._`{comparison: ${AJ[v].okStr}, limit: ${z}}`
        };
    X1.formatLimitDefinition = {
        keyword: Object.keys(AJ),
        type: "string",
        schemaType: "string",
        $data: !0,
        error: dH6,
        code(v) {
            let {
                gen: z,
                data: U,
                schemaCode: V,
                keyword: N,
                it: K
            } = v, {
                opts: x,
                self: j
            } = K;
            if (!x.validateFormats) return;
            let B = new QH6.KeywordCxt(K, j.RULES.all.format.definition, "format");
            if (B.$data) O();
            else J();

            function O() {
                let H = z.scopeValue("formats", {
                        ref: j.formats,
                        code: x.code.formats
                    }),
                    D = z.const("fmt", R8._`${H}[${B.schemaCode}]`);
                v.fail$data((0, R8.or)(R8._`typeof ${D} != "object"`, R8._`${D} instanceof RegExp`, R8._`typeof ${D}.compare != "function"`, q(D)))
            }

            function J() {
                let H = B.schema,
                    D = j.formats[H];
                if (!D || D === !0) return;
                if (typeof D != "object" || D instanceof RegExp || typeof D.compare != "function") throw Error(`"${N}": format "${H}" does not define "compare" function`);
                let A = z.scopeValue("formats", {
                    key: H,
                    ref: D,
                    code: x.code.formats ? R8._`${x.code.formats}${(0,R8.getProperty)(H)}` : void 0
                });
                v.fail$data(q(A))
            }

            function q(H) {
                return R8._`${H}.compare(${U}, ${V}) ${AJ[N].fail} 0`
            }
        },
        dependencies: ["format"]
    };
    var oH6 = (v) => {
        return v.addKeyword(X1.formatLimitDefinition), v
    };
    X1.default = oH6
});
var eX = _((LN, sX) => {
    Object.defineProperty(LN, "__esModule", {
        value: !0
    });
    var g1 = oX(),
        rH6 = rX(),
        AF = e6(),
        aX = new AF.Name("fullFormats"),
        aH6 = new AF.Name("fastFormats"),
        $F = (v, z = {
            keywords: !0
        }) => {
            if (Array.isArray(z)) return tX(v, z, g1.fullFormats, aX), v;
            let [U, V] = z.mode === "fast" ? [g1.fastFormats, aH6] : [g1.fullFormats, aX], N = z.formats || g1.formatNames;
            if (tX(v, N, U, V), z.keywords)(0, rH6.default)(v);
            return v
        };
    $F.get = (v, z = "full") => {
        let V = (z === "fast" ? g1.fastFormats : g1.fullFormats)[v];
        if (!V) throw Error(`Unknown format "${v}"`);
        return V
    };

    function tX(v, z, U, V) {
        var N, K;
        (N = (K = v.opts.code).formats) !== null && N !== void 0 || (K.formats = AF._`require("ajv-formats/dist/formats").${V}`);
        for (let x of z) v.addFormat(x, U[x])
    }
    sX.exports = LN = $F;
    Object.defineProperty(LN, "__esModule", {
        value: !0
    });
    LN.default = $F
});
var y9 = _((Vg6, Lc) => {
    var wc = ["nodebuffer", "arraybuffer", "fragments"],
        Zc = typeof Blob < "u";
    if (Zc) wc.push("blob");
    Lc.exports = {
        BINARY_TYPES: wc,
        EMPTY_BUFFER: Buffer.alloc(0),
        GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
        hasBlob: Zc,
        kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
        kListener: Symbol("kListener"),
        kStatusCode: Symbol("status-code"),
        kWebSocket: Symbol("websocket"),
        NOOP: () => {}
    }
});
var bN = _((Ng6, _J) => {
    var {
        EMPTY_BUFFER: YD6
    } = y9(), kF = Buffer[Symbol.species];

    function uD6(v, z) {
        if (v.length === 0) return YD6;
        if (v.length === 1) return v[0];
        let U = Buffer.allocUnsafe(z),
            V = 0;
        for (let N = 0; N < v.length; N++) {
            let K = v[N];
            U.set(K, V), V += K.length
        }
        if (V < z) return new kF(U.buffer, U.byteOffset, V);
        return U
    }

    function Fc(v, z, U, V, N) {
        for (let K = 0; K < N; K++) U[V + K] = v[K] ^ z[K & 3]
    }

    function Gc(v, z) {
        for (let U = 0; U < v.length; U++) v[U] ^= z[U & 3]
    }

    function yD6(v) {
        if (v.length === v.buffer.byteLength) return v.buffer;
        return v.buffer.slice(v.byteOffset, v.byteOffset + v.length)
    }

    function mF(v) {
        if (mF.readOnly = !0, Buffer.isBuffer(v)) return v;
        let z;
        if (v instanceof ArrayBuffer) z = new kF(v);
        else if (ArrayBuffer.isView(v)) z = new kF(v.buffer, v.byteOffset, v.byteLength);
        else z = Buffer.from(v), mF.readOnly = !1;
        return z
    }
    _J.exports = {
        concat: uD6,
        mask: Fc,
        toArrayBuffer: yD6,
        toBuffer: mF,
        unmask: Gc
    };
    if (!process.env.WS_NO_BUFFER_UTIL) try {
        let v = (() => {
            throw new Error("Cannot require module " + "bufferutil");
        })();
        _J.exports.mask = function(z, U, V, N, K) {
            if (K < 48) Fc(z, U, V, N, K);
            else v.mask(z, U, V, N, K)
        }, _J.exports.unmask = function(z, U) {
            if (z.length < 32) Gc(z, U);
            else v.unmask(z, U)
        }
    } catch (v) {}
});
var Rc = _((Kg6, bc) => {
    var Ic = Symbol("kDone"),
        XF = Symbol("kRun");
    class Mc {
        constructor(v) {
            this[Ic] = () => {
                this.pending--, this[XF]()
            }, this.concurrency = v || 1 / 0, this.jobs = [], this.pending = 0
        }
        add(v) {
            this.jobs.push(v), this[XF]()
        } [XF]() {
            if (this.pending === this.concurrency) return;
            if (this.jobs.length) {
                let v = this.jobs.shift();
                this.pending++, v(this[Ic])
            }
        }
    }
    bc.exports = Mc
});
var WN = _((xg6, _c) => {
    var RN = require("zlib"),
        Wc = bN(),
        kD6 = Rc(),
        {
            kStatusCode: Ec
        } = y9(),
        mD6 = Buffer[Symbol.species],
        XD6 = Buffer.from([0, 0, 255, 255]),
        fJ = Symbol("permessage-deflate"),
        k9 = Symbol("total-length"),
        h1 = Symbol("callback"),
        u5 = Symbol("buffers"),
        p1 = Symbol("error"),
        CJ;
    class Sc {
        constructor(v, z, U) {
            if (this._maxPayload = U | 0, this._options = v || {}, this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024, this._isServer = !!z, this._deflate = null, this._inflate = null, this.params = null, !CJ) {
                let V = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
                CJ = new kD6(V)
            }
        }
        static get extensionName() {
            return "permessage-deflate"
        }
        offer() {
            let v = {};
            if (this._options.serverNoContextTakeover) v.server_no_context_takeover = !0;
            if (this._options.clientNoContextTakeover) v.client_no_context_takeover = !0;
            if (this._options.serverMaxWindowBits) v.server_max_window_bits = this._options.serverMaxWindowBits;
            if (this._options.clientMaxWindowBits) v.client_max_window_bits = this._options.clientMaxWindowBits;
            else if (this._options.clientMaxWindowBits == null) v.client_max_window_bits = !0;
            return v
        }
        accept(v) {
            return v = this.normalizeParams(v), this.params = this._isServer ? this.acceptAsServer(v) : this.acceptAsClient(v), this.params
        }
        cleanup() {
            if (this._inflate) this._inflate.close(), this._inflate = null;
            if (this._deflate) {
                let v = this._deflate[h1];
                if (this._deflate.close(), this._deflate = null, v) v(Error("The deflate stream was closed while data was being processed"))
            }
        }
        acceptAsServer(v) {
            let z = this._options,
                U = v.find((V) => {
                    if (z.serverNoContextTakeover === !1 && V.server_no_context_takeover || V.server_max_window_bits && (z.serverMaxWindowBits === !1 || typeof z.serverMaxWindowBits === "number" && z.serverMaxWindowBits > V.server_max_window_bits) || typeof z.clientMaxWindowBits === "number" && !V.client_max_window_bits) return !1;
                    return !0
                });
            if (!U) throw Error("None of the extension offers can be accepted");
            if (z.serverNoContextTakeover) U.server_no_context_takeover = !0;
            if (z.clientNoContextTakeover) U.client_no_context_takeover = !0;
            if (typeof z.serverMaxWindowBits === "number") U.server_max_window_bits = z.serverMaxWindowBits;
            if (typeof z.clientMaxWindowBits === "number") U.client_max_window_bits = z.clientMaxWindowBits;
            else if (U.client_max_window_bits === !0 || z.clientMaxWindowBits === !1) delete U.client_max_window_bits;
            return U
        }
        acceptAsClient(v) {
            let z = v[0];
            if (this._options.clientNoContextTakeover === !1 && z.client_no_context_takeover) throw Error('Unexpected parameter "client_no_context_takeover"');
            if (!z.client_max_window_bits) {
                if (typeof this._options.clientMaxWindowBits === "number") z.client_max_window_bits = this._options.clientMaxWindowBits
            } else if (this._options.clientMaxWindowBits === !1 || typeof this._options.clientMaxWindowBits === "number" && z.client_max_window_bits > this._options.clientMaxWindowBits) throw Error('Unexpected or invalid parameter "client_max_window_bits"');
            return z
        }
        normalizeParams(v) {
            return v.forEach((z) => {
                Object.keys(z).forEach((U) => {
                    let V = z[U];
                    if (V.length > 1) throw Error(`Parameter "${U}" must have only a single value`);
                    if (V = V[0], U === "client_max_window_bits") {
                        if (V !== !0) {
                            let N = +V;
                            if (!Number.isInteger(N) || N < 8 || N > 15) throw TypeError(`Invalid value for parameter "${U}": ${V}`);
                            V = N
                        } else if (!this._isServer) throw TypeError(`Invalid value for parameter "${U}": ${V}`)
                    } else if (U === "server_max_window_bits") {
                        let N = +V;
                        if (!Number.isInteger(N) || N < 8 || N > 15) throw TypeError(`Invalid value for parameter "${U}": ${V}`);
                        V = N
                    } else if (U === "client_no_context_takeover" || U === "server_no_context_takeover") {
                        if (V !== !0) throw TypeError(`Invalid value for parameter "${U}": ${V}`)
                    } else throw Error(`Unknown parameter "${U}"`);
                    z[U] = V
                })
            }), v
        }
        decompress(v, z, U) {
            CJ.add((V) => {
                this._decompress(v, z, (N, K) => {
                    V(), U(N, K)
                })
            })
        }
        compress(v, z, U) {
            CJ.add((V) => {
                this._compress(v, z, (N, K) => {
                    V(), U(N, K)
                })
            })
        }
        _decompress(v, z, U) {
            let V = this._isServer ? "client" : "server";
            if (!this._inflate) {
                let N = `${V}_max_window_bits`,
                    K = typeof this.params[N] !== "number" ? RN.Z_DEFAULT_WINDOWBITS : this.params[N];
                this._inflate = RN.createInflateRaw({
                    ...this._options.zlibInflateOptions,
                    windowBits: K
                }), this._inflate[fJ] = this, this._inflate[k9] = 0, this._inflate[u5] = [], this._inflate.on("error", cD6), this._inflate.on("data", Pc)
            }
            if (this._inflate[h1] = U, this._inflate.write(v), z) this._inflate.write(XD6);
            this._inflate.flush(() => {
                let N = this._inflate[p1];
                if (N) {
                    this._inflate.close(), this._inflate = null, U(N);
                    return
                }
                let K = Wc.concat(this._inflate[u5], this._inflate[k9]);
                if (this._inflate._readableState.endEmitted) this._inflate.close(), this._inflate = null;
                else if (this._inflate[k9] = 0, this._inflate[u5] = [], z && this.params[`${V}_no_context_takeover`]) this._inflate.reset();
                U(null, K)
            })
        }
        _compress(v, z, U) {
            let V = this._isServer ? "server" : "client";
            if (!this._deflate) {
                let N = `${V}_max_window_bits`,
                    K = typeof this.params[N] !== "number" ? RN.Z_DEFAULT_WINDOWBITS : this.params[N];
                this._deflate = RN.createDeflateRaw({
                    ...this._options.zlibDeflateOptions,
                    windowBits: K
                }), this._deflate[k9] = 0, this._deflate[u5] = [], this._deflate.on("data", gD6)
            }
            this._deflate[h1] = U, this._deflate.write(v), this._deflate.flush(RN.Z_SYNC_FLUSH, () => {
                if (!this._deflate) return;
                let N = Wc.concat(this._deflate[u5], this._deflate[k9]);
                if (z) N = new mD6(N.buffer, N.byteOffset, N.length - 4);
                if (this._deflate[h1] = null, this._deflate[k9] = 0, this._deflate[u5] = [], z && this.params[`${V}_no_context_takeover`]) this._deflate.reset();
                U(null, N)
            })
        }
    }
    _c.exports = Sc;

    function gD6(v) {
        this[u5].push(v), this[k9] += v.length
    }

    function Pc(v) {
        if (this[k9] += v.length, this[fJ]._maxPayload < 1 || this[k9] <= this[fJ]._maxPayload) {
            this[u5].push(v);
            return
        }
        this[p1] = RangeError("Max payload size exceeded"), this[p1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[p1][Ec] = 1009, this.removeListener("data", Pc), this.reset()
    }

    function cD6(v) {
        if (this[fJ]._inflate = null, this[p1]) {
            this[h1](this[p1]);
            return
        }
        v[Ec] = 1007, this[h1](v)
    }
});
var n1 = _((jg6, TJ) => {
    var {
        isUtf8: Cc
    } = require("buffer"), {
        hasBlob: iD6
    } = y9(), lD6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0];

    function hD6(v) {
        return v >= 1000 && v <= 1014 && v !== 1004 && v !== 1005 && v !== 1006 || v >= 3000 && v <= 4999
    }

    function gF(v) {
        let z = v.length,
            U = 0;
        while (U < z)
            if ((v[U] & 128) === 0) U++;
            else if ((v[U] & 224) === 192) {
            if (U + 1 === z || (v[U + 1] & 192) !== 128 || (v[U] & 254) === 192) return !1;
            U += 2
        } else if ((v[U] & 240) === 224) {
            if (U + 2 >= z || (v[U + 1] & 192) !== 128 || (v[U + 2] & 192) !== 128 || v[U] === 224 && (v[U + 1] & 224) === 128 || v[U] === 237 && (v[U + 1] & 224) === 160) return !1;
            U += 3
        } else if ((v[U] & 248) === 240) {
            if (U + 3 >= z || (v[U + 1] & 192) !== 128 || (v[U + 2] & 192) !== 128 || (v[U + 3] & 192) !== 128 || v[U] === 240 && (v[U + 1] & 240) === 128 || v[U] === 244 && v[U + 1] > 143 || v[U] > 244) return !1;
            U += 4
        } else return !1;
        return !0
    }

    function pD6(v) {
        return iD6 && typeof v === "object" && typeof v.arrayBuffer === "function" && typeof v.type === "string" && typeof v.stream === "function" && (v[Symbol.toStringTag] === "Blob" || v[Symbol.toStringTag] === "File")
    }
    TJ.exports = {
        isBlob: pD6,
        isValidStatusCode: hD6,
        isValidUTF8: gF,
        tokenChars: lD6
    };
    if (Cc) TJ.exports.isValidUTF8 = function(v) {
        return v.length < 24 ? gF(v) : Cc(v)
    };
    else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
        let v = (() => {
            throw new Error("Cannot require module " + "utf-8-validate");
        })();
        TJ.exports.isValidUTF8 = function(z) {
            return z.length < 32 ? gF(z) : v(z)
        }
    } catch (v) {}
});
var iF = _((Bg6, yc) => {
    var {
        Writable: nD6
    } = require("stream"), fc = WN(), {
        BINARY_TYPES: QD6,
        EMPTY_BUFFER: Tc,
        kStatusCode: dD6,
        kWebSocket: oD6
    } = y9(), {
        concat: cF,
        toArrayBuffer: rD6,
        unmask: aD6
    } = bN(), {
        isValidStatusCode: tD6,
        isValidUTF8: Yc
    } = n1(), YJ = Buffer[Symbol.species];
    class uc extends nD6 {
        constructor(v = {}) {
            super();
            this._allowSynchronousEvents = v.allowSynchronousEvents !== void 0 ? v.allowSynchronousEvents : !0, this._binaryType = v.binaryType || QD6[0], this._extensions = v.extensions || {}, this._isServer = !!v.isServer, this._maxPayload = v.maxPayload | 0, this._skipUTF8Validation = !!v.skipUTF8Validation, this[oD6] = void 0, this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._errored = !1, this._loop = !1, this._state = 0
        }
        _write(v, z, U) {
            if (this._opcode === 8 && this._state == 0) return U();
            this._bufferedBytes += v.length, this._buffers.push(v), this.startLoop(U)
        }
        consume(v) {
            if (this._bufferedBytes -= v, v === this._buffers[0].length) return this._buffers.shift();
            if (v < this._buffers[0].length) {
                let U = this._buffers[0];
                return this._buffers[0] = new YJ(U.buffer, U.byteOffset + v, U.length - v), new YJ(U.buffer, U.byteOffset, v)
            }
            let z = Buffer.allocUnsafe(v);
            do {
                let U = this._buffers[0],
                    V = z.length - v;
                if (v >= U.length) z.set(this._buffers.shift(), V);
                else z.set(new Uint8Array(U.buffer, U.byteOffset, v), V), this._buffers[0] = new YJ(U.buffer, U.byteOffset + v, U.length - v);
                v -= U.length
            } while (v > 0);
            return z
        }
        startLoop(v) {
            this._loop = !0;
            do switch (this._state) {
                case 0:
                    this.getInfo(v);
                    break;
                case 1:
                    this.getPayloadLength16(v);
                    break;
                case 2:
                    this.getPayloadLength64(v);
                    break;
                case 3:
                    this.getMask();
                    break;
                case 4:
                    this.getData(v);
                    break;
                case 5:
                case 6:
                    this._loop = !1;
                    return
            }
            while (this._loop);
            if (!this._errored) v()
        }
        getInfo(v) {
            if (this._bufferedBytes < 2) {
                this._loop = !1;
                return
            }
            let z = this.consume(2);
            if ((z[0] & 48) !== 0) {
                let V = this.createError(RangeError, "RSV2 and RSV3 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
                v(V);
                return
            }
            let U = (z[0] & 64) === 64;
            if (U && !this._extensions[fc.extensionName]) {
                let V = this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                v(V);
                return
            }
            if (this._fin = (z[0] & 128) === 128, this._opcode = z[0] & 15, this._payloadLength = z[1] & 127, this._opcode === 0) {
                if (U) {
                    let V = this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                    v(V);
                    return
                }
                if (!this._fragmented) {
                    let V = this.createError(RangeError, "invalid opcode 0", !0, 1002, "WS_ERR_INVALID_OPCODE");
                    v(V);
                    return
                }
                this._opcode = this._fragmented
            } else if (this._opcode === 1 || this._opcode === 2) {
                if (this._fragmented) {
                    let V = this.createError(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE");
                    v(V);
                    return
                }
                this._compressed = U
            } else if (this._opcode > 7 && this._opcode < 11) {
                if (!this._fin) {
                    let V = this.createError(RangeError, "FIN must be set", !0, 1002, "WS_ERR_EXPECTED_FIN");
                    v(V);
                    return
                }
                if (U) {
                    let V = this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                    v(V);
                    return
                }
                if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
                    let V = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, !0, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
                    v(V);
                    return
                }
            } else {
                let V = this.createError(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE");
                v(V);
                return
            }
            if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
            if (this._masked = (z[1] & 128) === 128, this._isServer) {
                if (!this._masked) {
                    let V = this.createError(RangeError, "MASK must be set", !0, 1002, "WS_ERR_EXPECTED_MASK");
                    v(V);
                    return
                }
            } else if (this._masked) {
                let V = this.createError(RangeError, "MASK must be clear", !0, 1002, "WS_ERR_UNEXPECTED_MASK");
                v(V);
                return
            }
            if (this._payloadLength === 126) this._state = 1;
            else if (this._payloadLength === 127) this._state = 2;
            else this.haveLength(v)
        }
        getPayloadLength16(v) {
            if (this._bufferedBytes < 2) {
                this._loop = !1;
                return
            }
            this._payloadLength = this.consume(2).readUInt16BE(0), this.haveLength(v)
        }
        getPayloadLength64(v) {
            if (this._bufferedBytes < 8) {
                this._loop = !1;
                return
            }
            let z = this.consume(8),
                U = z.readUInt32BE(0);
            if (U > Math.pow(2, 21) - 1) {
                let V = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", !1, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
                v(V);
                return
            }
            this._payloadLength = U * Math.pow(2, 32) + z.readUInt32BE(4), this.haveLength(v)
        }
        haveLength(v) {
            if (this._payloadLength && this._opcode < 8) {
                if (this._totalPayloadLength += this._payloadLength, this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                    let z = this.createError(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
                    v(z);
                    return
                }
            }
            if (this._masked) this._state = 3;
            else this._state = 4
        }
        getMask() {
            if (this._bufferedBytes < 4) {
                this._loop = !1;
                return
            }
            this._mask = this.consume(4), this._state = 4
        }
        getData(v) {
            let z = Tc;
            if (this._payloadLength) {
                if (this._bufferedBytes < this._payloadLength) {
                    this._loop = !1;
                    return
                }
                if (z = this.consume(this._payloadLength), this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) aD6(z, this._mask)
            }
            if (this._opcode > 7) {
                this.controlMessage(z, v);
                return
            }
            if (this._compressed) {
                this._state = 5, this.decompress(z, v);
                return
            }
            if (z.length) this._messageLength = this._totalPayloadLength, this._fragments.push(z);
            this.dataMessage(v)
        }
        decompress(v, z) {
            this._extensions[fc.extensionName].decompress(v, this._fin, (V, N) => {
                if (V) return z(V);
                if (N.length) {
                    if (this._messageLength += N.length, this._messageLength > this._maxPayload && this._maxPayload > 0) {
                        let K = this.createError(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
                        z(K);
                        return
                    }
                    this._fragments.push(N)
                }
                if (this.dataMessage(z), this._state === 0) this.startLoop(z)
            })
        }
        dataMessage(v) {
            if (!this._fin) {
                this._state = 0;
                return
            }
            let z = this._messageLength,
                U = this._fragments;
            if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, this._fragments = [], this._opcode === 2) {
                let V;
                if (this._binaryType === "nodebuffer") V = cF(U, z);
                else if (this._binaryType === "arraybuffer") V = rD6(cF(U, z));
                else if (this._binaryType === "blob") V = new Blob(U);
                else V = U;
                if (this._allowSynchronousEvents) this.emit("message", V, !0), this._state = 0;
                else this._state = 6, setImmediate(() => {
                    this.emit("message", V, !0), this._state = 0, this.startLoop(v)
                })
            } else {
                let V = cF(U, z);
                if (!this._skipUTF8Validation && !Yc(V)) {
                    let N = this.createError(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
                    v(N);
                    return
                }
                if (this._state === 5 || this._allowSynchronousEvents) this.emit("message", V, !1), this._state = 0;
                else this._state = 6, setImmediate(() => {
                    this.emit("message", V, !1), this._state = 0, this.startLoop(v)
                })
            }
        }
        controlMessage(v, z) {
            if (this._opcode === 8) {
                if (v.length === 0) this._loop = !1, this.emit("conclude", 1005, Tc), this.end();
                else {
                    let U = v.readUInt16BE(0);
                    if (!tD6(U)) {
                        let N = this.createError(RangeError, `invalid status code ${U}`, !0, 1002, "WS_ERR_INVALID_CLOSE_CODE");
                        z(N);
                        return
                    }
                    let V = new YJ(v.buffer, v.byteOffset + 2, v.length - 2);
                    if (!this._skipUTF8Validation && !Yc(V)) {
                        let N = this.createError(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
                        z(N);
                        return
                    }
                    this._loop = !1, this.emit("conclude", U, V), this.end()
                }
                this._state = 0;
                return
            }
            if (this._allowSynchronousEvents) this.emit(this._opcode === 9 ? "ping" : "pong", v), this._state = 0;
            else this._state = 6, setImmediate(() => {
                this.emit(this._opcode === 9 ? "ping" : "pong", v), this._state = 0, this.startLoop(z)
            })
        }
        createError(v, z, U, V, N) {
            this._loop = !1, this._errored = !0;
            let K = new v(U ? `Invalid WebSocket frame: ${z}` : z);
            return Error.captureStackTrace(K, this.createError), K.code = N, K[dD6] = V, K
        }
    }
    yc.exports = uc
});
var hF = _((Jg6, Xc) => {
    var {
        Duplex: Og6
    } = require("stream"), {
        randomFillSync: sD6
    } = require("crypto"), kc = WN(), {
        EMPTY_BUFFER: eD6,
        kWebSocket: v26,
        NOOP: z26
    } = y9(), {
        isBlob: Q1,
        isValidStatusCode: U26
    } = n1(), {
        mask: mc,
        toBuffer: C7
    } = bN(), a3 = Symbol("kByteLength"), V26 = Buffer.alloc(4), f7, d1 = 8192, E8 = 0, N26 = 1, K26 = 2;
    class y5 {
        constructor(v, z, U) {
            if (this._extensions = z || {}, U) this._generateMask = U, this._maskBuffer = Buffer.alloc(4);
            this._socket = v, this._firstFragment = !0, this._compress = !1, this._bufferedBytes = 0, this._queue = [], this._state = E8, this.onerror = z26, this[v26] = void 0
        }
        static frame(v, z) {
            let U, V = !1,
                N = 2,
                K = !1;
            if (z.mask) {
                if (U = z.maskBuffer || V26, z.generateMask) z.generateMask(U);
                else {
                    if (d1 === 8192) {
                        if (f7 === void 0) f7 = Buffer.alloc(8192);
                        sD6(f7, 0, 8192), d1 = 0
                    }
                    U[0] = f7[d1++], U[1] = f7[d1++], U[2] = f7[d1++], U[3] = f7[d1++]
                }
                K = (U[0] | U[1] | U[2] | U[3]) === 0, N = 6
            }
            let x;
            if (typeof v === "string")
                if ((!z.mask || K) && z[a3] !== void 0) x = z[a3];
                else v = Buffer.from(v), x = v.length;
            else x = v.length, V = z.mask && z.readOnly && !K;
            let j = x;
            if (x >= 65536) N += 8, j = 127;
            else if (x > 125) N += 2, j = 126;
            let B = Buffer.allocUnsafe(V ? x + N : N);
            if (B[0] = z.fin ? z.opcode | 128 : z.opcode, z.rsv1) B[0] |= 64;
            if (B[1] = j, j === 126) B.writeUInt16BE(x, 2);
            else if (j === 127) B[2] = B[3] = 0, B.writeUIntBE(x, 4, 6);
            if (!z.mask) return [B, v];
            if (B[1] |= 128, B[N - 4] = U[0], B[N - 3] = U[1], B[N - 2] = U[2], B[N - 1] = U[3], K) return [B, v];
            if (V) return mc(v, U, B, N, x), [B];
            return mc(v, U, v, 0, x), [B, v]
        }
        close(v, z, U, V) {
            let N;
            if (v === void 0) N = eD6;
            else if (typeof v !== "number" || !U26(v)) throw TypeError("First argument must be a valid error code number");
            else if (z === void 0 || !z.length) N = Buffer.allocUnsafe(2), N.writeUInt16BE(v, 0);
            else {
                let x = Buffer.byteLength(z);
                if (x > 123) throw RangeError("The message must not be greater than 123 bytes");
                if (N = Buffer.allocUnsafe(2 + x), N.writeUInt16BE(v, 0), typeof z === "string") N.write(z, 2);
                else N.set(z, 2)
            }
            let K = {
                [a3]: N.length,
                fin: !0,
                generateMask: this._generateMask,
                mask: U,
                maskBuffer: this._maskBuffer,
                opcode: 8,
                readOnly: !1,
                rsv1: !1
            };
            if (this._state !== E8) this.enqueue([this.dispatch, N, !1, K, V]);
            else this.sendFrame(y5.frame(N, K), V)
        }
        ping(v, z, U) {
            let V, N;
            if (typeof v === "string") V = Buffer.byteLength(v), N = !1;
            else if (Q1(v)) V = v.size, N = !1;
            else v = C7(v), V = v.length, N = C7.readOnly;
            if (V > 125) throw RangeError("The data size must not be greater than 125 bytes");
            let K = {
                [a3]: V,
                fin: !0,
                generateMask: this._generateMask,
                mask: z,
                maskBuffer: this._maskBuffer,
                opcode: 9,
                readOnly: N,
                rsv1: !1
            };
            if (Q1(v))
                if (this._state !== E8) this.enqueue([this.getBlobData, v, !1, K, U]);
                else this.getBlobData(v, !1, K, U);
            else if (this._state !== E8) this.enqueue([this.dispatch, v, !1, K, U]);
            else this.sendFrame(y5.frame(v, K), U)
        }
        pong(v, z, U) {
            let V, N;
            if (typeof v === "string") V = Buffer.byteLength(v), N = !1;
            else if (Q1(v)) V = v.size, N = !1;
            else v = C7(v), V = v.length, N = C7.readOnly;
            if (V > 125) throw RangeError("The data size must not be greater than 125 bytes");
            let K = {
                [a3]: V,
                fin: !0,
                generateMask: this._generateMask,
                mask: z,
                maskBuffer: this._maskBuffer,
                opcode: 10,
                readOnly: N,
                rsv1: !1
            };
            if (Q1(v))
                if (this._state !== E8) this.enqueue([this.getBlobData, v, !1, K, U]);
                else this.getBlobData(v, !1, K, U);
            else if (this._state !== E8) this.enqueue([this.dispatch, v, !1, K, U]);
            else this.sendFrame(y5.frame(v, K), U)
        }
        send(v, z, U) {
            let V = this._extensions[kc.extensionName],
                N = z.binary ? 2 : 1,
                K = z.compress,
                x, j;
            if (typeof v === "string") x = Buffer.byteLength(v), j = !1;
            else if (Q1(v)) x = v.size, j = !1;
            else v = C7(v), x = v.length, j = C7.readOnly;
            if (this._firstFragment) {
                if (this._firstFragment = !1, K && V && V.params[V._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) K = x >= V._threshold;
                this._compress = K
            } else K = !1, N = 0;
            if (z.fin) this._firstFragment = !0;
            let B = {
                [a3]: x,
                fin: z.fin,
                generateMask: this._generateMask,
                mask: z.mask,
                maskBuffer: this._maskBuffer,
                opcode: N,
                readOnly: j,
                rsv1: K
            };
            if (Q1(v))
                if (this._state !== E8) this.enqueue([this.getBlobData, v, this._compress, B, U]);
                else this.getBlobData(v, this._compress, B, U);
            else if (this._state !== E8) this.enqueue([this.dispatch, v, this._compress, B, U]);
            else this.dispatch(v, this._compress, B, U)
        }
        getBlobData(v, z, U, V) {
            this._bufferedBytes += U[a3], this._state = K26, v.arrayBuffer().then((N) => {
                if (this._socket.destroyed) {
                    let x = Error("The socket was closed while the blob was being read");
                    process.nextTick(lF, this, x, V);
                    return
                }
                this._bufferedBytes -= U[a3];
                let K = C7(N);
                if (!z) this._state = E8, this.sendFrame(y5.frame(K, U), V), this.dequeue();
                else this.dispatch(K, z, U, V)
            }).catch((N) => {
                process.nextTick(x26, this, N, V)
            })
        }
        dispatch(v, z, U, V) {
            if (!z) {
                this.sendFrame(y5.frame(v, U), V);
                return
            }
            let N = this._extensions[kc.extensionName];
            this._bufferedBytes += U[a3], this._state = N26, N.compress(v, U.fin, (K, x) => {
                if (this._socket.destroyed) {
                    let j = Error("The socket was closed while data was being compressed");
                    lF(this, j, V);
                    return
                }
                this._bufferedBytes -= U[a3], this._state = E8, U.readOnly = !1, this.sendFrame(y5.frame(x, U), V), this.dequeue()
            })
        }
        dequeue() {
            while (this._state === E8 && this._queue.length) {
                let v = this._queue.shift();
                this._bufferedBytes -= v[3][a3], Reflect.apply(v[0], this, v.slice(1))
            }
        }
        enqueue(v) {
            this._bufferedBytes += v[3][a3], this._queue.push(v)
        }
        sendFrame(v, z) {
            if (v.length === 2) this._socket.cork(), this._socket.write(v[0]), this._socket.write(v[1], z), this._socket.uncork();
            else this._socket.write(v[0], z)
        }
    }
    Xc.exports = y5;

    function lF(v, z, U) {
        if (typeof U === "function") U(z);
        for (let V = 0; V < v._queue.length; V++) {
            let N = v._queue[V],
                K = N[N.length - 1];
            if (typeof K === "function") K(z)
        }
    }

    function x26(v, z, U) {
        lF(v, z, U), v.onerror(z)
    }
});
var dc = _((qg6, Qc) => {
    var {
        kForOnEventAttribute: EN,
        kListener: pF
    } = y9(), gc = Symbol("kCode"), cc = Symbol("kData"), ic = Symbol("kError"), lc = Symbol("kMessage"), hc = Symbol("kReason"), o1 = Symbol("kTarget"), pc = Symbol("kType"), nc = Symbol("kWasClean");
    class k5 {
        constructor(v) {
            this[o1] = null, this[pc] = v
        }
        get target() {
            return this[o1]
        }
        get type() {
            return this[pc]
        }
    }
    Object.defineProperty(k5.prototype, "target", {
        enumerable: !0
    });
    Object.defineProperty(k5.prototype, "type", {
        enumerable: !0
    });
    class r1 extends k5 {
        constructor(v, z = {}) {
            super(v);
            this[gc] = z.code === void 0 ? 0 : z.code, this[hc] = z.reason === void 0 ? "" : z.reason, this[nc] = z.wasClean === void 0 ? !1 : z.wasClean
        }
        get code() {
            return this[gc]
        }
        get reason() {
            return this[hc]
        }
        get wasClean() {
            return this[nc]
        }
    }
    Object.defineProperty(r1.prototype, "code", {
        enumerable: !0
    });
    Object.defineProperty(r1.prototype, "reason", {
        enumerable: !0
    });
    Object.defineProperty(r1.prototype, "wasClean", {
        enumerable: !0
    });
    class SN extends k5 {
        constructor(v, z = {}) {
            super(v);
            this[ic] = z.error === void 0 ? null : z.error, this[lc] = z.message === void 0 ? "" : z.message
        }
        get error() {
            return this[ic]
        }
        get message() {
            return this[lc]
        }
    }
    Object.defineProperty(SN.prototype, "error", {
        enumerable: !0
    });
    Object.defineProperty(SN.prototype, "message", {
        enumerable: !0
    });
    class yJ extends k5 {
        constructor(v, z = {}) {
            super(v);
            this[cc] = z.data === void 0 ? null : z.data
        }
        get data() {
            return this[cc]
        }
    }
    Object.defineProperty(yJ.prototype, "data", {
        enumerable: !0
    });
    var j26 = {
        addEventListener(v, z, U = {}) {
            for (let N of this.listeners(v))
                if (!U[EN] && N[pF] === z && !N[EN]) return;
            let V;
            if (v === "message") V = function(K, x) {
                let j = new yJ("message", {
                    data: x ? K : K.toString()
                });
                j[o1] = this, uJ(z, this, j)
            };
            else if (v === "close") V = function(K, x) {
                let j = new r1("close", {
                    code: K,
                    reason: x.toString(),
                    wasClean: this._closeFrameReceived && this._closeFrameSent
                });
                j[o1] = this, uJ(z, this, j)
            };
            else if (v === "error") V = function(K) {
                let x = new SN("error", {
                    error: K,
                    message: K.message
                });
                x[o1] = this, uJ(z, this, x)
            };
            else if (v === "open") V = function() {
                let K = new k5("open");
                K[o1] = this, uJ(z, this, K)
            };
            else return;
            if (V[EN] = !!U[EN], V[pF] = z, U.once) this.once(v, V);
            else this.on(v, V)
        },
        removeEventListener(v, z) {
            for (let U of this.listeners(v))
                if (U[pF] === z && !U[EN]) {
                    this.removeListener(v, U);
                    break
                }
        }
    };
    Qc.exports = {
        CloseEvent: r1,
        ErrorEvent: SN,
        Event: k5,
        EventTarget: j26,
        MessageEvent: yJ
    };

    function uJ(v, z, U) {
        if (typeof v === "object" && v.handleEvent) v.handleEvent.call(v, U);
        else v.call(z, U)
    }
});
var nF = _((Hg6, oc) => {
    var {
        tokenChars: PN
    } = n1();

    function s8(v, z, U) {
        if (v[z] === void 0) v[z] = [U];
        else v[z].push(U)
    }

    function B26(v) {
        let z = Object.create(null),
            U = Object.create(null),
            V = !1,
            N = !1,
            K = !1,
            x, j, B = -1,
            O = -1,
            J = -1,
            q = 0;
        for (; q < v.length; q++)
            if (O = v.charCodeAt(q), x === void 0)
                if (J === -1 && PN[O] === 1) {
                    if (B === -1) B = q
                } else if (q !== 0 && (O === 32 || O === 9)) {
            if (J === -1 && B !== -1) J = q
        } else if (O === 59 || O === 44) {
            if (B === -1) throw SyntaxError(`Unexpected character at index ${q}`);
            if (J === -1) J = q;
            let D = v.slice(B, J);
            if (O === 44) s8(z, D, U), U = Object.create(null);
            else x = D;
            B = J = -1
        } else throw SyntaxError(`Unexpected character at index ${q}`);
        else if (j === void 0)
            if (J === -1 && PN[O] === 1) {
                if (B === -1) B = q
            } else if (O === 32 || O === 9) {
            if (J === -1 && B !== -1) J = q
        } else if (O === 59 || O === 44) {
            if (B === -1) throw SyntaxError(`Unexpected character at index ${q}`);
            if (J === -1) J = q;
            if (s8(U, v.slice(B, J), !0), O === 44) s8(z, x, U), U = Object.create(null), x = void 0;
            B = J = -1
        } else if (O === 61 && B !== -1 && J === -1) j = v.slice(B, q), B = J = -1;
        else throw SyntaxError(`Unexpected character at index ${q}`);
        else if (N) {
            if (PN[O] !== 1) throw SyntaxError(`Unexpected character at index ${q}`);
            if (B === -1) B = q;
            else if (!V) V = !0;
            N = !1
        } else if (K)
            if (PN[O] === 1) {
                if (B === -1) B = q
            } else if (O === 34 && B !== -1) K = !1, J = q;
        else if (O === 92) N = !0;
        else throw SyntaxError(`Unexpected character at index ${q}`);
        else if (O === 34 && v.charCodeAt(q - 1) === 61) K = !0;
        else if (J === -1 && PN[O] === 1) {
            if (B === -1) B = q
        } else if (B !== -1 && (O === 32 || O === 9)) {
            if (J === -1) J = q
        } else if (O === 59 || O === 44) {
            if (B === -1) throw SyntaxError(`Unexpected character at index ${q}`);
            if (J === -1) J = q;
            let D = v.slice(B, J);
            if (V) D = D.replace(/\\/g, ""), V = !1;
            if (s8(U, j, D), O === 44) s8(z, x, U), U = Object.create(null), x = void 0;
            j = void 0, B = J = -1
        } else throw SyntaxError(`Unexpected character at index ${q}`);
        if (B === -1 || K || O === 32 || O === 9) throw SyntaxError("Unexpected end of input");
        if (J === -1) J = q;
        let H = v.slice(B, J);
        if (x === void 0) s8(z, H, U);
        else {
            if (j === void 0) s8(U, H, !0);
            else if (V) s8(U, j, H.replace(/\\/g, ""));
            else s8(U, j, H);
            s8(z, x, U)
        }
        return z
    }

    function O26(v) {
        return Object.keys(v).map((z) => {
            let U = v[z];
            if (!Array.isArray(U)) U = [U];
            return U.map((V) => {
                return [z].concat(Object.keys(V).map((N) => {
                    let K = V[N];
                    if (!Array.isArray(K)) K = [K];
                    return K.map((x) => x === !0 ? N : `${N}=${x}`).join("; ")
                })).join("; ")
            }).join(", ")
        }).join(", ")
    }
    oc.exports = {
        format: O26,
        parse: B26
    }
});
var gJ = _(($g6, xi) => {
    var J26 = require("events"),
        q26 = require("https"),
        H26 = require("http"),
        tc = require("net"),
        D26 = require("tls"),
        {
            randomBytes: A26,
            createHash: $26
        } = require("crypto"),
        {
            Duplex: Dg6,
            Readable: Ag6
        } = require("stream"),
        {
            URL: QF
        } = require("url"),
        m5 = WN(),
        w26 = iF(),
        Z26 = hF(),
        {
            isBlob: L26
        } = n1(),
        {
            BINARY_TYPES: rc,
            EMPTY_BUFFER: kJ,
            GUID: F26,
            kForOnEventAttribute: dF,
            kListener: G26,
            kStatusCode: I26,
            kWebSocket: C4,
            NOOP: sc
        } = y9(),
        {
            EventTarget: {
                addEventListener: M26,
                removeEventListener: b26
            }
        } = dc(),
        {
            format: R26,
            parse: W26
        } = nF(),
        {
            toBuffer: E26
        } = bN(),
        ec = Symbol("kAborted"),
        oF = [8, 13],
        m9 = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"],
        S26 = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    class d6 extends J26 {
        constructor(v, z, U) {
            super();
            if (this._binaryType = rc[0], this._closeCode = 1006, this._closeFrameReceived = !1, this._closeFrameSent = !1, this._closeMessage = kJ, this._closeTimer = null, this._errorEmitted = !1, this._extensions = {}, this._paused = !1, this._protocol = "", this._readyState = d6.CONNECTING, this._receiver = null, this._sender = null, this._socket = null, v !== null) {
                if (this._bufferedAmount = 0, this._isServer = !1, this._redirects = 0, z === void 0) z = [];
                else if (!Array.isArray(z))
                    if (typeof z === "object" && z !== null) U = z, z = [];
                    else z = [z];
                vi(this, v, z, U)
            } else this._autoPong = U.autoPong, this._isServer = !0
        }
        get binaryType() {
            return this._binaryType
        }
        set binaryType(v) {
            if (!rc.includes(v)) return;
            if (this._binaryType = v, this._receiver) this._receiver._binaryType = v
        }
        get bufferedAmount() {
            if (!this._socket) return this._bufferedAmount;
            return this._socket._writableState.length + this._sender._bufferedBytes
        }
        get extensions() {
            return Object.keys(this._extensions).join()
        }
        get isPaused() {
            return this._paused
        }
        get onclose() {
            return null
        }
        get onerror() {
            return null
        }
        get onopen() {
            return null
        }
        get onmessage() {
            return null
        }
        get protocol() {
            return this._protocol
        }
        get readyState() {
            return this._readyState
        }
        get url() {
            return this._url
        }
        setSocket(v, z, U) {
            let V = new w26({
                    allowSynchronousEvents: U.allowSynchronousEvents,
                    binaryType: this.binaryType,
                    extensions: this._extensions,
                    isServer: this._isServer,
                    maxPayload: U.maxPayload,
                    skipUTF8Validation: U.skipUTF8Validation
                }),
                N = new Z26(v, this._extensions, U.generateMask);
            if (this._receiver = V, this._sender = N, this._socket = v, V[C4] = this, N[C4] = this, v[C4] = this, V.on("conclude", C26), V.on("drain", f26), V.on("error", T26), V.on("message", Y26), V.on("ping", u26), V.on("pong", y26), N.onerror = k26, v.setTimeout) v.setTimeout(0);
            if (v.setNoDelay) v.setNoDelay();
            if (z.length > 0) v.unshift(z);
            v.on("close", Vi), v.on("data", XJ), v.on("end", Ni), v.on("error", Ki), this._readyState = d6.OPEN, this.emit("open")
        }
        emitClose() {
            if (!this._socket) {
                this._readyState = d6.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
                return
            }
            if (this._extensions[m5.extensionName]) this._extensions[m5.extensionName].cleanup();
            this._receiver.removeAllListeners(), this._readyState = d6.CLOSED, this.emit("close", this._closeCode, this._closeMessage)
        }
        close(v, z) {
            if (this.readyState === d6.CLOSED) return;
            if (this.readyState === d6.CONNECTING) {
                k3(this, this._req, "WebSocket was closed before the connection was established");
                return
            }
            if (this.readyState === d6.CLOSING) {
                if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
                return
            }
            this._readyState = d6.CLOSING, this._sender.close(v, z, !this._isServer, (U) => {
                if (U) return;
                if (this._closeFrameSent = !0, this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end()
            }), Ui(this)
        }
        pause() {
            if (this.readyState === d6.CONNECTING || this.readyState === d6.CLOSED) return;
            this._paused = !0, this._socket.pause()
        }
        ping(v, z, U) {
            if (this.readyState === d6.CONNECTING) throw Error("WebSocket is not open: readyState 0 (CONNECTING)");
            if (typeof v === "function") U = v, v = z = void 0;
            else if (typeof z === "function") U = z, z = void 0;
            if (typeof v === "number") v = v.toString();
            if (this.readyState !== d6.OPEN) {
                rF(this, v, U);
                return
            }
            if (z === void 0) z = !this._isServer;
            this._sender.ping(v || kJ, z, U)
        }
        pong(v, z, U) {
            if (this.readyState === d6.CONNECTING) throw Error("WebSocket is not open: readyState 0 (CONNECTING)");
            if (typeof v === "function") U = v, v = z = void 0;
            else if (typeof z === "function") U = z, z = void 0;
            if (typeof v === "number") v = v.toString();
            if (this.readyState !== d6.OPEN) {
                rF(this, v, U);
                return
            }
            if (z === void 0) z = !this._isServer;
            this._sender.pong(v || kJ, z, U)
        }
        resume() {
            if (this.readyState === d6.CONNECTING || this.readyState === d6.CLOSED) return;
            if (this._paused = !1, !this._receiver._writableState.needDrain) this._socket.resume()
        }
        send(v, z, U) {
            if (this.readyState === d6.CONNECTING) throw Error("WebSocket is not open: readyState 0 (CONNECTING)");
            if (typeof z === "function") U = z, z = {};
            if (typeof v === "number") v = v.toString();
            if (this.readyState !== d6.OPEN) {
                rF(this, v, U);
                return
            }
            let V = {
                binary: typeof v !== "string",
                mask: !this._isServer,
                compress: !0,
                fin: !0,
                ...z
            };
            if (!this._extensions[m5.extensionName]) V.compress = !1;
            this._sender.send(v || kJ, V, U)
        }
        terminate() {
            if (this.readyState === d6.CLOSED) return;
            if (this.readyState === d6.CONNECTING) {
                k3(this, this._req, "WebSocket was closed before the connection was established");
                return
            }
            if (this._socket) this._readyState = d6.CLOSING, this._socket.destroy()
        }
    }
    Object.defineProperty(d6, "CONNECTING", {
        enumerable: !0,
        value: m9.indexOf("CONNECTING")
    });
    Object.defineProperty(d6.prototype, "CONNECTING", {
        enumerable: !0,
        value: m9.indexOf("CONNECTING")
    });
    Object.defineProperty(d6, "OPEN", {
        enumerable: !0,
        value: m9.indexOf("OPEN")
    });
    Object.defineProperty(d6.prototype, "OPEN", {
        enumerable: !0,
        value: m9.indexOf("OPEN")
    });
    Object.defineProperty(d6, "CLOSING", {
        enumerable: !0,
        value: m9.indexOf("CLOSING")
    });
    Object.defineProperty(d6.prototype, "CLOSING", {
        enumerable: !0,
        value: m9.indexOf("CLOSING")
    });
    Object.defineProperty(d6, "CLOSED", {
        enumerable: !0,
        value: m9.indexOf("CLOSED")
    });
    Object.defineProperty(d6.prototype, "CLOSED", {
        enumerable: !0,
        value: m9.indexOf("CLOSED")
    });
    ["binaryType", "bufferedAmount", "extensions", "isPaused", "protocol", "readyState", "url"].forEach((v) => {
        Object.defineProperty(d6.prototype, v, {
            enumerable: !0
        })
    });
    ["open", "error", "close", "message"].forEach((v) => {
        Object.defineProperty(d6.prototype, `on${v}`, {
            enumerable: !0,
            get() {
                for (let z of this.listeners(v))
                    if (z[dF]) return z[G26];
                return null
            },
            set(z) {
                for (let U of this.listeners(v))
                    if (U[dF]) {
                        this.removeListener(v, U);
                        break
                    } if (typeof z !== "function") return;
                this.addEventListener(v, z, {
                    [dF]: !0
                })
            }
        })
    });
    d6.prototype.addEventListener = M26;
    d6.prototype.removeEventListener = b26;
    xi.exports = d6;

    function vi(v, z, U, V) {
        let N = {
            allowSynchronousEvents: !0,
            autoPong: !0,
            protocolVersion: oF[1],
            maxPayload: 104857600,
            skipUTF8Validation: !1,
            perMessageDeflate: !0,
            followRedirects: !1,
            maxRedirects: 10,
            ...V,
            socketPath: void 0,
            hostname: void 0,
            protocol: void 0,
            timeout: void 0,
            method: "GET",
            host: void 0,
            path: void 0,
            port: void 0
        };
        if (v._autoPong = N.autoPong, !oF.includes(N.protocolVersion)) throw RangeError(`Unsupported protocol version: ${N.protocolVersion} (supported versions: ${oF.join(", ")})`);
        let K;
        if (z instanceof QF) K = z;
        else try {
            K = new QF(z)
        } catch (w) {
            throw SyntaxError(`Invalid URL: ${z}`)
        }
        if (K.protocol === "http:") K.protocol = "ws:";
        else if (K.protocol === "https:") K.protocol = "wss:";
        v._url = K.href;
        let x = K.protocol === "wss:",
            j = K.protocol === "ws+unix:",
            B;
        if (K.protocol !== "ws:" && !x && !j) B = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
        else if (j && !K.pathname) B = "The URL's pathname is empty";
        else if (K.hash) B = "The URL contains a fragment identifier";
        if (B) {
            let w = SyntaxError(B);
            if (v._redirects === 0) throw w;
            else {
                mJ(v, w);
                return
            }
        }
        let O = x ? 443 : 80,
            J = A26(16).toString("base64"),
            q = x ? q26.request : H26.request,
            H = new Set,
            D;
        if (N.createConnection = N.createConnection || (x ? _26 : P26), N.defaultPort = N.defaultPort || O, N.port = K.port || O, N.host = K.hostname.startsWith("[") ? K.hostname.slice(1, -1) : K.hostname, N.headers = {
                ...N.headers,
                "Sec-WebSocket-Version": N.protocolVersion,
                "Sec-WebSocket-Key": J,
                Connection: "Upgrade",
                Upgrade: "websocket"
            }, N.path = K.pathname + K.search, N.timeout = N.handshakeTimeout, N.perMessageDeflate) D = new m5(N.perMessageDeflate !== !0 ? N.perMessageDeflate : {}, !1, N.maxPayload), N.headers["Sec-WebSocket-Extensions"] = R26({
            [m5.extensionName]: D.offer()
        });
        if (U.length) {
            for (let w of U) {
                if (typeof w !== "string" || !S26.test(w) || H.has(w)) throw SyntaxError("An invalid or duplicated subprotocol was specified");
                H.add(w)
            }
            N.headers["Sec-WebSocket-Protocol"] = U.join(",")
        }
        if (N.origin)
            if (N.protocolVersion < 13) N.headers["Sec-WebSocket-Origin"] = N.origin;
            else N.headers.Origin = N.origin;
        if (K.username || K.password) N.auth = `${K.username}:${K.password}`;
        if (j) {
            let w = N.path.split(":");
            N.socketPath = w[0], N.path = w[1]
        }
        let A;
        if (N.followRedirects) {
            if (v._redirects === 0) {
                v._originalIpc = j, v._originalSecure = x, v._originalHostOrSocketPath = j ? N.socketPath : K.host;
                let w = V && V.headers;
                if (V = {
                        ...V,
                        headers: {}
                    }, w)
                    for (let [Z, $] of Object.entries(w)) V.headers[Z.toLowerCase()] = $
            } else if (v.listenerCount("redirect") === 0) {
                let w = j ? v._originalIpc ? N.socketPath === v._originalHostOrSocketPath : !1 : v._originalIpc ? !1 : K.host === v._originalHostOrSocketPath;
                if (!w || v._originalSecure && !x) {
                    if (delete N.headers.authorization, delete N.headers.cookie, !w) delete N.headers.host;
                    N.auth = void 0
                }
            }
            if (N.auth && !V.headers.authorization) V.headers.authorization = "Basic " + Buffer.from(N.auth).toString("base64");
            if (A = v._req = q(N), v._redirects) v.emit("redirect", v.url, A)
        } else A = v._req = q(N);
        if (N.timeout) A.on("timeout", () => {
            k3(v, A, "Opening handshake has timed out")
        });
        if (A.on("error", (w) => {
                if (A === null || A[ec]) return;
                A = v._req = null, mJ(v, w)
            }), A.on("response", (w) => {
                let Z = w.headers.location,
                    $ = w.statusCode;
                if (Z && N.followRedirects && $ >= 300 && $ < 400) {
                    if (++v._redirects > N.maxRedirects) {
                        k3(v, A, "Maximum redirects exceeded");
                        return
                    }
                    A.abort();
                    let F;
                    try {
                        F = new QF(Z, z)
                    } catch (L) {
                        let G = SyntaxError(`Invalid URL: ${Z}`);
                        mJ(v, G);
                        return
                    }
                    vi(v, F, U, V)
                } else if (!v.emit("unexpected-response", A, w)) k3(v, A, `Unexpected server response: ${w.statusCode}`)
            }), A.on("upgrade", (w, Z, $) => {
                if (v.emit("upgrade", w), v.readyState !== d6.CONNECTING) return;
                A = v._req = null;
                let F = w.headers.upgrade;
                if (F === void 0 || F.toLowerCase() !== "websocket") {
                    k3(v, Z, "Invalid Upgrade header");
                    return
                }
                let L = $26("sha1").update(J + F26).digest("base64");
                if (w.headers["sec-websocket-accept"] !== L) {
                    k3(v, Z, "Invalid Sec-WebSocket-Accept header");
                    return
                }
                let G = w.headers["sec-websocket-protocol"],
                    I;
                if (G !== void 0) {
                    if (!H.size) I = "Server sent a subprotocol but none was requested";
                    else if (!H.has(G)) I = "Server sent an invalid subprotocol"
                } else if (H.size) I = "Server sent no subprotocol";
                if (I) {
                    k3(v, Z, I);
                    return
                }
                if (G) v._protocol = G;
                let M = w.headers["sec-websocket-extensions"];
                if (M !== void 0) {
                    if (!D) {
                        k3(v, Z, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
                        return
                    }
                    let b;
                    try {
                        b = W26(M)
                    } catch (E) {
                        k3(v, Z, "Invalid Sec-WebSocket-Extensions header");
                        return
                    }
                    let W = Object.keys(b);
                    if (W.length !== 1 || W[0] !== m5.extensionName) {
                        k3(v, Z, "Server indicated an extension that was not requested");
                        return
                    }
                    try {
                        D.accept(b[m5.extensionName])
                    } catch (E) {
                        k3(v, Z, "Invalid Sec-WebSocket-Extensions header");
                        return
                    }
                    v._extensions[m5.extensionName] = D
                }
                v.setSocket(Z, $, {
                    allowSynchronousEvents: N.allowSynchronousEvents,
                    generateMask: N.generateMask,
                    maxPayload: N.maxPayload,
                    skipUTF8Validation: N.skipUTF8Validation
                })
            }), N.finishRequest) N.finishRequest(A, v);
        else A.end()
    }

    function mJ(v, z) {
        v._readyState = d6.CLOSING, v._errorEmitted = !0, v.emit("error", z), v.emitClose()
    }

    function P26(v) {
        return v.path = v.socketPath, tc.connect(v)
    }

    function _26(v) {
        if (v.path = void 0, !v.servername && v.servername !== "") v.servername = tc.isIP(v.host) ? "" : v.host;
        return D26.connect(v)
    }

    function k3(v, z, U) {
        v._readyState = d6.CLOSING;
        let V = Error(U);
        if (Error.captureStackTrace(V, k3), z.setHeader) {
            if (z[ec] = !0, z.abort(), z.socket && !z.socket.destroyed) z.socket.destroy();
            process.nextTick(mJ, v, V)
        } else z.destroy(V), z.once("error", v.emit.bind(v, "error")), z.once("close", v.emitClose.bind(v))
    }

    function rF(v, z, U) {
        if (z) {
            let V = L26(z) ? z.size : E26(z).length;
            if (v._socket) v._sender._bufferedBytes += V;
            else v._bufferedAmount += V
        }
        if (U) {
            let V = Error(`WebSocket is not open: readyState ${v.readyState} (${m9[v.readyState]})`);
            process.nextTick(U, V)
        }
    }

    function C26(v, z) {
        let U = this[C4];
        if (U._closeFrameReceived = !0, U._closeMessage = z, U._closeCode = v, U._socket[C4] === void 0) return;
        if (U._socket.removeListener("data", XJ), process.nextTick(zi, U._socket), v === 1005) U.close();
        else U.close(v, z)
    }

    function f26() {
        let v = this[C4];
        if (!v.isPaused) v._socket.resume()
    }

    function T26(v) {
        let z = this[C4];
        if (z._socket[C4] !== void 0) z._socket.removeListener("data", XJ), process.nextTick(zi, z._socket), z.close(v[I26]);
        if (!z._errorEmitted) z._errorEmitted = !0, z.emit("error", v)
    }

    function ac() {
        this[C4].emitClose()
    }

    function Y26(v, z) {
        this[C4].emit("message", v, z)
    }

    function u26(v) {
        let z = this[C4];
        if (z._autoPong) z.pong(v, !this._isServer, sc);
        z.emit("ping", v)
    }

    function y26(v) {
        this[C4].emit("pong", v)
    }

    function zi(v) {
        v.resume()
    }

    function k26(v) {
        let z = this[C4];
        if (z.readyState === d6.CLOSED) return;
        if (z.readyState === d6.OPEN) z._readyState = d6.CLOSING, Ui(z);
        if (this._socket.end(), !z._errorEmitted) z._errorEmitted = !0, z.emit("error", v)
    }

    function Ui(v) {
        v._closeTimer = setTimeout(v._socket.destroy.bind(v._socket), 30000)
    }

    function Vi() {
        let v = this[C4];
        this.removeListener("close", Vi), this.removeListener("data", XJ), this.removeListener("end", Ni), v._readyState = d6.CLOSING;
        let z;
        if (!this._readableState.endEmitted && !v._closeFrameReceived && !v._receiver._writableState.errorEmitted && (z = v._socket.read()) !== null) v._receiver.write(z);
        if (v._receiver.end(), this[C4] = void 0, clearTimeout(v._closeTimer), v._receiver._writableState.finished || v._receiver._writableState.errorEmitted) v.emitClose();
        else v._receiver.on("error", ac), v._receiver.on("finish", ac)
    }

    function XJ(v) {
        if (!this[C4]._receiver.write(v)) this.pause()
    }

    function Ni() {
        let v = this[C4];
        v._readyState = d6.CLOSING, v._receiver.end(), this.end()
    }

    function Ki() {
        let v = this[C4];
        if (this.removeListener("error", Ki), this.on("error", sc), v) v._readyState = d6.CLOSING, this.destroy()
    }
});
var Ji = _((Zg6, Oi) => {
    var wg6 = gJ(),
        {
            Duplex: m26
        } = require("stream");

    function ji(v) {
        v.emit("close")
    }

    function X26() {
        if (!this.destroyed && this._writableState.finished) this.destroy()
    }

    function Bi(v) {
        if (this.removeListener("error", Bi), this.destroy(), this.listenerCount("error") === 0) this.emit("error", v)
    }

    function g26(v, z) {
        let U = !0,
            V = new m26({
                ...z,
                autoDestroy: !1,
                emitClose: !1,
                objectMode: !1,
                writableObjectMode: !1
            });
        return v.on("message", function(K, x) {
            let j = !x && V._readableState.objectMode ? K.toString() : K;
            if (!V.push(j)) v.pause()
        }), v.once("error", function(K) {
            if (V.destroyed) return;
            U = !1, V.destroy(K)
        }), v.once("close", function() {
            if (V.destroyed) return;
            V.push(null)
        }), V._destroy = function(N, K) {
            if (v.readyState === v.CLOSED) {
                K(N), process.nextTick(ji, V);
                return
            }
            let x = !1;
            if (v.once("error", function(B) {
                    x = !0, K(B)
                }), v.once("close", function() {
                    if (!x) K(N);
                    process.nextTick(ji, V)
                }), U) v.terminate()
        }, V._final = function(N) {
            if (v.readyState === v.CONNECTING) {
                v.once("open", function() {
                    V._final(N)
                });
                return
            }
            if (v._socket === null) return;
            if (v._socket._writableState.finished) {
                if (N(), V._readableState.endEmitted) V.destroy()
            } else v._socket.once("finish", function() {
                N()
            }), v.close()
        }, V._read = function() {
            if (v.isPaused) v.resume()
        }, V._write = function(N, K, x) {
            if (v.readyState === v.CONNECTING) {
                v.once("open", function() {
                    V._write(N, K, x)
                });
                return
            }
            v.send(N, x)
        }, V.on("end", X26), V.on("error", Bi), V
    }
    Oi.exports = g26
});
var Hi = _((Lg6, qi) => {
    var {
        tokenChars: c26
    } = n1();

    function i26(v) {
        let z = new Set,
            U = -1,
            V = -1,
            N = 0;
        for (N; N < v.length; N++) {
            let x = v.charCodeAt(N);
            if (V === -1 && c26[x] === 1) {
                if (U === -1) U = N
            } else if (N !== 0 && (x === 32 || x === 9)) {
                if (V === -1 && U !== -1) V = N
            } else if (x === 44) {
                if (U === -1) throw SyntaxError(`Unexpected character at index ${N}`);
                if (V === -1) V = N;
                let j = v.slice(U, V);
                if (z.has(j)) throw SyntaxError(`The "${j}" subprotocol is duplicated`);
                z.add(j), U = V = -1
            } else throw SyntaxError(`Unexpected character at index ${N}`)
        }
        if (U === -1 || V !== -1) throw SyntaxError("Unexpected end of input");
        let K = v.slice(U, N);
        if (z.has(K)) throw SyntaxError(`The "${K}" subprotocol is duplicated`);
        return z.add(K), z
    }
    qi.exports = {
        parse: i26
    }
});
var Zi = _((Gg6, wi) => {
    var l26 = require("events"),
        cJ = require("http"),
        {
            Duplex: Fg6
        } = require("stream"),
        {
            createHash: h26
        } = require("crypto"),
        Di = nF(),
        T7 = WN(),
        p26 = Hi(),
        n26 = gJ(),
        {
            GUID: Q26,
            kWebSocket: d26
        } = y9(),
        o26 = /^[+/0-9A-Za-z]{22}==$/;
    class $i extends l26 {
        constructor(v, z) {
            super();
            if (v = {
                    allowSynchronousEvents: !0,
                    autoPong: !0,
                    maxPayload: 104857600,
                    skipUTF8Validation: !1,
                    perMessageDeflate: !1,
                    handleProtocols: null,
                    clientTracking: !0,
                    verifyClient: null,
                    noServer: !1,
                    backlog: null,
                    server: null,
                    host: null,
                    path: null,
                    port: null,
                    WebSocket: n26,
                    ...v
                }, v.port == null && !v.server && !v.noServer || v.port != null && (v.server || v.noServer) || v.server && v.noServer) throw TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
            if (v.port != null) this._server = cJ.createServer((U, V) => {
                let N = cJ.STATUS_CODES[426];
                V.writeHead(426, {
                    "Content-Length": N.length,
                    "Content-Type": "text/plain"
                }), V.end(N)
            }), this._server.listen(v.port, v.host, v.backlog, z);
            else if (v.server) this._server = v.server;
            if (this._server) {
                let U = this.emit.bind(this, "connection");
                this._removeListeners = r26(this._server, {
                    listening: this.emit.bind(this, "listening"),
                    error: this.emit.bind(this, "error"),
                    upgrade: (V, N, K) => {
                        this.handleUpgrade(V, N, K, U)
                    }
                })
            }
            if (v.perMessageDeflate === !0) v.perMessageDeflate = {};
            if (v.clientTracking) this.clients = new Set, this._shouldEmitClose = !1;
            this.options = v, this._state = 0
        }
        address() {
            if (this.options.noServer) throw Error('The server is operating in "noServer" mode');
            if (!this._server) return null;
            return this._server.address()
        }
        close(v) {
            if (this._state === 2) {
                if (v) this.once("close", () => {
                    v(Error("The server is not running"))
                });
                process.nextTick(_N, this);
                return
            }
            if (v) this.once("close", v);
            if (this._state === 1) return;
            if (this._state = 1, this.options.noServer || this.options.server) {
                if (this._server) this._removeListeners(), this._removeListeners = this._server = null;
                if (this.clients)
                    if (!this.clients.size) process.nextTick(_N, this);
                    else this._shouldEmitClose = !0;
                else process.nextTick(_N, this)
            } else {
                let z = this._server;
                this._removeListeners(), this._removeListeners = this._server = null, z.close(() => {
                    _N(this)
                })
            }
        }
        shouldHandle(v) {
            if (this.options.path) {
                let z = v.url.indexOf("?");
                if ((z !== -1 ? v.url.slice(0, z) : v.url) !== this.options.path) return !1
            }
            return !0
        }
        handleUpgrade(v, z, U, V) {
            z.on("error", Ai);
            let N = v.headers["sec-websocket-key"],
                K = v.headers.upgrade,
                x = +v.headers["sec-websocket-version"];
            if (v.method !== "GET") {
                Y7(this, v, z, 405, "Invalid HTTP method");
                return
            }
            if (K === void 0 || K.toLowerCase() !== "websocket") {
                Y7(this, v, z, 400, "Invalid Upgrade header");
                return
            }
            if (N === void 0 || !o26.test(N)) {
                Y7(this, v, z, 400, "Missing or invalid Sec-WebSocket-Key header");
                return
            }
            if (x !== 13 && x !== 8) {
                Y7(this, v, z, 400, "Missing or invalid Sec-WebSocket-Version header", {
                    "Sec-WebSocket-Version": "13, 8"
                });
                return
            }
            if (!this.shouldHandle(v)) {
                CN(z, 400);
                return
            }
            let j = v.headers["sec-websocket-protocol"],
                B = new Set;
            if (j !== void 0) try {
                B = p26.parse(j)
            } catch (q) {
                Y7(this, v, z, 400, "Invalid Sec-WebSocket-Protocol header");
                return
            }
            let O = v.headers["sec-websocket-extensions"],
                J = {};
            if (this.options.perMessageDeflate && O !== void 0) {
                let q = new T7(this.options.perMessageDeflate, !0, this.options.maxPayload);
                try {
                    let H = Di.parse(O);
                    if (H[T7.extensionName]) q.accept(H[T7.extensionName]), J[T7.extensionName] = q
                } catch (H) {
                    Y7(this, v, z, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
                    return
                }
            }
            if (this.options.verifyClient) {
                let q = {
                    origin: v.headers[`${x===8?"sec-websocket-origin":"origin"}`],
                    secure: !!(v.socket.authorized || v.socket.encrypted),
                    req: v
                };
                if (this.options.verifyClient.length === 2) {
                    this.options.verifyClient(q, (H, D, A, w) => {
                        if (!H) return CN(z, D || 401, A, w);
                        this.completeUpgrade(J, N, B, v, z, U, V)
                    });
                    return
                }
                if (!this.options.verifyClient(q)) return CN(z, 401)
            }
            this.completeUpgrade(J, N, B, v, z, U, V)
        }
        completeUpgrade(v, z, U, V, N, K, x) {
            if (!N.readable || !N.writable) return N.destroy();
            if (N[d26]) throw Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
            if (this._state > 0) return CN(N, 503);
            let B = ["HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", `Sec-WebSocket-Accept: ${h26("sha1").update(z+Q26).digest("base64")}`],
                O = new this.options.WebSocket(null, void 0, this.options);
            if (U.size) {
                let J = this.options.handleProtocols ? this.options.handleProtocols(U, V) : U.values().next().value;
                if (J) B.push(`Sec-WebSocket-Protocol: ${J}`), O._protocol = J
            }
            if (v[T7.extensionName]) {
                let J = v[T7.extensionName].params,
                    q = Di.format({
                        [T7.extensionName]: [J]
                    });
                B.push(`Sec-WebSocket-Extensions: ${q}`), O._extensions = v
            }
            if (this.emit("headers", B, V), N.write(B.concat(`\r
`).join(`\r
`)), N.removeListener("error", Ai), O.setSocket(N, K, {
                    allowSynchronousEvents: this.options.allowSynchronousEvents,
                    maxPayload: this.options.maxPayload,
                    skipUTF8Validation: this.options.skipUTF8Validation
                }), this.clients) this.clients.add(O), O.on("close", () => {
                if (this.clients.delete(O), this._shouldEmitClose && !this.clients.size) process.nextTick(_N, this)
            });
            x(O, V)
        }
    }
    wi.exports = $i;

    function r26(v, z) {
        for (let U of Object.keys(z)) v.on(U, z[U]);
        return function() {
            for (let V of Object.keys(z)) v.removeListener(V, z[V])
        }
    }

    function _N(v) {
        v._state = 2, v.emit("close")
    }

    function Ai() {
        this.destroy()
    }

    function CN(v, z, U, V) {
        U = U || cJ.STATUS_CODES[z], V = {
            Connection: "close",
            "Content-Type": "text/html",
            "Content-Length": Buffer.byteLength(U),
            ...V
        }, v.once("finish", v.destroy), v.end(`HTTP/1.1 ${z} ${cJ.STATUS_CODES[z]}\r
` + Object.keys(V).map((N) => `${N}: ${V[N]}`).join(`\r
`) + `\r
\r
` + U)
    }

    function Y7(v, z, U, V, N, K) {
        if (v.listenerCount("wsClientError")) {
            let x = Error(N);
            Error.captureStackTrace(x, Y7), v.emit("wsClientError", x, U, z)
        } else CN(U, V, N, K)
    }
});
var qA6 = {};
S8(qA6, {
    openTabs: () => JA6,
    deactivate: () => OA6,
    activate: () => NA6
});
module.exports = Xi(qA6);
var L6 = o(require("vscode"));
var M0 = o(require("vscode")),
    mg = o(require("path")),
    bF = o(require("os")),
    RF = o(require("fs"));
var OG = require("crypto");

function e8() {
    return OG.randomBytes(16).toString("hex")
}
var P4 = o(require("fs"));
var rI = require("node:buffer"),
    aI = o(require("node:path")),
    pN = o(require("node:child_process")),
    Uz = o(require("node:process")),
    tI = o(eJ(), 1);

function vq(v) {
    let z = typeof v === "string" ? `
` : `
`.charCodeAt(),
        U = typeof v === "string" ? "\r" : "\r".charCodeAt();
    if (v[v.length - 1] === z) v = v.slice(0, -1);
    if (v[v.length - 1] === U) v = v.slice(0, -1);
    return v
}
var e1 = o(require("node:process")),
    X7 = o(require("node:path")),
    zq = require("node:url");

function YN(v = {}) {
    let {
        env: z = process.env,
        platform: U = process.platform
    } = v;
    if (U !== "win32") return "PATH";
    return Object.keys(z).reverse().find((V) => V.toUpperCase() === "PATH") || "Path"
}
var ql = ({
        cwd: v = e1.default.cwd(),
        path: z = e1.default.env[YN()],
        preferLocal: U = !0,
        execPath: V = e1.default.execPath,
        addExecPath: N = !0
    } = {}) => {
        let K = v instanceof URL ? zq.fileURLToPath(v) : v,
            x = X7.default.resolve(K),
            j = [];
        if (U) Hl(j, x);
        if (N) Dl(j, V, x);
        return [...j, z].join(X7.default.delimiter)
    },
    Hl = (v, z) => {
        let U;
        while (U !== z) v.push(X7.default.join(z, "node_modules/.bin")), U = z, z = X7.default.resolve(z, "..")
    },
    Dl = (v, z, U) => {
        let V = z instanceof URL ? zq.fileURLToPath(z) : z;
        v.push(X7.default.resolve(U, V, ".."))
    },
    tG = ({
        env: v = e1.default.env,
        ...z
    } = {}) => {
        v = {
            ...v
        };
        let U = YN({
            env: v
        });
        return z.path = v[U], v[U] = ql(z), v
    };
var Al = (v, z, U, V) => {
        if (U === "length" || U === "prototype") return;
        if (U === "arguments" || U === "caller") return;
        let N = Object.getOwnPropertyDescriptor(v, U),
            K = Object.getOwnPropertyDescriptor(z, U);
        if (!$l(N, K) && V) return;
        Object.defineProperty(v, U, K)
    },
    $l = function(v, z) {
        return v === void 0 || v.configurable || v.writable === z.writable && v.enumerable === z.enumerable && v.configurable === z.configurable && (v.writable || v.value === z.value)
    },
    wl = (v, z) => {
        let U = Object.getPrototypeOf(z);
        if (U === Object.getPrototypeOf(v)) return;
        Object.setPrototypeOf(v, U)
    },
    Zl = (v, z) => `/* Wrapped ${v}*/
${z}`,
    Ll = Object.getOwnPropertyDescriptor(Function.prototype, "toString"),
    Fl = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"),
    Gl = (v, z, U) => {
        let V = U === "" ? "" : `with ${U.trim()}() `,
            N = Zl.bind(null, V, z.toString());
        Object.defineProperty(N, "name", Fl), Object.defineProperty(v, "toString", {
            ...Ll,
            value: N
        })
    };

function Uq(v, z, {
    ignoreNonConfigurable: U = !1
} = {}) {
    let {
        name: V
    } = v;
    for (let N of Reflect.ownKeys(z)) Al(v, z, N, U);
    return wl(v, z), Gl(v, z, V), v
}
var uN = new WeakMap,
    sG = (v, z = {}) => {
        if (typeof v !== "function") throw TypeError("Expected a function");
        let U, V = 0,
            N = v.displayName || v.name || "<anonymous>",
            K = function(...x) {
                if (uN.set(K, ++V), V === 1) U = v.apply(this, x), v = null;
                else if (z.throw === !0) throw Error(`Function \`${N}\` can only be called once`);
                return U
            };
        return Uq(K, v), uN.set(K, V), K
    };
sG.callCount = (v) => {
    if (!uN.has(v)) throw Error(`The given function \`${v.name}\` is not wrapped by the \`onetime\` package`);
    return uN.get(v)
};
var eG = sG;
var xI = o(require("node:process"));
var NI = require("node:os");
var vI = () => {
        let v = Vq - zI + 1;
        return Array.from({
            length: v
        }, Il)
    },
    Il = (v, z) => ({
        name: `SIGRT${z+1}`,
        number: zI + z,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
    }),
    zI = 34,
    Vq = 64;
var VI = require("node:os");
var UI = [{
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
}, {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
}, {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
}, {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
}, {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
}, {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
}, {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
}, {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
}, {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
}, {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
}, {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: !0
}, {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
}, {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
}, {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
}, {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
}, {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
}, {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
}, {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
}, {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
}, {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
}, {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: !0
}, {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: !0
}, {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
}, {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
}, {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
}, {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
}, {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
}, {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
}, {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
}, {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
}, {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
}, {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
}, {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
}, {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
}, {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
}, {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
}, {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
}, {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
}];
var Nq = () => {
        let v = vI();
        return [...UI, ...v].map(Ml)
    },
    Ml = ({
        name: v,
        number: z,
        description: U,
        action: V,
        forced: N = !1,
        standard: K
    }) => {
        let {
            signals: {
                [v]: x
            }
        } = VI.constants, j = x !== void 0;
        return {
            name: v,
            number: j ? x : z,
            description: U,
            supported: j,
            action: V,
            forced: N,
            standard: K
        }
    };
var bl = () => {
        let v = Nq();
        return Object.fromEntries(v.map(Rl))
    },
    Rl = ({
        name: v,
        number: z,
        description: U,
        supported: V,
        action: N,
        forced: K,
        standard: x
    }) => [v, {
        name: v,
        number: z,
        description: U,
        supported: V,
        action: N,
        forced: K,
        standard: x
    }],
    KI = bl(),
    Wl = () => {
        let v = Nq(),
            z = Vq + 1,
            U = Array.from({
                length: z
            }, (V, N) => El(N, v));
        return Object.assign({}, ...U)
    },
    El = (v, z) => {
        let U = Sl(v, z);
        if (U === void 0) return {};
        let {
            name: V,
            description: N,
            supported: K,
            action: x,
            forced: j,
            standard: B
        } = U;
        return {
            [v]: {
                name: V,
                number: v,
                description: N,
                supported: K,
                action: x,
                forced: j,
                standard: B
            }
        }
    },
    Sl = (v, z) => {
        let U = z.find(({
            name: V
        }) => NI.constants.signals[V] === v);
        if (U !== void 0) return U;
        return z.find((V) => V.number === v)
    },
    lA6 = Wl();
var Pl = ({
        timedOut: v,
        timeout: z,
        errorCode: U,
        signal: V,
        signalDescription: N,
        exitCode: K,
        isCanceled: x
    }) => {
        if (v) return `timed out after ${z} milliseconds`;
        if (x) return "was canceled";
        if (U !== void 0) return `failed with ${U}`;
        if (V !== void 0) return `was killed with ${V} (${N})`;
        if (K !== void 0) return `failed with exit code ${K}`;
        return "failed"
    },
    vz = ({
        stdout: v,
        stderr: z,
        all: U,
        error: V,
        signal: N,
        exitCode: K,
        command: x,
        escapedCommand: j,
        timedOut: B,
        isCanceled: O,
        killed: J,
        parsed: {
            options: {
                timeout: q,
                cwd: H = xI.default.cwd()
            }
        }
    }) => {
        K = K === null ? void 0 : K, N = N === null ? void 0 : N;
        let D = N === void 0 ? void 0 : KI[N].description,
            A = V && V.code,
            Z = `Command ${Pl({timedOut:B,timeout:q,errorCode:A,signal:N,signalDescription:D,exitCode:K,isCanceled:O})}: ${x}`,
            $ = Object.prototype.toString.call(V) === "[object Error]",
            F = $ ? `${Z}
${V.message}` : Z,
            L = [F, z, v].filter(Boolean).join(`
`);
        if ($) V.originalMessage = V.message, V.message = L;
        else V = Error(L);
        if (V.shortMessage = F, V.command = x, V.escapedCommand = j, V.exitCode = K, V.signal = N, V.signalDescription = D, V.stdout = v, V.stderr = z, V.cwd = H, U !== void 0) V.all = U;
        if ("bufferedData" in V) delete V.bufferedData;
        return V.failed = !0, V.timedOut = Boolean(B), V.isCanceled = O, V.killed = J && !B, V
    };
var yN = ["stdin", "stdout", "stderr"],
    _l = (v) => yN.some((z) => v[z] !== void 0),
    jI = (v) => {
        if (!v) return;
        let {
            stdio: z
        } = v;
        if (z === void 0) return yN.map((V) => v[V]);
        if (_l(v)) throw Error(`It's not possible to provide \`stdio\` in combination with one of ${yN.map((V)=>`\`${V}\``).join(", ")}`);
        if (typeof z === "string") return z;
        if (!Array.isArray(z)) throw TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof z}\``);
        let U = Math.max(z.length, yN.length);
        return Array.from({
            length: U
        }, (V, N) => z[N])
    };
var HI = o(require("node:os"));
var X5 = [];
X5.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") X5.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") X5.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
var kN = (v) => !!v && typeof v === "object" && typeof v.removeListener === "function" && typeof v.emit === "function" && typeof v.reallyExit === "function" && typeof v.listeners === "function" && typeof v.kill === "function" && typeof v.pid === "number" && typeof v.on === "function",
    Kq = Symbol.for("signal-exit emitter"),
    xq = globalThis,
    Cl = Object.defineProperty.bind(Object);
class BI {
    emitted = {
        afterExit: !1,
        exit: !1
    };
    listeners = {
        afterExit: [],
        exit: []
    };
    count = 0;
    id = Math.random();
    constructor() {
        if (xq[Kq]) return xq[Kq];
        Cl(xq, Kq, {
            value: this,
            writable: !1,
            enumerable: !1,
            configurable: !1
        })
    }
    on(v, z) {
        this.listeners[v].push(z)
    }
    removeListener(v, z) {
        let U = this.listeners[v],
            V = U.indexOf(z);
        if (V === -1) return;
        if (V === 0 && U.length === 1) U.length = 0;
        else U.splice(V, 1)
    }
    emit(v, z, U) {
        if (this.emitted[v]) return !1;
        this.emitted[v] = !0;
        let V = !1;
        for (let N of this.listeners[v]) V = N(z, U) === !0 || V;
        if (v === "exit") V = this.emit("afterExit", z, U) || V;
        return V
    }
}
class Bq {}
var fl = (v) => {
    return {
        onExit(z, U) {
            return v.onExit(z, U)
        },
        load() {
            return v.load()
        },
        unload() {
            return v.unload()
        }
    }
};
class OI extends Bq {
    onExit() {
        return () => {}
    }
    load() {}
    unload() {}
}
class JI extends Bq {
    #x = jq.platform === "win32" ? "SIGINT" : "SIGHUP";
    #z = new BI;
    #v;
    #N;
    #K;
    #V = {};
    #U = !1;
    constructor(v) {
        super();
        this.#v = v, this.#V = {};
        for (let z of X5) this.#V[z] = () => {
            let U = this.#v.listeners(z),
                {
                    count: V
                } = this.#z,
                N = v;
            if (typeof N.__signal_exit_emitter__ === "object" && typeof N.__signal_exit_emitter__.count === "number") V += N.__signal_exit_emitter__.count;
            if (U.length === V) {
                this.unload();
                let K = this.#z.emit("exit", null, z),
                    x = z === "SIGHUP" ? this.#x : z;
                if (!K) v.kill(v.pid, x)
            }
        };
        this.#K = v.reallyExit, this.#N = v.emit
    }
    onExit(v, z) {
        if (!kN(this.#v)) return () => {};
        if (this.#U === !1) this.load();
        let U = z?.alwaysLast ? "afterExit" : "exit";
        return this.#z.on(U, v), () => {
            if (this.#z.removeListener(U, v), this.#z.listeners.exit.length === 0 && this.#z.listeners.afterExit.length === 0) this.unload()
        }
    }
    load() {
        if (this.#U) return;
        this.#U = !0, this.#z.count += 1;
        for (let v of X5) try {
            let z = this.#V[v];
            if (z) this.#v.on(v, z)
        } catch (z) {}
        this.#v.emit = (v, ...z) => {
            return this.#B(v, ...z)
        }, this.#v.reallyExit = (v) => {
            return this.#j(v)
        }
    }
    unload() {
        if (!this.#U) return;
        this.#U = !1, X5.forEach((v) => {
            let z = this.#V[v];
            if (!z) throw Error("Listener not defined for signal: " + v);
            try {
                this.#v.removeListener(v, z)
            } catch (U) {}
        }), this.#v.emit = this.#N, this.#v.reallyExit = this.#K, this.#z.count -= 1
    }
    #j(v) {
        if (!kN(this.#v)) return 0;
        return this.#v.exitCode = v || 0, this.#z.emit("exit", this.#v.exitCode, null), this.#K.call(this.#v, this.#v.exitCode)
    }
    #B(v, ...z) {
        let U = this.#N;
        if (v === "exit" && kN(this.#v)) {
            if (typeof z[0] === "number") this.#v.exitCode = z[0];
            let V = U.call(this.#v, v, ...z);
            return this.#z.emit("exit", this.#v.exitCode, null), V
        } else return U.call(this.#v, v, ...z)
    }
}
var jq = globalThis.process,
    {
        onExit: qI,
        load: rA6,
        unload: aA6
    } = fl(kN(jq) ? new JI(jq) : new OI);
var Tl = 5000,
    DI = (v, z = "SIGTERM", U = {}) => {
        let V = v(z);
        return Yl(v, z, U, V), V
    },
    Yl = (v, z, U, V) => {
        if (!ul(z, U, V)) return;
        let N = kl(U),
            K = setTimeout(() => {
                v("SIGKILL")
            }, N);
        if (K.unref) K.unref()
    },
    ul = (v, {
        forceKillAfterTimeout: z
    }, U) => yl(v) && z !== !1 && U,
    yl = (v) => v === HI.default.constants.signals.SIGTERM || typeof v === "string" && v.toUpperCase() === "SIGTERM",
    kl = ({
        forceKillAfterTimeout: v = !0
    }) => {
        if (v === !0) return Tl;
        if (!Number.isFinite(v) || v < 0) throw TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${v}\` (${typeof v})`);
        return v
    },
    AI = (v, z) => {
        if (v.kill()) z.isCanceled = !0
    },
    ml = (v, z, U) => {
        v.kill(z), U(Object.assign(Error("Timed out"), {
            timedOut: !0,
            signal: z
        }))
    },
    $I = (v, {
        timeout: z,
        killSignal: U = "SIGTERM"
    }, V) => {
        if (z === 0 || z === void 0) return V;
        let N, K = new Promise((j, B) => {
                N = setTimeout(() => {
                    ml(v, U, B)
                }, z)
            }),
            x = V.finally(() => {
                clearTimeout(N)
            });
        return Promise.race([K, x])
    },
    wI = ({
        timeout: v
    }) => {
        if (v !== void 0 && (!Number.isFinite(v) || v < 0)) throw TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${v}\` (${typeof v})`)
    },
    ZI = async (v, {
        cleanup: z,
        detached: U
    }, V) => {
        if (!z || U) return V;
        let N = qI(() => {
            v.kill()
        });
        return V.finally(() => {
            N()
        })
    };
var LI = require("node:fs"),
    FI = require("node:child_process");

function mN(v) {
    return v !== null && typeof v === "object" && typeof v.pipe === "function"
}

function Oq(v) {
    return mN(v) && v.writable !== !1 && typeof v._write === "function" && typeof v._writableState === "object"
}
var Xl = (v) => v instanceof FI.ChildProcess && typeof v.then === "function",
    Jq = (v, z, U) => {
        if (typeof U === "string") return v[z].pipe(LI.createWriteStream(U)), v;
        if (Oq(U)) return v[z].pipe(U), v;
        if (!Xl(U)) throw TypeError("The second argument must be a string, a stream or an Execa child process.");
        if (!Oq(U.stdin)) throw TypeError("The target child process's stdin must be available.");
        return v[z].pipe(U.stdin), U
    },
    GI = (v) => {
        if (v.stdout !== null) v.pipeStdout = Jq.bind(void 0, v, "stdout");
        if (v.stderr !== null) v.pipeStderr = Jq.bind(void 0, v, "stderr");
        if (v.all !== void 0) v.pipeAll = Jq.bind(void 0, v, "all")
    };
var lN = require("node:fs"),
    TI = require("node:timers/promises");
var zz = async (v, {
    init: z,
    convertChunk: U,
    getSize: V,
    truncateChunk: N,
    addChunk: K,
    getFinalChunk: x,
    finalize: j
}, {
    maxBuffer: B = Number.POSITIVE_INFINITY
} = {}) => {
    if (!cl(v)) throw Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
    let O = z();
    O.length = 0;
    try {
        for await (let J of v) {
            let q = il(J),
                H = U[q](J, O);
            bI({
                convertedChunk: H,
                state: O,
                getSize: V,
                truncateChunk: N,
                addChunk: K,
                maxBuffer: B
            })
        }
        return gl({
            state: O,
            convertChunk: U,
            getSize: V,
            truncateChunk: N,
            addChunk: K,
            getFinalChunk: x,
            maxBuffer: B
        }), j(O)
    } catch (J) {
        throw J.bufferedData = j(O), J
    }
}, gl = ({
    state: v,
    getSize: z,
    truncateChunk: U,
    addChunk: V,
    getFinalChunk: N,
    maxBuffer: K
}) => {
    let x = N(v);
    if (x !== void 0) bI({
        convertedChunk: x,
        state: v,
        getSize: z,
        truncateChunk: U,
        addChunk: V,
        maxBuffer: K
    })
}, bI = ({
    convertedChunk: v,
    state: z,
    getSize: U,
    truncateChunk: V,
    addChunk: N,
    maxBuffer: K
}) => {
    let x = U(v),
        j = z.length + x;
    if (j <= K) {
        II(v, z, N, j);
        return
    }
    let B = V(v, K - z.length);
    if (B !== void 0) II(B, z, N, K);
    throw new qq
}, II = (v, z, U, V) => {
    z.contents = U(v, z, V), z.length = V
}, cl = (v) => typeof v === "object" && v !== null && typeof v[Symbol.asyncIterator] === "function", il = (v) => {
    let z = typeof v;
    if (z === "string") return "string";
    if (z !== "object" || v === null) return "others";
    if (globalThis.Buffer?.isBuffer(v)) return "buffer";
    let U = MI.call(v);
    if (U === "[object ArrayBuffer]") return "arrayBuffer";
    if (U === "[object DataView]") return "dataView";
    if (Number.isInteger(v.byteLength) && Number.isInteger(v.byteOffset) && MI.call(v.buffer) === "[object ArrayBuffer]") return "typedArray";
    return "others"
}, {
    toString: MI
} = Object.prototype;
class qq extends Error {
    name = "MaxBufferError";
    constructor() {
        super("maxBuffer exceeded")
    }
}
var Hq = (v) => v,
    Dq = () => {
        return
    },
    Aq = ({
        contents: v
    }) => v,
    XN = (v) => {
        throw Error(`Streams in object mode are not supported: ${String(v)}`)
    },
    gN = (v) => v.length;
async function $q(v, z) {
    return zz(v, al, z)
}
var ll = () => ({
        contents: new ArrayBuffer(0)
    }),
    hl = (v) => pl.encode(v),
    pl = new TextEncoder,
    RI = (v) => new Uint8Array(v),
    WI = (v) => new Uint8Array(v.buffer, v.byteOffset, v.byteLength),
    nl = (v, z) => v.slice(0, z),
    Ql = (v, {
        contents: z,
        length: U
    }, V) => {
        let N = PI() ? ol(z, V) : dl(z, V);
        return new Uint8Array(N).set(v, U), N
    },
    dl = (v, z) => {
        if (z <= v.byteLength) return v;
        let U = new ArrayBuffer(SI(z));
        return new Uint8Array(U).set(new Uint8Array(v), 0), U
    },
    ol = (v, z) => {
        if (z <= v.maxByteLength) return v.resize(z), v;
        let U = new ArrayBuffer(z, {
            maxByteLength: SI(z)
        });
        return new Uint8Array(U).set(new Uint8Array(v), 0), U
    },
    SI = (v) => EI ** Math.ceil(Math.log(v) / Math.log(EI)),
    EI = 2,
    rl = ({
        contents: v,
        length: z
    }) => PI() ? v : v.slice(0, z),
    PI = () => ("resize" in ArrayBuffer.prototype),
    al = {
        init: ll,
        convertChunk: {
            string: hl,
            buffer: RI,
            arrayBuffer: RI,
            dataView: WI,
            typedArray: WI,
            others: XN
        },
        getSize: gN,
        truncateChunk: nl,
        addChunk: Ql,
        getFinalChunk: Dq,
        finalize: rl
    };
async function cN(v, z) {
    if (!("Buffer" in globalThis)) throw Error("getStreamAsBuffer() is only supported in Node.js");
    try {
        return _I(await $q(v, z))
    } catch (U) {
        if (U.bufferedData !== void 0) U.bufferedData = _I(U.bufferedData);
        throw U
    }
}
var _I = (v) => globalThis.Buffer.from(v);
async function wq(v, z) {
    return zz(v, zh, z)
}
var tl = () => ({
        contents: "",
        textDecoder: new TextDecoder
    }),
    iN = (v, {
        textDecoder: z
    }) => z.decode(v, {
        stream: !0
    }),
    sl = (v, {
        contents: z
    }) => z + v,
    el = (v, z) => v.slice(0, z),
    vh = ({
        textDecoder: v
    }) => {
        let z = v.decode();
        return z === "" ? void 0 : z
    },
    zh = {
        init: tl,
        convertChunk: {
            string: Hq,
            buffer: iN,
            arrayBuffer: iN,
            dataView: iN,
            typedArray: iN,
            others: XN
        },
        getSize: gN,
        truncateChunk: el,
        addChunk: sl,
        getFinalChunk: vh,
        finalize: Aq
    };
var YI = o(fI(), 1),
    uI = (v) => {
        if (v !== void 0) throw TypeError("The `input` and `inputFile` options cannot be both set.")
    },
    Vh = ({
        input: v,
        inputFile: z
    }) => {
        if (typeof z !== "string") return v;
        return uI(v), lN.readFileSync(z)
    },
    yI = (v) => {
        let z = Vh(v);
        if (mN(z)) throw TypeError("The `input` option cannot be a stream in sync mode");
        return z
    },
    Nh = ({
        input: v,
        inputFile: z
    }) => {
        if (typeof z !== "string") return v;
        return uI(v), lN.createReadStream(z)
    },
    kI = (v, z) => {
        let U = Nh(z);
        if (U === void 0) return;
        if (mN(U)) U.pipe(v.stdin);
        else v.stdin.end(U)
    },
    mI = (v, {
        all: z
    }) => {
        if (!z || !v.stdout && !v.stderr) return;
        let U = YI.default();
        if (v.stdout) U.add(v.stdout);
        if (v.stderr) U.add(v.stderr);
        return U
    },
    Zq = async (v, z) => {
        if (!v || z === void 0) return;
        await TI.setTimeout(0), v.destroy();
        try {
            return await z
        } catch (U) {
            return U.bufferedData
        }
    }, Lq = (v, {
        encoding: z,
        buffer: U,
        maxBuffer: V
    }) => {
        if (!v || !U) return;
        if (z === "utf8" || z === "utf-8") return wq(v, {
            maxBuffer: V
        });
        if (z === null || z === "buffer") return cN(v, {
            maxBuffer: V
        });
        return Kh(v, V, z)
    }, Kh = async (v, z, U) => {
        return (await cN(v, {
            maxBuffer: z
        })).toString(U)
    }, XI = async ({
        stdout: v,
        stderr: z,
        all: U
    }, {
        encoding: V,
        buffer: N,
        maxBuffer: K
    }, x) => {
        let j = Lq(v, {
                encoding: V,
                buffer: N,
                maxBuffer: K
            }),
            B = Lq(z, {
                encoding: V,
                buffer: N,
                maxBuffer: K
            }),
            O = Lq(U, {
                encoding: V,
                buffer: N,
                maxBuffer: K * 2
            });
        try {
            return await Promise.all([x, j, B, O])
        } catch (J) {
            return Promise.all([{
                error: J,
                signal: J.signal,
                timedOut: J.timedOut
            }, Zq(v, j), Zq(z, B), Zq(U, O)])
        }
    };
var xh = (async () => {})().constructor.prototype,
    jh = ["then", "catch", "finally"].map((v) => [v, Reflect.getOwnPropertyDescriptor(xh, v)]),
    Fq = (v, z) => {
        for (let [U, V] of jh) {
            let N = typeof z === "function" ? (...K) => Reflect.apply(V.value, z(), K) : V.value.bind(z);
            Reflect.defineProperty(v, U, {
                ...V,
                value: N
            })
        }
    },
    gI = (v) => new Promise((z, U) => {
        if (v.on("exit", (V, N) => {
                z({
                    exitCode: V,
                    signal: N
                })
            }), v.on("error", (V) => {
                U(V)
            }), v.stdin) v.stdin.on("error", (V) => {
            U(V)
        })
    });
var lI = require("node:buffer"),
    hI = require("node:child_process"),
    pI = (v, z = []) => {
        if (!Array.isArray(z)) return [v];
        return [v, ...z]
    },
    Bh = /^[\w.-]+$/,
    Oh = (v) => {
        if (typeof v !== "string" || Bh.test(v)) return v;
        return `"${v.replaceAll('"',"\\\"")}"`
    },
    Gq = (v, z) => pI(v, z).join(" "),
    Iq = (v, z) => pI(v, z).map((U) => Oh(U)).join(" "),
    Jh = / +/g;
var cI = (v) => {
        let z = typeof v;
        if (z === "string") return v;
        if (z === "number") return String(v);
        if (z === "object" && v !== null && !(v instanceof hI.ChildProcess) && "stdout" in v) {
            let U = typeof v.stdout;
            if (U === "string") return v.stdout;
            if (lI.Buffer.isBuffer(v.stdout)) return v.stdout.toString();
            throw TypeError(`Unexpected "${U}" stdout in template expression`)
        }
        throw TypeError(`Unexpected "${z}" in template expression`)
    },
    iI = (v, z, U) => U || v.length === 0 || z.length === 0 ? [...v, ...z] : [...v.slice(0, -1), `${v.at(-1)}${z[0]}`, ...z.slice(1)],
    qh = ({
        templates: v,
        expressions: z,
        tokens: U,
        index: V,
        template: N
    }) => {
        let K = N ?? v.raw[V],
            x = K.split(Jh).filter(Boolean),
            j = iI(U, x, K.startsWith(" "));
        if (V === z.length) return j;
        let B = z[V],
            O = Array.isArray(B) ? B.map((J) => cI(J)) : [cI(B)];
        return iI(j, O, K.endsWith(" "))
    },
    Mq = (v, z) => {
        let U = [];
        for (let [V, N] of v.entries()) U = qh({
            templates: v,
            expressions: z,
            tokens: U,
            index: V,
            template: N
        });
        return U
    };
var nI = require("node:util"),
    QI = o(require("node:process")),
    dI = nI.debuglog("execa").enabled,
    hN = (v, z) => String(v).padStart(z, "0"),
    Hh = () => {
        let v = new Date;
        return `${hN(v.getHours(),2)}:${hN(v.getMinutes(),2)}:${hN(v.getSeconds(),2)}.${hN(v.getMilliseconds(),3)}`
    },
    bq = (v, {
        verbose: z
    }) => {
        if (!z) return;
        QI.default.stderr.write(`[${Hh()}] ${v}
`)
    };
var Dh = 1e8,
    Ah = ({
        env: v,
        extendEnv: z,
        preferLocal: U,
        localDir: V,
        execPath: N
    }) => {
        let K = z ? {
            ...Uz.default.env,
            ...v
        } : v;
        if (U) return tG({
            env: K,
            cwd: V,
            execPath: N
        });
        return K
    },
    sI = (v, z, U = {}) => {
        let V = tI.default._parse(v, z, U);
        if (v = V.command, z = V.args, U = V.options, U = {
                maxBuffer: Dh,
                buffer: !0,
                stripFinalNewline: !0,
                extendEnv: !0,
                preferLocal: !1,
                localDir: U.cwd || Uz.default.cwd(),
                execPath: Uz.default.execPath,
                encoding: "utf8",
                reject: !0,
                cleanup: !0,
                all: !1,
                windowsHide: !0,
                verbose: dI,
                ...U
            }, U.env = Ah(U), U.stdio = jI(U), Uz.default.platform === "win32" && aI.default.basename(v, ".exe") === "cmd") z.unshift("/q");
        return {
            file: v,
            args: z,
            options: U,
            parsed: V
        }
    },
    Vz = (v, z, U) => {
        if (typeof z !== "string" && !rI.Buffer.isBuffer(z)) return U === void 0 ? void 0 : "";
        if (v.stripFinalNewline) return vq(z);
        return z
    };

function g7(v, z, U) {
    let V = sI(v, z, U),
        N = Gq(v, z),
        K = Iq(v, z);
    bq(K, V.options), wI(V.options);
    let x;
    try {
        x = pN.default.spawn(V.file, V.args, V.options)
    } catch (D) {
        let A = new pN.default.ChildProcess,
            w = Promise.reject(vz({
                error: D,
                stdout: "",
                stderr: "",
                all: "",
                command: N,
                escapedCommand: K,
                parsed: V,
                timedOut: !1,
                isCanceled: !1,
                killed: !1
            }));
        return Fq(A, w), A
    }
    let j = gI(x),
        B = $I(x, V.options, j),
        O = ZI(x, V.options, B),
        J = {
            isCanceled: !1
        };
    x.kill = DI.bind(null, x.kill.bind(x)), x.cancel = AI.bind(null, x, J);
    let H = eG(async () => {
        let [{
            error: D,
            exitCode: A,
            signal: w,
            timedOut: Z
        }, $, F, L] = await XI(x, V.options, O), G = Vz(V.options, $), I = Vz(V.options, F), M = Vz(V.options, L);
        if (D || A !== 0 || w !== null) {
            let b = vz({
                error: D,
                exitCode: A,
                signal: w,
                stdout: G,
                stderr: I,
                all: M,
                command: N,
                escapedCommand: K,
                parsed: V,
                timedOut: Z,
                isCanceled: J.isCanceled || (V.options.signal ? V.options.signal.aborted : !1),
                killed: x.killed
            });
            if (!V.options.reject) return b;
            throw b
        }
        return {
            command: N,
            escapedCommand: K,
            exitCode: 0,
            stdout: G,
            stderr: I,
            all: M,
            failed: !1,
            timedOut: !1,
            isCanceled: !1,
            killed: !1
        }
    });
    return kI(x, V.options), x.all = mI(x, V.options), GI(x), Fq(x, H), x
}

function E3(v, z, U) {
    let V = sI(v, z, U),
        N = Gq(v, z),
        K = Iq(v, z);
    bq(K, V.options);
    let x = yI(V.options),
        j;
    try {
        j = pN.default.spawnSync(V.file, V.args, {
            ...V.options,
            input: x
        })
    } catch (J) {
        throw vz({
            error: J,
            stdout: "",
            stderr: "",
            all: "",
            command: N,
            escapedCommand: K,
            parsed: V,
            timedOut: !1,
            isCanceled: !1,
            killed: !1
        })
    }
    let B = Vz(V.options, j.stdout, j.error),
        O = Vz(V.options, j.stderr, j.error);
    if (j.error || j.status !== 0 || j.signal !== null) {
        let J = vz({
            stdout: B,
            stderr: O,
            error: j.error,
            signal: j.signal,
            exitCode: j.status,
            command: N,
            escapedCommand: K,
            parsed: V,
            timedOut: j.error && j.error.code === "ETIMEDOUT",
            isCanceled: !1,
            killed: j.signal !== null
        });
        if (!V.options.reject) return J;
        throw J
    }
    return {
        command: N,
        escapedCommand: K,
        exitCode: 0,
        stdout: B,
        stderr: O,
        failed: !1,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
    }
}
var $h = ({
        input: v,
        inputFile: z,
        stdio: U
    }) => v === void 0 && z === void 0 && U === void 0 ? {
        stdin: "inherit"
    } : {},
    oI = (v = {}) => ({
        preferLocal: !0,
        ...$h(v),
        ...v
    });

function eI(v) {
    function z(U, ...V) {
        if (!Array.isArray(U)) return eI({
            ...v,
            ...U
        });
        let [N, ...K] = Mq(U, V);
        return g7(N, K, oI(v))
    }
    return z.sync = (U, ...V) => {
        if (!Array.isArray(U)) throw TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
        let [N, ...K] = Mq(U, V);
        return E3(N, K, oI(v))
    }, z
}
var h$6 = eI();
var yg = o(Xq(), 1);
var hb = require("child_process");
class gq {
    logger;
    getClaudeBinary;
    constructor(v, z) {
        this.logger = v;
        this.getClaudeBinary = z
    }
    runClaudeCommand(v, z) {
        let U = this.runClaudeCommandRaw(v, z);
        return JSON.parse(U.stdout)
    }
    runClaudeCommandRaw(v, z) {
        let U = this.getClaudeBinary(),
            {
                pathToClaudeCodeExecutable: V
            } = U,
            {
                executableArgs: N,
                env: K
            } = U;
        if (!V) throw Error("Claude binary not available");
        let x = [...N, ...v];
        if (V.endsWith(".js")) x.unshift(V), V = "node";
        let j = hb.spawnSync(V, x, {
            cwd: z,
            env: {
                ...process.env,
                ...K
            },
            encoding: "utf-8",
            timeout: 30000
        });
        if (j.error) throw j.error;
        if (j.status !== 0) throw Error(`Claude CLI exited with code ${j.status}: ${j.stderr}`);
        return {
            stdout: j.stdout,
            stderr: j.stderr
        }
    }
    async listPlugins(v, z) {
        let U = ["plugin", "list", "--json"];
        if (z?.includeAvailable) U.push("--available");
        if (z?.includeAvailable) {
            let V = this.runClaudeCommand(U, v),
                N = V.installed.map((x) => ({
                    name: x.id,
                    manifest: {
                        name: x.id,
                        version: x.version
                    },
                    path: x.installPath,
                    source: x.id,
                    enabled: x.enabled,
                    mcpServers: x.mcpServers
                }));
            return {
                type: "list_plugins_response",
                available: V.available.map((x) => ({
                    entry: {
                        name: x.name,
                        description: x.description
                    },
                    marketplaceName: x.marketplaceName,
                    pluginId: x.pluginId,
                    isInstalled: !1,
                    source: x.source,
                    installCount: x.installCount
                })),
                installed: N,
                errors: []
            }
        } else {
            let N = this.runClaudeCommand(U, v).map((K) => ({
                name: K.id,
                manifest: {
                    name: K.id,
                    version: K.version
                },
                path: K.installPath,
                source: K.id,
                enabled: K.enabled,
                mcpServers: K.mcpServers
            }));
            return {
                type: "list_plugins_response",
                available: [],
                installed: N,
                errors: []
            }
        }
    }
    async listMarketplaces(v) {
        return {
            type: "list_marketplaces_response",
            marketplaces: this.runClaudeCommand(["plugin", "marketplace", "list", "--json"], v).map((V) => ({
                name: V.name,
                config: {
                    source: this.buildMarketplaceSource(V),
                    installLocation: V.installLocation
                },
                pluginCount: 0,
                installedCount: 0
            }))
        }
    }
    buildMarketplaceSource(v) {
        switch (v.source) {
            case "github":
                return {
                    source: "github", repo: v.repo ?? ""
                };
            case "git":
                return {
                    source: "git", url: v.url ?? ""
                };
            case "url":
                return {
                    source: "url", url: v.url ?? ""
                };
            case "directory":
                return {
                    source: "directory", path: v.path ?? ""
                };
            case "file":
                return {
                    source: "file", path: v.path ?? ""
                };
            case "npm":
                return {
                    source: "npm", package: v.package ?? ""
                };
            default:
                return {
                    source: "url", url: ""
                }
        }
    }
    async installPlugin(v, z, U) {
        return this.runClaudeCommandRaw(["plugin", "install", v, "--scope", z], U), this.logger.log(`Installed plugin ${v} in ${z} scope`), {
            type: "install_plugin_response",
            needsRestart: !0
        }
    }
    async uninstallPlugin(v, z) {
        return this.runClaudeCommandRaw(["plugin", "uninstall", v], z), this.logger.log(`Uninstalled plugin ${v}`), {
            type: "uninstall_plugin_response",
            needsRestart: !0
        }
    }
    async setPluginEnabled(v, z, U) {
        let V = z ? "enable" : "disable";
        return this.runClaudeCommandRaw(["plugin", V, v], U), this.logger.log(`Set plugin ${v} enabled=${z}`), {
            type: "set_plugin_enabled_response",
            needsRestart: !0
        }
    }
    async addMarketplace(v, z) {
        return this.runClaudeCommandRaw(["plugin", "marketplace", "add", v], z), this.logger.log(`Added marketplace: ${v}`), {
            type: "add_marketplace_response"
        }
    }
    async removeMarketplace(v, z) {
        return this.runClaudeCommandRaw(["plugin", "marketplace", "remove", v], z), this.logger.log(`Removed marketplace ${v}`), {
            type: "remove_marketplace_response"
        }
    }
    async refreshMarketplace(v, z) {
        return this.runClaudeCommandRaw(["plugin", "marketplace", "update", v], z), this.logger.log(`Refreshed marketplace ${v}`), {
            type: "refresh_marketplace_response"
        }
    }
}
class l7 {
    returned;
    queue = [];
    readResolve;
    readReject;
    isDone = !1;
    hasError;
    started = !1;
    constructor(v) {
        this.returned = v
    } [Symbol.asyncIterator]() {
        if (this.started) throw Error("Stream can only be iterated once");
        return this.started = !0, this
    }
    next() {
        if (this.queue.length > 0) return Promise.resolve({
            done: !1,
            value: this.queue.shift()
        });
        if (this.isDone) return Promise.resolve({
            done: !0,
            value: void 0
        });
        if (this.hasError) return Promise.reject(this.hasError);
        return new Promise((v, z) => {
            this.readResolve = v, this.readReject = z
        })
    }
    enqueue(v) {
        if (this.readResolve) {
            let z = this.readResolve;
            this.readResolve = void 0, this.readReject = void 0, z({
                done: !1,
                value: v
            })
        } else this.queue.push(v)
    }
    done() {
        if (this.isDone = !0, this.readResolve) {
            let v = this.readResolve;
            this.readResolve = void 0, this.readReject = void 0, v({
                done: !0,
                value: void 0
            })
        }
    }
    error(v) {
        if (this.hasError = v, this.readReject) {
            let z = this.readReject;
            this.readResolve = void 0, this.readReject = void 0, z(v)
        }
    }
    return () {
        if (this.isDone = !0, this.returned) this.returned();
        return Promise.resolve({
            done: !0,
            value: void 0
        })
    }
    static from(v) {
        let z = new l7;
        for (let U of v) z.enqueue(U);
        return z.done(), z
    }
}

function pb() {
    return {
        ["clawd"]: {
            light: "/resources/clawd.svg",
            dark: "/resources/clawd.svg"
        },
        ["welcome-art"]: {
            light: "/resources/welcome-art-light.svg",
            dark: "/resources/welcome-art-dark.svg"
        },
        ["clawd-with-grad-cap"]: {
            light: "/resources/ClawdWithGradCap.png",
            dark: "/resources/ClawdWithGradCap.png"
        },
        ["onboarding-highlight-text"]: {
            light: "/resources/HighlightText.jpg",
            dark: "/resources/HighlightText.jpg"
        },
        ["onboarding-accept-mode"]: {
            light: "/resources/AcceptMode.jpg",
            dark: "/resources/AcceptMode.jpg"
        },
        ["onboarding-plan-mode"]: {
            light: "/resources/PlanMode.jpg",
            dark: "/resources/PlanMode.jpg"
        }
    }
}

function nb() {
    return {
        ["clawd"]: {
            light: "./resources/clawd.svg",
            dark: "./resources/clawd.svg"
        },
        ["welcome-art"]: {
            light: "./resources/welcome-art-light.svg",
            dark: "./resources/welcome-art-dark.svg"
        },
        ["clawd-with-grad-cap"]: {
            light: "./resources/ClawdWithGradCap.png",
            dark: "./resources/ClawdWithGradCap.png"
        },
        ["onboarding-highlight-text"]: {
            light: "./resources/HighlightText.jpg",
            dark: "./resources/HighlightText.jpg"
        },
        ["onboarding-accept-mode"]: {
            light: "./resources/AcceptMode.jpg",
            dark: "./resources/AcceptMode.jpg"
        },
        ["onboarding-plan-mode"]: {
            light: "./resources/PlanMode.jpg",
            dark: "./resources/PlanMode.jpg"
        }
    }
}
var BT = require("child_process");
var g4 = require("path"),
    f4 = o(require("fs")),
    NK = require("crypto");
var Hz = o(require("path")),
    Qb = o(require("os"));

function h7() {
    if (process.env.CLAUDE_CONFIG_DIR) return process.env.CLAUDE_CONFIG_DIR;
    return Hz.join(Qb.homedir(), ".claude")
}

function Dz(v) {
    let z = Hz.join(h7(), "plans");
    return v.startsWith(z + Hz.sep)
}
var OQ = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

function JQ() {
    return g4.join(h7(), "projects")
}

function Az(v) {
    return g4.join(JQ(), v.replace(/[^a-zA-Z0-9]/g, "-"))
}

function cq(v, z) {
    return g4.join(h7(), "file-history", z, v)
}
class B3 {
    sessionMessages;
    messages;
    summaries;
    customTitles;
    projectRoot;
    fileModificationTimes;
    logger;
    fileHistorySnapshots;
    teleportedFromSessionIds;
    teleportBranches;
    teleportedMessageCounts;
    skippedBranches;
    branchCheckoutFailures;
    static cache = new Map;
    refreshing = Promise.resolve();
    constructor(v, z, U, V, N, K, x, j, B = new Map, O = new Map, J = new Map, q = new Map, H = new Map) {
        this.sessionMessages = v;
        this.messages = z;
        this.summaries = U;
        this.customTitles = V;
        this.projectRoot = N;
        this.fileModificationTimes = K;
        this.logger = x;
        this.fileHistorySnapshots = j;
        this.teleportedFromSessionIds = B;
        this.teleportBranches = O;
        this.teleportedMessageCounts = J;
        this.skippedBranches = q;
        this.branchCheckoutFailures = H
    }
    async fetchSessions() {
        return this.getTranscripts().map((z) => {
            let U = z[z.length - 1],
                V = z[0],
                N = DQ(z),
                K = U.sessionId,
                x = this.customTitles.get(K) || this.summaries.get(U.uuid) || N,
                j = this.teleportedFromSessionIds.get(K),
                B = this.teleportBranches.get(K),
                O = this.teleportedMessageCounts.get(K),
                J = this.skippedBranches.get(K),
                q = this.branchCheckoutFailures.get(K) ?? void 0;
            return {
                lastModified: new Date(U.timestamp).getTime(),
                messageCount: z.length,
                isSidechain: V.isSidechain,
                id: U.sessionId,
                summary: x,
                gitBranch: U.gitBranch,
                teleportedFromSessionId: j,
                teleportBranch: B,
                teleportedMessageCount: O,
                skippedBranch: J,
                branchCheckoutFailed: q
            }
        })
    }
    getTranscripts() {
        let v = [...this.messages.values()],
            z = new Set(v.map((U) => U.parentUuid));
        return v.filter((U) => !z.has(U.uuid)).map((U) => this.getTranscript(U)).filter((U) => U.length)
    }
    getSessionMessages(v) {
        let z = this.sessionMessages.get(v);
        if (!z) return [];
        let V = Array.from(this.messages.values()).filter((K) => z.has(K.uuid)).filter((K) => !K.isSidechain).sort((K, x) => new Date(x.timestamp).getTime() - new Date(K.timestamp).getTime())[0];
        if (!V) return [];
        return this.getTranscript(V).map(HQ).filter((K) => !!K)
    }
    async getSessionDiffs(v, z, U) {
        return
    }
    getTranscript(v, z = !1) {
        let U = [],
            V = v;
        while (V) {
            U.unshift(V);
            let N = V.parentUuid ?? (z ? V.logicalParentUuid : null);
            V = N ? this.messages.get(N) : void 0
        }
        return U
    }
    static async load(v, z) {
        let U = Az(v);
        if (!B3.cache.has(U)) {
            let N = new B3(new Map, new Map, new Map, new Map, v, new Map, z, new Map);
            B3.cache.set(U, N)
        }
        let V = B3.cache.get(U);
        return await V.refresh(), V
    }
    refresh() {
        return this.refreshing = this.refreshing.then(async () => this.performRefresh()), this.refreshing
    }
    async performRefresh() {
        let v = Az(this.projectRoot),
            z = await f4.promises.readdir(v),
            U = [];
        for (let V of z) {
            let N = g4.join(v, V);
            if (!N.endsWith(".jsonl")) continue;
            let K = qQ(g4.basename(N, ".jsonl"));
            if (!K) continue;
            try {
                let x = await f4.promises.stat(N),
                    j = this.fileModificationTimes.get(N) || 0;
                if (x.mtime.getTime() > j) U.push({
                    path: N,
                    sessionId: K,
                    mtime: x.mtime.getTime()
                })
            } catch {
                if (this.fileModificationTimes.has(N)) {
                    this.fileModificationTimes.delete(N), this.sessionMessages.delete(K);
                    for (let [x, j] of this.messages.entries())
                        if (j.sessionId === K) this.messages.delete(x)
                }
            }
        }
        for (let {
                path: V,
                sessionId: N,
                mtime: K
            }
            of U) {
            let x = this.sessionMessages.get(N);
            if (x)
                for (let q of x) this.messages.delete(q), this.summaries.delete(q), this.fileHistorySnapshots.delete(q);
            this.customTitles.delete(N);
            let j = new Map,
                B = new Map,
                O, J = new Map;
            try {
                let q = !1,
                    H = !1;
                for (let D of await db(V))
                    if (D.type === "user" || D.type === "assistant" || D.type === "attachment" || D.type === "system") {
                        if (!q) {
                            if (q = !0, D.isSidechain === !0) {
                                H = !0;
                                break
                            }
                        }
                        j.set(D.uuid, D)
                    } else if (D.type === "progress") j.set(D.uuid, D);
                else if (D.type === "summary" && D.leafUuid) B.set(D.leafUuid, D.summary);
                else if (D.type === "custom-title" && D.customTitle) O = D.customTitle;
                else if (D.type === "teleported-from" && D.remoteSessionId) {
                    if (this.teleportedFromSessionIds.set(N, D.remoteSessionId), D.branch) this.teleportBranches.set(N, D.branch);
                    if (D.messageCount !== void 0) this.teleportedMessageCounts.set(N, D.messageCount)
                } else if (D.type === "teleport-skipped-branch" && D.branch) {
                    if (this.skippedBranches.set(N, D.branch), D.failed) this.branchCheckoutFailures.set(N, !0)
                } else if (D.type === "file-history-snapshot") J.set(D.messageId, D);
                if (!H) {
                    this.sessionMessages.set(N, new Set(j.keys()));
                    for (let [D, A] of j.entries()) this.messages.set(D, A);
                    for (let [D, A] of B.entries()) this.summaries.set(D, A);
                    if (O) this.customTitles.set(N, O);
                    for (let [D, A] of J.entries()) this.fileHistorySnapshots.set(D, A);
                    this.fileModificationTimes.set(V, K)
                } else this.sessionMessages.delete(N), this.fileModificationTimes.delete(V)
            } catch {}
        }
    }
    async saveSession(v, z, U, V, N) {
        let K = Az(this.projectRoot),
            x = g4.join(K, `${v}.jsonl`);
        await f4.promises.mkdir(K, {
            recursive: !0
        });
        let j = "",
            B = new Set,
            O = new Map,
            J = null,
            q = Date.now(),
            H = 0;
        for (let D of z) {
            if (!("message" in D)) continue;
            let A = D.uuid || NK.randomUUID();
            B.add(A);
            let w = new Date(q + H).toISOString();
            H++;
            let Z;
            if (D.type === "user") Z = {
                type: "user",
                message: D.message,
                uuid: A,
                parentUuid: J,
                sessionId: v,
                timestamp: w,
                cwd: this.projectRoot,
                userType: "unknown",
                version: "1.0",
                isSidechain: !1
            };
            else if (D.type === "assistant") Z = {
                type: "assistant",
                message: D.message,
                uuid: A,
                parentUuid: J,
                sessionId: v,
                timestamp: w,
                cwd: this.projectRoot,
                userType: "unknown",
                version: "1.0",
                isSidechain: !1,
                requestId: A
            };
            else continue;
            O.set(A, Z), j += JSON.stringify(Z) + `
`, J = A
        }
        if (U && J) j += JSON.stringify({
            type: "summary",
            leafUuid: J,
            summary: U
        }) + `
`;
        if (V) {
            let D = O.size;
            if (j += JSON.stringify({
                    type: "teleported-from",
                    remoteSessionId: V,
                    branch: N,
                    messageCount: D
                }) + `
`, this.teleportedFromSessionIds.set(v, V), N) this.teleportBranches.set(v, N);
            this.teleportedMessageCounts.set(v, D)
        }
        await f4.promises.writeFile(x, j), this.sessionMessages.set(v, B);
        for (let [D, A] of O.entries()) this.messages.set(D, A);
        this.logger.log(`Saved teleported session ${v} with ${z.length} messages`)
    }
    async appendSkippedBranch(v, z, U) {
        let V = Az(this.projectRoot),
            N = g4.join(V, `${v}.jsonl`),
            K = {
                type: "teleport-skipped-branch",
                branch: z,
                failed: U
            };
        if (await f4.promises.appendFile(N, JSON.stringify(K) + `
`), this.skippedBranches.set(v, z), U) this.branchCheckoutFailures.set(v, !0)
    }
    async forkSession(v, z) {
        let U = this.sessionMessages.get(v);
        if (!U) throw Error(`Session ${v} not found`);
        let N = Array.from(this.messages.values()).filter((G) => U.has(G.uuid)).sort((G, I) => new Date(I.timestamp).getTime() - new Date(G.timestamp).getTime())[0];
        if (!N) throw Error(`No messages found for session ${v}`);
        let K = this.getTranscript(N, !!z);
        if (z) {
            let G = -1;
            for (let I = K.length - 1; I >= 0; I--)
                if (K[I].uuid === z) {
                    G = I;
                    break
                } if (G === -1) throw Error(`Message ${z} not found in session ${v}`);
            K = K.slice(0, G + 1)
        }
        let x = NK.randomUUID(),
            j = Az(this.projectRoot),
            B = g4.join(j, `${x}.jsonl`),
            O = K.length > 0 ? this.summaries.get(K[K.length - 1].uuid) : void 0,
            J = g4.join(j, `${v}.jsonl`),
            q = new Map;
        for (let G of await db(J))
            if (G.type === "file-history-snapshot") q.set(G.messageId, G);
        let H = new Map;
        for (let G of K) H.set(G.uuid, NK.randomUUID());
        let D = K.filter((G) => G.type !== "progress"),
            A = [],
            w = [],
            Z = "",
            $ = new Date().toISOString(),
            F = new Set;
        for (let G = 0; G < D.length; G++) {
            let I = D[G],
                M = H.get(I.uuid),
                b = null;
            if (I.parentUuid) {
                let T = I.parentUuid;
                while (T) {
                    let X = K.find((Q) => Q.uuid === T);
                    if (!X) break;
                    if (X.type !== "progress") {
                        b = H.get(T) || null;
                        break
                    }
                    T = X.parentUuid
                }
            }
            let W = G === D.length - 1 ? $ : I.timestamp,
                E = {
                    ...I,
                    uuid: M,
                    parentUuid: b,
                    sessionId: x,
                    timestamp: W
                };
            if (E.type === "assistant" && E.message) E = {
                ...E,
                message: {
                    ...E.message,
                    id: M
                }
            };
            A.push(E), Z += JSON.stringify(E) + `
`;
            let y = q.get(I.uuid);
            if (y) {
                let T = H.get(I.uuid),
                    X = {
                        ...y,
                        messageId: T,
                        snapshot: {
                            ...y.snapshot,
                            messageId: T
                        }
                    };
                Z += JSON.stringify(X) + `
`, w.push(X), AQ(y.snapshot, v, x, this.logger, F)
            }
        }
        await f4.promises.appendFile(B, Z);
        let L = A[A.length - 1]?.uuid;
        if (O && L) {
            let G = {
                type: "summary",
                leafUuid: L,
                summary: O
            };
            await f4.promises.appendFile(B, JSON.stringify(G) + `
`)
        }
        this.sessionMessages.set(x, new Set(A.map((G) => G.uuid)));
        for (let G of A) this.messages.set(G.uuid, G);
        for (let G of w) this.fileHistorySnapshots.set(G.messageId, G);
        if (O && L) this.summaries.set(L, O);
        return x
    }
}

function qQ(v) {
    if (typeof v !== "string") return null;
    return OQ.test(v) ? v : null
}
async function db(v) {
    try {
        let z = await f4.promises.readFile(v, "utf8");
        if (!z.trim()) return [];
        return z.split(`
`).filter((U) => U.trim()).map((U) => {
            try {
                return JSON.parse(U)
            } catch (V) {
                return null
            }
        }).filter((U) => U !== null)
    } catch (z) {
        return []
    }
}

function HQ(v) {
    if (v.type === "progress") return;
    if (v.isMeta) return;
    if (v.type === "user") return {
        type: "user",
        message: v.message,
        uuid: v.uuid,
        session_id: v.sessionId,
        parent_tool_use_id: null
    };
    else if (v.type === "assistant") return {
        type: "assistant",
        message: v.message,
        uuid: v.uuid,
        session_id: v.sessionId,
        parent_tool_use_id: null
    };
    else if (v.type === "system") return;
    else if (v.type === "attachment") return
}

function DQ(v) {
    let z;
    for (let N of v)
        if (N.type === "user" && !N.isMeta) z = N;
        else if (z) break;
    if (!z || z.type !== "user") return "No prompt";
    let U = z.message?.content,
        V = "";
    if (typeof U === "string") V = U;
    else if (Array.isArray(U)) V = U.findLast((K) => K.type === "text")?.text || "No prompt";
    else V = "No prompt";
    if (V = V.replace(/\n/g, " ").trim(), V.length > 45) V = V.slice(0, 45) + "...";
    return V
}
async function AQ(v, z, U, V, N) {
    for (let K of Object.values(v.trackedFileBackups)) {
        if (!K.backupFileName) continue;
        if (N.has(K.backupFileName)) continue;
        N.add(K.backupFileName);
        let x = cq(K.backupFileName, z),
            j = cq(K.backupFileName, U);
        if (!f4.existsSync(x)) {
            V.error(`FileHistory: Backup file does not exist at ${x}`);
            continue
        }
        if (f4.existsSync(j)) continue;
        let B = g4.dirname(j);
        if (!f4.existsSync(B)) await f4.promises.mkdir(B, {
            recursive: !0
        });
        try {
            await f4.promises.link(x, j), V.log(`FileHistory: Hard linked backup ${K.backupFileName} from ${z} to ${U}`)
        } catch {
            V.log(`FileHistory: Hard link failed, falling back to copy for ${K.backupFileName}`);
            try {
                await f4.promises.copyFile(x, j), V.log(`FileHistory: Copied backup ${K.backupFileName} from ${z} to ${U}`)
            } catch (O) {
                V.error(`FileHistory: Failed to copy backup ${K.backupFileName}: ${O}`)
            }
        }
    }
}

function $Q(v, z) {
    if (typeof v !== "object" || v === null) return null;
    let U = v;
    if (typeof U.filePath === "string" && typeof U.oldString === "string" && typeof U.newString === "string" && typeof U.originalFile === "string" && typeof U.replaceAll === "boolean") {
        let V = U.filePath.startsWith("/") ? U.filePath : g4.join(z, U.filePath),
            N = U.replaceAll ? U.originalFile.replaceAll(U.oldString, U.newString) : U.originalFile.replace(U.oldString, U.newString);
        return {
            filePath: V,
            oldContent: U.originalFile,
            newContent: N
        }
    }
    if (typeof U.filePath === "string" && typeof U.content === "string" && (U.type === "create" || U.type === "update")) {
        let V = U.filePath.startsWith("/") ? U.filePath : g4.join(z, U.filePath),
            N = typeof U.originalFile === "string" ? U.originalFile : null;
        return {
            filePath: V,
            oldContent: N,
            newContent: U.content
        }
    }
    return null
}
var ob = ["Edit", "Write"],
    S3 = {
        totalSessions: 0,
        recentSessions: 0,
        editsAccepted: 0,
        editsAutoAccepted: 0,
        editsDeclined: 0
    };

function rb() {
    return S3
}

function ab(v) {
    let z = Date.now(),
        U = 604800000,
        V = z - 604800000,
        N = v.length,
        K = v.filter((x) => x.lastModified >= V).length;
    return S3 = {
        ...S3,
        totalSessions: N,
        recentSessions: K
    }, S3
}

function tb(v, z) {
    if (ob.includes(v))
        if (z.result.behavior === "allow") S3 = {
            ...S3,
            editsAccepted: S3.editsAccepted + 1
        };
        else S3 = {
            ...S3,
            editsDeclined: S3.editsDeclined + 1
        }
}
var iq = new Set;

function sb(v) {
    if (v.type === "assistant" && Array.isArray(v.message.content)) {
        for (let z of v.message.content)
            if (z.type === "tool_use" && ob.includes(z.name)) iq.add(z.id)
    }
    if (v.type === "user" && Array.isArray(v.message.content)) {
        for (let z of v.message.content)
            if (z.type === "tool_result" && !z.is_error && iq.has(z.tool_use_id)) S3 = {
                ...S3,
                editsAutoAccepted: S3.editsAutoAccepted + 1
            }, iq.delete(z.tool_use_id)
    }
}
var tq = require("path"),
    rR = require("url"),
    aR = require("events"),
    sR = require("child_process"),
    eR = require("readline"),
    h6 = o(require("fs")),
    $4 = require("fs/promises"),
    NW = require("path"),
    KW = require("os"),
    Kv = require("path"),
    jW = require("process"),
    sq = require("fs"),
    BW = require("crypto"),
    wW = require("crypto"),
    xv = require("fs"),
    eq = require("path"),
    GW = require("crypto");
var wQ = Object.create,
    {
        getPrototypeOf: ZQ,
        defineProperty: aq,
        getOwnPropertyNames: LQ
    } = Object,
    FQ = Object.prototype.hasOwnProperty,
    cR = (v, z, U) => {
        U = v != null ? wQ(ZQ(v)) : {};
        let V = z || !v || !v.__esModule ? aq(U, "default", {
            value: v,
            enumerable: !0
        }) : U;
        for (let N of LQ(v))
            if (!FQ.call(V, N)) aq(V, N, {
                get: () => v[N],
                enumerable: !0
            });
        return V
    },
    J6 = (v, z) => () => (z || v((z = {
        exports: {}
    }).exports, z), z.exports),
    iR = (v, z) => {
        for (var U in z) aq(v, U, {
            get: z[U],
            enumerable: !0,
            configurable: !0,
            set: (V) => z[U] = () => V
        })
    };
var JK = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.regexpCode = v.getEsmExportName = v.getProperty = v.safeStringify = v.stringify = v.strConcat = v.addCodeArg = v.str = v._ = v.nil = v._Code = v.Name = v.IDENTIFIER = v._CodeOrName = void 0;
        class z {}
        v._CodeOrName = z, v.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class U extends z {
            constructor($) {
                super();
                if (!v.IDENTIFIER.test($)) throw Error("CodeGen: name must be a valid identifier");
                this.str = $
            }
            toString() {
                return this.str
            }
            emptyStr() {
                return !1
            }
            get names() {
                return {
                    [this.str]: 1
                }
            }
        }
        v.Name = U;
        class V extends z {
            constructor($) {
                super();
                this._items = typeof $ === "string" ? [$] : $
            }
            toString() {
                return this.str
            }
            emptyStr() {
                if (this._items.length > 1) return !1;
                let $ = this._items[0];
                return $ === "" || $ === '""'
            }
            get str() {
                var $;
                return ($ = this._str) !== null && $ !== void 0 ? $ : this._str = this._items.reduce((F, L) => `${F}${L}`, "")
            }
            get names() {
                var $;
                return ($ = this._names) !== null && $ !== void 0 ? $ : this._names = this._items.reduce((F, L) => {
                    if (L instanceof U) F[L.str] = (F[L.str] || 0) + 1;
                    return F
                }, {})
            }
        }
        v._Code = V, v.nil = new V("");

        function N($, ...F) {
            let L = [$[0]],
                G = 0;
            while (G < F.length) j(L, F[G]), L.push($[++G]);
            return new V(L)
        }
        v._ = N;
        var K = new V("+");

        function x($, ...F) {
            let L = [D($[0])],
                G = 0;
            while (G < F.length) L.push(K), j(L, F[G]), L.push(K, D($[++G]));
            return B(L), new V(L)
        }
        v.str = x;

        function j($, F) {
            if (F instanceof V) $.push(...F._items);
            else if (F instanceof U) $.push(F);
            else $.push(q(F))
        }
        v.addCodeArg = j;

        function B($) {
            let F = 1;
            while (F < $.length - 1) {
                if ($[F] === K) {
                    let L = O($[F - 1], $[F + 1]);
                    if (L !== void 0) {
                        $.splice(F - 1, 3, L);
                        continue
                    }
                    $[F++] = "+"
                }
                F++
            }
        }

        function O($, F) {
            if (F === '""') return $;
            if ($ === '""') return F;
            if (typeof $ == "string") {
                if (F instanceof U || $[$.length - 1] !== '"') return;
                if (typeof F != "string") return `${$.slice(0,-1)}${F}"`;
                if (F[0] === '"') return $.slice(0, -1) + F.slice(1);
                return
            }
            if (typeof F == "string" && F[0] === '"' && !($ instanceof U)) return `"${$}${F.slice(1)}`;
            return
        }

        function J($, F) {
            return F.emptyStr() ? $ : $.emptyStr() ? F : x`${$}${F}`
        }
        v.strConcat = J;

        function q($) {
            return typeof $ == "number" || typeof $ == "boolean" || $ === null ? $ : D(Array.isArray($) ? $.join(",") : $)
        }

        function H($) {
            return new V(D($))
        }
        v.stringify = H;

        function D($) {
            return JSON.stringify($).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
        }
        v.safeStringify = D;

        function A($) {
            return typeof $ == "string" && v.IDENTIFIER.test($) ? new V(`.${$}`) : N`[${$}]`
        }
        v.getProperty = A;

        function w($) {
            if (typeof $ == "string" && v.IDENTIFIER.test($)) return new V(`${$}`);
            throw Error(`CodeGen: invalid export name: ${$}, use explicit $id name mapping`)
        }
        v.getEsmExportName = w;

        function Z($) {
            return new V($.toString())
        }
        v.regexpCode = Z
    }),
    eb = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.ValueScope = v.ValueScopeName = v.Scope = v.varKinds = v.UsedValueState = void 0;
        var z = JK();
        class U extends Error {
            constructor(B) {
                super(`CodeGen: "code" for ${B} not defined`);
                this.value = B.value
            }
        }
        var V;
        (function(B) {
            B[B.Started = 0] = "Started", B[B.Completed = 1] = "Completed"
        })(V || (v.UsedValueState = V = {})), v.varKinds = {
            const: new z.Name("const"),
            let: new z.Name("let"),
            var: new z.Name("var")
        };
        class N {
            constructor({
                prefixes: B,
                parent: O
            } = {}) {
                this._names = {}, this._prefixes = B, this._parent = O
            }
            toName(B) {
                return B instanceof z.Name ? B : this.name(B)
            }
            name(B) {
                return new z.Name(this._newName(B))
            }
            _newName(B) {
                let O = this._names[B] || this._nameGroup(B);
                return `${B}${O.index++}`
            }
            _nameGroup(B) {
                var O, J;
                if (((J = (O = this._parent) === null || O === void 0 ? void 0 : O._prefixes) === null || J === void 0 ? void 0 : J.has(B)) || this._prefixes && !this._prefixes.has(B)) throw Error(`CodeGen: prefix "${B}" is not allowed in this scope`);
                return this._names[B] = {
                    prefix: B,
                    index: 0
                }
            }
        }
        v.Scope = N;
        class K extends z.Name {
            constructor(B, O) {
                super(O);
                this.prefix = B
            }
            setValue(B, {
                property: O,
                itemIndex: J
            }) {
                this.value = B, this.scopePath = z._`.${new z.Name(O)}[${J}]`
            }
        }
        v.ValueScopeName = K;
        var x = z._`\n`;
        class j extends N {
            constructor(B) {
                super(B);
                this._values = {}, this._scope = B.scope, this.opts = {
                    ...B,
                    _n: B.lines ? x : z.nil
                }
            }
            get() {
                return this._scope
            }
            name(B) {
                return new K(B, this._newName(B))
            }
            value(B, O) {
                var J;
                if (O.ref === void 0) throw Error("CodeGen: ref must be passed in value");
                let q = this.toName(B),
                    {
                        prefix: H
                    } = q,
                    D = (J = O.key) !== null && J !== void 0 ? J : O.ref,
                    A = this._values[H];
                if (A) {
                    let $ = A.get(D);
                    if ($) return $
                } else A = this._values[H] = new Map;
                A.set(D, q);
                let w = this._scope[H] || (this._scope[H] = []),
                    Z = w.length;
                return w[Z] = O.ref, q.setValue(O, {
                    property: H,
                    itemIndex: Z
                }), q
            }
            getValue(B, O) {
                let J = this._values[B];
                if (!J) return;
                return J.get(O)
            }
            scopeRefs(B, O = this._values) {
                return this._reduceValues(O, (J) => {
                    if (J.scopePath === void 0) throw Error(`CodeGen: name "${J}" has no value`);
                    return z._`${B}${J.scopePath}`
                })
            }
            scopeCode(B = this._values, O, J) {
                return this._reduceValues(B, (q) => {
                    if (q.value === void 0) throw Error(`CodeGen: name "${q}" has no value`);
                    return q.value.code
                }, O, J)
            }
            _reduceValues(B, O, J = {}, q) {
                let H = z.nil;
                for (let D in B) {
                    let A = B[D];
                    if (!A) continue;
                    let w = J[D] = J[D] || new Map;
                    A.forEach((Z) => {
                        if (w.has(Z)) return;
                        w.set(Z, V.Started);
                        let $ = O(Z);
                        if ($) {
                            let F = this.opts.es5 ? v.varKinds.var : v.varKinds.const;
                            H = z._`${H}${F} ${Z} = ${$};${this.opts._n}`
                        } else if ($ = q === null || q === void 0 ? void 0 : q(Z)) H = z._`${H}${$}${this.opts._n}`;
                        else throw new U(Z);
                        w.set(Z, V.Completed)
                    })
                }
                return H
            }
        }
        v.ValueScope = j
    }),
    v0 = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.or = v.and = v.not = v.CodeGen = v.operators = v.varKinds = v.ValueScopeName = v.ValueScope = v.Scope = v.Name = v.regexpCode = v.stringify = v.getProperty = v.nil = v.strConcat = v.str = v._ = void 0;
        var z = JK(),
            U = eb(),
            V = JK();
        Object.defineProperty(v, "_", {
            enumerable: !0,
            get: function() {
                return V._
            }
        }), Object.defineProperty(v, "str", {
            enumerable: !0,
            get: function() {
                return V.str
            }
        }), Object.defineProperty(v, "strConcat", {
            enumerable: !0,
            get: function() {
                return V.strConcat
            }
        }), Object.defineProperty(v, "nil", {
            enumerable: !0,
            get: function() {
                return V.nil
            }
        }), Object.defineProperty(v, "getProperty", {
            enumerable: !0,
            get: function() {
                return V.getProperty
            }
        }), Object.defineProperty(v, "stringify", {
            enumerable: !0,
            get: function() {
                return V.stringify
            }
        }), Object.defineProperty(v, "regexpCode", {
            enumerable: !0,
            get: function() {
                return V.regexpCode
            }
        }), Object.defineProperty(v, "Name", {
            enumerable: !0,
            get: function() {
                return V.Name
            }
        });
        var N = eb();
        Object.defineProperty(v, "Scope", {
            enumerable: !0,
            get: function() {
                return N.Scope
            }
        }), Object.defineProperty(v, "ValueScope", {
            enumerable: !0,
            get: function() {
                return N.ValueScope
            }
        }), Object.defineProperty(v, "ValueScopeName", {
            enumerable: !0,
            get: function() {
                return N.ValueScopeName
            }
        }), Object.defineProperty(v, "varKinds", {
            enumerable: !0,
            get: function() {
                return N.varKinds
            }
        }), v.operators = {
            GT: new z._Code(">"),
            GTE: new z._Code(">="),
            LT: new z._Code("<"),
            LTE: new z._Code("<="),
            EQ: new z._Code("==="),
            NEQ: new z._Code("!=="),
            NOT: new z._Code("!"),
            OR: new z._Code("||"),
            AND: new z._Code("&&"),
            ADD: new z._Code("+")
        };
        class K {
            optimizeNodes() {
                return this
            }
            optimizeNames(R, S) {
                return this
            }
        }
        class x extends K {
            constructor(R, S, k) {
                super();
                this.varKind = R, this.name = S, this.rhs = k
            }
            render({
                es5: R,
                _n: S
            }) {
                let k = R ? U.varKinds.var : this.varKind,
                    D6 = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
                return `${k} ${this.name}${D6};` + S
            }
            optimizeNames(R, S) {
                if (!R[this.name.str]) return;
                if (this.rhs) this.rhs = m(this.rhs, R, S);
                return this
            }
            get names() {
                return this.rhs instanceof z._CodeOrName ? this.rhs.names : {}
            }
        }
        class j extends K {
            constructor(R, S, k) {
                super();
                this.lhs = R, this.rhs = S, this.sideEffects = k
            }
            render({
                _n: R
            }) {
                return `${this.lhs} = ${this.rhs};` + R
            }
            optimizeNames(R, S) {
                if (this.lhs instanceof z.Name && !R[this.lhs.str] && !this.sideEffects) return;
                return this.rhs = m(this.rhs, R, S), this
            }
            get names() {
                let R = this.lhs instanceof z.Name ? {} : {
                    ...this.lhs.names
                };
                return Q(R, this.rhs)
            }
        }
        class B extends j {
            constructor(R, S, k, D6) {
                super(R, k, D6);
                this.op = S
            }
            render({
                _n: R
            }) {
                return `${this.lhs} ${this.op}= ${this.rhs};` + R
            }
        }
        class O extends K {
            constructor(R) {
                super();
                this.label = R, this.names = {}
            }
            render({
                _n: R
            }) {
                return `${this.label}:` + R
            }
        }
        class J extends K {
            constructor(R) {
                super();
                this.label = R, this.names = {}
            }
            render({
                _n: R
            }) {
                return `break${this.label?` ${this.label}`:""};` + R
            }
        }
        class q extends K {
            constructor(R) {
                super();
                this.error = R
            }
            render({
                _n: R
            }) {
                return `throw ${this.error};` + R
            }
            get names() {
                return this.error.names
            }
        }
        class H extends K {
            constructor(R) {
                super();
                this.code = R
            }
            render({
                _n: R
            }) {
                return `${this.code};` + R
            }
            optimizeNodes() {
                return `${this.code}` ? this : void 0
            }
            optimizeNames(R, S) {
                return this.code = m(this.code, R, S), this
            }
            get names() {
                return this.code instanceof z._CodeOrName ? this.code.names : {}
            }
        }
        class D extends K {
            constructor(R = []) {
                super();
                this.nodes = R
            }
            render(R) {
                return this.nodes.reduce((S, k) => S + k.render(R), "")
            }
            optimizeNodes() {
                let {
                    nodes: R
                } = this, S = R.length;
                while (S--) {
                    let k = R[S].optimizeNodes();
                    if (Array.isArray(k)) R.splice(S, 1, ...k);
                    else if (k) R[S] = k;
                    else R.splice(S, 1)
                }
                return R.length > 0 ? this : void 0
            }
            optimizeNames(R, S) {
                let {
                    nodes: k
                } = this, D6 = k.length;
                while (D6--) {
                    let f6 = k[D6];
                    if (f6.optimizeNames(R, S)) continue;
                    P6(R, f6.names), k.splice(D6, 1)
                }
                return k.length > 0 ? this : void 0
            }
            get names() {
                return this.nodes.reduce((R, S) => X(R, S.names), {})
            }
        }
        class A extends D {
            render(R) {
                return "{" + R._n + super.render(R) + "}" + R._n
            }
        }
        class w extends D {}
        class Z extends A {}
        Z.kind = "else";
        class $ extends A {
            constructor(R, S) {
                super(S);
                this.condition = R
            }
            render(R) {
                let S = `if(${this.condition})` + super.render(R);
                if (this.else) S += "else " + this.else.render(R);
                return S
            }
            optimizeNodes() {
                super.optimizeNodes();
                let R = this.condition;
                if (R === !0) return this.nodes;
                let S = this.else;
                if (S) {
                    let k = S.optimizeNodes();
                    S = this.else = Array.isArray(k) ? new Z(k) : k
                }
                if (S) {
                    if (R === !1) return S instanceof $ ? S : S.nodes;
                    if (this.nodes.length) return this;
                    return new $(F6(R), S instanceof $ ? [S] : S.nodes)
                }
                if (R === !1 || !this.nodes.length) return;
                return this
            }
            optimizeNames(R, S) {
                var k;
                if (this.else = (k = this.else) === null || k === void 0 ? void 0 : k.optimizeNames(R, S), !(super.optimizeNames(R, S) || this.else)) return;
                return this.condition = m(this.condition, R, S), this
            }
            get names() {
                let R = super.names;
                if (Q(R, this.condition), this.else) X(R, this.else.names);
                return R
            }
        }
        $.kind = "if";
        class F extends A {}
        F.kind = "for";
        class L extends F {
            constructor(R) {
                super();
                this.iteration = R
            }
            render(R) {
                return `for(${this.iteration})` + super.render(R)
            }
            optimizeNames(R, S) {
                if (!super.optimizeNames(R, S)) return;
                return this.iteration = m(this.iteration, R, S), this
            }
            get names() {
                return X(super.names, this.iteration.names)
            }
        }
        class G extends F {
            constructor(R, S, k, D6) {
                super();
                this.varKind = R, this.name = S, this.from = k, this.to = D6
            }
            render(R) {
                let S = R.es5 ? U.varKinds.var : this.varKind,
                    {
                        name: k,
                        from: D6,
                        to: f6
                    } = this;
                return `for(${S} ${k}=${D6}; ${k}<${f6}; ${k}++)` + super.render(R)
            }
            get names() {
                let R = Q(super.names, this.from);
                return Q(R, this.to)
            }
        }
        class I extends F {
            constructor(R, S, k, D6) {
                super();
                this.loop = R, this.varKind = S, this.name = k, this.iterable = D6
            }
            render(R) {
                return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(R)
            }
            optimizeNames(R, S) {
                if (!super.optimizeNames(R, S)) return;
                return this.iterable = m(this.iterable, R, S), this
            }
            get names() {
                return X(super.names, this.iterable.names)
            }
        }
        class M extends A {
            constructor(R, S, k) {
                super();
                this.name = R, this.args = S, this.async = k
            }
            render(R) {
                return `${this.async?"async ":""}function ${this.name}(${this.args})` + super.render(R)
            }
        }
        M.kind = "func";
        class b extends D {
            render(R) {
                return "return " + super.render(R)
            }
        }
        b.kind = "return";
        class W extends A {
            render(R) {
                let S = "try" + super.render(R);
                if (this.catch) S += this.catch.render(R);
                if (this.finally) S += this.finally.render(R);
                return S
            }
            optimizeNodes() {
                var R, S;
                return super.optimizeNodes(), (R = this.catch) === null || R === void 0 || R.optimizeNodes(), (S = this.finally) === null || S === void 0 || S.optimizeNodes(), this
            }
            optimizeNames(R, S) {
                var k, D6;
                return super.optimizeNames(R, S), (k = this.catch) === null || k === void 0 || k.optimizeNames(R, S), (D6 = this.finally) === null || D6 === void 0 || D6.optimizeNames(R, S), this
            }
            get names() {
                let R = super.names;
                if (this.catch) X(R, this.catch.names);
                if (this.finally) X(R, this.finally.names);
                return R
            }
        }
        class E extends A {
            constructor(R) {
                super();
                this.error = R
            }
            render(R) {
                return `catch(${this.error})` + super.render(R)
            }
        }
        E.kind = "catch";
        class y extends A {
            render(R) {
                return "finally" + super.render(R)
            }
        }
        y.kind = "finally";
        class T {
            constructor(R, S = {}) {
                this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = {
                    ...S,
                    _n: S.lines ? `
` : ""
                }, this._extScope = R, this._scope = new U.Scope({
                    parent: R
                }), this._nodes = [new w]
            }
            toString() {
                return this._root.render(this.opts)
            }
            name(R) {
                return this._scope.name(R)
            }
            scopeName(R) {
                return this._extScope.name(R)
            }
            scopeValue(R, S) {
                let k = this._extScope.value(R, S);
                return (this._values[k.prefix] || (this._values[k.prefix] = new Set)).add(k), k
            }
            getScopeValue(R, S) {
                return this._extScope.getValue(R, S)
            }
            scopeRefs(R) {
                return this._extScope.scopeRefs(R, this._values)
            }
            scopeCode() {
                return this._extScope.scopeCode(this._values)
            }
            _def(R, S, k, D6) {
                let f6 = this._scope.toName(S);
                if (k !== void 0 && D6) this._constants[f6.str] = k;
                return this._leafNode(new x(R, f6, k)), f6
            }
            const (R, S, k) {
                return this._def(U.varKinds.const, R, S, k)
            }
            let (R, S, k) {
                return this._def(U.varKinds.let, R, S, k)
            }
            var (R, S, k) {
                return this._def(U.varKinds.var, R, S, k)
            }
            assign(R, S, k) {
                return this._leafNode(new j(R, S, k))
            }
            add(R, S) {
                return this._leafNode(new B(R, v.operators.ADD, S))
            }
            code(R) {
                if (typeof R == "function") R();
                else if (R !== z.nil) this._leafNode(new H(R));
                return this
            }
            object(...R) {
                let S = ["{"];
                for (let [k, D6] of R) {
                    if (S.length > 1) S.push(",");
                    if (S.push(k), k !== D6 || this.opts.es5) S.push(":"), (0, z.addCodeArg)(S, D6)
                }
                return S.push("}"), new z._Code(S)
            }
            if (R, S, k) {
                if (this._blockNode(new $(R)), S && k) this.code(S).else().code(k).endIf();
                else if (S) this.code(S).endIf();
                else if (k) throw Error('CodeGen: "else" body without "then" body');
                return this
            }
            elseIf(R) {
                return this._elseNode(new $(R))
            } else() {
                return this._elseNode(new Z)
            }
            endIf() {
                return this._endBlockNode($, Z)
            }
            _for(R, S) {
                if (this._blockNode(R), S) this.code(S).endFor();
                return this
            }
            for (R, S) {
                return this._for(new L(R), S)
            }
            forRange(R, S, k, D6, f6 = this.opts.es5 ? U.varKinds.var : U.varKinds.let) {
                let Y6 = this._scope.toName(R);
                return this._for(new G(f6, Y6, S, k), () => D6(Y6))
            }
            forOf(R, S, k, D6 = U.varKinds.const) {
                let f6 = this._scope.toName(R);
                if (this.opts.es5) {
                    let Y6 = S instanceof z.Name ? S : this.var("_arr", S);
                    return this.forRange("_i", 0, z._`${Y6}.length`, (X6) => {
                        this.var(f6, z._`${Y6}[${X6}]`), k(f6)
                    })
                }
                return this._for(new I("of", D6, f6, S), () => k(f6))
            }
            forIn(R, S, k, D6 = this.opts.es5 ? U.varKinds.var : U.varKinds.const) {
                if (this.opts.ownProperties) return this.forOf(R, z._`Object.keys(${S})`, k);
                let f6 = this._scope.toName(R);
                return this._for(new I("in", D6, f6, S), () => k(f6))
            }
            endFor() {
                return this._endBlockNode(F)
            }
            label(R) {
                return this._leafNode(new O(R))
            }
            break (R) {
                return this._leafNode(new J(R))
            }
            return (R) {
                let S = new b;
                if (this._blockNode(S), this.code(R), S.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
                return this._endBlockNode(b)
            }
            try (R, S, k) {
                if (!S && !k) throw Error('CodeGen: "try" without "catch" and "finally"');
                let D6 = new W;
                if (this._blockNode(D6), this.code(R), S) {
                    let f6 = this.name("e");
                    this._currNode = D6.catch = new E(f6), S(f6)
                }
                if (k) this._currNode = D6.finally = new y, this.code(k);
                return this._endBlockNode(E, y)
            }
            throw (R) {
                return this._leafNode(new q(R))
            }
            block(R, S) {
                if (this._blockStarts.push(this._nodes.length), R) this.code(R).endBlock(S);
                return this
            }
            endBlock(R) {
                let S = this._blockStarts.pop();
                if (S === void 0) throw Error("CodeGen: not in self-balancing block");
                let k = this._nodes.length - S;
                if (k < 0 || R !== void 0 && k !== R) throw Error(`CodeGen: wrong number of nodes: ${k} vs ${R} expected`);
                return this._nodes.length = S, this
            }
            func(R, S = z.nil, k, D6) {
                if (this._blockNode(new M(R, S, k)), D6) this.code(D6).endFunc();
                return this
            }
            endFunc() {
                return this._endBlockNode(M)
            }
            optimize(R = 1) {
                while (R-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants)
            }
            _leafNode(R) {
                return this._currNode.nodes.push(R), this
            }
            _blockNode(R) {
                this._currNode.nodes.push(R), this._nodes.push(R)
            }
            _endBlockNode(R, S) {
                let k = this._currNode;
                if (k instanceof R || S && k instanceof S) return this._nodes.pop(), this;
                throw Error(`CodeGen: not in block "${S?`${R.kind}/${S.kind}`:R.kind}"`)
            }
            _elseNode(R) {
                let S = this._currNode;
                if (!(S instanceof $)) throw Error('CodeGen: "else" without "if"');
                return this._currNode = S.else = R, this
            }
            get _root() {
                return this._nodes[0]
            }
            get _currNode() {
                let R = this._nodes;
                return R[R.length - 1]
            }
            set _currNode(R) {
                let S = this._nodes;
                S[S.length - 1] = R
            }
        }
        v.CodeGen = T;

        function X(R, S) {
            for (let k in S) R[k] = (R[k] || 0) + (S[k] || 0);
            return R
        }

        function Q(R, S) {
            return S instanceof z._CodeOrName ? X(R, S.names) : R
        }

        function m(R, S, k) {
            if (R instanceof z.Name) return D6(R);
            if (!f6(R)) return R;
            return new z._Code(R._items.reduce((Y6, X6) => {
                if (X6 instanceof z.Name) X6 = D6(X6);
                if (X6 instanceof z._Code) Y6.push(...X6._items);
                else Y6.push(X6);
                return Y6
            }, []));

            function D6(Y6) {
                let X6 = k[Y6.str];
                if (X6 === void 0 || S[Y6.str] !== 1) return Y6;
                return delete S[Y6.str], X6
            }

            function f6(Y6) {
                return Y6 instanceof z._Code && Y6._items.some((X6) => X6 instanceof z.Name && S[X6.str] === 1 && k[X6.str] !== void 0)
            }
        }

        function P6(R, S) {
            for (let k in S) R[k] = (R[k] || 0) - (S[k] || 0)
        }

        function F6(R) {
            return typeof R == "boolean" || typeof R == "number" || R === null ? !R : z._`!${p(R)}`
        }
        v.not = F6;
        var q6 = u(v.operators.AND);

        function Z6(...R) {
            return R.reduce(q6)
        }
        v.and = Z6;
        var T6 = u(v.operators.OR);

        function C(...R) {
            return R.reduce(T6)
        }
        v.or = C;

        function u(R) {
            return (S, k) => S === z.nil ? k : k === z.nil ? S : z._`${p(S)} ${R} ${p(k)}`
        }

        function p(R) {
            return R instanceof z.Name ? R : z._`(${R})`
        }
    }),
    Z0 = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.checkStrictMode = v.getErrorPath = v.Type = v.useFunc = v.setEvaluated = v.evaluatedPropsToName = v.mergeEvaluated = v.eachItem = v.unescapeJsonPointer = v.escapeJsonPointer = v.escapeFragment = v.unescapeFragment = v.schemaRefOrVal = v.schemaHasRulesButRef = v.schemaHasRules = v.checkUnknownRules = v.alwaysValidSchema = v.toHash = void 0;
        var z = v0(),
            U = JK();

        function V(M) {
            let b = {};
            for (let W of M) b[W] = !0;
            return b
        }
        v.toHash = V;

        function N(M, b) {
            if (typeof b == "boolean") return b;
            if (Object.keys(b).length === 0) return !0;
            return K(M, b), !x(b, M.self.RULES.all)
        }
        v.alwaysValidSchema = N;

        function K(M, b = M.schema) {
            let {
                opts: W,
                self: E
            } = M;
            if (!W.strictSchema) return;
            if (typeof b === "boolean") return;
            let y = E.RULES.keywords;
            for (let T in b)
                if (!y[T]) I(M, `unknown keyword: "${T}"`)
        }
        v.checkUnknownRules = K;

        function x(M, b) {
            if (typeof M == "boolean") return !M;
            for (let W in M)
                if (b[W]) return !0;
            return !1
        }
        v.schemaHasRules = x;

        function j(M, b) {
            if (typeof M == "boolean") return !M;
            for (let W in M)
                if (W !== "$ref" && b.all[W]) return !0;
            return !1
        }
        v.schemaHasRulesButRef = j;

        function B({
            topSchemaRef: M,
            schemaPath: b
        }, W, E, y) {
            if (!y) {
                if (typeof W == "number" || typeof W == "boolean") return W;
                if (typeof W == "string") return z._`${W}`
            }
            return z._`${M}${b}${(0,z.getProperty)(E)}`
        }
        v.schemaRefOrVal = B;

        function O(M) {
            return H(decodeURIComponent(M))
        }
        v.unescapeFragment = O;

        function J(M) {
            return encodeURIComponent(q(M))
        }
        v.escapeFragment = J;

        function q(M) {
            if (typeof M == "number") return `${M}`;
            return M.replace(/~/g, "~0").replace(/\//g, "~1")
        }
        v.escapeJsonPointer = q;

        function H(M) {
            return M.replace(/~1/g, "/").replace(/~0/g, "~")
        }
        v.unescapeJsonPointer = H;

        function D(M, b) {
            if (Array.isArray(M))
                for (let W of M) b(W);
            else b(M)
        }
        v.eachItem = D;

        function A({
            mergeNames: M,
            mergeToName: b,
            mergeValues: W,
            resultToName: E
        }) {
            return (y, T, X, Q) => {
                let m = X === void 0 ? T : X instanceof z.Name ? (T instanceof z.Name ? M(y, T, X) : b(y, T, X), X) : T instanceof z.Name ? (b(y, X, T), T) : W(T, X);
                return Q === z.Name && !(m instanceof z.Name) ? E(y, m) : m
            }
        }
        v.mergeEvaluated = {
            props: A({
                mergeNames: (M, b, W) => M.if(z._`${W} !== true && ${b} !== undefined`, () => {
                    M.if(z._`${b} === true`, () => M.assign(W, !0), () => M.assign(W, z._`${W} || {}`).code(z._`Object.assign(${W}, ${b})`))
                }),
                mergeToName: (M, b, W) => M.if(z._`${W} !== true`, () => {
                    if (b === !0) M.assign(W, !0);
                    else M.assign(W, z._`${W} || {}`), Z(M, W, b)
                }),
                mergeValues: (M, b) => M === !0 ? !0 : {
                    ...M,
                    ...b
                },
                resultToName: w
            }),
            items: A({
                mergeNames: (M, b, W) => M.if(z._`${W} !== true && ${b} !== undefined`, () => M.assign(W, z._`${b} === true ? true : ${W} > ${b} ? ${W} : ${b}`)),
                mergeToName: (M, b, W) => M.if(z._`${W} !== true`, () => M.assign(W, b === !0 ? !0 : z._`${W} > ${b} ? ${W} : ${b}`)),
                mergeValues: (M, b) => M === !0 ? !0 : Math.max(M, b),
                resultToName: (M, b) => M.var("items", b)
            })
        };

        function w(M, b) {
            if (b === !0) return M.var("props", !0);
            let W = M.var("props", z._`{}`);
            if (b !== void 0) Z(M, W, b);
            return W
        }
        v.evaluatedPropsToName = w;

        function Z(M, b, W) {
            Object.keys(W).forEach((E) => M.assign(z._`${b}${(0,z.getProperty)(E)}`, !0))
        }
        v.setEvaluated = Z;
        var $ = {};

        function F(M, b) {
            return M.scopeValue("func", {
                ref: b,
                code: $[b.code] || ($[b.code] = new U._Code(b.code))
            })
        }
        v.useFunc = F;
        var L;
        (function(M) {
            M[M.Num = 0] = "Num", M[M.Str = 1] = "Str"
        })(L || (v.Type = L = {}));

        function G(M, b, W) {
            if (M instanceof z.Name) {
                let E = b === L.Num;
                return W ? E ? z._`"[" + ${M} + "]"` : z._`"['" + ${M} + "']"` : E ? z._`"/" + ${M}` : z._`"/" + ${M}.replace(/~/g, "~0").replace(/\\//g, "~1")`
            }
            return W ? (0, z.getProperty)(M).toString() : "/" + q(M)
        }
        v.getErrorPath = G;

        function I(M, b, W = M.opts.strictSchema) {
            if (!W) return;
            if (b = `strict mode: ${b}`, W === !0) throw Error(b);
            M.self.logger.warn(b)
        }
        v.checkStrictMode = I
    }),
    Q9 = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = {
                data: new z.Name("data"),
                valCxt: new z.Name("valCxt"),
                instancePath: new z.Name("instancePath"),
                parentData: new z.Name("parentData"),
                parentDataProperty: new z.Name("parentDataProperty"),
                rootData: new z.Name("rootData"),
                dynamicAnchors: new z.Name("dynamicAnchors"),
                vErrors: new z.Name("vErrors"),
                errors: new z.Name("errors"),
                this: new z.Name("this"),
                self: new z.Name("self"),
                scope: new z.Name("scope"),
                json: new z.Name("json"),
                jsonPos: new z.Name("jsonPos"),
                jsonLen: new z.Name("jsonLen"),
                jsonPart: new z.Name("jsonPart")
            };
        v.default = U
    }),
    SK = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.extendErrors = v.resetErrorsCount = v.reportExtraError = v.reportError = v.keyword$DataError = v.keywordError = void 0;
        var z = v0(),
            U = Z0(),
            V = Q9();
        v.keywordError = {
            message: ({
                keyword: Z
            }) => z.str`must pass "${Z}" keyword validation`
        }, v.keyword$DataError = {
            message: ({
                keyword: Z,
                schemaType: $
            }) => $ ? z.str`"${Z}" keyword must be ${$} ($data)` : z.str`"${Z}" keyword is invalid ($data)`
        };

        function N(Z, $ = v.keywordError, F, L) {
            let {
                it: G
            } = Z, {
                gen: I,
                compositeRule: M,
                allErrors: b
            } = G, W = q(Z, $, F);
            if (L !== null && L !== void 0 ? L : M || b) B(I, W);
            else O(G, z._`[${W}]`)
        }
        v.reportError = N;

        function K(Z, $ = v.keywordError, F) {
            let {
                it: L
            } = Z, {
                gen: G,
                compositeRule: I,
                allErrors: M
            } = L, b = q(Z, $, F);
            if (B(G, b), !(I || M)) O(L, V.default.vErrors)
        }
        v.reportExtraError = K;

        function x(Z, $) {
            Z.assign(V.default.errors, $), Z.if(z._`${V.default.vErrors} !== null`, () => Z.if($, () => Z.assign(z._`${V.default.vErrors}.length`, $), () => Z.assign(V.default.vErrors, null)))
        }
        v.resetErrorsCount = x;

        function j({
            gen: Z,
            keyword: $,
            schemaValue: F,
            data: L,
            errsCount: G,
            it: I
        }) {
            if (G === void 0) throw Error("ajv implementation error");
            let M = Z.name("err");
            Z.forRange("i", G, V.default.errors, (b) => {
                if (Z.const(M, z._`${V.default.vErrors}[${b}]`), Z.if(z._`${M}.instancePath === undefined`, () => Z.assign(z._`${M}.instancePath`, (0, z.strConcat)(V.default.instancePath, I.errorPath))), Z.assign(z._`${M}.schemaPath`, z.str`${I.errSchemaPath}/${$}`), I.opts.verbose) Z.assign(z._`${M}.schema`, F), Z.assign(z._`${M}.data`, L)
            })
        }
        v.extendErrors = j;

        function B(Z, $) {
            let F = Z.const("err", $);
            Z.if(z._`${V.default.vErrors} === null`, () => Z.assign(V.default.vErrors, z._`[${F}]`), z._`${V.default.vErrors}.push(${F})`), Z.code(z._`${V.default.errors}++`)
        }

        function O(Z, $) {
            let {
                gen: F,
                validateName: L,
                schemaEnv: G
            } = Z;
            if (G.$async) F.throw(z._`new ${Z.ValidationError}(${$})`);
            else F.assign(z._`${L}.errors`, $), F.return(!1)
        }
        var J = {
            keyword: new z.Name("keyword"),
            schemaPath: new z.Name("schemaPath"),
            params: new z.Name("params"),
            propertyName: new z.Name("propertyName"),
            message: new z.Name("message"),
            schema: new z.Name("schema"),
            parentSchema: new z.Name("parentSchema")
        };

        function q(Z, $, F) {
            let {
                createErrors: L
            } = Z.it;
            if (L === !1) return z._`{}`;
            return H(Z, $, F)
        }

        function H(Z, $, F = {}) {
            let {
                gen: L,
                it: G
            } = Z, I = [D(G, F), A(Z, F)];
            return w(Z, $, I), L.object(...I)
        }

        function D({
            errorPath: Z
        }, {
            instancePath: $
        }) {
            let F = $ ? z.str`${Z}${(0,U.getErrorPath)($,U.Type.Str)}` : Z;
            return [V.default.instancePath, (0, z.strConcat)(V.default.instancePath, F)]
        }

        function A({
            keyword: Z,
            it: {
                errSchemaPath: $
            }
        }, {
            schemaPath: F,
            parentSchema: L
        }) {
            let G = L ? $ : z.str`${$}/${Z}`;
            if (F) G = z.str`${G}${(0,U.getErrorPath)(F,U.Type.Str)}`;
            return [J.schemaPath, G]
        }

        function w(Z, {
            params: $,
            message: F
        }, L) {
            let {
                keyword: G,
                data: I,
                schemaValue: M,
                it: b
            } = Z, {
                opts: W,
                propertyName: E,
                topSchemaRef: y,
                schemaPath: T
            } = b;
            if (L.push([J.keyword, G], [J.params, typeof $ == "function" ? $(Z) : $ || z._`{}`]), W.messages) L.push([J.message, typeof F == "function" ? F(Z) : F]);
            if (W.verbose) L.push([J.schema, M], [J.parentSchema, z._`${y}${T}`], [V.default.data, I]);
            if (E) L.push([J.propertyName, E])
        }
    }),
    GQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.boolOrEmptySchema = v.topBoolOrEmptySchema = void 0;
        var z = SK(),
            U = v0(),
            V = Q9(),
            N = {
                message: "boolean schema is false"
            };

        function K(B) {
            let {
                gen: O,
                schema: J,
                validateName: q
            } = B;
            if (J === !1) j(B, !1);
            else if (typeof J == "object" && J.$async === !0) O.return(V.default.data);
            else O.assign(U._`${q}.errors`, null), O.return(!0)
        }
        v.topBoolOrEmptySchema = K;

        function x(B, O) {
            let {
                gen: J,
                schema: q
            } = B;
            if (q === !1) J.var(O, !1), j(B);
            else J.var(O, !0)
        }
        v.boolOrEmptySchema = x;

        function j(B, O) {
            let {
                gen: J,
                data: q
            } = B, H = {
                gen: J,
                keyword: "false schema",
                data: q,
                schema: !1,
                schemaCode: !1,
                schemaValue: !1,
                params: {},
                it: B
            };
            (0, z.reportError)(H, N, void 0, O)
        }
    }),
    lR = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.getRules = v.isJSONType = void 0;
        var z = ["string", "number", "integer", "boolean", "null", "object", "array"],
            U = new Set(z);

        function V(K) {
            return typeof K == "string" && U.has(K)
        }
        v.isJSONType = V;

        function N() {
            let K = {
                number: {
                    type: "number",
                    rules: []
                },
                string: {
                    type: "string",
                    rules: []
                },
                array: {
                    type: "array",
                    rules: []
                },
                object: {
                    type: "object",
                    rules: []
                }
            };
            return {
                types: {
                    ...K,
                    integer: !0,
                    boolean: !0,
                    null: !0
                },
                rules: [{
                    rules: []
                }, K.number, K.string, K.array, K.object],
                post: {
                    rules: []
                },
                all: {},
                keywords: {}
            }
        }
        v.getRules = N
    }),
    hR = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.shouldUseRule = v.shouldUseGroup = v.schemaHasRulesForType = void 0;

        function z({
            schema: N,
            self: K
        }, x) {
            let j = K.RULES.types[x];
            return j && j !== !0 && U(N, j)
        }
        v.schemaHasRulesForType = z;

        function U(N, K) {
            return K.rules.some((x) => V(N, x))
        }
        v.shouldUseGroup = U;

        function V(N, K) {
            var x;
            return N[K.keyword] !== void 0 || ((x = K.definition.implements) === null || x === void 0 ? void 0 : x.some((j) => N[j] !== void 0))
        }
        v.shouldUseRule = V
    }),
    qK = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.reportTypeError = v.checkDataTypes = v.checkDataType = v.coerceAndCheckDataType = v.getJSONTypes = v.getSchemaTypes = v.DataType = void 0;
        var z = lR(),
            U = hR(),
            V = SK(),
            N = v0(),
            K = Z0(),
            x;
        (function(L) {
            L[L.Correct = 0] = "Correct", L[L.Wrong = 1] = "Wrong"
        })(x || (v.DataType = x = {}));

        function j(L) {
            let G = B(L.type);
            if (G.includes("null")) {
                if (L.nullable === !1) throw Error("type: null contradicts nullable: false")
            } else {
                if (!G.length && L.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
                if (L.nullable === !0) G.push("null")
            }
            return G
        }
        v.getSchemaTypes = j;

        function B(L) {
            let G = Array.isArray(L) ? L : L ? [L] : [];
            if (G.every(z.isJSONType)) return G;
            throw Error("type must be JSONType or JSONType[]: " + G.join(","))
        }
        v.getJSONTypes = B;

        function O(L, G) {
            let {
                gen: I,
                data: M,
                opts: b
            } = L, W = q(G, b.coerceTypes), E = G.length > 0 && !(W.length === 0 && G.length === 1 && (0, U.schemaHasRulesForType)(L, G[0]));
            if (E) {
                let y = w(G, M, b.strictNumbers, x.Wrong);
                I.if(y, () => {
                    if (W.length) H(L, G, W);
                    else $(L)
                })
            }
            return E
        }
        v.coerceAndCheckDataType = O;
        var J = new Set(["string", "number", "integer", "boolean", "null"]);

        function q(L, G) {
            return G ? L.filter((I) => J.has(I) || G === "array" && I === "array") : []
        }

        function H(L, G, I) {
            let {
                gen: M,
                data: b,
                opts: W
            } = L, E = M.let("dataType", N._`typeof ${b}`), y = M.let("coerced", N._`undefined`);
            if (W.coerceTypes === "array") M.if(N._`${E} == 'object' && Array.isArray(${b}) && ${b}.length == 1`, () => M.assign(b, N._`${b}[0]`).assign(E, N._`typeof ${b}`).if(w(G, b, W.strictNumbers), () => M.assign(y, b)));
            M.if(N._`${y} !== undefined`);
            for (let X of I)
                if (J.has(X) || X === "array" && W.coerceTypes === "array") T(X);
            M.else(), $(L), M.endIf(), M.if(N._`${y} !== undefined`, () => {
                M.assign(b, y), D(L, y)
            });

            function T(X) {
                switch (X) {
                    case "string":
                        M.elseIf(N._`${E} == "number" || ${E} == "boolean"`).assign(y, N._`"" + ${b}`).elseIf(N._`${b} === null`).assign(y, N._`""`);
                        return;
                    case "number":
                        M.elseIf(N._`${E} == "boolean" || ${b} === null
              || (${E} == "string" && ${b} && ${b} == +${b})`).assign(y, N._`+${b}`);
                        return;
                    case "integer":
                        M.elseIf(N._`${E} === "boolean" || ${b} === null
              || (${E} === "string" && ${b} && ${b} == +${b} && !(${b} % 1))`).assign(y, N._`+${b}`);
                        return;
                    case "boolean":
                        M.elseIf(N._`${b} === "false" || ${b} === 0 || ${b} === null`).assign(y, !1).elseIf(N._`${b} === "true" || ${b} === 1`).assign(y, !0);
                        return;
                    case "null":
                        M.elseIf(N._`${b} === "" || ${b} === 0 || ${b} === false`), M.assign(y, null);
                        return;
                    case "array":
                        M.elseIf(N._`${E} === "string" || ${E} === "number"
              || ${E} === "boolean" || ${b} === null`).assign(y, N._`[${b}]`)
                }
            }
        }

        function D({
            gen: L,
            parentData: G,
            parentDataProperty: I
        }, M) {
            L.if(N._`${G} !== undefined`, () => L.assign(N._`${G}[${I}]`, M))
        }

        function A(L, G, I, M = x.Correct) {
            let b = M === x.Correct ? N.operators.EQ : N.operators.NEQ,
                W;
            switch (L) {
                case "null":
                    return N._`${G} ${b} null`;
                case "array":
                    W = N._`Array.isArray(${G})`;
                    break;
                case "object":
                    W = N._`${G} && typeof ${G} == "object" && !Array.isArray(${G})`;
                    break;
                case "integer":
                    W = E(N._`!(${G} % 1) && !isNaN(${G})`);
                    break;
                case "number":
                    W = E();
                    break;
                default:
                    return N._`typeof ${G} ${b} ${L}`
            }
            return M === x.Correct ? W : (0, N.not)(W);

            function E(y = N.nil) {
                return (0, N.and)(N._`typeof ${G} == "number"`, y, I ? N._`isFinite(${G})` : N.nil)
            }
        }
        v.checkDataType = A;

        function w(L, G, I, M) {
            if (L.length === 1) return A(L[0], G, I, M);
            let b, W = (0, K.toHash)(L);
            if (W.array && W.object) {
                let E = N._`typeof ${G} != "object"`;
                b = W.null ? E : N._`!${G} || ${E}`, delete W.null, delete W.array, delete W.object
            } else b = N.nil;
            if (W.number) delete W.integer;
            for (let E in W) b = (0, N.and)(b, A(E, G, I, M));
            return b
        }
        v.checkDataTypes = w;
        var Z = {
            message: ({
                schema: L
            }) => `must be ${L}`,
            params: ({
                schema: L,
                schemaValue: G
            }) => typeof L == "string" ? N._`{type: ${L}}` : N._`{type: ${G}}`
        };

        function $(L) {
            let G = F(L);
            (0, V.reportError)(G, Z)
        }
        v.reportTypeError = $;

        function F(L) {
            let {
                gen: G,
                data: I,
                schema: M
            } = L, b = (0, K.schemaRefOrVal)(L, M, "type");
            return {
                gen: G,
                keyword: "type",
                data: I,
                schema: M.type,
                schemaCode: b,
                schemaValue: b,
                parentSchema: M,
                params: {},
                it: L
            }
        }
    }),
    IQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.assignDefaults = void 0;
        var z = v0(),
            U = Z0();

        function V(K, x) {
            let {
                properties: j,
                items: B
            } = K.schema;
            if (x === "object" && j)
                for (let O in j) N(K, O, j[O].default);
            else if (x === "array" && Array.isArray(B)) B.forEach((O, J) => N(K, J, O.default))
        }
        v.assignDefaults = V;

        function N(K, x, j) {
            let {
                gen: B,
                compositeRule: O,
                data: J,
                opts: q
            } = K;
            if (j === void 0) return;
            let H = z._`${J}${(0,z.getProperty)(x)}`;
            if (O) {
                (0, U.checkStrictMode)(K, `default is ignored for: ${H}`);
                return
            }
            let D = z._`${H} === undefined`;
            if (q.useDefaults === "empty") D = z._`${D} || ${H} === null || ${H} === ""`;
            B.if(D, z._`${H} = ${(0,z.stringify)(j)}`)
        }
    }),
    N8 = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.validateUnion = v.validateArray = v.usePattern = v.callValidateCode = v.schemaProperties = v.allSchemaProperties = v.noPropertyInData = v.propertyInData = v.isOwnProperty = v.hasPropFunc = v.reportMissingProp = v.checkMissingProp = v.checkReportMissingProp = void 0;
        var z = v0(),
            U = Z0(),
            V = Q9(),
            N = Z0();

        function K(L, G) {
            let {
                gen: I,
                data: M,
                it: b
            } = L;
            I.if(q(I, M, G, b.opts.ownProperties), () => {
                L.setParams({
                    missingProperty: z._`${G}`
                }, !0), L.error()
            })
        }
        v.checkReportMissingProp = K;

        function x({
            gen: L,
            data: G,
            it: {
                opts: I
            }
        }, M, b) {
            return (0, z.or)(...M.map((W) => (0, z.and)(q(L, G, W, I.ownProperties), z._`${b} = ${W}`)))
        }
        v.checkMissingProp = x;

        function j(L, G) {
            L.setParams({
                missingProperty: G
            }, !0), L.error()
        }
        v.reportMissingProp = j;

        function B(L) {
            return L.scopeValue("func", {
                ref: Object.prototype.hasOwnProperty,
                code: z._`Object.prototype.hasOwnProperty`
            })
        }
        v.hasPropFunc = B;

        function O(L, G, I) {
            return z._`${B(L)}.call(${G}, ${I})`
        }
        v.isOwnProperty = O;

        function J(L, G, I, M) {
            let b = z._`${G}${(0,z.getProperty)(I)} !== undefined`;
            return M ? z._`${b} && ${O(L,G,I)}` : b
        }
        v.propertyInData = J;

        function q(L, G, I, M) {
            let b = z._`${G}${(0,z.getProperty)(I)} === undefined`;
            return M ? (0, z.or)(b, (0, z.not)(O(L, G, I))) : b
        }
        v.noPropertyInData = q;

        function H(L) {
            return L ? Object.keys(L).filter((G) => G !== "__proto__") : []
        }
        v.allSchemaProperties = H;

        function D(L, G) {
            return H(G).filter((I) => !(0, U.alwaysValidSchema)(L, G[I]))
        }
        v.schemaProperties = D;

        function A({
            schemaCode: L,
            data: G,
            it: {
                gen: I,
                topSchemaRef: M,
                schemaPath: b,
                errorPath: W
            },
            it: E
        }, y, T, X) {
            let Q = X ? z._`${L}, ${G}, ${M}${b}` : G,
                m = [
                    [V.default.instancePath, (0, z.strConcat)(V.default.instancePath, W)],
                    [V.default.parentData, E.parentData],
                    [V.default.parentDataProperty, E.parentDataProperty],
                    [V.default.rootData, V.default.rootData]
                ];
            if (E.opts.dynamicRef) m.push([V.default.dynamicAnchors, V.default.dynamicAnchors]);
            let P6 = z._`${Q}, ${I.object(...m)}`;
            return T !== z.nil ? z._`${y}.call(${T}, ${P6})` : z._`${y}(${P6})`
        }
        v.callValidateCode = A;
        var w = z._`new RegExp`;

        function Z({
            gen: L,
            it: {
                opts: G
            }
        }, I) {
            let M = G.unicodeRegExp ? "u" : "",
                {
                    regExp: b
                } = G.code,
                W = b(I, M);
            return L.scopeValue("pattern", {
                key: W.toString(),
                ref: W,
                code: z._`${b.code==="new RegExp"?w:(0,N.useFunc)(L,b)}(${I}, ${M})`
            })
        }
        v.usePattern = Z;

        function $(L) {
            let {
                gen: G,
                data: I,
                keyword: M,
                it: b
            } = L, W = G.name("valid");
            if (b.allErrors) {
                let y = G.let("valid", !0);
                return E(() => G.assign(y, !1)), y
            }
            return G.var(W, !0), E(() => G.break()), W;

            function E(y) {
                let T = G.const("len", z._`${I}.length`);
                G.forRange("i", 0, T, (X) => {
                    L.subschema({
                        keyword: M,
                        dataProp: X,
                        dataPropType: U.Type.Num
                    }, W), G.if((0, z.not)(W), y)
                })
            }
        }
        v.validateArray = $;

        function F(L) {
            let {
                gen: G,
                schema: I,
                keyword: M,
                it: b
            } = L;
            if (!Array.isArray(I)) throw Error("ajv implementation error");
            if (I.some((y) => (0, U.alwaysValidSchema)(b, y)) && !b.opts.unevaluated) return;
            let W = G.let("valid", !1),
                E = G.name("_valid");
            G.block(() => I.forEach((y, T) => {
                let X = L.subschema({
                    keyword: M,
                    schemaProp: T,
                    compositeRule: !0
                }, E);
                if (G.assign(W, z._`${W} || ${E}`), !L.mergeValidEvaluated(X, E)) G.if((0, z.not)(W))
            })), L.result(W, () => L.reset(), () => L.error(!0))
        }
        v.validateUnion = F
    }),
    MQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.validateKeywordUsage = v.validSchemaType = v.funcKeywordCode = v.macroKeywordCode = void 0;
        var z = v0(),
            U = Q9(),
            V = N8(),
            N = SK();

        function K(D, A) {
            let {
                gen: w,
                keyword: Z,
                schema: $,
                parentSchema: F,
                it: L
            } = D, G = A.macro.call(L.self, $, F, L), I = J(w, Z, G);
            if (L.opts.validateSchema !== !1) L.self.validateSchema(G, !0);
            let M = w.name("valid");
            D.subschema({
                schema: G,
                schemaPath: z.nil,
                errSchemaPath: `${L.errSchemaPath}/${Z}`,
                topSchemaRef: I,
                compositeRule: !0
            }, M), D.pass(M, () => D.error(!0))
        }
        v.macroKeywordCode = K;

        function x(D, A) {
            var w;
            let {
                gen: Z,
                keyword: $,
                schema: F,
                parentSchema: L,
                $data: G,
                it: I
            } = D;
            O(I, A);
            let M = !G && A.compile ? A.compile.call(I.self, F, L, I) : A.validate,
                b = J(Z, $, M),
                W = Z.let("valid");
            D.block$data(W, E), D.ok((w = A.valid) !== null && w !== void 0 ? w : W);

            function E() {
                if (A.errors === !1) {
                    if (X(), A.modifying) j(D);
                    Q(() => D.error())
                } else {
                    let m = A.async ? y() : T();
                    if (A.modifying) j(D);
                    Q(() => B(D, m))
                }
            }

            function y() {
                let m = Z.let("ruleErrs", null);
                return Z.try(() => X(z._`await `), (P6) => Z.assign(W, !1).if(z._`${P6} instanceof ${I.ValidationError}`, () => Z.assign(m, z._`${P6}.errors`), () => Z.throw(P6))), m
            }

            function T() {
                let m = z._`${b}.errors`;
                return Z.assign(m, null), X(z.nil), m
            }

            function X(m = A.async ? z._`await ` : z.nil) {
                let P6 = I.opts.passContext ? U.default.this : U.default.self,
                    F6 = !(("compile" in A) && !G || A.schema === !1);
                Z.assign(W, z._`${m}${(0,V.callValidateCode)(D,b,P6,F6)}`, A.modifying)
            }

            function Q(m) {
                var P6;
                Z.if((0, z.not)((P6 = A.valid) !== null && P6 !== void 0 ? P6 : W), m)
            }
        }
        v.funcKeywordCode = x;

        function j(D) {
            let {
                gen: A,
                data: w,
                it: Z
            } = D;
            A.if(Z.parentData, () => A.assign(w, z._`${Z.parentData}[${Z.parentDataProperty}]`))
        }

        function B(D, A) {
            let {
                gen: w
            } = D;
            w.if(z._`Array.isArray(${A})`, () => {
                w.assign(U.default.vErrors, z._`${U.default.vErrors} === null ? ${A} : ${U.default.vErrors}.concat(${A})`).assign(U.default.errors, z._`${U.default.vErrors}.length`), (0, N.extendErrors)(D)
            }, () => D.error())
        }

        function O({
            schemaEnv: D
        }, A) {
            if (A.async && !D.$async) throw Error("async keyword in sync schema")
        }

        function J(D, A, w) {
            if (w === void 0) throw Error(`keyword "${A}" failed to compile`);
            return D.scopeValue("keyword", typeof w == "function" ? {
                ref: w
            } : {
                ref: w,
                code: (0, z.stringify)(w)
            })
        }

        function q(D, A, w = !1) {
            return !A.length || A.some((Z) => Z === "array" ? Array.isArray(D) : Z === "object" ? D && typeof D == "object" && !Array.isArray(D) : typeof D == Z || w && typeof D > "u")
        }
        v.validSchemaType = q;

        function H({
            schema: D,
            opts: A,
            self: w,
            errSchemaPath: Z
        }, $, F) {
            if (Array.isArray($.keyword) ? !$.keyword.includes(F) : $.keyword !== F) throw Error("ajv implementation error");
            let L = $.dependencies;
            if (L === null || L === void 0 ? void 0 : L.some((G) => !Object.prototype.hasOwnProperty.call(D, G))) throw Error(`parent schema must have dependencies of ${F}: ${L.join(",")}`);
            if ($.validateSchema) {
                if (!$.validateSchema(D[F])) {
                    let G = `keyword "${F}" value is invalid at path "${Z}": ` + w.errorsText($.validateSchema.errors);
                    if (A.validateSchema === "log") w.logger.error(G);
                    else throw Error(G)
                }
            }
        }
        v.validateKeywordUsage = H
    }),
    bQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.extendSubschemaMode = v.extendSubschemaData = v.getSubschema = void 0;
        var z = v0(),
            U = Z0();

        function V(x, {
            keyword: j,
            schemaProp: B,
            schema: O,
            schemaPath: J,
            errSchemaPath: q,
            topSchemaRef: H
        }) {
            if (j !== void 0 && O !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
            if (j !== void 0) {
                let D = x.schema[j];
                return B === void 0 ? {
                    schema: D,
                    schemaPath: z._`${x.schemaPath}${(0,z.getProperty)(j)}`,
                    errSchemaPath: `${x.errSchemaPath}/${j}`
                } : {
                    schema: D[B],
                    schemaPath: z._`${x.schemaPath}${(0,z.getProperty)(j)}${(0,z.getProperty)(B)}`,
                    errSchemaPath: `${x.errSchemaPath}/${j}/${(0,U.escapeFragment)(B)}`
                }
            }
            if (O !== void 0) {
                if (J === void 0 || q === void 0 || H === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
                return {
                    schema: O,
                    schemaPath: J,
                    topSchemaRef: H,
                    errSchemaPath: q
                }
            }
            throw Error('either "keyword" or "schema" must be passed')
        }
        v.getSubschema = V;

        function N(x, j, {
            dataProp: B,
            dataPropType: O,
            data: J,
            dataTypes: q,
            propertyName: H
        }) {
            if (J !== void 0 && B !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
            let {
                gen: D
            } = j;
            if (B !== void 0) {
                let {
                    errorPath: w,
                    dataPathArr: Z,
                    opts: $
                } = j, F = D.let("data", z._`${j.data}${(0,z.getProperty)(B)}`, !0);
                A(F), x.errorPath = z.str`${w}${(0,U.getErrorPath)(B,O,$.jsPropertySyntax)}`, x.parentDataProperty = z._`${B}`, x.dataPathArr = [...Z, x.parentDataProperty]
            }
            if (J !== void 0) {
                let w = J instanceof z.Name ? J : D.let("data", J, !0);
                if (A(w), H !== void 0) x.propertyName = H
            }
            if (q) x.dataTypes = q;

            function A(w) {
                x.data = w, x.dataLevel = j.dataLevel + 1, x.dataTypes = [], j.definedProperties = new Set, x.parentData = j.data, x.dataNames = [...j.dataNames, w]
            }
        }
        v.extendSubschemaData = N;

        function K(x, {
            jtdDiscriminator: j,
            jtdMetadata: B,
            compositeRule: O,
            createErrors: J,
            allErrors: q
        }) {
            if (O !== void 0) x.compositeRule = O;
            if (J !== void 0) x.createErrors = J;
            if (q !== void 0) x.allErrors = q;
            x.jtdDiscriminator = j, x.jtdMetadata = B
        }
        v.extendSubschemaMode = K
    }),
    pR = J6((v, z) => {
        z.exports = function U(V, N) {
            if (V === N) return !0;
            if (V && N && typeof V == "object" && typeof N == "object") {
                if (V.constructor !== N.constructor) return !1;
                var K, x, j;
                if (Array.isArray(V)) {
                    if (K = V.length, K != N.length) return !1;
                    for (x = K; x-- !== 0;)
                        if (!U(V[x], N[x])) return !1;
                    return !0
                }
                if (V.constructor === RegExp) return V.source === N.source && V.flags === N.flags;
                if (V.valueOf !== Object.prototype.valueOf) return V.valueOf() === N.valueOf();
                if (V.toString !== Object.prototype.toString) return V.toString() === N.toString();
                if (j = Object.keys(V), K = j.length, K !== Object.keys(N).length) return !1;
                for (x = K; x-- !== 0;)
                    if (!Object.prototype.hasOwnProperty.call(N, j[x])) return !1;
                for (x = K; x-- !== 0;) {
                    var B = j[x];
                    if (!U(V[B], N[B])) return !1
                }
                return !0
            }
            return V !== V && N !== N
        }
    }),
    RQ = J6((v, z) => {
        var U = z.exports = function(K, x, j) {
            if (typeof x == "function") j = x, x = {};
            j = x.cb || j;
            var B = typeof j == "function" ? j : j.pre || function() {},
                O = j.post || function() {};
            V(x, B, O, K, "", K)
        };
        U.keywords = {
            additionalItems: !0,
            items: !0,
            contains: !0,
            additionalProperties: !0,
            propertyNames: !0,
            not: !0,
            if: !0,
            then: !0,
            else: !0
        }, U.arrayKeywords = {
            items: !0,
            allOf: !0,
            anyOf: !0,
            oneOf: !0
        }, U.propsKeywords = {
            $defs: !0,
            definitions: !0,
            properties: !0,
            patternProperties: !0,
            dependencies: !0
        }, U.skipKeywords = {
            default: !0,
            enum: !0,
            const: !0,
            required: !0,
            maximum: !0,
            minimum: !0,
            exclusiveMaximum: !0,
            exclusiveMinimum: !0,
            multipleOf: !0,
            maxLength: !0,
            minLength: !0,
            pattern: !0,
            format: !0,
            maxItems: !0,
            minItems: !0,
            uniqueItems: !0,
            maxProperties: !0,
            minProperties: !0
        };

        function V(K, x, j, B, O, J, q, H, D, A) {
            if (B && typeof B == "object" && !Array.isArray(B)) {
                x(B, O, J, q, H, D, A);
                for (var w in B) {
                    var Z = B[w];
                    if (Array.isArray(Z)) {
                        if (w in U.arrayKeywords)
                            for (var $ = 0; $ < Z.length; $++) V(K, x, j, Z[$], O + "/" + w + "/" + $, J, O, w, B, $)
                    } else if (w in U.propsKeywords) {
                        if (Z && typeof Z == "object")
                            for (var F in Z) V(K, x, j, Z[F], O + "/" + w + "/" + N(F), J, O, w, B, F)
                    } else if (w in U.keywords || K.allKeys && !(w in U.skipKeywords)) V(K, x, j, Z, O + "/" + w, J, O, w, B)
                }
                j(B, O, J, q, H, D, A)
            }
        }

        function N(K) {
            return K.replace(/~/g, "~0").replace(/\//g, "~1")
        }
    }),
    PK = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.getSchemaRefs = v.resolveUrl = v.normalizeId = v._getFullPath = v.getFullPath = v.inlineRef = void 0;
        var z = Z0(),
            U = pR(),
            V = RQ(),
            N = new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);

        function K(Z, $ = !0) {
            if (typeof Z == "boolean") return !0;
            if ($ === !0) return !j(Z);
            if (!$) return !1;
            return B(Z) <= $
        }
        v.inlineRef = K;
        var x = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);

        function j(Z) {
            for (let $ in Z) {
                if (x.has($)) return !0;
                let F = Z[$];
                if (Array.isArray(F) && F.some(j)) return !0;
                if (typeof F == "object" && j(F)) return !0
            }
            return !1
        }

        function B(Z) {
            let $ = 0;
            for (let F in Z) {
                if (F === "$ref") return 1 / 0;
                if ($++, N.has(F)) continue;
                if (typeof Z[F] == "object")(0, z.eachItem)(Z[F], (L) => $ += B(L));
                if ($ === 1 / 0) return 1 / 0
            }
            return $
        }

        function O(Z, $ = "", F) {
            if (F !== !1) $ = H($);
            let L = Z.parse($);
            return J(Z, L)
        }
        v.getFullPath = O;

        function J(Z, $) {
            return Z.serialize($).split("#")[0] + "#"
        }
        v._getFullPath = J;
        var q = /#\/?$/;

        function H(Z) {
            return Z ? Z.replace(q, "") : ""
        }
        v.normalizeId = H;

        function D(Z, $, F) {
            return F = H(F), Z.resolve($, F)
        }
        v.resolveUrl = D;
        var A = /^[a-z_][-a-z0-9._]*$/i;

        function w(Z, $) {
            if (typeof Z == "boolean") return {};
            let {
                schemaId: F,
                uriResolver: L
            } = this.opts, G = H(Z[F] || $), I = {
                "": G
            }, M = O(L, G, !1), b = {}, W = new Set;
            return V(Z, {
                allKeys: !0
            }, (T, X, Q, m) => {
                if (m === void 0) return;
                let P6 = M + X,
                    F6 = I[m];
                if (typeof T[F] == "string") F6 = q6.call(this, T[F]);
                Z6.call(this, T.$anchor), Z6.call(this, T.$dynamicAnchor), I[X] = F6;

                function q6(T6) {
                    let C = this.opts.uriResolver.resolve;
                    if (T6 = H(F6 ? C(F6, T6) : T6), W.has(T6)) throw y(T6);
                    W.add(T6);
                    let u = this.refs[T6];
                    if (typeof u == "string") u = this.refs[u];
                    if (typeof u == "object") E(T, u.schema, T6);
                    else if (T6 !== H(P6))
                        if (T6[0] === "#") E(T, b[T6], T6), b[T6] = T;
                        else this.refs[T6] = P6;
                    return T6
                }

                function Z6(T6) {
                    if (typeof T6 == "string") {
                        if (!A.test(T6)) throw Error(`invalid anchor "${T6}"`);
                        q6.call(this, `#${T6}`)
                    }
                }
            }), b;

            function E(T, X, Q) {
                if (X !== void 0 && !U(T, X)) throw y(Q)
            }

            function y(T) {
                return Error(`reference "${T}" resolves to more than one schema`)
            }
        }
        v.getSchemaRefs = w
    }),
    _K = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.getData = v.KeywordCxt = v.validateFunctionCode = void 0;
        var z = GQ(),
            U = qK(),
            V = hR(),
            N = qK(),
            K = IQ(),
            x = MQ(),
            j = bQ(),
            B = v0(),
            O = Q9(),
            J = PK(),
            q = Z0(),
            H = SK();

        function D(P) {
            if (M(P)) {
                if (W(P), I(P)) {
                    $(P);
                    return
                }
            }
            A(P, () => (0, z.topBoolOrEmptySchema)(P))
        }
        v.validateFunctionCode = D;

        function A({
            gen: P,
            validateName: g,
            schema: n,
            schemaEnv: _6,
            opts: u6
        }, s6) {
            if (u6.code.es5) P.func(g, B._`${O.default.data}, ${O.default.valCxt}`, _6.$async, () => {
                P.code(B._`"use strict"; ${L(n,u6)}`), Z(P, u6), P.code(s6)
            });
            else P.func(g, B._`${O.default.data}, ${w(u6)}`, _6.$async, () => P.code(L(n, u6)).code(s6))
        }

        function w(P) {
            return B._`{${O.default.instancePath}="", ${O.default.parentData}, ${O.default.parentDataProperty}, ${O.default.rootData}=${O.default.data}${P.dynamicRef?B._`, ${O.default.dynamicAnchors}={}`:B.nil}}={}`
        }

        function Z(P, g) {
            P.if(O.default.valCxt, () => {
                if (P.var(O.default.instancePath, B._`${O.default.valCxt}.${O.default.instancePath}`), P.var(O.default.parentData, B._`${O.default.valCxt}.${O.default.parentData}`), P.var(O.default.parentDataProperty, B._`${O.default.valCxt}.${O.default.parentDataProperty}`), P.var(O.default.rootData, B._`${O.default.valCxt}.${O.default.rootData}`), g.dynamicRef) P.var(O.default.dynamicAnchors, B._`${O.default.valCxt}.${O.default.dynamicAnchors}`)
            }, () => {
                if (P.var(O.default.instancePath, B._`""`), P.var(O.default.parentData, B._`undefined`), P.var(O.default.parentDataProperty, B._`undefined`), P.var(O.default.rootData, O.default.data), g.dynamicRef) P.var(O.default.dynamicAnchors, B._`{}`)
            })
        }

        function $(P) {
            let {
                schema: g,
                opts: n,
                gen: _6
            } = P;
            A(P, () => {
                if (n.$comment && g.$comment) m(P);
                if (T(P), _6.let(O.default.vErrors, null), _6.let(O.default.errors, 0), n.unevaluated) F(P);
                E(P), P6(P)
            });
            return
        }

        function F(P) {
            let {
                gen: g,
                validateName: n
            } = P;
            P.evaluated = g.const("evaluated", B._`${n}.evaluated`), g.if(B._`${P.evaluated}.dynamicProps`, () => g.assign(B._`${P.evaluated}.props`, B._`undefined`)), g.if(B._`${P.evaluated}.dynamicItems`, () => g.assign(B._`${P.evaluated}.items`, B._`undefined`))
        }

        function L(P, g) {
            let n = typeof P == "object" && P[g.schemaId];
            return n && (g.code.source || g.code.process) ? B._`/*# sourceURL=${n} */` : B.nil
        }

        function G(P, g) {
            if (M(P)) {
                if (W(P), I(P)) {
                    b(P, g);
                    return
                }
            }(0, z.boolOrEmptySchema)(P, g)
        }

        function I({
            schema: P,
            self: g
        }) {
            if (typeof P == "boolean") return !P;
            for (let n in P)
                if (g.RULES.all[n]) return !0;
            return !1
        }

        function M(P) {
            return typeof P.schema != "boolean"
        }

        function b(P, g) {
            let {
                schema: n,
                gen: _6,
                opts: u6
            } = P;
            if (u6.$comment && n.$comment) m(P);
            X(P), Q(P);
            let s6 = _6.const("_errs", O.default.errors);
            E(P, s6), _6.var(g, B._`${s6} === ${O.default.errors}`)
        }

        function W(P) {
            (0, q.checkUnknownRules)(P), y(P)
        }

        function E(P, g) {
            if (P.opts.jtd) return q6(P, [], !1, g);
            let n = (0, U.getSchemaTypes)(P.schema),
                _6 = (0, U.coerceAndCheckDataType)(P, n);
            q6(P, n, !_6, g)
        }

        function y(P) {
            let {
                schema: g,
                errSchemaPath: n,
                opts: _6,
                self: u6
            } = P;
            if (g.$ref && _6.ignoreKeywordsWithRef && (0, q.schemaHasRulesButRef)(g, u6.RULES)) u6.logger.warn(`$ref: keywords ignored in schema at path "${n}"`)
        }

        function T(P) {
            let {
                schema: g,
                opts: n
            } = P;
            if (g.default !== void 0 && n.useDefaults && n.strictSchema)(0, q.checkStrictMode)(P, "default is ignored in the schema root")
        }

        function X(P) {
            let g = P.schema[P.opts.schemaId];
            if (g) P.baseId = (0, J.resolveUrl)(P.opts.uriResolver, P.baseId, g)
        }

        function Q(P) {
            if (P.schema.$async && !P.schemaEnv.$async) throw Error("async schema in sync schema")
        }

        function m({
            gen: P,
            schemaEnv: g,
            schema: n,
            errSchemaPath: _6,
            opts: u6
        }) {
            let s6 = n.$comment;
            if (u6.$comment === !0) P.code(B._`${O.default.self}.logger.log(${s6})`);
            else if (typeof u6.$comment == "function") {
                let z4 = B.str`${_6}/$comment`,
                    m4 = P.scopeValue("root", {
                        ref: g.root
                    });
                P.code(B._`${O.default.self}.opts.$comment(${s6}, ${z4}, ${m4}.schema)`)
            }
        }

        function P6(P) {
            let {
                gen: g,
                schemaEnv: n,
                validateName: _6,
                ValidationError: u6,
                opts: s6
            } = P;
            if (n.$async) g.if(B._`${O.default.errors} === 0`, () => g.return(O.default.data), () => g.throw(B._`new ${u6}(${O.default.vErrors})`));
            else {
                if (g.assign(B._`${_6}.errors`, O.default.vErrors), s6.unevaluated) F6(P);
                g.return(B._`${O.default.errors} === 0`)
            }
        }

        function F6({
            gen: P,
            evaluated: g,
            props: n,
            items: _6
        }) {
            if (n instanceof B.Name) P.assign(B._`${g}.props`, n);
            if (_6 instanceof B.Name) P.assign(B._`${g}.items`, _6)
        }

        function q6(P, g, n, _6) {
            let {
                gen: u6,
                schema: s6,
                data: z4,
                allErrors: m4,
                opts: W3,
                self: U4
            } = P, {
                RULES: g0
            } = U4;
            if (s6.$ref && (W3.ignoreKeywordsWithRef || !(0, q.schemaHasRulesButRef)(s6, g0))) {
                u6.block(() => Y6(P, "$ref", g0.all.$ref.definition));
                return
            }
            if (!W3.jtd) T6(P, g);
            u6.block(() => {
                for (let m3 of g0.rules) y7(m3);
                y7(g0.post)
            });

            function y7(m3) {
                if (!(0, V.shouldUseGroup)(s6, m3)) return;
                if (m3.type) {
                    if (u6.if((0, N.checkDataType)(m3.type, z4, W3.strictNumbers)), Z6(P, m3), g.length === 1 && g[0] === m3.type && n) u6.else(), (0, N.reportTypeError)(P);
                    u6.endIf()
                } else Z6(P, m3);
                if (!m4) u6.if(B._`${O.default.errors} === ${_6||0}`)
            }
        }

        function Z6(P, g) {
            let {
                gen: n,
                schema: _6,
                opts: {
                    useDefaults: u6
                }
            } = P;
            if (u6)(0, K.assignDefaults)(P, g.type);
            n.block(() => {
                for (let s6 of g.rules)
                    if ((0, V.shouldUseRule)(_6, s6)) Y6(P, s6.keyword, s6.definition, g.type)
            })
        }

        function T6(P, g) {
            if (P.schemaEnv.meta || !P.opts.strictTypes) return;
            if (C(P, g), !P.opts.allowUnionTypes) u(P, g);
            p(P, P.dataTypes)
        }

        function C(P, g) {
            if (!g.length) return;
            if (!P.dataTypes.length) {
                P.dataTypes = g;
                return
            }
            g.forEach((n) => {
                if (!S(P.dataTypes, n)) D6(P, `type "${n}" not allowed by context "${P.dataTypes.join(",")}"`)
            }), k(P, g)
        }

        function u(P, g) {
            if (g.length > 1 && !(g.length === 2 && g.includes("null"))) D6(P, "use allowUnionTypes to allow union type keyword")
        }

        function p(P, g) {
            let n = P.self.RULES.all;
            for (let _6 in n) {
                let u6 = n[_6];
                if (typeof u6 == "object" && (0, V.shouldUseRule)(P.schema, u6)) {
                    let {
                        type: s6
                    } = u6.definition;
                    if (s6.length && !s6.some((z4) => R(g, z4))) D6(P, `missing type "${s6.join(",")}" for keyword "${_6}"`)
                }
            }
        }

        function R(P, g) {
            return P.includes(g) || g === "number" && P.includes("integer")
        }

        function S(P, g) {
            return P.includes(g) || g === "integer" && P.includes("number")
        }

        function k(P, g) {
            let n = [];
            for (let _6 of P.dataTypes)
                if (S(g, _6)) n.push(_6);
                else if (g.includes("integer") && _6 === "number") n.push("integer");
            P.dataTypes = n
        }

        function D6(P, g) {
            let n = P.schemaEnv.baseId + P.errSchemaPath;
            g += ` at "${n}" (strictTypes)`, (0, q.checkStrictMode)(P, g, P.opts.strictTypes)
        }
        class f6 {
            constructor(P, g, n) {
                if ((0, x.validateKeywordUsage)(P, g, n), this.gen = P.gen, this.allErrors = P.allErrors, this.keyword = n, this.data = P.data, this.schema = P.schema[n], this.$data = g.$data && P.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, q.schemaRefOrVal)(P, this.schema, n, this.$data), this.schemaType = g.schemaType, this.parentSchema = P.schema, this.params = {}, this.it = P, this.def = g, this.$data) this.schemaCode = P.gen.const("vSchema", t3(this.$data, P));
                else if (this.schemaCode = this.schemaValue, !(0, x.validSchemaType)(this.schema, g.schemaType, g.allowUndefined)) throw Error(`${n} value must be ${JSON.stringify(g.schemaType)}`);
                if ("code" in g ? g.trackErrors : g.errors !== !1) this.errsCount = P.gen.const("_errs", O.default.errors)
            }
            result(P, g, n) {
                this.failResult((0, B.not)(P), g, n)
            }
            failResult(P, g, n) {
                if (this.gen.if(P), n) n();
                else this.error();
                if (g) {
                    if (this.gen.else(), g(), this.allErrors) this.gen.endIf()
                } else if (this.allErrors) this.gen.endIf();
                else this.gen.else()
            }
            pass(P, g) {
                this.failResult((0, B.not)(P), void 0, g)
            }
            fail(P) {
                if (P === void 0) {
                    if (this.error(), !this.allErrors) this.gen.if(!1);
                    return
                }
                if (this.gen.if(P), this.error(), this.allErrors) this.gen.endIf();
                else this.gen.else()
            }
            fail$data(P) {
                if (!this.$data) return this.fail(P);
                let {
                    schemaCode: g
                } = this;
                this.fail(B._`${g} !== undefined && (${(0,B.or)(this.invalid$data(),P)})`)
            }
            error(P, g, n) {
                if (g) {
                    this.setParams(g), this._error(P, n), this.setParams({});
                    return
                }
                this._error(P, n)
            }
            _error(P, g) {
                (P ? H.reportExtraError : H.reportError)(this, this.def.error, g)
            }
            $dataError() {
                (0, H.reportError)(this, this.def.$dataError || H.keyword$DataError)
            }
            reset() {
                if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
                (0, H.resetErrorsCount)(this.gen, this.errsCount)
            }
            ok(P) {
                if (!this.allErrors) this.gen.if(P)
            }
            setParams(P, g) {
                if (g) Object.assign(this.params, P);
                else this.params = P
            }
            block$data(P, g, n = B.nil) {
                this.gen.block(() => {
                    this.check$data(P, n), g()
                })
            }
            check$data(P = B.nil, g = B.nil) {
                if (!this.$data) return;
                let {
                    gen: n,
                    schemaCode: _6,
                    schemaType: u6,
                    def: s6
                } = this;
                if (n.if((0, B.or)(B._`${_6} === undefined`, g)), P !== B.nil) n.assign(P, !0);
                if (u6.length || s6.validateSchema) {
                    if (n.elseIf(this.invalid$data()), this.$dataError(), P !== B.nil) n.assign(P, !1)
                }
                n.else()
            }
            invalid$data() {
                let {
                    gen: P,
                    schemaCode: g,
                    schemaType: n,
                    def: _6,
                    it: u6
                } = this;
                return (0, B.or)(s6(), z4());

                function s6() {
                    if (n.length) {
                        if (!(g instanceof B.Name)) throw Error("ajv implementation error");
                        let m4 = Array.isArray(n) ? n : [n];
                        return B._`${(0,N.checkDataTypes)(m4,g,u6.opts.strictNumbers,N.DataType.Wrong)}`
                    }
                    return B.nil
                }

                function z4() {
                    if (_6.validateSchema) {
                        let m4 = P.scopeValue("validate$data", {
                            ref: _6.validateSchema
                        });
                        return B._`!${m4}(${g})`
                    }
                    return B.nil
                }
            }
            subschema(P, g) {
                let n = (0, j.getSubschema)(this.it, P);
                (0, j.extendSubschemaData)(n, this.it, P), (0, j.extendSubschemaMode)(n, P);
                let _6 = {
                    ...this.it,
                    ...n,
                    items: void 0,
                    props: void 0
                };
                return G(_6, g), _6
            }
            mergeEvaluated(P, g) {
                let {
                    it: n,
                    gen: _6
                } = this;
                if (!n.opts.unevaluated) return;
                if (n.props !== !0 && P.props !== void 0) n.props = q.mergeEvaluated.props(_6, P.props, n.props, g);
                if (n.items !== !0 && P.items !== void 0) n.items = q.mergeEvaluated.items(_6, P.items, n.items, g)
            }
            mergeValidEvaluated(P, g) {
                let {
                    it: n,
                    gen: _6
                } = this;
                if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0)) return _6.if(g, () => this.mergeEvaluated(P, B.Name)), !0
            }
        }
        v.KeywordCxt = f6;

        function Y6(P, g, n, _6) {
            let u6 = new f6(P, n, g);
            if ("code" in n) n.code(u6, _6);
            else if (u6.$data && n.validate)(0, x.funcKeywordCode)(u6, n);
            else if ("macro" in n)(0, x.macroKeywordCode)(u6, n);
            else if (n.compile || n.validate)(0, x.funcKeywordCode)(u6, n)
        }
        var X6 = /^\/(?:[^~]|~0|~1)*$/,
            t0 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

        function t3(P, {
            dataLevel: g,
            dataNames: n,
            dataPathArr: _6
        }) {
            let u6, s6;
            if (P === "") return O.default.rootData;
            if (P[0] === "/") {
                if (!X6.test(P)) throw Error(`Invalid JSON-pointer: ${P}`);
                u6 = P, s6 = O.default.rootData
            } else {
                let U4 = t0.exec(P);
                if (!U4) throw Error(`Invalid JSON-pointer: ${P}`);
                let g0 = +U4[1];
                if (u6 = U4[2], u6 === "#") {
                    if (g0 >= g) throw Error(W3("property/index", g0));
                    return _6[g - g0]
                }
                if (g0 > g) throw Error(W3("data", g0));
                if (s6 = n[g - g0], !u6) return s6
            }
            let z4 = s6,
                m4 = u6.split("/");
            for (let U4 of m4)
                if (U4) s6 = B._`${s6}${(0,B.getProperty)((0,q.unescapeJsonPointer)(U4))}`, z4 = B._`${z4} && ${s6}`;
            return z4;

            function W3(U4, g0) {
                return `Cannot access ${U4} ${g0} levels up, current level is ${g}`
            }
        }
        v.getData = t3
    }),
    LH = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        class z extends Error {
            constructor(U) {
                super("validation failed");
                this.errors = U, this.ajv = this.validation = !0
            }
        }
        v.default = z
    }),
    CK = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = PK();
        class U extends Error {
            constructor(V, N, K, x) {
                super(x || `can't resolve reference ${K} from id ${N}`);
                this.missingRef = (0, z.resolveUrl)(V, N, K), this.missingSchema = (0, z.normalizeId)((0, z.getFullPath)(V, this.missingRef))
            }
        }
        v.default = U
    }),
    FH = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.resolveSchema = v.getCompilingSchema = v.resolveRef = v.compileSchema = v.SchemaEnv = void 0;
        var z = v0(),
            U = LH(),
            V = Q9(),
            N = PK(),
            K = Z0(),
            x = _K();
        class j {
            constructor($) {
                var F;
                this.refs = {}, this.dynamicAnchors = {};
                let L;
                if (typeof $.schema == "object") L = $.schema;
                this.schema = $.schema, this.schemaId = $.schemaId, this.root = $.root || this, this.baseId = (F = $.baseId) !== null && F !== void 0 ? F : (0, N.normalizeId)(L === null || L === void 0 ? void 0 : L[$.schemaId || "$id"]), this.schemaPath = $.schemaPath, this.localRefs = $.localRefs, this.meta = $.meta, this.$async = L === null || L === void 0 ? void 0 : L.$async, this.refs = {}
            }
        }
        v.SchemaEnv = j;

        function B($) {
            let F = q.call(this, $);
            if (F) return F;
            let L = (0, N.getFullPath)(this.opts.uriResolver, $.root.baseId),
                {
                    es5: G,
                    lines: I
                } = this.opts.code,
                {
                    ownProperties: M
                } = this.opts,
                b = new z.CodeGen(this.scope, {
                    es5: G,
                    lines: I,
                    ownProperties: M
                }),
                W;
            if ($.$async) W = b.scopeValue("Error", {
                ref: U.default,
                code: z._`require("ajv/dist/runtime/validation_error").default`
            });
            let E = b.scopeName("validate");
            $.validateName = E;
            let y = {
                    gen: b,
                    allErrors: this.opts.allErrors,
                    data: V.default.data,
                    parentData: V.default.parentData,
                    parentDataProperty: V.default.parentDataProperty,
                    dataNames: [V.default.data],
                    dataPathArr: [z.nil],
                    dataLevel: 0,
                    dataTypes: [],
                    definedProperties: new Set,
                    topSchemaRef: b.scopeValue("schema", this.opts.code.source === !0 ? {
                        ref: $.schema,
                        code: (0, z.stringify)($.schema)
                    } : {
                        ref: $.schema
                    }),
                    validateName: E,
                    ValidationError: W,
                    schema: $.schema,
                    schemaEnv: $,
                    rootId: L,
                    baseId: $.baseId || L,
                    schemaPath: z.nil,
                    errSchemaPath: $.schemaPath || (this.opts.jtd ? "" : "#"),
                    errorPath: z._`""`,
                    opts: this.opts,
                    self: this
                },
                T;
            try {
                this._compilations.add($), (0, x.validateFunctionCode)(y), b.optimize(this.opts.code.optimize);
                let X = b.toString();
                if (T = `${b.scopeRefs(V.default.scope)}return ${X}`, this.opts.code.process) T = this.opts.code.process(T, $);
                let Q = Function(`${V.default.self}`, `${V.default.scope}`, T)(this, this.scope.get());
                if (this.scope.value(E, {
                        ref: Q
                    }), Q.errors = null, Q.schema = $.schema, Q.schemaEnv = $, $.$async) Q.$async = !0;
                if (this.opts.code.source === !0) Q.source = {
                    validateName: E,
                    validateCode: X,
                    scopeValues: b._values
                };
                if (this.opts.unevaluated) {
                    let {
                        props: m,
                        items: P6
                    } = y;
                    if (Q.evaluated = {
                            props: m instanceof z.Name ? void 0 : m,
                            items: P6 instanceof z.Name ? void 0 : P6,
                            dynamicProps: m instanceof z.Name,
                            dynamicItems: P6 instanceof z.Name
                        }, Q.source) Q.source.evaluated = (0, z.stringify)(Q.evaluated)
                }
                return $.validate = Q, $
            } catch (X) {
                if (delete $.validate, delete $.validateName, T) this.logger.error("Error compiling schema, function code:", T);
                throw X
            } finally {
                this._compilations.delete($)
            }
        }
        v.compileSchema = B;

        function O($, F, L) {
            var G;
            L = (0, N.resolveUrl)(this.opts.uriResolver, F, L);
            let I = $.refs[L];
            if (I) return I;
            let M = D.call(this, $, L);
            if (M === void 0) {
                let b = (G = $.localRefs) === null || G === void 0 ? void 0 : G[L],
                    {
                        schemaId: W
                    } = this.opts;
                if (b) M = new j({
                    schema: b,
                    schemaId: W,
                    root: $,
                    baseId: F
                })
            }
            if (M === void 0) return;
            return $.refs[L] = J.call(this, M)
        }
        v.resolveRef = O;

        function J($) {
            if ((0, N.inlineRef)($.schema, this.opts.inlineRefs)) return $.schema;
            return $.validate ? $ : B.call(this, $)
        }

        function q($) {
            for (let F of this._compilations)
                if (H(F, $)) return F
        }
        v.getCompilingSchema = q;

        function H($, F) {
            return $.schema === F.schema && $.root === F.root && $.baseId === F.baseId
        }

        function D($, F) {
            let L;
            while (typeof(L = this.refs[F]) == "string") F = L;
            return L || this.schemas[F] || A.call(this, $, F)
        }

        function A($, F) {
            let L = this.opts.uriResolver.parse(F),
                G = (0, N._getFullPath)(this.opts.uriResolver, L),
                I = (0, N.getFullPath)(this.opts.uriResolver, $.baseId, void 0);
            if (Object.keys($.schema).length > 0 && G === I) return Z.call(this, L, $);
            let M = (0, N.normalizeId)(G),
                b = this.refs[M] || this.schemas[M];
            if (typeof b == "string") {
                let W = A.call(this, $, b);
                if (typeof(W === null || W === void 0 ? void 0 : W.schema) !== "object") return;
                return Z.call(this, L, W)
            }
            if (typeof(b === null || b === void 0 ? void 0 : b.schema) !== "object") return;
            if (!b.validate) B.call(this, b);
            if (M === (0, N.normalizeId)(F)) {
                let {
                    schema: W
                } = b, {
                    schemaId: E
                } = this.opts, y = W[E];
                if (y) I = (0, N.resolveUrl)(this.opts.uriResolver, I, y);
                return new j({
                    schema: W,
                    schemaId: E,
                    root: $,
                    baseId: I
                })
            }
            return Z.call(this, L, b)
        }
        v.resolveSchema = A;
        var w = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);

        function Z($, {
            baseId: F,
            schema: L,
            root: G
        }) {
            var I;
            if (((I = $.fragment) === null || I === void 0 ? void 0 : I[0]) !== "/") return;
            for (let W of $.fragment.slice(1).split("/")) {
                if (typeof L === "boolean") return;
                let E = L[(0, K.unescapeFragment)(W)];
                if (E === void 0) return;
                L = E;
                let y = typeof L === "object" && L[this.opts.schemaId];
                if (!w.has(W) && y) F = (0, N.resolveUrl)(this.opts.uriResolver, F, y)
            }
            let M;
            if (typeof L != "boolean" && L.$ref && !(0, K.schemaHasRulesButRef)(L, this.RULES)) {
                let W = (0, N.resolveUrl)(this.opts.uriResolver, F, L.$ref);
                M = A.call(this, G, W)
            }
            let {
                schemaId: b
            } = this.opts;
            if (M = M || new j({
                    schema: L,
                    schemaId: b,
                    root: G,
                    baseId: F
                }), M.schema !== M.root.schema) return M;
            return
        }
    }),
    WQ = J6((v, z) => {
        z.exports = {
            $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
            description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
            type: "object",
            required: ["$data"],
            properties: {
                $data: {
                    type: "string",
                    anyOf: [{
                        format: "relative-json-pointer"
                    }, {
                        format: "json-pointer"
                    }]
                }
            },
            additionalProperties: !1
        }
    }),
    EQ = J6((v, z) => {
        var U = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15
        };
        z.exports = {
            HEX: U
        }
    }),
    SQ = J6((v, z) => {
        var {
            HEX: U
        } = EQ(), V = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;

        function N($) {
            if (O($, ".") < 3) return {
                host: $,
                isIPV4: !1
            };
            let F = $.match(V) || [],
                [L] = F;
            if (L) return {
                host: B(L, "."),
                isIPV4: !0
            };
            else return {
                host: $,
                isIPV4: !1
            }
        }

        function K($, F = !1) {
            let L = "",
                G = !0;
            for (let I of $) {
                if (U[I] === void 0) return;
                if (I !== "0" && G === !0) G = !1;
                if (!G) L += I
            }
            if (F && L.length === 0) L = "0";
            return L
        }

        function x($) {
            let F = 0,
                L = {
                    error: !1,
                    address: "",
                    zone: ""
                },
                G = [],
                I = [],
                M = !1,
                b = !1,
                W = !1;

            function E() {
                if (I.length) {
                    if (M === !1) {
                        let y = K(I);
                        if (y !== void 0) G.push(y);
                        else return L.error = !0, !1
                    }
                    I.length = 0
                }
                return !0
            }
            for (let y = 0; y < $.length; y++) {
                let T = $[y];
                if (T === "[" || T === "]") continue;
                if (T === ":") {
                    if (b === !0) W = !0;
                    if (!E()) break;
                    if (F++, G.push(":"), F > 7) {
                        L.error = !0;
                        break
                    }
                    if (y - 1 >= 0 && $[y - 1] === ":") b = !0;
                    continue
                } else if (T === "%") {
                    if (!E()) break;
                    M = !0
                } else {
                    I.push(T);
                    continue
                }
            }
            if (I.length)
                if (M) L.zone = I.join("");
                else if (W) G.push(I.join(""));
            else G.push(K(I));
            return L.address = G.join(""), L
        }

        function j($) {
            if (O($, ":") < 2) return {
                host: $,
                isIPV6: !1
            };
            let F = x($);
            if (!F.error) {
                let {
                    address: L,
                    address: G
                } = F;
                if (F.zone) L += "%" + F.zone, G += "%25" + F.zone;
                return {
                    host: L,
                    escapedHost: G,
                    isIPV6: !0
                }
            } else return {
                host: $,
                isIPV6: !1
            }
        }

        function B($, F) {
            let L = "",
                G = !0,
                I = $.length;
            for (let M = 0; M < I; M++) {
                let b = $[M];
                if (b === "0" && G) {
                    if (M + 1 <= I && $[M + 1] === F || M + 1 === I) L += b, G = !1
                } else {
                    if (b === F) G = !0;
                    else G = !1;
                    L += b
                }
            }
            return L
        }

        function O($, F) {
            let L = 0;
            for (let G = 0; G < $.length; G++)
                if ($[G] === F) L++;
            return L
        }
        var J = /^\.\.?\//u,
            q = /^\/\.(?:\/|$)/u,
            H = /^\/\.\.(?:\/|$)/u,
            D = /^\/?(?:.|\n)*?(?=\/|$)/u;

        function A($) {
            let F = [];
            while ($.length)
                if ($.match(J)) $ = $.replace(J, "");
                else if ($.match(q)) $ = $.replace(q, "/");
            else if ($.match(H)) $ = $.replace(H, "/"), F.pop();
            else if ($ === "." || $ === "..") $ = "";
            else {
                let L = $.match(D);
                if (L) {
                    let G = L[0];
                    $ = $.slice(G.length), F.push(G)
                } else throw Error("Unexpected dot segment condition")
            }
            return F.join("")
        }

        function w($, F) {
            let L = F !== !0 ? escape : unescape;
            if ($.scheme !== void 0) $.scheme = L($.scheme);
            if ($.userinfo !== void 0) $.userinfo = L($.userinfo);
            if ($.host !== void 0) $.host = L($.host);
            if ($.path !== void 0) $.path = L($.path);
            if ($.query !== void 0) $.query = L($.query);
            if ($.fragment !== void 0) $.fragment = L($.fragment);
            return $
        }

        function Z($) {
            let F = [];
            if ($.userinfo !== void 0) F.push($.userinfo), F.push("@");
            if ($.host !== void 0) {
                let L = unescape($.host),
                    G = N(L);
                if (G.isIPV4) L = G.host;
                else {
                    let I = j(G.host);
                    if (I.isIPV6 === !0) L = `[${I.escapedHost}]`;
                    else L = $.host
                }
                F.push(L)
            }
            if (typeof $.port === "number" || typeof $.port === "string") F.push(":"), F.push(String($.port));
            return F.length ? F.join("") : void 0
        }
        z.exports = {
            recomposeAuthority: Z,
            normalizeComponentEncoding: w,
            removeDotSegments: A,
            normalizeIPv4: N,
            normalizeIPv6: j,
            stringArrayToHexStripped: K
        }
    }),
    PQ = J6((v, z) => {
        var U = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu,
            V = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

        function N(G) {
            return typeof G.secure === "boolean" ? G.secure : String(G.scheme).toLowerCase() === "wss"
        }

        function K(G) {
            if (!G.host) G.error = G.error || "HTTP URIs must have a host.";
            return G
        }

        function x(G) {
            let I = String(G.scheme).toLowerCase() === "https";
            if (G.port === (I ? 443 : 80) || G.port === "") G.port = void 0;
            if (!G.path) G.path = "/";
            return G
        }

        function j(G) {
            return G.secure = N(G), G.resourceName = (G.path || "/") + (G.query ? "?" + G.query : ""), G.path = void 0, G.query = void 0, G
        }

        function B(G) {
            if (G.port === (N(G) ? 443 : 80) || G.port === "") G.port = void 0;
            if (typeof G.secure === "boolean") G.scheme = G.secure ? "wss" : "ws", G.secure = void 0;
            if (G.resourceName) {
                let [I, M] = G.resourceName.split("?");
                G.path = I && I !== "/" ? I : void 0, G.query = M, G.resourceName = void 0
            }
            return G.fragment = void 0, G
        }

        function O(G, I) {
            if (!G.path) return G.error = "URN can not be parsed", G;
            let M = G.path.match(V);
            if (M) {
                let b = I.scheme || G.scheme || "urn";
                G.nid = M[1].toLowerCase(), G.nss = M[2];
                let W = `${b}:${I.nid||G.nid}`,
                    E = L[W];
                if (G.path = void 0, E) G = E.parse(G, I)
            } else G.error = G.error || "URN can not be parsed.";
            return G
        }

        function J(G, I) {
            let M = I.scheme || G.scheme || "urn",
                b = G.nid.toLowerCase(),
                W = `${M}:${I.nid||b}`,
                E = L[W];
            if (E) G = E.serialize(G, I);
            let y = G,
                T = G.nss;
            return y.path = `${b||I.nid}:${T}`, I.skipEscape = !0, y
        }

        function q(G, I) {
            let M = G;
            if (M.uuid = M.nss, M.nss = void 0, !I.tolerant && (!M.uuid || !U.test(M.uuid))) M.error = M.error || "UUID is not valid.";
            return M
        }

        function H(G) {
            let I = G;
            return I.nss = (G.uuid || "").toLowerCase(), I
        }
        var D = {
                scheme: "http",
                domainHost: !0,
                parse: K,
                serialize: x
            },
            A = {
                scheme: "https",
                domainHost: D.domainHost,
                parse: K,
                serialize: x
            },
            w = {
                scheme: "ws",
                domainHost: !0,
                parse: j,
                serialize: B
            },
            Z = {
                scheme: "wss",
                domainHost: w.domainHost,
                parse: w.parse,
                serialize: w.serialize
            },
            $ = {
                scheme: "urn",
                parse: O,
                serialize: J,
                skipNormalize: !0
            },
            F = {
                scheme: "urn:uuid",
                parse: q,
                serialize: H,
                skipNormalize: !0
            },
            L = {
                http: D,
                https: A,
                ws: w,
                wss: Z,
                urn: $,
                "urn:uuid": F
            };
        z.exports = L
    }),
    _Q = J6((v, z) => {
        var {
            normalizeIPv6: U,
            normalizeIPv4: V,
            removeDotSegments: N,
            recomposeAuthority: K,
            normalizeComponentEncoding: x
        } = SQ(), j = PQ();

        function B(F, L) {
            if (typeof F === "string") F = H(Z(F, L), L);
            else if (typeof F === "object") F = Z(H(F, L), L);
            return F
        }

        function O(F, L, G) {
            let I = Object.assign({
                    scheme: "null"
                }, G),
                M = J(Z(F, I), Z(L, I), I, !0);
            return H(M, {
                ...I,
                skipEscape: !0
            })
        }

        function J(F, L, G, I) {
            let M = {};
            if (!I) F = Z(H(F, G), G), L = Z(H(L, G), G);
            if (G = G || {}, !G.tolerant && L.scheme) M.scheme = L.scheme, M.userinfo = L.userinfo, M.host = L.host, M.port = L.port, M.path = N(L.path || ""), M.query = L.query;
            else {
                if (L.userinfo !== void 0 || L.host !== void 0 || L.port !== void 0) M.userinfo = L.userinfo, M.host = L.host, M.port = L.port, M.path = N(L.path || ""), M.query = L.query;
                else {
                    if (!L.path)
                        if (M.path = F.path, L.query !== void 0) M.query = L.query;
                        else M.query = F.query;
                    else {
                        if (L.path.charAt(0) === "/") M.path = N(L.path);
                        else {
                            if ((F.userinfo !== void 0 || F.host !== void 0 || F.port !== void 0) && !F.path) M.path = "/" + L.path;
                            else if (!F.path) M.path = L.path;
                            else M.path = F.path.slice(0, F.path.lastIndexOf("/") + 1) + L.path;
                            M.path = N(M.path)
                        }
                        M.query = L.query
                    }
                    M.userinfo = F.userinfo, M.host = F.host, M.port = F.port
                }
                M.scheme = F.scheme
            }
            return M.fragment = L.fragment, M
        }

        function q(F, L, G) {
            if (typeof F === "string") F = unescape(F), F = H(x(Z(F, G), !0), {
                ...G,
                skipEscape: !0
            });
            else if (typeof F === "object") F = H(x(F, !0), {
                ...G,
                skipEscape: !0
            });
            if (typeof L === "string") L = unescape(L), L = H(x(Z(L, G), !0), {
                ...G,
                skipEscape: !0
            });
            else if (typeof L === "object") L = H(x(L, !0), {
                ...G,
                skipEscape: !0
            });
            return F.toLowerCase() === L.toLowerCase()
        }

        function H(F, L) {
            let G = {
                    host: F.host,
                    scheme: F.scheme,
                    userinfo: F.userinfo,
                    port: F.port,
                    path: F.path,
                    query: F.query,
                    nid: F.nid,
                    nss: F.nss,
                    uuid: F.uuid,
                    fragment: F.fragment,
                    reference: F.reference,
                    resourceName: F.resourceName,
                    secure: F.secure,
                    error: ""
                },
                I = Object.assign({}, L),
                M = [],
                b = j[(I.scheme || G.scheme || "").toLowerCase()];
            if (b && b.serialize) b.serialize(G, I);
            if (G.path !== void 0)
                if (!I.skipEscape) {
                    if (G.path = escape(G.path), G.scheme !== void 0) G.path = G.path.split("%3A").join(":")
                } else G.path = unescape(G.path);
            if (I.reference !== "suffix" && G.scheme) M.push(G.scheme, ":");
            let W = K(G);
            if (W !== void 0) {
                if (I.reference !== "suffix") M.push("//");
                if (M.push(W), G.path && G.path.charAt(0) !== "/") M.push("/")
            }
            if (G.path !== void 0) {
                let E = G.path;
                if (!I.absolutePath && (!b || !b.absolutePath)) E = N(E);
                if (W === void 0) E = E.replace(/^\/\//u, "/%2F");
                M.push(E)
            }
            if (G.query !== void 0) M.push("?", G.query);
            if (G.fragment !== void 0) M.push("#", G.fragment);
            return M.join("")
        }
        var D = Array.from({
            length: 127
        }, (F, L) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(L)));

        function A(F) {
            let L = 0;
            for (let G = 0, I = F.length; G < I; ++G)
                if (L = F.charCodeAt(G), L > 126 || D[L]) return !0;
            return !1
        }
        var w = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

        function Z(F, L) {
            let G = Object.assign({}, L),
                I = {
                    scheme: void 0,
                    userinfo: void 0,
                    host: "",
                    port: void 0,
                    path: "",
                    query: void 0,
                    fragment: void 0
                },
                M = F.indexOf("%") !== -1,
                b = !1;
            if (G.reference === "suffix") F = (G.scheme ? G.scheme + ":" : "") + "//" + F;
            let W = F.match(w);
            if (W) {
                if (I.scheme = W[1], I.userinfo = W[3], I.host = W[4], I.port = parseInt(W[5], 10), I.path = W[6] || "", I.query = W[7], I.fragment = W[8], isNaN(I.port)) I.port = W[5];
                if (I.host) {
                    let y = V(I.host);
                    if (y.isIPV4 === !1) {
                        let T = U(y.host);
                        I.host = T.host.toLowerCase(), b = T.isIPV6
                    } else I.host = y.host, b = !0
                }
                if (I.scheme === void 0 && I.userinfo === void 0 && I.host === void 0 && I.port === void 0 && I.query === void 0 && !I.path) I.reference = "same-document";
                else if (I.scheme === void 0) I.reference = "relative";
                else if (I.fragment === void 0) I.reference = "absolute";
                else I.reference = "uri";
                if (G.reference && G.reference !== "suffix" && G.reference !== I.reference) I.error = I.error || "URI is not a " + G.reference + " reference.";
                let E = j[(G.scheme || I.scheme || "").toLowerCase()];
                if (!G.unicodeSupport && (!E || !E.unicodeSupport)) {
                    if (I.host && (G.domainHost || E && E.domainHost) && b === !1 && A(I.host)) try {
                        I.host = URL.domainToASCII(I.host.toLowerCase())
                    } catch (y) {
                        I.error = I.error || "Host's domain name can not be converted to ASCII: " + y
                    }
                }
                if (!E || E && !E.skipNormalize) {
                    if (M && I.scheme !== void 0) I.scheme = unescape(I.scheme);
                    if (M && I.host !== void 0) I.host = unescape(I.host);
                    if (I.path) I.path = escape(unescape(I.path));
                    if (I.fragment) I.fragment = encodeURI(decodeURIComponent(I.fragment))
                }
                if (E && E.parse) E.parse(I, G)
            } else I.error = I.error || "URI can not be parsed.";
            return I
        }
        var $ = {
            SCHEMES: j,
            normalize: B,
            resolve: O,
            resolveComponents: J,
            equal: q,
            serialize: H,
            parse: Z
        };
        z.exports = $, z.exports.default = $, z.exports.fastUri = $
    }),
    CQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = _Q();
        z.code = 'require("ajv/dist/runtime/uri").default', v.default = z
    }),
    fQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.CodeGen = v.Name = v.nil = v.stringify = v.str = v._ = v.KeywordCxt = void 0;
        var z = _K();
        Object.defineProperty(v, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return z.KeywordCxt
            }
        });
        var U = v0();
        Object.defineProperty(v, "_", {
            enumerable: !0,
            get: function() {
                return U._
            }
        }), Object.defineProperty(v, "str", {
            enumerable: !0,
            get: function() {
                return U.str
            }
        }), Object.defineProperty(v, "stringify", {
            enumerable: !0,
            get: function() {
                return U.stringify
            }
        }), Object.defineProperty(v, "nil", {
            enumerable: !0,
            get: function() {
                return U.nil
            }
        }), Object.defineProperty(v, "Name", {
            enumerable: !0,
            get: function() {
                return U.Name
            }
        }), Object.defineProperty(v, "CodeGen", {
            enumerable: !0,
            get: function() {
                return U.CodeGen
            }
        });
        var V = LH(),
            N = CK(),
            K = lR(),
            x = FH(),
            j = v0(),
            B = PK(),
            O = qK(),
            J = Z0(),
            q = WQ(),
            H = CQ(),
            D = (C, u) => new RegExp(C, u);
        D.code = "new RegExp";
        var A = ["removeAdditional", "useDefaults", "coerceTypes"],
            w = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]),
            Z = {
                errorDataPath: "",
                format: "`validateFormats: false` can be used instead.",
                nullable: '"nullable" keyword is supported by default.',
                jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
                extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
                missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
                processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
                sourceCode: "Use option `code: {source: true}`",
                strictDefaults: "It is default now, see option `strict`.",
                strictKeywords: "It is default now, see option `strict`.",
                uniqueItems: '"uniqueItems" keyword is always validated.',
                unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
                cache: "Map is used as cache, schema object as key.",
                serialize: "Map is used as cache, schema object as key.",
                ajvErrors: "It is default now."
            },
            $ = {
                ignoreKeywordsWithRef: "",
                jsPropertySyntax: "",
                unicode: '"minLength"/"maxLength" account for unicode characters by default.'
            },
            F = 200;

        function L(C) {
            var u, p, R, S, k, D6, f6, Y6, X6, t0, t3, P, g, n, _6, u6, s6, z4, m4, W3, U4, g0, y7, m3, lJ;
            let t1 = C.strict,
                hJ = (u = C.code) === null || u === void 0 ? void 0 : u.optimize,
                NG = hJ === !0 || hJ === void 0 ? 1 : hJ || 0,
                KG = (R = (p = C.code) === null || p === void 0 ? void 0 : p.regExp) !== null && R !== void 0 ? R : D,
                ui = (S = C.uriResolver) !== null && S !== void 0 ? S : H.default;
            return {
                strictSchema: (D6 = (k = C.strictSchema) !== null && k !== void 0 ? k : t1) !== null && D6 !== void 0 ? D6 : !0,
                strictNumbers: (Y6 = (f6 = C.strictNumbers) !== null && f6 !== void 0 ? f6 : t1) !== null && Y6 !== void 0 ? Y6 : !0,
                strictTypes: (t0 = (X6 = C.strictTypes) !== null && X6 !== void 0 ? X6 : t1) !== null && t0 !== void 0 ? t0 : "log",
                strictTuples: (P = (t3 = C.strictTuples) !== null && t3 !== void 0 ? t3 : t1) !== null && P !== void 0 ? P : "log",
                strictRequired: (n = (g = C.strictRequired) !== null && g !== void 0 ? g : t1) !== null && n !== void 0 ? n : !1,
                code: C.code ? {
                    ...C.code,
                    optimize: NG,
                    regExp: KG
                } : {
                    optimize: NG,
                    regExp: KG
                },
                loopRequired: (_6 = C.loopRequired) !== null && _6 !== void 0 ? _6 : F,
                loopEnum: (u6 = C.loopEnum) !== null && u6 !== void 0 ? u6 : F,
                meta: (s6 = C.meta) !== null && s6 !== void 0 ? s6 : !0,
                messages: (z4 = C.messages) !== null && z4 !== void 0 ? z4 : !0,
                inlineRefs: (m4 = C.inlineRefs) !== null && m4 !== void 0 ? m4 : !0,
                schemaId: (W3 = C.schemaId) !== null && W3 !== void 0 ? W3 : "$id",
                addUsedSchema: (U4 = C.addUsedSchema) !== null && U4 !== void 0 ? U4 : !0,
                validateSchema: (g0 = C.validateSchema) !== null && g0 !== void 0 ? g0 : !0,
                validateFormats: (y7 = C.validateFormats) !== null && y7 !== void 0 ? y7 : !0,
                unicodeRegExp: (m3 = C.unicodeRegExp) !== null && m3 !== void 0 ? m3 : !0,
                int32range: (lJ = C.int32range) !== null && lJ !== void 0 ? lJ : !0,
                uriResolver: ui
            }
        }
        class G {
            constructor(C = {}) {
                this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = new Set, this._loading = {}, this._cache = new Map, C = this.opts = {
                    ...C,
                    ...L(C)
                };
                let {
                    es5: u,
                    lines: p
                } = this.opts.code;
                this.scope = new j.ValueScope({
                    scope: {},
                    prefixes: w,
                    es5: u,
                    lines: p
                }), this.logger = X(C.logger);
                let R = C.validateFormats;
                if (C.validateFormats = !1, this.RULES = (0, K.getRules)(), I.call(this, Z, C, "NOT SUPPORTED"), I.call(this, $, C, "DEPRECATED", "warn"), this._metaOpts = y.call(this), C.formats) W.call(this);
                if (this._addVocabularies(), this._addDefaultMetaSchema(), C.keywords) E.call(this, C.keywords);
                if (typeof C.meta == "object") this.addMetaSchema(C.meta);
                b.call(this), C.validateFormats = R
            }
            _addVocabularies() {
                this.addKeyword("$async")
            }
            _addDefaultMetaSchema() {
                let {
                    $data: C,
                    meta: u,
                    schemaId: p
                } = this.opts, R = q;
                if (p === "id") R = {
                    ...q
                }, R.id = R.$id, delete R.$id;
                if (u && C) this.addMetaSchema(R, R[p], !1)
            }
            defaultMeta() {
                let {
                    meta: C,
                    schemaId: u
                } = this.opts;
                return this.opts.defaultMeta = typeof C == "object" ? C[u] || C : void 0
            }
            validate(C, u) {
                let p;
                if (typeof C == "string") {
                    if (p = this.getSchema(C), !p) throw Error(`no schema with key or ref "${C}"`)
                } else p = this.compile(C);
                let R = p(u);
                if (!("$async" in p)) this.errors = p.errors;
                return R
            }
            compile(C, u) {
                let p = this._addSchema(C, u);
                return p.validate || this._compileSchemaEnv(p)
            }
            compileAsync(C, u) {
                if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
                let {
                    loadSchema: p
                } = this.opts;
                return R.call(this, C, u);
                async function R(X6, t0) {
                    await S.call(this, X6.$schema);
                    let t3 = this._addSchema(X6, t0);
                    return t3.validate || k.call(this, t3)
                }
                async function S(X6) {
                    if (X6 && !this.getSchema(X6)) await R.call(this, {
                        $ref: X6
                    }, !0)
                }
                async function k(X6) {
                    try {
                        return this._compileSchemaEnv(X6)
                    } catch (t0) {
                        if (!(t0 instanceof N.default)) throw t0;
                        return D6.call(this, t0), await f6.call(this, t0.missingSchema), k.call(this, X6)
                    }
                }

                function D6({
                    missingSchema: X6,
                    missingRef: t0
                }) {
                    if (this.refs[X6]) throw Error(`AnySchema ${X6} is loaded but ${t0} cannot be resolved`)
                }
                async function f6(X6) {
                    let t0 = await Y6.call(this, X6);
                    if (!this.refs[X6]) await S.call(this, t0.$schema);
                    if (!this.refs[X6]) this.addSchema(t0, X6, u)
                }
                async function Y6(X6) {
                    let t0 = this._loading[X6];
                    if (t0) return t0;
                    try {
                        return await (this._loading[X6] = p(X6))
                    } finally {
                        delete this._loading[X6]
                    }
                }
            }
            addSchema(C, u, p, R = this.opts.validateSchema) {
                if (Array.isArray(C)) {
                    for (let k of C) this.addSchema(k, void 0, p, R);
                    return this
                }
                let S;
                if (typeof C === "object") {
                    let {
                        schemaId: k
                    } = this.opts;
                    if (S = C[k], S !== void 0 && typeof S != "string") throw Error(`schema ${k} must be string`)
                }
                return u = (0, B.normalizeId)(u || S), this._checkUnique(u), this.schemas[u] = this._addSchema(C, p, u, R, !0), this
            }
            addMetaSchema(C, u, p = this.opts.validateSchema) {
                return this.addSchema(C, u, !0, p), this
            }
            validateSchema(C, u) {
                if (typeof C == "boolean") return !0;
                let p;
                if (p = C.$schema, p !== void 0 && typeof p != "string") throw Error("$schema must be a string");
                if (p = p || this.opts.defaultMeta || this.defaultMeta(), !p) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
                let R = this.validate(p, C);
                if (!R && u) {
                    let S = "schema is invalid: " + this.errorsText();
                    if (this.opts.validateSchema === "log") this.logger.error(S);
                    else throw Error(S)
                }
                return R
            }
            getSchema(C) {
                let u;
                while (typeof(u = M.call(this, C)) == "string") C = u;
                if (u === void 0) {
                    let {
                        schemaId: p
                    } = this.opts, R = new x.SchemaEnv({
                        schema: {},
                        schemaId: p
                    });
                    if (u = x.resolveSchema.call(this, R, C), !u) return;
                    this.refs[C] = u
                }
                return u.validate || this._compileSchemaEnv(u)
            }
            removeSchema(C) {
                if (C instanceof RegExp) return this._removeAllSchemas(this.schemas, C), this._removeAllSchemas(this.refs, C), this;
                switch (typeof C) {
                    case "undefined":
                        return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
                    case "string": {
                        let u = M.call(this, C);
                        if (typeof u == "object") this._cache.delete(u.schema);
                        return delete this.schemas[C], delete this.refs[C], this
                    }
                    case "object": {
                        let u = C;
                        this._cache.delete(u);
                        let p = C[this.opts.schemaId];
                        if (p) p = (0, B.normalizeId)(p), delete this.schemas[p], delete this.refs[p];
                        return this
                    }
                    default:
                        throw Error("ajv.removeSchema: invalid parameter")
                }
            }
            addVocabulary(C) {
                for (let u of C) this.addKeyword(u);
                return this
            }
            addKeyword(C, u) {
                let p;
                if (typeof C == "string") {
                    if (p = C, typeof u == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), u.keyword = p
                } else if (typeof C == "object" && u === void 0) {
                    if (u = C, p = u.keyword, Array.isArray(p) && !p.length) throw Error("addKeywords: keyword must be string or non-empty array")
                } else throw Error("invalid addKeywords parameters");
                if (m.call(this, p, u), !u) return (0, J.eachItem)(p, (S) => P6.call(this, S)), this;
                q6.call(this, u);
                let R = {
                    ...u,
                    type: (0, O.getJSONTypes)(u.type),
                    schemaType: (0, O.getJSONTypes)(u.schemaType)
                };
                return (0, J.eachItem)(p, R.type.length === 0 ? (S) => P6.call(this, S, R) : (S) => R.type.forEach((k) => P6.call(this, S, R, k))), this
            }
            getKeyword(C) {
                let u = this.RULES.all[C];
                return typeof u == "object" ? u.definition : !!u
            }
            removeKeyword(C) {
                let {
                    RULES: u
                } = this;
                delete u.keywords[C], delete u.all[C];
                for (let p of u.rules) {
                    let R = p.rules.findIndex((S) => S.keyword === C);
                    if (R >= 0) p.rules.splice(R, 1)
                }
                return this
            }
            addFormat(C, u) {
                if (typeof u == "string") u = new RegExp(u);
                return this.formats[C] = u, this
            }
            errorsText(C = this.errors, {
                separator: u = ", ",
                dataVar: p = "data"
            } = {}) {
                if (!C || C.length === 0) return "No errors";
                return C.map((R) => `${p}${R.instancePath} ${R.message}`).reduce((R, S) => R + u + S)
            }
            $dataMetaSchema(C, u) {
                let p = this.RULES.all;
                C = JSON.parse(JSON.stringify(C));
                for (let R of u) {
                    let S = R.split("/").slice(1),
                        k = C;
                    for (let D6 of S) k = k[D6];
                    for (let D6 in p) {
                        let f6 = p[D6];
                        if (typeof f6 != "object") continue;
                        let {
                            $data: Y6
                        } = f6.definition, X6 = k[D6];
                        if (Y6 && X6) k[D6] = T6(X6)
                    }
                }
                return C
            }
            _removeAllSchemas(C, u) {
                for (let p in C) {
                    let R = C[p];
                    if (!u || u.test(p)) {
                        if (typeof R == "string") delete C[p];
                        else if (R && !R.meta) this._cache.delete(R.schema), delete C[p]
                    }
                }
            }
            _addSchema(C, u, p, R = this.opts.validateSchema, S = this.opts.addUsedSchema) {
                let k, {
                    schemaId: D6
                } = this.opts;
                if (typeof C == "object") k = C[D6];
                else if (this.opts.jtd) throw Error("schema must be object");
                else if (typeof C != "boolean") throw Error("schema must be object or boolean");
                let f6 = this._cache.get(C);
                if (f6 !== void 0) return f6;
                p = (0, B.normalizeId)(k || p);
                let Y6 = B.getSchemaRefs.call(this, C, p);
                if (f6 = new x.SchemaEnv({
                        schema: C,
                        schemaId: D6,
                        meta: u,
                        baseId: p,
                        localRefs: Y6
                    }), this._cache.set(f6.schema, f6), S && !p.startsWith("#")) {
                    if (p) this._checkUnique(p);
                    this.refs[p] = f6
                }
                if (R) this.validateSchema(C, !0);
                return f6
            }
            _checkUnique(C) {
                if (this.schemas[C] || this.refs[C]) throw Error(`schema with key or id "${C}" already exists`)
            }
            _compileSchemaEnv(C) {
                if (C.meta) this._compileMetaSchema(C);
                else x.compileSchema.call(this, C);
                if (!C.validate) throw Error("ajv implementation error");
                return C.validate
            }
            _compileMetaSchema(C) {
                let u = this.opts;
                this.opts = this._metaOpts;
                try {
                    x.compileSchema.call(this, C)
                } finally {
                    this.opts = u
                }
            }
        }
        G.ValidationError = V.default, G.MissingRefError = N.default, v.default = G;

        function I(C, u, p, R = "error") {
            for (let S in C) {
                let k = S;
                if (k in u) this.logger[R](`${p}: option ${S}. ${C[k]}`)
            }
        }

        function M(C) {
            return C = (0, B.normalizeId)(C), this.schemas[C] || this.refs[C]
        }

        function b() {
            let C = this.opts.schemas;
            if (!C) return;
            if (Array.isArray(C)) this.addSchema(C);
            else
                for (let u in C) this.addSchema(C[u], u)
        }

        function W() {
            for (let C in this.opts.formats) {
                let u = this.opts.formats[C];
                if (u) this.addFormat(C, u)
            }
        }

        function E(C) {
            if (Array.isArray(C)) {
                this.addVocabulary(C);
                return
            }
            this.logger.warn("keywords option as map is deprecated, pass array");
            for (let u in C) {
                let p = C[u];
                if (!p.keyword) p.keyword = u;
                this.addKeyword(p)
            }
        }

        function y() {
            let C = {
                ...this.opts
            };
            for (let u of A) delete C[u];
            return C
        }
        var T = {
            log() {},
            warn() {},
            error() {}
        };

        function X(C) {
            if (C === !1) return T;
            if (C === void 0) return console;
            if (C.log && C.warn && C.error) return C;
            throw Error("logger must implement log, warn and error methods")
        }
        var Q = /^[a-z_$][a-z0-9_$:-]*$/i;

        function m(C, u) {
            let {
                RULES: p
            } = this;
            if ((0, J.eachItem)(C, (R) => {
                    if (p.keywords[R]) throw Error(`Keyword ${R} is already defined`);
                    if (!Q.test(R)) throw Error(`Keyword ${R} has invalid name`)
                }), !u) return;
            if (u.$data && !(("code" in u) || ("validate" in u))) throw Error('$data keyword must have "code" or "validate" function')
        }

        function P6(C, u, p) {
            var R;
            let S = u === null || u === void 0 ? void 0 : u.post;
            if (p && S) throw Error('keyword with "post" flag cannot have "type"');
            let {
                RULES: k
            } = this, D6 = S ? k.post : k.rules.find(({
                type: Y6
            }) => Y6 === p);
            if (!D6) D6 = {
                type: p,
                rules: []
            }, k.rules.push(D6);
            if (k.keywords[C] = !0, !u) return;
            let f6 = {
                keyword: C,
                definition: {
                    ...u,
                    type: (0, O.getJSONTypes)(u.type),
                    schemaType: (0, O.getJSONTypes)(u.schemaType)
                }
            };
            if (u.before) F6.call(this, D6, f6, u.before);
            else D6.rules.push(f6);
            k.all[C] = f6, (R = u.implements) === null || R === void 0 || R.forEach((Y6) => this.addKeyword(Y6))
        }

        function F6(C, u, p) {
            let R = C.rules.findIndex((S) => S.keyword === p);
            if (R >= 0) C.rules.splice(R, 0, u);
            else C.rules.push(u), this.logger.warn(`rule ${p} is not defined`)
        }

        function q6(C) {
            let {
                metaSchema: u
            } = C;
            if (u === void 0) return;
            if (C.$data && this.opts.$data) u = T6(u);
            C.validateSchema = this.compile(u, !0)
        }
        var Z6 = {
            $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };

        function T6(C) {
            return {
                anyOf: [C, Z6]
            }
        }
    }),
    TQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = {
            keyword: "id",
            code() {
                throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID')
            }
        };
        v.default = z
    }),
    YQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.callRef = v.getValidate = void 0;
        var z = CK(),
            U = N8(),
            V = v0(),
            N = Q9(),
            K = FH(),
            x = Z0(),
            j = {
                keyword: "$ref",
                schemaType: "string",
                code(J) {
                    let {
                        gen: q,
                        schema: H,
                        it: D
                    } = J, {
                        baseId: A,
                        schemaEnv: w,
                        validateName: Z,
                        opts: $,
                        self: F
                    } = D, {
                        root: L
                    } = w;
                    if ((H === "#" || H === "#/") && A === L.baseId) return I();
                    let G = K.resolveRef.call(F, L, A, H);
                    if (G === void 0) throw new z.default(D.opts.uriResolver, A, H);
                    if (G instanceof K.SchemaEnv) return M(G);
                    return b(G);

                    function I() {
                        if (w === L) return O(J, Z, w, w.$async);
                        let W = q.scopeValue("root", {
                            ref: L
                        });
                        return O(J, V._`${W}.validate`, L, L.$async)
                    }

                    function M(W) {
                        let E = B(J, W);
                        O(J, E, W, W.$async)
                    }

                    function b(W) {
                        let E = q.scopeValue("schema", $.code.source === !0 ? {
                                ref: W,
                                code: (0, V.stringify)(W)
                            } : {
                                ref: W
                            }),
                            y = q.name("valid"),
                            T = J.subschema({
                                schema: W,
                                dataTypes: [],
                                schemaPath: V.nil,
                                topSchemaRef: E,
                                errSchemaPath: H
                            }, y);
                        J.mergeEvaluated(T), J.ok(y)
                    }
                }
            };

        function B(J, q) {
            let {
                gen: H
            } = J;
            return q.validate ? H.scopeValue("validate", {
                ref: q.validate
            }) : V._`${H.scopeValue("wrapper",{ref:q})}.validate`
        }
        v.getValidate = B;

        function O(J, q, H, D) {
            let {
                gen: A,
                it: w
            } = J, {
                allErrors: Z,
                schemaEnv: $,
                opts: F
            } = w, L = F.passContext ? N.default.this : V.nil;
            if (D) G();
            else I();

            function G() {
                if (!$.$async) throw Error("async schema referenced by sync schema");
                let W = A.let("valid");
                A.try(() => {
                    if (A.code(V._`await ${(0,U.callValidateCode)(J,q,L)}`), b(q), !Z) A.assign(W, !0)
                }, (E) => {
                    if (A.if(V._`!(${E} instanceof ${w.ValidationError})`, () => A.throw(E)), M(E), !Z) A.assign(W, !1)
                }), J.ok(W)
            }

            function I() {
                J.result((0, U.callValidateCode)(J, q, L), () => b(q), () => M(q))
            }

            function M(W) {
                let E = V._`${W}.errors`;
                A.assign(N.default.vErrors, V._`${N.default.vErrors} === null ? ${E} : ${N.default.vErrors}.concat(${E})`), A.assign(N.default.errors, V._`${N.default.vErrors}.length`)
            }

            function b(W) {
                var E;
                if (!w.opts.unevaluated) return;
                let y = (E = H === null || H === void 0 ? void 0 : H.validate) === null || E === void 0 ? void 0 : E.evaluated;
                if (w.props !== !0)
                    if (y && !y.dynamicProps) {
                        if (y.props !== void 0) w.props = x.mergeEvaluated.props(A, y.props, w.props)
                    } else {
                        let T = A.var("props", V._`${W}.evaluated.props`);
                        w.props = x.mergeEvaluated.props(A, T, w.props, V.Name)
                    } if (w.items !== !0)
                    if (y && !y.dynamicItems) {
                        if (y.items !== void 0) w.items = x.mergeEvaluated.items(A, y.items, w.items)
                    } else {
                        let T = A.var("items", V._`${W}.evaluated.items`);
                        w.items = x.mergeEvaluated.items(A, T, w.items, V.Name)
                    }
            }
        }
        v.callRef = O, v.default = j
    }),
    uQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = TQ(),
            U = YQ(),
            V = ["$schema", "$id", "$defs", "$vocabulary", {
                keyword: "$comment"
            }, "definitions", z.default, U.default];
        v.default = V
    }),
    yQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = z.operators,
            V = {
                maximum: {
                    okStr: "<=",
                    ok: U.LTE,
                    fail: U.GT
                },
                minimum: {
                    okStr: ">=",
                    ok: U.GTE,
                    fail: U.LT
                },
                exclusiveMaximum: {
                    okStr: "<",
                    ok: U.LT,
                    fail: U.GTE
                },
                exclusiveMinimum: {
                    okStr: ">",
                    ok: U.GT,
                    fail: U.LTE
                }
            },
            N = {
                message: ({
                    keyword: x,
                    schemaCode: j
                }) => z.str`must be ${V[x].okStr} ${j}`,
                params: ({
                    keyword: x,
                    schemaCode: j
                }) => z._`{comparison: ${V[x].okStr}, limit: ${j}}`
            },
            K = {
                keyword: Object.keys(V),
                type: "number",
                schemaType: "number",
                $data: !0,
                error: N,
                code(x) {
                    let {
                        keyword: j,
                        data: B,
                        schemaCode: O
                    } = x;
                    x.fail$data(z._`${B} ${V[j].fail} ${O} || isNaN(${B})`)
                }
            };
        v.default = K
    }),
    kQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = {
                message: ({
                    schemaCode: N
                }) => z.str`must be multiple of ${N}`,
                params: ({
                    schemaCode: N
                }) => z._`{multipleOf: ${N}}`
            },
            V = {
                keyword: "multipleOf",
                type: "number",
                schemaType: "number",
                $data: !0,
                error: U,
                code(N) {
                    let {
                        gen: K,
                        data: x,
                        schemaCode: j,
                        it: B
                    } = N, O = B.opts.multipleOfPrecision, J = K.let("res"), q = O ? z._`Math.abs(Math.round(${J}) - ${J}) > 1e-${O}` : z._`${J} !== parseInt(${J})`;
                    N.fail$data(z._`(${j} === 0 || (${J} = ${x}/${j}, ${q}))`)
                }
            };
        v.default = V
    }),
    mQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });

        function z(U) {
            let V = U.length,
                N = 0,
                K = 0,
                x;
            while (K < V)
                if (N++, x = U.charCodeAt(K++), x >= 55296 && x <= 56319 && K < V) {
                    if (x = U.charCodeAt(K), (x & 64512) === 56320) K++
                } return N
        }
        v.default = z, z.code = 'require("ajv/dist/runtime/ucs2length").default'
    }),
    XQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = mQ(),
            N = {
                message({
                    keyword: x,
                    schemaCode: j
                }) {
                    let B = x === "maxLength" ? "more" : "fewer";
                    return z.str`must NOT have ${B} than ${j} characters`
                },
                params: ({
                    schemaCode: x
                }) => z._`{limit: ${x}}`
            },
            K = {
                keyword: ["maxLength", "minLength"],
                type: "string",
                schemaType: "number",
                $data: !0,
                error: N,
                code(x) {
                    let {
                        keyword: j,
                        data: B,
                        schemaCode: O,
                        it: J
                    } = x, q = j === "maxLength" ? z.operators.GT : z.operators.LT, H = J.opts.unicode === !1 ? z._`${B}.length` : z._`${(0,U.useFunc)(x.gen,V.default)}(${B})`;
                    x.fail$data(z._`${H} ${q} ${O}`)
                }
            };
        v.default = K
    }),
    gQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = N8(),
            U = v0(),
            V = {
                message: ({
                    schemaCode: K
                }) => U.str`must match pattern "${K}"`,
                params: ({
                    schemaCode: K
                }) => U._`{pattern: ${K}}`
            },
            N = {
                keyword: "pattern",
                type: "string",
                schemaType: "string",
                $data: !0,
                error: V,
                code(K) {
                    let {
                        data: x,
                        $data: j,
                        schema: B,
                        schemaCode: O,
                        it: J
                    } = K, q = J.opts.unicodeRegExp ? "u" : "", H = j ? U._`(new RegExp(${O}, ${q}))` : (0, z.usePattern)(K, B);
                    K.fail$data(U._`!${H}.test(${x})`)
                }
            };
        v.default = N
    }),
    cQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = {
                message({
                    keyword: N,
                    schemaCode: K
                }) {
                    let x = N === "maxProperties" ? "more" : "fewer";
                    return z.str`must NOT have ${x} than ${K} properties`
                },
                params: ({
                    schemaCode: N
                }) => z._`{limit: ${N}}`
            },
            V = {
                keyword: ["maxProperties", "minProperties"],
                type: "object",
                schemaType: "number",
                $data: !0,
                error: U,
                code(N) {
                    let {
                        keyword: K,
                        data: x,
                        schemaCode: j
                    } = N, B = K === "maxProperties" ? z.operators.GT : z.operators.LT;
                    N.fail$data(z._`Object.keys(${x}).length ${B} ${j}`)
                }
            };
        v.default = V
    }),
    iQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = N8(),
            U = v0(),
            V = Z0(),
            N = {
                message: ({
                    params: {
                        missingProperty: x
                    }
                }) => U.str`must have required property '${x}'`,
                params: ({
                    params: {
                        missingProperty: x
                    }
                }) => U._`{missingProperty: ${x}}`
            },
            K = {
                keyword: "required",
                type: "object",
                schemaType: "array",
                $data: !0,
                error: N,
                code(x) {
                    let {
                        gen: j,
                        schema: B,
                        schemaCode: O,
                        data: J,
                        $data: q,
                        it: H
                    } = x, {
                        opts: D
                    } = H;
                    if (!q && B.length === 0) return;
                    let A = B.length >= D.loopRequired;
                    if (H.allErrors) w();
                    else Z();
                    if (D.strictRequired) {
                        let L = x.parentSchema.properties,
                            {
                                definedProperties: G
                            } = x.it;
                        for (let I of B)
                            if ((L === null || L === void 0 ? void 0 : L[I]) === void 0 && !G.has(I)) {
                                let M = H.schemaEnv.baseId + H.errSchemaPath,
                                    b = `required property "${I}" is not defined at "${M}" (strictRequired)`;
                                (0, V.checkStrictMode)(H, b, H.opts.strictRequired)
                            }
                    }

                    function w() {
                        if (A || q) x.block$data(U.nil, $);
                        else
                            for (let L of B)(0, z.checkReportMissingProp)(x, L)
                    }

                    function Z() {
                        let L = j.let("missing");
                        if (A || q) {
                            let G = j.let("valid", !0);
                            x.block$data(G, () => F(L, G)), x.ok(G)
                        } else j.if((0, z.checkMissingProp)(x, B, L)), (0, z.reportMissingProp)(x, L), j.else()
                    }

                    function $() {
                        j.forOf("prop", O, (L) => {
                            x.setParams({
                                missingProperty: L
                            }), j.if((0, z.noPropertyInData)(j, J, L, D.ownProperties), () => x.error())
                        })
                    }

                    function F(L, G) {
                        x.setParams({
                            missingProperty: L
                        }), j.forOf(L, O, () => {
                            j.assign(G, (0, z.propertyInData)(j, J, L, D.ownProperties)), j.if((0, U.not)(G), () => {
                                x.error(), j.break()
                            })
                        }, U.nil)
                    }
                }
            };
        v.default = K
    }),
    lQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = {
                message({
                    keyword: N,
                    schemaCode: K
                }) {
                    let x = N === "maxItems" ? "more" : "fewer";
                    return z.str`must NOT have ${x} than ${K} items`
                },
                params: ({
                    schemaCode: N
                }) => z._`{limit: ${N}}`
            },
            V = {
                keyword: ["maxItems", "minItems"],
                type: "array",
                schemaType: "number",
                $data: !0,
                error: U,
                code(N) {
                    let {
                        keyword: K,
                        data: x,
                        schemaCode: j
                    } = N, B = K === "maxItems" ? z.operators.GT : z.operators.LT;
                    N.fail$data(z._`${x}.length ${B} ${j}`)
                }
            };
        v.default = V
    }),
    GH = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = pR();
        z.code = 'require("ajv/dist/runtime/equal").default', v.default = z
    }),
    hQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = qK(),
            U = v0(),
            V = Z0(),
            N = GH(),
            K = {
                message: ({
                    params: {
                        i: j,
                        j: B
                    }
                }) => U.str`must NOT have duplicate items (items ## ${B} and ${j} are identical)`,
                params: ({
                    params: {
                        i: j,
                        j: B
                    }
                }) => U._`{i: ${j}, j: ${B}}`
            },
            x = {
                keyword: "uniqueItems",
                type: "array",
                schemaType: "boolean",
                $data: !0,
                error: K,
                code(j) {
                    let {
                        gen: B,
                        data: O,
                        $data: J,
                        schema: q,
                        parentSchema: H,
                        schemaCode: D,
                        it: A
                    } = j;
                    if (!J && !q) return;
                    let w = B.let("valid"),
                        Z = H.items ? (0, z.getSchemaTypes)(H.items) : [];
                    j.block$data(w, $, U._`${D} === false`), j.ok(w);

                    function $() {
                        let I = B.let("i", U._`${O}.length`),
                            M = B.let("j");
                        j.setParams({
                            i: I,
                            j: M
                        }), B.assign(w, !0), B.if(U._`${I} > 1`, () => (F() ? L : G)(I, M))
                    }

                    function F() {
                        return Z.length > 0 && !Z.some((I) => I === "object" || I === "array")
                    }

                    function L(I, M) {
                        let b = B.name("item"),
                            W = (0, z.checkDataTypes)(Z, b, A.opts.strictNumbers, z.DataType.Wrong),
                            E = B.const("indices", U._`{}`);
                        B.for(U._`;${I}--;`, () => {
                            if (B.let(b, U._`${O}[${I}]`), B.if(W, U._`continue`), Z.length > 1) B.if(U._`typeof ${b} == "string"`, U._`${b} += "_"`);
                            B.if(U._`typeof ${E}[${b}] == "number"`, () => {
                                B.assign(M, U._`${E}[${b}]`), j.error(), B.assign(w, !1).break()
                            }).code(U._`${E}[${b}] = ${I}`)
                        })
                    }

                    function G(I, M) {
                        let b = (0, V.useFunc)(B, N.default),
                            W = B.name("outer");
                        B.label(W).for(U._`;${I}--;`, () => B.for(U._`${M} = ${I}; ${M}--;`, () => B.if(U._`${b}(${O}[${I}], ${O}[${M}])`, () => {
                            j.error(), B.assign(w, !1).break(W)
                        })))
                    }
                }
            };
        v.default = x
    }),
    pQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = GH(),
            N = {
                message: "must be equal to constant",
                params: ({
                    schemaCode: x
                }) => z._`{allowedValue: ${x}}`
            },
            K = {
                keyword: "const",
                $data: !0,
                error: N,
                code(x) {
                    let {
                        gen: j,
                        data: B,
                        $data: O,
                        schemaCode: J,
                        schema: q
                    } = x;
                    if (O || q && typeof q == "object") x.fail$data(z._`!${(0,U.useFunc)(j,V.default)}(${B}, ${J})`);
                    else x.fail(z._`${q} !== ${B}`)
                }
            };
        v.default = K
    }),
    nQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = GH(),
            N = {
                message: "must be equal to one of the allowed values",
                params: ({
                    schemaCode: x
                }) => z._`{allowedValues: ${x}}`
            },
            K = {
                keyword: "enum",
                schemaType: "array",
                $data: !0,
                error: N,
                code(x) {
                    let {
                        gen: j,
                        data: B,
                        $data: O,
                        schema: J,
                        schemaCode: q,
                        it: H
                    } = x;
                    if (!O && J.length === 0) throw Error("enum must have non-empty array");
                    let D = J.length >= H.opts.loopEnum,
                        A, w = () => A !== null && A !== void 0 ? A : A = (0, U.useFunc)(j, V.default),
                        Z;
                    if (D || O) Z = j.let("valid"), x.block$data(Z, $);
                    else {
                        if (!Array.isArray(J)) throw Error("ajv implementation error");
                        let L = j.const("vSchema", q);
                        Z = (0, z.or)(...J.map((G, I) => F(L, I)))
                    }
                    x.pass(Z);

                    function $() {
                        j.assign(Z, !1), j.forOf("v", q, (L) => j.if(z._`${w()}(${B}, ${L})`, () => j.assign(Z, !0).break()))
                    }

                    function F(L, G) {
                        let I = J[G];
                        return typeof I === "object" && I !== null ? z._`${w()}(${B}, ${L}[${G}])` : z._`${B} === ${I}`
                    }
                }
            };
        v.default = K
    }),
    QQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = yQ(),
            U = kQ(),
            V = XQ(),
            N = gQ(),
            K = cQ(),
            x = iQ(),
            j = lQ(),
            B = hQ(),
            O = pQ(),
            J = nQ(),
            q = [z.default, U.default, V.default, N.default, K.default, x.default, j.default, B.default, {
                keyword: "type",
                schemaType: ["string", "array"]
            }, {
                keyword: "nullable",
                schemaType: "boolean"
            }, O.default, J.default];
        v.default = q
    }),
    nR = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.validateAdditionalItems = void 0;
        var z = v0(),
            U = Z0(),
            V = {
                message: ({
                    params: {
                        len: x
                    }
                }) => z.str`must NOT have more than ${x} items`,
                params: ({
                    params: {
                        len: x
                    }
                }) => z._`{limit: ${x}}`
            },
            N = {
                keyword: "additionalItems",
                type: "array",
                schemaType: ["boolean", "object"],
                before: "uniqueItems",
                error: V,
                code(x) {
                    let {
                        parentSchema: j,
                        it: B
                    } = x, {
                        items: O
                    } = j;
                    if (!Array.isArray(O)) {
                        (0, U.checkStrictMode)(B, '"additionalItems" is ignored when "items" is not an array of schemas');
                        return
                    }
                    K(x, O)
                }
            };

        function K(x, j) {
            let {
                gen: B,
                schema: O,
                data: J,
                keyword: q,
                it: H
            } = x;
            H.items = !0;
            let D = B.const("len", z._`${J}.length`);
            if (O === !1) x.setParams({
                len: j.length
            }), x.pass(z._`${D} <= ${j.length}`);
            else if (typeof O == "object" && !(0, U.alwaysValidSchema)(H, O)) {
                let w = B.var("valid", z._`${D} <= ${j.length}`);
                B.if((0, z.not)(w), () => A(w)), x.ok(w)
            }

            function A(w) {
                B.forRange("i", j.length, D, (Z) => {
                    if (x.subschema({
                            keyword: q,
                            dataProp: Z,
                            dataPropType: U.Type.Num
                        }, w), !H.allErrors) B.if((0, z.not)(w), () => B.break())
                })
            }
        }
        v.validateAdditionalItems = K, v.default = N
    }),
    QR = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.validateTuple = void 0;
        var z = v0(),
            U = Z0(),
            V = N8(),
            N = {
                keyword: "items",
                type: "array",
                schemaType: ["object", "array", "boolean"],
                before: "uniqueItems",
                code(x) {
                    let {
                        schema: j,
                        it: B
                    } = x;
                    if (Array.isArray(j)) return K(x, "additionalItems", j);
                    if (B.items = !0, (0, U.alwaysValidSchema)(B, j)) return;
                    x.ok((0, V.validateArray)(x))
                }
            };

        function K(x, j, B = x.schema) {
            let {
                gen: O,
                parentSchema: J,
                data: q,
                keyword: H,
                it: D
            } = x;
            if (Z(J), D.opts.unevaluated && B.length && D.items !== !0) D.items = U.mergeEvaluated.items(O, B.length, D.items);
            let A = O.name("valid"),
                w = O.const("len", z._`${q}.length`);
            B.forEach(($, F) => {
                if ((0, U.alwaysValidSchema)(D, $)) return;
                O.if(z._`${w} > ${F}`, () => x.subschema({
                    keyword: H,
                    schemaProp: F,
                    dataProp: F
                }, A)), x.ok(A)
            });

            function Z($) {
                let {
                    opts: F,
                    errSchemaPath: L
                } = D, G = B.length, I = G === $.minItems && (G === $.maxItems || $[j] === !1);
                if (F.strictTuples && !I) {
                    let M = `"${H}" is ${G}-tuple, but minItems or maxItems/${j} are not specified or different at path "${L}"`;
                    (0, U.checkStrictMode)(D, M, F.strictTuples)
                }
            }
        }
        v.validateTuple = K, v.default = N
    }),
    dQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = QR(),
            U = {
                keyword: "prefixItems",
                type: "array",
                schemaType: ["array"],
                before: "uniqueItems",
                code: (V) => (0, z.validateTuple)(V, "items")
            };
        v.default = U
    }),
    oQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = N8(),
            N = nR(),
            K = {
                message: ({
                    params: {
                        len: j
                    }
                }) => z.str`must NOT have more than ${j} items`,
                params: ({
                    params: {
                        len: j
                    }
                }) => z._`{limit: ${j}}`
            },
            x = {
                keyword: "items",
                type: "array",
                schemaType: ["object", "boolean"],
                before: "uniqueItems",
                error: K,
                code(j) {
                    let {
                        schema: B,
                        parentSchema: O,
                        it: J
                    } = j, {
                        prefixItems: q
                    } = O;
                    if (J.items = !0, (0, U.alwaysValidSchema)(J, B)) return;
                    if (q)(0, N.validateAdditionalItems)(j, q);
                    else j.ok((0, V.validateArray)(j))
                }
            };
        v.default = x
    }),
    rQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = {
                message: ({
                    params: {
                        min: K,
                        max: x
                    }
                }) => x === void 0 ? z.str`must contain at least ${K} valid item(s)` : z.str`must contain at least ${K} and no more than ${x} valid item(s)`,
                params: ({
                    params: {
                        min: K,
                        max: x
                    }
                }) => x === void 0 ? z._`{minContains: ${K}}` : z._`{minContains: ${K}, maxContains: ${x}}`
            },
            N = {
                keyword: "contains",
                type: "array",
                schemaType: ["object", "boolean"],
                before: "uniqueItems",
                trackErrors: !0,
                error: V,
                code(K) {
                    let {
                        gen: x,
                        schema: j,
                        parentSchema: B,
                        data: O,
                        it: J
                    } = K, q, H, {
                        minContains: D,
                        maxContains: A
                    } = B;
                    if (J.opts.next) q = D === void 0 ? 1 : D, H = A;
                    else q = 1;
                    let w = x.const("len", z._`${O}.length`);
                    if (K.setParams({
                            min: q,
                            max: H
                        }), H === void 0 && q === 0) {
                        (0, U.checkStrictMode)(J, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                        return
                    }
                    if (H !== void 0 && q > H) {
                        (0, U.checkStrictMode)(J, '"minContains" > "maxContains" is always invalid'), K.fail();
                        return
                    }
                    if ((0, U.alwaysValidSchema)(J, j)) {
                        let G = z._`${w} >= ${q}`;
                        if (H !== void 0) G = z._`${G} && ${w} <= ${H}`;
                        K.pass(G);
                        return
                    }
                    J.items = !0;
                    let Z = x.name("valid");
                    if (H === void 0 && q === 1) F(Z, () => x.if(Z, () => x.break()));
                    else if (q === 0) {
                        if (x.let(Z, !0), H !== void 0) x.if(z._`${O}.length > 0`, $)
                    } else x.let(Z, !1), $();
                    K.result(Z, () => K.reset());

                    function $() {
                        let G = x.name("_valid"),
                            I = x.let("count", 0);
                        F(G, () => x.if(G, () => L(I)))
                    }

                    function F(G, I) {
                        x.forRange("i", 0, w, (M) => {
                            K.subschema({
                                keyword: "contains",
                                dataProp: M,
                                dataPropType: U.Type.Num,
                                compositeRule: !0
                            }, G), I()
                        })
                    }

                    function L(G) {
                        if (x.code(z._`${G}++`), H === void 0) x.if(z._`${G} >= ${q}`, () => x.assign(Z, !0).break());
                        else if (x.if(z._`${G} > ${H}`, () => x.assign(Z, !1).break()), q === 1) x.assign(Z, !0);
                        else x.if(z._`${G} >= ${q}`, () => x.assign(Z, !0))
                    }
                }
            };
        v.default = N
    }),
    aQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.validateSchemaDeps = v.validatePropertyDeps = v.error = void 0;
        var z = v0(),
            U = Z0(),
            V = N8();
        v.error = {
            message: ({
                params: {
                    property: B,
                    depsCount: O,
                    deps: J
                }
            }) => {
                let q = O === 1 ? "property" : "properties";
                return z.str`must have ${q} ${J} when property ${B} is present`
            },
            params: ({
                params: {
                    property: B,
                    depsCount: O,
                    deps: J,
                    missingProperty: q
                }
            }) => z._`{property: ${B},
    missingProperty: ${q},
    depsCount: ${O},
    deps: ${J}}`
        };
        var N = {
            keyword: "dependencies",
            type: "object",
            schemaType: "object",
            error: v.error,
            code(B) {
                let [O, J] = K(B);
                x(B, O), j(B, J)
            }
        };

        function K({
            schema: B
        }) {
            let O = {},
                J = {};
            for (let q in B) {
                if (q === "__proto__") continue;
                let H = Array.isArray(B[q]) ? O : J;
                H[q] = B[q]
            }
            return [O, J]
        }

        function x(B, O = B.schema) {
            let {
                gen: J,
                data: q,
                it: H
            } = B;
            if (Object.keys(O).length === 0) return;
            let D = J.let("missing");
            for (let A in O) {
                let w = O[A];
                if (w.length === 0) continue;
                let Z = (0, V.propertyInData)(J, q, A, H.opts.ownProperties);
                if (B.setParams({
                        property: A,
                        depsCount: w.length,
                        deps: w.join(", ")
                    }), H.allErrors) J.if(Z, () => {
                    for (let $ of w)(0, V.checkReportMissingProp)(B, $)
                });
                else J.if(z._`${Z} && (${(0,V.checkMissingProp)(B,w,D)})`), (0, V.reportMissingProp)(B, D), J.else()
            }
        }
        v.validatePropertyDeps = x;

        function j(B, O = B.schema) {
            let {
                gen: J,
                data: q,
                keyword: H,
                it: D
            } = B, A = J.name("valid");
            for (let w in O) {
                if ((0, U.alwaysValidSchema)(D, O[w])) continue;
                J.if((0, V.propertyInData)(J, q, w, D.opts.ownProperties), () => {
                    let Z = B.subschema({
                        keyword: H,
                        schemaProp: w
                    }, A);
                    B.mergeValidEvaluated(Z, A)
                }, () => J.var(A, !0)), B.ok(A)
            }
        }
        v.validateSchemaDeps = j, v.default = N
    }),
    tQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = {
                message: "property name must be valid",
                params: ({
                    params: K
                }) => z._`{propertyName: ${K.propertyName}}`
            },
            N = {
                keyword: "propertyNames",
                type: "object",
                schemaType: ["object", "boolean"],
                error: V,
                code(K) {
                    let {
                        gen: x,
                        schema: j,
                        data: B,
                        it: O
                    } = K;
                    if ((0, U.alwaysValidSchema)(O, j)) return;
                    let J = x.name("valid");
                    x.forIn("key", B, (q) => {
                        K.setParams({
                            propertyName: q
                        }), K.subschema({
                            keyword: "propertyNames",
                            data: q,
                            dataTypes: ["string"],
                            propertyName: q,
                            compositeRule: !0
                        }, J), x.if((0, z.not)(J), () => {
                            if (K.error(!0), !O.allErrors) x.break()
                        })
                    }), K.ok(J)
                }
            };
        v.default = N
    }),
    dR = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = N8(),
            U = v0(),
            V = Q9(),
            N = Z0(),
            K = {
                message: "must NOT have additional properties",
                params: ({
                    params: j
                }) => U._`{additionalProperty: ${j.additionalProperty}}`
            },
            x = {
                keyword: "additionalProperties",
                type: ["object"],
                schemaType: ["boolean", "object"],
                allowUndefined: !0,
                trackErrors: !0,
                error: K,
                code(j) {
                    let {
                        gen: B,
                        schema: O,
                        parentSchema: J,
                        data: q,
                        errsCount: H,
                        it: D
                    } = j;
                    if (!H) throw Error("ajv implementation error");
                    let {
                        allErrors: A,
                        opts: w
                    } = D;
                    if (D.props = !0, w.removeAdditional !== "all" && (0, N.alwaysValidSchema)(D, O)) return;
                    let Z = (0, z.allSchemaProperties)(J.properties),
                        $ = (0, z.allSchemaProperties)(J.patternProperties);
                    F(), j.ok(U._`${H} === ${V.default.errors}`);

                    function F() {
                        B.forIn("key", q, (b) => {
                            if (!Z.length && !$.length) I(b);
                            else B.if(L(b), () => I(b))
                        })
                    }

                    function L(b) {
                        let W;
                        if (Z.length > 8) {
                            let E = (0, N.schemaRefOrVal)(D, J.properties, "properties");
                            W = (0, z.isOwnProperty)(B, E, b)
                        } else if (Z.length) W = (0, U.or)(...Z.map((E) => U._`${b} === ${E}`));
                        else W = U.nil;
                        if ($.length) W = (0, U.or)(W, ...$.map((E) => U._`${(0,z.usePattern)(j,E)}.test(${b})`));
                        return (0, U.not)(W)
                    }

                    function G(b) {
                        B.code(U._`delete ${q}[${b}]`)
                    }

                    function I(b) {
                        if (w.removeAdditional === "all" || w.removeAdditional && O === !1) {
                            G(b);
                            return
                        }
                        if (O === !1) {
                            if (j.setParams({
                                    additionalProperty: b
                                }), j.error(), !A) B.break();
                            return
                        }
                        if (typeof O == "object" && !(0, N.alwaysValidSchema)(D, O)) {
                            let W = B.name("valid");
                            if (w.removeAdditional === "failing") M(b, W, !1), B.if((0, U.not)(W), () => {
                                j.reset(), G(b)
                            });
                            else if (M(b, W), !A) B.if((0, U.not)(W), () => B.break())
                        }
                    }

                    function M(b, W, E) {
                        let y = {
                            keyword: "additionalProperties",
                            dataProp: b,
                            dataPropType: N.Type.Str
                        };
                        if (E === !1) Object.assign(y, {
                            compositeRule: !0,
                            createErrors: !1,
                            allErrors: !1
                        });
                        j.subschema(y, W)
                    }
                }
            };
        v.default = x
    }),
    sQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = _K(),
            U = N8(),
            V = Z0(),
            N = dR(),
            K = {
                keyword: "properties",
                type: "object",
                schemaType: "object",
                code(x) {
                    let {
                        gen: j,
                        schema: B,
                        parentSchema: O,
                        data: J,
                        it: q
                    } = x;
                    if (q.opts.removeAdditional === "all" && O.additionalProperties === void 0) N.default.code(new z.KeywordCxt(q, N.default, "additionalProperties"));
                    let H = (0, U.allSchemaProperties)(B);
                    for (let $ of H) q.definedProperties.add($);
                    if (q.opts.unevaluated && H.length && q.props !== !0) q.props = V.mergeEvaluated.props(j, (0, V.toHash)(H), q.props);
                    let D = H.filter(($) => !(0, V.alwaysValidSchema)(q, B[$]));
                    if (D.length === 0) return;
                    let A = j.name("valid");
                    for (let $ of D) {
                        if (w($)) Z($);
                        else {
                            if (j.if((0, U.propertyInData)(j, J, $, q.opts.ownProperties)), Z($), !q.allErrors) j.else().var(A, !0);
                            j.endIf()
                        }
                        x.it.definedProperties.add($), x.ok(A)
                    }

                    function w($) {
                        return q.opts.useDefaults && !q.compositeRule && B[$].default !== void 0
                    }

                    function Z($) {
                        x.subschema({
                            keyword: "properties",
                            schemaProp: $,
                            dataProp: $
                        }, A)
                    }
                }
            };
        v.default = K
    }),
    eQ = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = N8(),
            U = v0(),
            V = Z0(),
            N = Z0(),
            K = {
                keyword: "patternProperties",
                type: "object",
                schemaType: "object",
                code(x) {
                    let {
                        gen: j,
                        schema: B,
                        data: O,
                        parentSchema: J,
                        it: q
                    } = x, {
                        opts: H
                    } = q, D = (0, z.allSchemaProperties)(B), A = D.filter((I) => (0, V.alwaysValidSchema)(q, B[I]));
                    if (D.length === 0 || A.length === D.length && (!q.opts.unevaluated || q.props === !0)) return;
                    let w = H.strictSchema && !H.allowMatchingProperties && J.properties,
                        Z = j.name("valid");
                    if (q.props !== !0 && !(q.props instanceof U.Name)) q.props = (0, N.evaluatedPropsToName)(j, q.props);
                    let {
                        props: $
                    } = q;
                    F();

                    function F() {
                        for (let I of D) {
                            if (w) L(I);
                            if (q.allErrors) G(I);
                            else j.var(Z, !0), G(I), j.if(Z)
                        }
                    }

                    function L(I) {
                        for (let M in w)
                            if (new RegExp(I).test(M))(0, V.checkStrictMode)(q, `property ${M} matches pattern ${I} (use allowMatchingProperties)`)
                    }

                    function G(I) {
                        j.forIn("key", O, (M) => {
                            j.if(U._`${(0,z.usePattern)(x,I)}.test(${M})`, () => {
                                let b = A.includes(I);
                                if (!b) x.subschema({
                                    keyword: "patternProperties",
                                    schemaProp: I,
                                    dataProp: M,
                                    dataPropType: N.Type.Str
                                }, Z);
                                if (q.opts.unevaluated && $ !== !0) j.assign(U._`${$}[${M}]`, !0);
                                else if (!b && !q.allErrors) j.if((0, U.not)(Z), () => j.break())
                            })
                        })
                    }
                }
            };
        v.default = K
    }),
    vd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = Z0(),
            U = {
                keyword: "not",
                schemaType: ["object", "boolean"],
                trackErrors: !0,
                code(V) {
                    let {
                        gen: N,
                        schema: K,
                        it: x
                    } = V;
                    if ((0, z.alwaysValidSchema)(x, K)) {
                        V.fail();
                        return
                    }
                    let j = N.name("valid");
                    V.subschema({
                        keyword: "not",
                        compositeRule: !0,
                        createErrors: !1,
                        allErrors: !1
                    }, j), V.failResult(j, () => V.reset(), () => V.error())
                },
                error: {
                    message: "must NOT be valid"
                }
            };
        v.default = U
    }),
    zd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = N8(),
            U = {
                keyword: "anyOf",
                schemaType: "array",
                trackErrors: !0,
                code: z.validateUnion,
                error: {
                    message: "must match a schema in anyOf"
                }
            };
        v.default = U
    }),
    Ud = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = {
                message: "must match exactly one schema in oneOf",
                params: ({
                    params: K
                }) => z._`{passingSchemas: ${K.passing}}`
            },
            N = {
                keyword: "oneOf",
                schemaType: "array",
                trackErrors: !0,
                error: V,
                code(K) {
                    let {
                        gen: x,
                        schema: j,
                        parentSchema: B,
                        it: O
                    } = K;
                    if (!Array.isArray(j)) throw Error("ajv implementation error");
                    if (O.opts.discriminator && B.discriminator) return;
                    let J = j,
                        q = x.let("valid", !1),
                        H = x.let("passing", null),
                        D = x.name("_valid");
                    K.setParams({
                        passing: H
                    }), x.block(A), K.result(q, () => K.reset(), () => K.error(!0));

                    function A() {
                        J.forEach((w, Z) => {
                            let $;
                            if ((0, U.alwaysValidSchema)(O, w)) x.var(D, !0);
                            else $ = K.subschema({
                                keyword: "oneOf",
                                schemaProp: Z,
                                compositeRule: !0
                            }, D);
                            if (Z > 0) x.if(z._`${D} && ${q}`).assign(q, !1).assign(H, z._`[${H}, ${Z}]`).else();
                            x.if(D, () => {
                                if (x.assign(q, !0), x.assign(H, Z), $) K.mergeEvaluated($, z.Name)
                            })
                        })
                    }
                }
            };
        v.default = N
    }),
    Vd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = Z0(),
            U = {
                keyword: "allOf",
                schemaType: "array",
                code(V) {
                    let {
                        gen: N,
                        schema: K,
                        it: x
                    } = V;
                    if (!Array.isArray(K)) throw Error("ajv implementation error");
                    let j = N.name("valid");
                    K.forEach((B, O) => {
                        if ((0, z.alwaysValidSchema)(x, B)) return;
                        let J = V.subschema({
                            keyword: "allOf",
                            schemaProp: O
                        }, j);
                        V.ok(j), V.mergeEvaluated(J)
                    })
                }
            };
        v.default = U
    }),
    Nd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = Z0(),
            V = {
                message: ({
                    params: x
                }) => z.str`must match "${x.ifClause}" schema`,
                params: ({
                    params: x
                }) => z._`{failingKeyword: ${x.ifClause}}`
            },
            N = {
                keyword: "if",
                schemaType: ["object", "boolean"],
                trackErrors: !0,
                error: V,
                code(x) {
                    let {
                        gen: j,
                        parentSchema: B,
                        it: O
                    } = x;
                    if (B.then === void 0 && B.else === void 0)(0, U.checkStrictMode)(O, '"if" without "then" and "else" is ignored');
                    let J = K(O, "then"),
                        q = K(O, "else");
                    if (!J && !q) return;
                    let H = j.let("valid", !0),
                        D = j.name("_valid");
                    if (A(), x.reset(), J && q) {
                        let Z = j.let("ifClause");
                        x.setParams({
                            ifClause: Z
                        }), j.if(D, w("then", Z), w("else", Z))
                    } else if (J) j.if(D, w("then"));
                    else j.if((0, z.not)(D), w("else"));
                    x.pass(H, () => x.error(!0));

                    function A() {
                        let Z = x.subschema({
                            keyword: "if",
                            compositeRule: !0,
                            createErrors: !1,
                            allErrors: !1
                        }, D);
                        x.mergeEvaluated(Z)
                    }

                    function w(Z, $) {
                        return () => {
                            let F = x.subschema({
                                keyword: Z
                            }, D);
                            if (j.assign(H, D), x.mergeValidEvaluated(F, H), $) j.assign($, z._`${Z}`);
                            else x.setParams({
                                ifClause: Z
                            })
                        }
                    }
                }
            };

        function K(x, j) {
            let B = x.schema[j];
            return B !== void 0 && !(0, U.alwaysValidSchema)(x, B)
        }
        v.default = N
    }),
    Kd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = Z0(),
            U = {
                keyword: ["then", "else"],
                schemaType: ["object", "boolean"],
                code({
                    keyword: V,
                    parentSchema: N,
                    it: K
                }) {
                    if (N.if === void 0)(0, z.checkStrictMode)(K, `"${V}" without "if" is ignored`)
                }
            };
        v.default = U
    }),
    xd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = nR(),
            U = dQ(),
            V = QR(),
            N = oQ(),
            K = rQ(),
            x = aQ(),
            j = tQ(),
            B = dR(),
            O = sQ(),
            J = eQ(),
            q = vd(),
            H = zd(),
            D = Ud(),
            A = Vd(),
            w = Nd(),
            Z = Kd();

        function $(F = !1) {
            let L = [q.default, H.default, D.default, A.default, w.default, Z.default, j.default, B.default, x.default, O.default, J.default];
            if (F) L.push(U.default, N.default);
            else L.push(z.default, V.default);
            return L.push(K.default), L
        }
        v.default = $
    }),
    jd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = {
                message: ({
                    schemaCode: N
                }) => z.str`must match format "${N}"`,
                params: ({
                    schemaCode: N
                }) => z._`{format: ${N}}`
            },
            V = {
                keyword: "format",
                type: ["number", "string"],
                schemaType: "string",
                $data: !0,
                error: U,
                code(N, K) {
                    let {
                        gen: x,
                        data: j,
                        $data: B,
                        schema: O,
                        schemaCode: J,
                        it: q
                    } = N, {
                        opts: H,
                        errSchemaPath: D,
                        schemaEnv: A,
                        self: w
                    } = q;
                    if (!H.validateFormats) return;
                    if (B) Z();
                    else $();

                    function Z() {
                        let F = x.scopeValue("formats", {
                                ref: w.formats,
                                code: H.code.formats
                            }),
                            L = x.const("fDef", z._`${F}[${J}]`),
                            G = x.let("fType"),
                            I = x.let("format");
                        x.if(z._`typeof ${L} == "object" && !(${L} instanceof RegExp)`, () => x.assign(G, z._`${L}.type || "string"`).assign(I, z._`${L}.validate`), () => x.assign(G, z._`"string"`).assign(I, L)), N.fail$data((0, z.or)(M(), b()));

                        function M() {
                            if (H.strictSchema === !1) return z.nil;
                            return z._`${J} && !${I}`
                        }

                        function b() {
                            let W = A.$async ? z._`(${L}.async ? await ${I}(${j}) : ${I}(${j}))` : z._`${I}(${j})`,
                                E = z._`(typeof ${I} == "function" ? ${W} : ${I}.test(${j}))`;
                            return z._`${I} && ${I} !== true && ${G} === ${K} && !${E}`
                        }
                    }

                    function $() {
                        let F = w.formats[O];
                        if (!F) {
                            M();
                            return
                        }
                        if (F === !0) return;
                        let [L, G, I] = b(F);
                        if (L === K) N.pass(W());

                        function M() {
                            if (H.strictSchema === !1) {
                                w.logger.warn(E());
                                return
                            }
                            throw Error(E());

                            function E() {
                                return `unknown format "${O}" ignored in schema at path "${D}"`
                            }
                        }

                        function b(E) {
                            let y = E instanceof RegExp ? (0, z.regexpCode)(E) : H.code.formats ? z._`${H.code.formats}${(0,z.getProperty)(O)}` : void 0,
                                T = x.scopeValue("formats", {
                                    key: O,
                                    ref: E,
                                    code: y
                                });
                            if (typeof E == "object" && !(E instanceof RegExp)) return [E.type || "string", E.validate, z._`${T}.validate`];
                            return ["string", E, T]
                        }

                        function W() {
                            if (typeof F == "object" && !(F instanceof RegExp) && F.async) {
                                if (!A.$async) throw Error("async format in sync schema");
                                return z._`await ${I}(${j})`
                            }
                            return typeof G == "function" ? z._`${I}(${j})` : z._`${I}.test(${j})`
                        }
                    }
                }
            };
        v.default = V
    }),
    Bd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = jd(),
            U = [z.default];
        v.default = U
    }),
    Od = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.contentVocabulary = v.metadataVocabulary = void 0, v.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"], v.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"]
    }),
    Jd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = uQ(),
            U = QQ(),
            V = xd(),
            N = Bd(),
            K = Od(),
            x = [z.default, U.default, (0, V.default)(), N.default, K.metadataVocabulary, K.contentVocabulary];
        v.default = x
    }),
    qd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.DiscrError = void 0;
        var z;
        (function(U) {
            U.Tag = "tag", U.Mapping = "mapping"
        })(z || (v.DiscrError = z = {}))
    }),
    Hd = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var z = v0(),
            U = qd(),
            V = FH(),
            N = CK(),
            K = Z0(),
            x = {
                message: ({
                    params: {
                        discrError: B,
                        tagName: O
                    }
                }) => B === U.DiscrError.Tag ? `tag "${O}" must be string` : `value of tag "${O}" must be in oneOf`,
                params: ({
                    params: {
                        discrError: B,
                        tag: O,
                        tagName: J
                    }
                }) => z._`{error: ${B}, tag: ${J}, tagValue: ${O}}`
            },
            j = {
                keyword: "discriminator",
                type: "object",
                schemaType: "object",
                error: x,
                code(B) {
                    let {
                        gen: O,
                        data: J,
                        schema: q,
                        parentSchema: H,
                        it: D
                    } = B, {
                        oneOf: A
                    } = H;
                    if (!D.opts.discriminator) throw Error("discriminator: requires discriminator option");
                    let w = q.propertyName;
                    if (typeof w != "string") throw Error("discriminator: requires propertyName");
                    if (q.mapping) throw Error("discriminator: mapping is not supported");
                    if (!A) throw Error("discriminator: requires oneOf keyword");
                    let Z = O.let("valid", !1),
                        $ = O.const("tag", z._`${J}${(0,z.getProperty)(w)}`);
                    O.if(z._`typeof ${$} == "string"`, () => F(), () => B.error(!1, {
                        discrError: U.DiscrError.Tag,
                        tag: $,
                        tagName: w
                    })), B.ok(Z);

                    function F() {
                        let I = G();
                        O.if(!1);
                        for (let M in I) O.elseIf(z._`${$} === ${M}`), O.assign(Z, L(I[M]));
                        O.else(), B.error(!1, {
                            discrError: U.DiscrError.Mapping,
                            tag: $,
                            tagName: w
                        }), O.endIf()
                    }

                    function L(I) {
                        let M = O.name("valid"),
                            b = B.subschema({
                                keyword: "oneOf",
                                schemaProp: I
                            }, M);
                        return B.mergeEvaluated(b, z.Name), M
                    }

                    function G() {
                        var I;
                        let M = {},
                            b = E(H),
                            W = !0;
                        for (let X = 0; X < A.length; X++) {
                            let Q = A[X];
                            if ((Q === null || Q === void 0 ? void 0 : Q.$ref) && !(0, K.schemaHasRulesButRef)(Q, D.self.RULES)) {
                                let P6 = Q.$ref;
                                if (Q = V.resolveRef.call(D.self, D.schemaEnv.root, D.baseId, P6), Q instanceof V.SchemaEnv) Q = Q.schema;
                                if (Q === void 0) throw new N.default(D.opts.uriResolver, D.baseId, P6)
                            }
                            let m = (I = Q === null || Q === void 0 ? void 0 : Q.properties) === null || I === void 0 ? void 0 : I[w];
                            if (typeof m != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${w}"`);
                            W = W && (b || E(Q)), y(m, X)
                        }
                        if (!W) throw Error(`discriminator: "${w}" must be required`);
                        return M;

                        function E({
                            required: X
                        }) {
                            return Array.isArray(X) && X.includes(w)
                        }

                        function y(X, Q) {
                            if (X.const) T(X.const, Q);
                            else if (X.enum)
                                for (let m of X.enum) T(m, Q);
                            else throw Error(`discriminator: "properties/${w}" must have "const" or "enum"`)
                        }

                        function T(X, Q) {
                            if (typeof X != "string" || X in M) throw Error(`discriminator: "${w}" values must be unique strings`);
                            M[X] = Q
                        }
                    }
                }
            };
        v.default = j
    }),
    Dd = J6((v, z) => {
        z.exports = {
            $schema: "http://json-schema.org/draft-07/schema#",
            $id: "http://json-schema.org/draft-07/schema#",
            title: "Core schema meta-schema",
            definitions: {
                schemaArray: {
                    type: "array",
                    minItems: 1,
                    items: {
                        $ref: "#"
                    }
                },
                nonNegativeInteger: {
                    type: "integer",
                    minimum: 0
                },
                nonNegativeIntegerDefault0: {
                    allOf: [{
                        $ref: "#/definitions/nonNegativeInteger"
                    }, {
                        default: 0
                    }]
                },
                simpleTypes: {
                    enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
                },
                stringArray: {
                    type: "array",
                    items: {
                        type: "string"
                    },
                    uniqueItems: !0,
                    default: []
                }
            },
            type: ["object", "boolean"],
            properties: {
                $id: {
                    type: "string",
                    format: "uri-reference"
                },
                $schema: {
                    type: "string",
                    format: "uri"
                },
                $ref: {
                    type: "string",
                    format: "uri-reference"
                },
                $comment: {
                    type: "string"
                },
                title: {
                    type: "string"
                },
                description: {
                    type: "string"
                },
                default: !0,
                readOnly: {
                    type: "boolean",
                    default: !1
                },
                examples: {
                    type: "array",
                    items: !0
                },
                multipleOf: {
                    type: "number",
                    exclusiveMinimum: 0
                },
                maximum: {
                    type: "number"
                },
                exclusiveMaximum: {
                    type: "number"
                },
                minimum: {
                    type: "number"
                },
                exclusiveMinimum: {
                    type: "number"
                },
                maxLength: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minLength: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                pattern: {
                    type: "string",
                    format: "regex"
                },
                additionalItems: {
                    $ref: "#"
                },
                items: {
                    anyOf: [{
                        $ref: "#"
                    }, {
                        $ref: "#/definitions/schemaArray"
                    }],
                    default: !0
                },
                maxItems: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minItems: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                uniqueItems: {
                    type: "boolean",
                    default: !1
                },
                contains: {
                    $ref: "#"
                },
                maxProperties: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minProperties: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                required: {
                    $ref: "#/definitions/stringArray"
                },
                additionalProperties: {
                    $ref: "#"
                },
                definitions: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    default: {}
                },
                properties: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    default: {}
                },
                patternProperties: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    propertyNames: {
                        format: "regex"
                    },
                    default: {}
                },
                dependencies: {
                    type: "object",
                    additionalProperties: {
                        anyOf: [{
                            $ref: "#"
                        }, {
                            $ref: "#/definitions/stringArray"
                        }]
                    }
                },
                propertyNames: {
                    $ref: "#"
                },
                const: !0,
                enum: {
                    type: "array",
                    items: !0,
                    minItems: 1,
                    uniqueItems: !0
                },
                type: {
                    anyOf: [{
                        $ref: "#/definitions/simpleTypes"
                    }, {
                        type: "array",
                        items: {
                            $ref: "#/definitions/simpleTypes"
                        },
                        minItems: 1,
                        uniqueItems: !0
                    }]
                },
                format: {
                    type: "string"
                },
                contentMediaType: {
                    type: "string"
                },
                contentEncoding: {
                    type: "string"
                },
                if: {
                    $ref: "#"
                },
                then: {
                    $ref: "#"
                },
                else: {
                    $ref: "#"
                },
                allOf: {
                    $ref: "#/definitions/schemaArray"
                },
                anyOf: {
                    $ref: "#/definitions/schemaArray"
                },
                oneOf: {
                    $ref: "#/definitions/schemaArray"
                },
                not: {
                    $ref: "#"
                }
            },
            default: !0
        }
    }),
    oR = J6((v, z) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.MissingRefError = v.ValidationError = v.CodeGen = v.Name = v.nil = v.stringify = v.str = v._ = v.KeywordCxt = v.Ajv = void 0;
        var U = fQ(),
            V = Jd(),
            N = Hd(),
            K = Dd(),
            x = ["/properties"],
            j = "http://json-schema.org/draft-07/schema";
        class B extends U.default {
            _addVocabularies() {
                if (super._addVocabularies(), V.default.forEach((D) => this.addVocabulary(D)), this.opts.discriminator) this.addKeyword(N.default)
            }
            _addDefaultMetaSchema() {
                if (super._addDefaultMetaSchema(), !this.opts.meta) return;
                let D = this.opts.$data ? this.$dataMetaSchema(K, x) : K;
                this.addMetaSchema(D, j, !1), this.refs["http://json-schema.org/schema"] = j
            }
            defaultMeta() {
                return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(j) ? j : void 0)
            }
        }
        v.Ajv = B, z.exports = v = B, z.exports.Ajv = B, Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.default = B;
        var O = _K();
        Object.defineProperty(v, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return O.KeywordCxt
            }
        });
        var J = v0();
        Object.defineProperty(v, "_", {
            enumerable: !0,
            get: function() {
                return J._
            }
        }), Object.defineProperty(v, "str", {
            enumerable: !0,
            get: function() {
                return J.str
            }
        }), Object.defineProperty(v, "stringify", {
            enumerable: !0,
            get: function() {
                return J.stringify
            }
        }), Object.defineProperty(v, "nil", {
            enumerable: !0,
            get: function() {
                return J.nil
            }
        }), Object.defineProperty(v, "Name", {
            enumerable: !0,
            get: function() {
                return J.Name
            }
        }), Object.defineProperty(v, "CodeGen", {
            enumerable: !0,
            get: function() {
                return J.CodeGen
            }
        });
        var q = LH();
        Object.defineProperty(v, "ValidationError", {
            enumerable: !0,
            get: function() {
                return q.default
            }
        });
        var H = CK();
        Object.defineProperty(v, "MissingRefError", {
            enumerable: !0,
            get: function() {
                return H.default
            }
        })
    }),
    Ad = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.formatNames = v.fastFormats = v.fullFormats = void 0;

        function z(T, X) {
            return {
                validate: T,
                compare: X
            }
        }
        v.fullFormats = {
            date: z(K, x),
            time: z(B(!0), O),
            "date-time": z(H(!0), D),
            "iso-time": z(B(), J),
            "iso-date-time": z(H(), A),
            duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
            uri: $,
            "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
            "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
            url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
            email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
            hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
            ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
            ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
            regex: y,
            uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
            "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
            "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
            "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
            byte: L,
            int32: {
                type: "number",
                validate: M
            },
            int64: {
                type: "number",
                validate: b
            },
            float: {
                type: "number",
                validate: W
            },
            double: {
                type: "number",
                validate: W
            },
            password: !0,
            binary: !0
        }, v.fastFormats = {
            ...v.fullFormats,
            date: z(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, x),
            time: z(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, O),
            "date-time": z(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, D),
            "iso-time": z(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, J),
            "iso-date-time": z(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, A),
            uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
            "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
            email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
        }, v.formatNames = Object.keys(v.fullFormats);

        function U(T) {
            return T % 4 === 0 && (T % 100 !== 0 || T % 400 === 0)
        }
        var V = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
            N = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        function K(T) {
            let X = V.exec(T);
            if (!X) return !1;
            let Q = +X[1],
                m = +X[2],
                P6 = +X[3];
            return m >= 1 && m <= 12 && P6 >= 1 && P6 <= (m === 2 && U(Q) ? 29 : N[m])
        }

        function x(T, X) {
            if (!(T && X)) return;
            if (T > X) return 1;
            if (T < X) return -1;
            return 0
        }
        var j = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;

        function B(T) {
            return function(X) {
                let Q = j.exec(X);
                if (!Q) return !1;
                let m = +Q[1],
                    P6 = +Q[2],
                    F6 = +Q[3],
                    q6 = Q[4],
                    Z6 = Q[5] === "-" ? -1 : 1,
                    T6 = +(Q[6] || 0),
                    C = +(Q[7] || 0);
                if (T6 > 23 || C > 59 || T && !q6) return !1;
                if (m <= 23 && P6 <= 59 && F6 < 60) return !0;
                let u = P6 - C * Z6,
                    p = m - T6 * Z6 - (u < 0 ? 1 : 0);
                return (p === 23 || p === -1) && (u === 59 || u === -1) && F6 < 61
            }
        }

        function O(T, X) {
            if (!(T && X)) return;
            let Q = new Date("2020-01-01T" + T).valueOf(),
                m = new Date("2020-01-01T" + X).valueOf();
            if (!(Q && m)) return;
            return Q - m
        }

        function J(T, X) {
            if (!(T && X)) return;
            let Q = j.exec(T),
                m = j.exec(X);
            if (!(Q && m)) return;
            if (T = Q[1] + Q[2] + Q[3], X = m[1] + m[2] + m[3], T > X) return 1;
            if (T < X) return -1;
            return 0
        }
        var q = /t|\s/i;

        function H(T) {
            let X = B(T);
            return function(Q) {
                let m = Q.split(q);
                return m.length === 2 && K(m[0]) && X(m[1])
            }
        }

        function D(T, X) {
            if (!(T && X)) return;
            let Q = new Date(T).valueOf(),
                m = new Date(X).valueOf();
            if (!(Q && m)) return;
            return Q - m
        }

        function A(T, X) {
            if (!(T && X)) return;
            let [Q, m] = T.split(q), [P6, F6] = X.split(q), q6 = x(Q, P6);
            if (q6 === void 0) return;
            return q6 || O(m, F6)
        }
        var w = /\/|:/,
            Z = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;

        function $(T) {
            return w.test(T) && Z.test(T)
        }
        var F = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;

        function L(T) {
            return F.lastIndex = 0, F.test(T)
        }
        var G = -2147483648,
            I = 2147483647;

        function M(T) {
            return Number.isInteger(T) && T <= I && T >= G
        }

        function b(T) {
            return Number.isInteger(T)
        }

        function W() {
            return !0
        }
        var E = /[^\\]\\Z/;

        function y(T) {
            if (E.test(T)) return !1;
            try {
                return new RegExp(T), !0
            } catch (X) {
                return !1
            }
        }
    }),
    $d = J6((v) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.formatLimitDefinition = void 0;
        var z = oR(),
            U = v0(),
            V = U.operators,
            N = {
                formatMaximum: {
                    okStr: "<=",
                    ok: V.LTE,
                    fail: V.GT
                },
                formatMinimum: {
                    okStr: ">=",
                    ok: V.GTE,
                    fail: V.LT
                },
                formatExclusiveMaximum: {
                    okStr: "<",
                    ok: V.LT,
                    fail: V.GTE
                },
                formatExclusiveMinimum: {
                    okStr: ">",
                    ok: V.GT,
                    fail: V.LTE
                }
            },
            K = {
                message: ({
                    keyword: j,
                    schemaCode: B
                }) => U.str`should be ${N[j].okStr} ${B}`,
                params: ({
                    keyword: j,
                    schemaCode: B
                }) => U._`{comparison: ${N[j].okStr}, limit: ${B}}`
            };
        v.formatLimitDefinition = {
            keyword: Object.keys(N),
            type: "string",
            schemaType: "string",
            $data: !0,
            error: K,
            code(j) {
                let {
                    gen: B,
                    data: O,
                    schemaCode: J,
                    keyword: q,
                    it: H
                } = j, {
                    opts: D,
                    self: A
                } = H;
                if (!D.validateFormats) return;
                let w = new z.KeywordCxt(H, A.RULES.all.format.definition, "format");
                if (w.$data) Z();
                else $();

                function Z() {
                    let L = B.scopeValue("formats", {
                            ref: A.formats,
                            code: D.code.formats
                        }),
                        G = B.const("fmt", U._`${L}[${w.schemaCode}]`);
                    j.fail$data((0, U.or)(U._`typeof ${G} != "object"`, U._`${G} instanceof RegExp`, U._`typeof ${G}.compare != "function"`, F(G)))
                }

                function $() {
                    let L = w.schema,
                        G = A.formats[L];
                    if (!G || G === !0) return;
                    if (typeof G != "object" || G instanceof RegExp || typeof G.compare != "function") throw Error(`"${q}": format "${L}" does not define "compare" function`);
                    let I = B.scopeValue("formats", {
                        key: L,
                        ref: G,
                        code: D.code.formats ? U._`${D.code.formats}${(0,U.getProperty)(L)}` : void 0
                    });
                    j.fail$data(F(I))
                }

                function F(L) {
                    return U._`${L}.compare(${O}, ${J}) ${N[q].fail} 0`
                }
            },
            dependencies: ["format"]
        };
        var x = (j) => {
            return j.addKeyword(v.formatLimitDefinition), j
        };
        v.default = x
    }),
    wd = J6((v, z) => {
        Object.defineProperty(v, "__esModule", {
            value: !0
        });
        var U = Ad(),
            V = $d(),
            N = v0(),
            K = new N.Name("fullFormats"),
            x = new N.Name("fastFormats"),
            j = (O, J = {
                keywords: !0
            }) => {
                if (Array.isArray(J)) return B(O, J, U.fullFormats, K), O;
                let [q, H] = J.mode === "fast" ? [U.fastFormats, x] : [U.fullFormats, K], D = J.formats || U.formatNames;
                if (B(O, D, q, H), J.keywords)(0, V.default)(O);
                return O
            };
        j.get = (O, J = "full") => {
            let q = (J === "fast" ? U.fastFormats : U.fullFormats)[O];
            if (!q) throw Error(`Unknown format "${O}"`);
            return q
        };

        function B(O, J, q, H) {
            var D, A;
            (D = (A = O.opts.code).formats) !== null && D !== void 0 || (A.formats = N._`require("ajv-formats/dist/formats").${H}`);
            for (let w of J) O.addFormat(w, q[w])
        }
        z.exports = v = j, Object.defineProperty(v, "__esModule", {
            value: !0
        }), v.default = j
    }),
    Zd = 50;

function tR(v = Zd) {
    let z = new AbortController;
    return aR.setMaxListeners(v, z.signal), z
}
var Ld = typeof global == "object" && global && global.Object === Object && global,
    Fd = Ld,
    Gd = typeof self == "object" && self && self.Object === Object && self,
    Id = Fd || Gd || Function("return this")(),
    IH = Id,
    Md = IH.Symbol,
    HK = Md,
    vW = Object.prototype,
    bd = vW.hasOwnProperty,
    Rd = vW.toString,
    $z = HK ? HK.toStringTag : void 0;

function Wd(v) {
    var z = bd.call(v, $z),
        U = v[$z];
    try {
        v[$z] = void 0;
        var V = !0
    } catch (K) {}
    var N = Rd.call(v);
    if (V)
        if (z) v[$z] = U;
        else delete v[$z];
    return N
}
var Ed = Wd,
    Sd = Object.prototype,
    Pd = Sd.toString;

function _d(v) {
    return Pd.call(v)
}
var Cd = _d,
    fd = "[object Null]",
    Td = "[object Undefined]",
    vR = HK ? HK.toStringTag : void 0;

function Yd(v) {
    if (v == null) return v === void 0 ? Td : fd;
    return vR && vR in Object(v) ? Ed(v) : Cd(v)
}
var ud = Yd;

function yd(v) {
    var z = typeof v;
    return v != null && (z == "object" || z == "function")
}
var zW = yd,
    kd = "[object AsyncFunction]",
    md = "[object Function]",
    Xd = "[object GeneratorFunction]",
    gd = "[object Proxy]";

function cd(v) {
    if (!zW(v)) return !1;
    var z = ud(v);
    return z == md || z == Xd || z == kd || z == gd
}
var id = cd,
    ld = IH["__core-js_shared__"],
    lq = ld,
    zR = function() {
        var v = /[^.]+$/.exec(lq && lq.keys && lq.keys.IE_PROTO || "");
        return v ? "Symbol(src)_1." + v : ""
    }();

function hd(v) {
    return !!zR && zR in v
}
var pd = hd,
    nd = Function.prototype,
    Qd = nd.toString;

function dd(v) {
    if (v != null) {
        try {
            return Qd.call(v)
        } catch (z) {}
        try {
            return v + ""
        } catch (z) {}
    }
    return ""
}
var od = dd,
    rd = /[\\^$.*+?()[\]{}|]/g,
    ad = /^\[object .+?Constructor\]$/,
    td = Function.prototype,
    sd = Object.prototype,
    ed = td.toString,
    vo = sd.hasOwnProperty,
    zo = RegExp("^" + ed.call(vo).replace(rd, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function Uo(v) {
    if (!zW(v) || pd(v)) return !1;
    var z = id(v) ? zo : ad;
    return z.test(od(v))
}
var Vo = Uo;

function No(v, z) {
    return v == null ? void 0 : v[z]
}
var Ko = No;

function xo(v, z) {
    var U = Ko(v, z);
    return Vo(U) ? U : void 0
}
var UW = xo,
    jo = UW(Object, "create"),
    Rz = jo;

function Bo() {
    this.__data__ = Rz ? Rz(null) : {}, this.size = 0
}
var Oo = Bo;

function Jo(v) {
    var z = this.has(v) && delete this.__data__[v];
    return this.size -= z ? 1 : 0, z
}
var qo = Jo,
    Ho = "__lodash_hash_undefined__",
    Do = Object.prototype,
    Ao = Do.hasOwnProperty;

function $o(v) {
    var z = this.__data__;
    if (Rz) {
        var U = z[v];
        return U === Ho ? void 0 : U
    }
    return Ao.call(z, v) ? z[v] : void 0
}
var wo = $o,
    Zo = Object.prototype,
    Lo = Zo.hasOwnProperty;

function Fo(v) {
    var z = this.__data__;
    return Rz ? z[v] !== void 0 : Lo.call(z, v)
}
var Go = Fo,
    Io = "__lodash_hash_undefined__";

function Mo(v, z) {
    var U = this.__data__;
    return this.size += this.has(v) ? 0 : 1, U[v] = Rz && z === void 0 ? Io : z, this
}
var bo = Mo;

function zv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
zv.prototype.clear = Oo;
zv.prototype.delete = qo;
zv.prototype.get = wo;
zv.prototype.has = Go;
zv.prototype.set = bo;
var UR = zv;

function Ro() {
    this.__data__ = [], this.size = 0
}
var Wo = Ro;

function Eo(v, z) {
    return v === z || v !== v && z !== z
}
var So = Eo;

function Po(v, z) {
    var U = v.length;
    while (U--)
        if (So(v[U][0], z)) return U;
    return -1
}
var fK = Po,
    _o = Array.prototype,
    Co = _o.splice;

function fo(v) {
    var z = this.__data__,
        U = fK(z, v);
    if (U < 0) return !1;
    var V = z.length - 1;
    if (U == V) z.pop();
    else Co.call(z, U, 1);
    return --this.size, !0
}
var To = fo;

function Yo(v) {
    var z = this.__data__,
        U = fK(z, v);
    return U < 0 ? void 0 : z[U][1]
}
var uo = Yo;

function yo(v) {
    return fK(this.__data__, v) > -1
}
var ko = yo;

function mo(v, z) {
    var U = this.__data__,
        V = fK(U, v);
    if (V < 0) ++this.size, U.push([v, z]);
    else U[V][1] = z;
    return this
}
var Xo = mo;

function Uv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
Uv.prototype.clear = Wo;
Uv.prototype.delete = To;
Uv.prototype.get = uo;
Uv.prototype.has = ko;
Uv.prototype.set = Xo;
var go = Uv,
    co = UW(IH, "Map"),
    io = co;

function lo() {
    this.size = 0, this.__data__ = {
        hash: new UR,
        map: new(io || go),
        string: new UR
    }
}
var ho = lo;

function po(v) {
    var z = typeof v;
    return z == "string" || z == "number" || z == "symbol" || z == "boolean" ? v !== "__proto__" : v === null
}
var no = po;

function Qo(v, z) {
    var U = v.__data__;
    return no(z) ? U[typeof z == "string" ? "string" : "hash"] : U.map
}
var TK = Qo;

function oo(v) {
    var z = TK(this, v).delete(v);
    return this.size -= z ? 1 : 0, z
}
var ro = oo;

function ao(v) {
    return TK(this, v).get(v)
}
var to = ao;

function so(v) {
    return TK(this, v).has(v)
}
var eo = so;

function vr(v, z) {
    var U = TK(this, v),
        V = U.size;
    return U.set(v, z), this.size += U.size == V ? 0 : 1, this
}
var zr = vr;

function Vv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
Vv.prototype.clear = ho;
Vv.prototype.delete = ro;
Vv.prototype.get = to;
Vv.prototype.has = eo;
Vv.prototype.set = zr;
var VW = Vv,
    Ur = "Expected a function";

function MH(v, z) {
    if (typeof v != "function" || z != null && typeof z != "function") throw TypeError(Ur);
    var U = function() {
        var V = arguments,
            N = z ? z.apply(this, V) : V[0],
            K = U.cache;
        if (K.has(N)) return K.get(N);
        var x = v.apply(this, V);
        return U.cache = K.set(N, x) || K, x
    };
    return U.cache = new(MH.Cache || VW), U
}
MH.Cache = VW;
var Nv = MH;

function Vr(v, z) {
    if (v.destroyed) return;
    v.write(z)
}

function Nr(v) {
    Vr(process.stderr, v)
}
var Kr = Nv((v) => {
    if (!v || v.trim() === "") return null;
    let z = v.split(",").map((K) => K.trim()).filter(Boolean);
    if (z.length === 0) return null;
    let U = z.some((K) => K.startsWith("!")),
        V = z.some((K) => !K.startsWith("!"));
    if (U && V) return null;
    let N = z.map((K) => K.replace(/^!/, "").toLowerCase());
    return {
        include: U ? [] : N,
        exclude: U ? N : [],
        isExclusive: U
    }
});

function xr(v) {
    let z = [],
        U = v.match(/^MCP server ["']([^"']+)["']/);
    if (U && U[1]) z.push("mcp"), z.push(U[1].toLowerCase());
    else {
        let K = v.match(/^([^:[]+):/);
        if (K && K[1]) z.push(K[1].trim().toLowerCase())
    }
    let V = v.match(/^\[([^\]]+)]/);
    if (V && V[1]) z.push(V[1].trim().toLowerCase());
    if (v.toLowerCase().includes("1p event:")) z.push("1p");
    let N = v.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
    if (N && N[1]) {
        let K = N[1].trim().toLowerCase();
        if (K.length < 30 && !K.includes(" ")) z.push(K)
    }
    return Array.from(new Set(z))
}

function jr(v, z) {
    if (!z) return !0;
    if (v.length === 0) return !1;
    if (z.isExclusive) return !v.some((U) => z.exclude.includes(U));
    else return v.some((U) => z.include.includes(U))
}

function Br(v, z) {
    if (!z) return !0;
    let U = xr(v);
    return jr(U, z)
}

function xW() {
    return (process.env.CLAUDE_CONFIG_DIR ?? NW.join(KW.homedir(), ".claude")).normalize("NFC")
}

function VR(v) {
    if (!v) return !1;
    if (typeof v === "boolean") return v;
    let z = v.toLowerCase().trim();
    return ["1", "true", "yes", "on"].includes(z)
}

function Or() {
    let v = "";
    if (typeof process < "u" && typeof process.cwd === "function" && typeof sq.realpathSync === "function") v = sq.realpathSync(jW.cwd()).normalize("NFC");
    return {
        originalCwd: v,
        projectRoot: v,
        totalCostUSD: 0,
        totalAPIDuration: 0,
        totalAPIDurationWithoutRetries: 0,
        totalToolDuration: 0,
        startTime: Date.now(),
        lastInteractionTime: Date.now(),
        totalLinesAdded: 0,
        totalLinesRemoved: 0,
        hasUnknownModelCost: !1,
        cwd: v,
        modelUsage: {},
        mainLoopModelOverride: void 0,
        initialMainLoopModel: null,
        modelStrings: null,
        isInteractive: !1,
        clientType: "cli",
        sessionIngressToken: void 0,
        oauthTokenFromFd: void 0,
        apiKeyFromFd: void 0,
        flagSettingsPath: void 0,
        allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"],
        meter: null,
        sessionCounter: null,
        locCounter: null,
        prCounter: null,
        commitCounter: null,
        costCounter: null,
        tokenCounter: null,
        codeEditToolDecisionCounter: null,
        activeTimeCounter: null,
        sessionId: BW.randomUUID(),
        parentSessionId: void 0,
        loggerProvider: null,
        eventLogger: null,
        meterProvider: null,
        tracerProvider: null,
        agentColorMap: new Map,
        agentColorIndex: 0,
        lastAPIRequest: null,
        inMemoryErrorLog: [],
        inlinePlugins: [],
        useCoworkPlugins: !1,
        sessionBypassPermissionsMode: !1,
        sessionTrustAccepted: !1,
        sessionPersistenceDisabled: !1,
        hasExitedPlanMode: !1,
        needsPlanModeExitAttachment: !1,
        hasExitedDelegateMode: !1,
        needsDelegateModeExitAttachment: !1,
        lspRecommendationShownThisSession: !1,
        initJsonSchema: null,
        registeredHooks: null,
        planSlugCache: new Map,
        teleportedSessionInfo: null,
        invokedSkills: new Map,
        slowOperations: [],
        promptCacheBreaks: [],
        sdkBetas: void 0,
        mainThreadAgentType: void 0,
        isRemoteMode: !1,
        directConnectServerUrl: void 0,
        systemPromptSectionCache: new Map,
        lastEmittedDate: null,
        additionalDirectoriesForClaudeMd: [],
        resumedTranscriptPath: null,
        promptCache1hAllowlist: null
    }
}
var Jr = Or();

function qr() {
    return Jr.sessionId
}

function Hr({
    writeFn: v,
    flushIntervalMs: z = 1000,
    maxBufferSize: U = 100,
    immediateMode: V = !1
}) {
    let N = [],
        K = null;

    function x() {
        if (K) clearTimeout(K), K = null
    }

    function j() {
        if (N.length === 0) return;
        v(N.join("")), N = [], x()
    }

    function B() {
        if (!K) K = setTimeout(j, z)
    }
    return {
        write(O) {
            if (V) {
                v(O);
                return
            }
            if (N.push(O), B(), N.length >= U) j()
        },
        flush: j,
        dispose() {
            j()
        }
    }
}
var NR = new Set;

function Dr(v) {
    return NR.add(v), () => NR.delete(v)
}
var OW = (() => {
    let v = process.env.CLAUDE_CODE_SLOW_OPERATION_THRESHOLD_MS;
    if (v !== void 0) {
        let z = Number(v);
        if (!Number.isNaN(z) && z >= 0) return z
    }
    return 1 / 0
})();

function Ar(v) {
    if (v === null) return "null";
    if (v === void 0) return "undefined";
    if (Array.isArray(v)) return `Array[${v.length}]`;
    if (typeof v === "object") return `Object{${Object.keys(v).length} keys}`;
    if (typeof v === "string") return `string(${v.length} chars)`;
    return typeof v
}

function JW(v, z) {
    let U = performance.now();
    try {
        return z()
    } finally {
        performance.now() - U > OW
    }
}

function _8(v, z, U) {
    let V = Ar(v);
    return JW(`JSON.stringify(${V})`, () => JSON.stringify(v, z, U))
}
var qW = (v, z) => {
        let U = typeof v === "string" ? v.length : 0;
        return JW(`JSON.parse(${U} chars)`, () => JSON.parse(v, z))
    },
    $r = Nv(() => {
        return VR(process.env.DEBUG) || VR(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || HW() || process.argv.some((v) => v.startsWith("--debug=")) || DW() !== null
    }),
    wr = Nv(() => {
        let v = process.argv.find((U) => U.startsWith("--debug="));
        if (!v) return null;
        let z = v.substring(8);
        return Kr(z)
    }),
    HW = Nv(() => {
        return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e")
    }),
    DW = Nv(() => {
        for (let v = 0; v < process.argv.length; v++) {
            let z = process.argv[v];
            if (z.startsWith("--debug-file=")) return z.substring(13);
            if (z === "--debug-file" && v + 1 < process.argv.length) return process.argv[v + 1]
        }
        return null
    });

function Zr(v) {
    if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return !1;
    let z = wr();
    return Br(v, z)
}
var Lr = !1,
    KK = null;

function Fr() {
    if (!KK) {
        let v = null;
        KK = Hr({
            writeFn: (z) => {
                let U = AW(),
                    V = Kv.dirname(U);
                if (v !== V) {
                    try {
                        h9().mkdirSync(V)
                    } catch {}
                    v = V
                }
                h9().appendFileSync(U, z), Gr()
            },
            flushIntervalMs: 1000,
            maxBufferSize: 100,
            immediateMode: $r()
        }), Dr(async () => KK?.dispose())
    }
    return KK
}

function c5(v, {
    level: z
} = {
    level: "debug"
}) {
    if (!Zr(v)) return;
    if (Lr && v.includes(`
`)) v = _8(v);
    let U = `${new Date().toISOString()} [${z.toUpperCase()}] ${v.trim()}
`;
    if (HW()) {
        Nr(U);
        return
    }
    Fr().write(U)
}

function AW() {
    return DW() ?? process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? Kv.join(xW(), "debug", `${qr()}.txt`)
}
var Gr = Nv(() => {
    if (process.argv[2] === "--ripgrep") return;
    try {
        let v = AW(),
            z = Kv.dirname(v),
            U = Kv.join(z, "latest");
        if (!h9().existsSync(z)) h9().mkdirSync(z);
        if (h9().existsSync(U)) try {
            h9().unlinkSync(U)
        } catch {}
        h9().symlinkSync(v, U)
    } catch {}
});

function j4(v, z) {
    let U = performance.now();
    try {
        return z()
    } finally {
        performance.now() - U > OW
    }
}
var Ir = {
        cwd() {
            return process.cwd()
        },
        existsSync(v) {
            return j4(`existsSync(${v})`, () => h6.existsSync(v))
        },
        async stat(v) {
            return $4.stat(v)
        },
        async readdir(v) {
            return $4.readdir(v, {
                withFileTypes: !0
            })
        },
        async unlink(v) {
            return $4.unlink(v)
        },
        async rmdir(v) {
            return $4.rmdir(v)
        },
        async rm(v, z) {
            return $4.rm(v, z)
        },
        async mkdir(v, z) {
            await $4.mkdir(v, {
                recursive: !0,
                ...z
            })
        },
        async readFile(v, z) {
            return $4.readFile(v, {
                encoding: z.encoding
            })
        },
        async rename(v, z) {
            return $4.rename(v, z)
        },
        statSync(v) {
            return j4(`statSync(${v})`, () => h6.statSync(v))
        },
        lstatSync(v) {
            return j4(`lstatSync(${v})`, () => h6.lstatSync(v))
        },
        readFileSync(v, z) {
            return j4(`readFileSync(${v})`, () => h6.readFileSync(v, {
                encoding: z.encoding
            }))
        },
        readFileBytesSync(v) {
            return j4(`readFileBytesSync(${v})`, () => h6.readFileSync(v))
        },
        readSync(v, z) {
            return j4(`readSync(${v}, ${z.length} bytes)`, () => {
                let U = void 0;
                try {
                    U = h6.openSync(v, "r");
                    let V = Buffer.alloc(z.length),
                        N = h6.readSync(U, V, 0, z.length, 0);
                    return {
                        buffer: V,
                        bytesRead: N
                    }
                } finally {
                    if (U) h6.closeSync(U)
                }
            })
        },
        appendFileSync(v, z, U) {
            return j4(`appendFileSync(${v}, ${z.length} chars)`, () => {
                if (!h6.existsSync(v) && U?.mode !== void 0) {
                    let V = h6.openSync(v, "a", U.mode);
                    try {
                        h6.appendFileSync(V, z)
                    } finally {
                        h6.closeSync(V)
                    }
                } else h6.appendFileSync(v, z)
            })
        },
        copyFileSync(v, z) {
            return j4(`copyFileSync(${v}  ${z})`, () => h6.copyFileSync(v, z))
        },
        unlinkSync(v) {
            return j4(`unlinkSync(${v})`, () => h6.unlinkSync(v))
        },
        renameSync(v, z) {
            return j4(`renameSync(${v}  ${z})`, () => h6.renameSync(v, z))
        },
        linkSync(v, z) {
            return j4(`linkSync(${v}  ${z})`, () => h6.linkSync(v, z))
        },
        symlinkSync(v, z, U) {
            return j4(`symlinkSync(${v}  ${z})`, () => h6.symlinkSync(v, z, U))
        },
        readlinkSync(v) {
            return j4(`readlinkSync(${v})`, () => h6.readlinkSync(v))
        },
        realpathSync(v) {
            return j4(`realpathSync(${v})`, () => h6.realpathSync(v).normalize("NFC"))
        },
        mkdirSync(v, z) {
            return j4(`mkdirSync(${v})`, () => {
                if (!h6.existsSync(v)) {
                    let U = {
                        recursive: !0
                    };
                    if (z?.mode !== void 0) U.mode = z.mode;
                    h6.mkdirSync(v, U)
                }
            })
        },
        readdirSync(v) {
            return j4(`readdirSync(${v})`, () => h6.readdirSync(v, {
                withFileTypes: !0
            }))
        },
        readdirStringSync(v) {
            return j4(`readdirStringSync(${v})`, () => h6.readdirSync(v))
        },
        isDirEmptySync(v) {
            return j4(`isDirEmptySync(${v})`, () => {
                return this.readdirSync(v).length === 0
            })
        },
        rmdirSync(v) {
            return j4(`rmdirSync(${v})`, () => h6.rmdirSync(v))
        },
        rmSync(v, z) {
            return j4(`rmSync(${v})`, () => h6.rmSync(v, z))
        },
        createWriteStream(v) {
            return h6.createWriteStream(v)
        },
        async readFileBytes(v, z) {
            if (z === void 0) return $4.readFile(v);
            let U = await $4.open(v, "r");
            try {
                let {
                    size: V
                } = await U.stat(), N = Math.min(V, z), K = Buffer.allocUnsafe(N), x = 0;
                while (x < N) {
                    let {
                        bytesRead: j
                    } = await U.read(K, x, N - x, x);
                    if (j === 0) break;
                    x += j
                }
                return x < N ? K.subarray(0, x) : K
            } finally {
                await U.close()
            }
        }
    },
    Mr = Ir;

function h9() {
    return Mr
}
class Q7 extends Error {}

function $W() {
    return process.versions.bun !== void 0
}
var xK = null,
    KR = !1;

function br() {
    if (KR) return xK;
    if (KR = !0, !process.env.DEBUG_CLAUDE_AGENT_SDK) return null;
    let v = eq.join(xW(), "debug");
    if (xK = eq.join(v, `sdk-${wW.randomUUID()}.txt`), !xv.existsSync(v)) xv.mkdirSync(v, {
        recursive: !0
    });
    return process.stderr.write(`SDK debug logs: ${xK}
`), xK
}

function c9(v) {
    let z = br();
    if (!z) return;
    let U = `${new Date().toISOString()} ${v}
`;
    xv.appendFileSync(z, U)
}

function Rr(v, z) {
    let U = {
        ...v
    };
    if (z) {
        let V = {
            sandbox: z
        };
        if (U.settings) try {
            V = {
                ...qW(U.settings),
                sandbox: z
            }
        } catch {}
        U.settings = _8(V)
    }
    return U
}
class ZW {
    options;
    process;
    processStdin;
    processStdout;
    ready = !1;
    abortController;
    exitError;
    exitListeners = [];
    processExitHandler;
    abortHandler;
    constructor(v) {
        this.options = v, this.abortController = v.abortController || tR(), this.initialize()
    }
    getDefaultExecutable() {
        return $W() ? "bun" : "node"
    }
    spawnLocalProcess(v) {
        let {
            command: z,
            args: U,
            cwd: V,
            env: N,
            signal: K
        } = v, x = N.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore", j = sR.spawn(z, U, {
            cwd: V,
            stdio: ["pipe", "pipe", x],
            signal: K,
            env: N,
            windowsHide: !0
        });
        if (N.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) j.stderr.on("data", (B) => {
            let O = B.toString();
            if (c9(O), this.options.stderr) this.options.stderr(O)
        });
        return {
            stdin: j.stdin,
            stdout: j.stdout,
            get killed() {
                return j.killed
            },
            get exitCode() {
                return j.exitCode
            },
            kill: j.kill.bind(j),
            on: j.on.bind(j),
            once: j.once.bind(j),
            off: j.off.bind(j)
        }
    }
    initialize() {
        try {
            let {
                additionalDirectories: v = [],
                agent: z,
                betas: U,
                cwd: V,
                executable: N = this.getDefaultExecutable(),
                executableArgs: K = [],
                extraArgs: x = {},
                pathToClaudeCodeExecutable: j,
                env: B = {
                    ...process.env
                },
                maxThinkingTokens: O,
                maxTurns: J,
                maxBudgetUsd: q,
                model: H,
                fallbackModel: D,
                jsonSchema: A,
                permissionMode: w,
                allowDangerouslySkipPermissions: Z,
                permissionPromptToolName: $,
                continueConversation: F,
                resume: L,
                settingSources: G,
                allowedTools: I = [],
                disallowedTools: M = [],
                tools: b,
                mcpServers: W,
                strictMcpConfig: E,
                canUseTool: y,
                includePartialMessages: T,
                plugins: X,
                sandbox: Q
            } = this.options, m = ["--output-format", "stream-json", "--verbose", "--input-format", "stream-json"];
            if (O !== void 0) m.push("--max-thinking-tokens", O.toString());
            if (this.options.effort) m.push("--effort", this.options.effort);
            if (J) m.push("--max-turns", J.toString());
            if (q !== void 0) m.push("--max-budget-usd", q.toString());
            if (H) m.push("--model", H);
            if (z) m.push("--agent", z);
            if (U && U.length > 0) m.push("--betas", U.join(","));
            if (A) m.push("--json-schema", _8(A));
            if (this.options.debugFile) m.push("--debug-file", this.options.debugFile);
            else if (this.options.debug) m.push("--debug");
            if (B.DEBUG_CLAUDE_AGENT_SDK) m.push("--debug-to-stderr");
            if (y) {
                if ($) throw Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
                m.push("--permission-prompt-tool", "stdio")
            } else if ($) m.push("--permission-prompt-tool", $);
            if (F) m.push("--continue");
            if (L) m.push("--resume", L);
            if (I.length > 0) m.push("--allowedTools", I.join(","));
            if (M.length > 0) m.push("--disallowedTools", M.join(","));
            if (b !== void 0)
                if (Array.isArray(b))
                    if (b.length === 0) m.push("--tools", "");
                    else m.push("--tools", b.join(","));
            else m.push("--tools", "default");
            if (W && Object.keys(W).length > 0) m.push("--mcp-config", _8({
                mcpServers: W
            }));
            if (G) m.push("--setting-sources", G.join(","));
            if (E) m.push("--strict-mcp-config");
            if (w) m.push("--permission-mode", w);
            if (Z) m.push("--allow-dangerously-skip-permissions");
            if (D) {
                if (H && D === H) throw Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
                m.push("--fallback-model", D)
            }
            if (T) m.push("--include-partial-messages");
            for (let u of v) m.push("--add-dir", u);
            if (X && X.length > 0)
                for (let u of X)
                    if (u.type === "local") m.push("--plugin-dir", u.path);
                    else throw Error(`Unsupported plugin type: ${u.type}`);
            if (this.options.forkSession) m.push("--fork-session");
            if (this.options.resumeSessionAt) m.push("--resume-session-at", this.options.resumeSessionAt);
            if (this.options.sessionId) m.push("--session-id", this.options.sessionId);
            if (this.options.persistSession === !1) m.push("--no-session-persistence");
            let P6 = Rr(x ?? {}, Q);
            for (let [u, p] of Object.entries(P6))
                if (p === null) m.push(`--${u}`);
                else m.push(`--${u}`, p);
            if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
            if (delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK) B.DEBUG = "1";
            else delete B.DEBUG;
            let F6 = Wr(j),
                q6 = F6 ? j : N,
                Z6 = F6 ? [...K, ...m] : [...K, j, ...m],
                T6 = {
                    command: q6,
                    args: Z6,
                    cwd: V,
                    env: B,
                    signal: this.abortController.signal
                };
            if (this.options.spawnClaudeCodeProcess) c9(`Spawning Claude Code (custom): ${q6} ${Z6.join(" ")}`), this.process = this.options.spawnClaudeCodeProcess(T6);
            else {
                if (!h9().existsSync(j)) {
                    let u = F6 ? `Claude Code native binary not found at ${j}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${j}. Is options.pathToClaudeCodeExecutable set?`;
                    throw ReferenceError(u)
                }
                c9(`Spawning Claude Code: ${q6} ${Z6.join(" ")}`), this.process = this.spawnLocalProcess(T6)
            }
            this.processStdin = this.process.stdin, this.processStdout = this.process.stdout;
            let C = () => {
                if (this.process && !this.process.killed) this.process.kill("SIGTERM")
            };
            this.processExitHandler = C, this.abortHandler = C, process.on("exit", this.processExitHandler), this.abortController.signal.addEventListener("abort", this.abortHandler), this.process.on("error", (u) => {
                if (this.ready = !1, this.abortController.signal.aborted) this.exitError = new Q7("Claude Code process aborted by user");
                else this.exitError = Error(`Failed to spawn Claude Code process: ${u.message}`), c9(this.exitError.message)
            }), this.process.on("exit", (u, p) => {
                if (this.ready = !1, this.abortController.signal.aborted) this.exitError = new Q7("Claude Code process aborted by user");
                else {
                    let R = this.getProcessExitError(u, p);
                    if (R) this.exitError = R, c9(R.message)
                }
            }), this.ready = !0
        } catch (v) {
            throw this.ready = !1, v
        }
    }
    getProcessExitError(v, z) {
        if (v !== 0 && v !== null) return Error(`Claude Code process exited with code ${v}`);
        else if (z) return Error(`Claude Code process terminated by signal ${z}`);
        return
    }
    write(v) {
        if (this.abortController.signal.aborted) throw new Q7("Operation aborted");
        if (!this.ready || !this.processStdin) throw Error("ProcessTransport is not ready for writing");
        if (this.process?.killed || this.process?.exitCode !== null) throw Error("Cannot write to terminated process");
        if (this.exitError) throw Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
        c9(`[ProcessTransport] Writing to stdin: ${v.substring(0,100)}`);
        try {
            if (!this.processStdin.write(v)) c9("[ProcessTransport] Write buffer full, data queued")
        } catch (z) {
            throw this.ready = !1, Error(`Failed to write to process stdin: ${z.message}`)
        }
    }
    close() {
        if (this.processStdin) this.processStdin.end(), this.processStdin = void 0;
        if (this.abortHandler) this.abortController.signal.removeEventListener("abort", this.abortHandler), this.abortHandler = void 0;
        for (let {
                handler: v
            }
            of this.exitListeners) this.process?.off("exit", v);
        if (this.exitListeners = [], this.process && !this.process.killed) this.process.kill("SIGTERM"), setTimeout(() => {
            if (this.process && !this.process.killed) this.process.kill("SIGKILL")
        }, 5000);
        if (this.ready = !1, this.processExitHandler) process.off("exit", this.processExitHandler), this.processExitHandler = void 0
    }
    isReady() {
        return this.ready
    }
    async * readMessages() {
        if (!this.processStdout) throw Error("ProcessTransport output stream not available");
        let v = eR.createInterface({
            input: this.processStdout
        });
        try {
            for await (let z of v) if (z.trim()) try {
                yield qW(z)
            } catch (U) {
                throw c9(`Non-JSON stdout: ${z}`), Error(`CLI output was not valid JSON. This may indicate an error during startup. Output: ${z.slice(0,200)}${z.length>200?"...":""}`)
            }
            await this.waitForExit()
        } catch (z) {
            throw z
        } finally {
            v.close()
        }
    }
    endInput() {
        if (this.processStdin) this.processStdin.end()
    }
    getInputStream() {
        return this.processStdin
    }
    onExit(v) {
        if (!this.process) return () => {};
        let z = (U, V) => {
            let N = this.getProcessExitError(U, V);
            v(N)
        };
        return this.process.on("exit", z), this.exitListeners.push({
            callback: v,
            handler: z
        }), () => {
            if (this.process) this.process.off("exit", z);
            let U = this.exitListeners.findIndex((V) => V.handler === z);
            if (U !== -1) this.exitListeners.splice(U, 1)
        }
    }
    async waitForExit() {
        if (!this.process) {
            if (this.exitError) throw this.exitError;
            return
        }
        if (this.process.exitCode !== null || this.process.killed) {
            if (this.exitError) throw this.exitError;
            return
        }
        return new Promise((v, z) => {
            let U = (N, K) => {
                if (this.abortController.signal.aborted) {
                    z(new Q7("Operation aborted"));
                    return
                }
                let x = this.getProcessExitError(N, K);
                if (x) z(x);
                else v()
            };
            this.process.once("exit", U);
            let V = (N) => {
                this.process.off("exit", U), z(N)
            };
            this.process.once("error", V), this.process.once("exit", () => {
                this.process.off("error", V)
            })
        })
    }
}

function Wr(v) {
    return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some((z) => v.endsWith(z))
}
class LW {
    returned;
    queue = [];
    readResolve;
    readReject;
    isDone = !1;
    hasError;
    started = !1;
    constructor(v) {
        this.returned = v
    } [Symbol.asyncIterator]() {
        if (this.started) throw Error("Stream can only be iterated once");
        return this.started = !0, this
    }
    next() {
        if (this.queue.length > 0) return Promise.resolve({
            done: !1,
            value: this.queue.shift()
        });
        if (this.isDone) return Promise.resolve({
            done: !0,
            value: void 0
        });
        if (this.hasError) return Promise.reject(this.hasError);
        return new Promise((v, z) => {
            this.readResolve = v, this.readReject = z
        })
    }
    enqueue(v) {
        if (this.readResolve) {
            let z = this.readResolve;
            this.readResolve = void 0, this.readReject = void 0, z({
                done: !1,
                value: v
            })
        } else this.queue.push(v)
    }
    done() {
        if (this.isDone = !0, this.readResolve) {
            let v = this.readResolve;
            this.readResolve = void 0, this.readReject = void 0, v({
                done: !0,
                value: void 0
            })
        }
    }
    error(v) {
        if (this.hasError = v, this.readReject) {
            let z = this.readReject;
            this.readResolve = void 0, this.readReject = void 0, z(v)
        }
    }
    return () {
        if (this.isDone = !0, this.returned) this.returned();
        return Promise.resolve({
            done: !0,
            value: void 0
        })
    }
}
class FW {
    sendMcpMessage;
    isClosed = !1;
    constructor(v) {
        this.sendMcpMessage = v
    }
    onclose;
    onerror;
    onmessage;
    async start() {}
    async send(v) {
        if (this.isClosed) throw Error("Transport is closed");
        this.sendMcpMessage(v)
    }
    async close() {
        if (this.isClosed) return;
        this.isClosed = !0, this.onclose?.()
    }
}
class IW {
    transport;
    isSingleUserTurn;
    canUseTool;
    hooks;
    abortController;
    jsonSchema;
    initConfig;
    pendingControlResponses = new Map;
    cleanupPerformed = !1;
    sdkMessages;
    inputStream = new LW;
    initialization;
    cancelControllers = new Map;
    hookCallbacks = new Map;
    nextCallbackId = 0;
    sdkMcpTransports = new Map;
    sdkMcpServerInstances = new Map;
    pendingMcpResponses = new Map;
    firstResultReceivedResolve;
    firstResultReceived = !1;
    hasBidirectionalNeeds() {
        return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0
    }
    constructor(v, z, U, V, N, K = new Map, x, j) {
        this.transport = v, this.isSingleUserTurn = z, this.canUseTool = U, this.hooks = V, this.abortController = N, this.jsonSchema = x, this.initConfig = j;
        for (let [B, O] of K) this.connectSdkMcpServer(B, O);
        this.sdkMessages = this.readSdkMessages(), this.readMessages(), this.initialization = this.initialize(), this.initialization.catch(() => {})
    }
    setError(v) {
        this.inputStream.error(v)
    }
    async stopTask(v) {
        await this.request({
            subtype: "stop_task",
            task_id: v
        })
    }
    close() {
        this.cleanup()
    }
    cleanup(v) {
        if (this.cleanupPerformed) return;
        this.cleanupPerformed = !0;
        try {
            this.transport.close();
            let z = Error("Query closed before response received");
            for (let {
                    reject: U
                }
                of this.pendingControlResponses.values()) U(z);
            this.pendingControlResponses.clear();
            for (let {
                    reject: U
                }
                of this.pendingMcpResponses.values()) U(z);
            this.pendingMcpResponses.clear(), this.cancelControllers.clear(), this.hookCallbacks.clear();
            for (let U of this.sdkMcpTransports.values()) try {
                U.close()
            } catch {}
            if (this.sdkMcpTransports.clear(), v) this.inputStream.error(v);
            else this.inputStream.done()
        } catch (z) {}
    }
    next(...[v]) {
        return this.sdkMessages.next(...[v])
    }
    return (v) {
        return this.sdkMessages.return(v)
    }
    throw (v) {
        return this.sdkMessages.throw(v)
    } [Symbol.asyncIterator]() {
        return this.sdkMessages
    } [Symbol.asyncDispose]() {
        return this.sdkMessages[Symbol.asyncDispose]()
    }
    async readMessages() {
        try {
            for await (let v of this.transport.readMessages()) {
                if (v.type === "control_response") {
                    let z = this.pendingControlResponses.get(v.response.request_id);
                    if (z) z.handler(v.response);
                    continue
                } else if (v.type === "control_request") {
                    this.handleControlRequest(v);
                    continue
                } else if (v.type === "control_cancel_request") {
                    this.handleControlCancelRequest(v);
                    continue
                } else if (v.type === "keep_alive") continue;
                if (v.type === "streamlined_text" || v.type === "streamlined_tool_use_summary") continue;
                if (v.type === "result") {
                    if (this.firstResultReceived = !0, this.firstResultReceivedResolve) this.firstResultReceivedResolve();
                    if (this.isSingleUserTurn) c5("[Query.readMessages] First result received for single-turn query, closing stdin"), this.transport.endInput()
                }
                this.inputStream.enqueue(v)
            }
            if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
            this.inputStream.done(), this.cleanup()
        } catch (v) {
            if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
            this.inputStream.error(v), this.cleanup(v)
        }
    }
    async handleControlRequest(v) {
        let z = new AbortController;
        this.cancelControllers.set(v.request_id, z);
        try {
            let U = await this.processControlRequest(v, z.signal),
                V = {
                    type: "control_response",
                    response: {
                        subtype: "success",
                        request_id: v.request_id,
                        response: U
                    }
                };
            await Promise.resolve(this.transport.write(_8(V) + `
`))
        } catch (U) {
            let V = {
                type: "control_response",
                response: {
                    subtype: "error",
                    request_id: v.request_id,
                    error: U.message || String(U)
                }
            };
            await Promise.resolve(this.transport.write(_8(V) + `
`))
        } finally {
            this.cancelControllers.delete(v.request_id)
        }
    }
    handleControlCancelRequest(v) {
        let z = this.cancelControllers.get(v.request_id);
        if (z) z.abort(), this.cancelControllers.delete(v.request_id)
    }
    async processControlRequest(v, z) {
        if (v.request.subtype === "can_use_tool") {
            if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
            return {
                ...await this.canUseTool(v.request.tool_name, v.request.input, {
                    signal: z,
                    suggestions: v.request.permission_suggestions,
                    blockedPath: v.request.blocked_path,
                    decisionReason: v.request.decision_reason,
                    toolUseID: v.request.tool_use_id,
                    agentID: v.request.agent_id
                }),
                toolUseID: v.request.tool_use_id
            }
        } else if (v.request.subtype === "hook_callback") return await this.handleHookCallbacks(v.request.callback_id, v.request.input, v.request.tool_use_id, z);
        else if (v.request.subtype === "mcp_message") {
            let U = v.request,
                V = this.sdkMcpTransports.get(U.server_name);
            if (!V) throw Error(`SDK MCP server not found: ${U.server_name}`);
            if ("method" in U.message && "id" in U.message && U.message.id !== null) return {
                mcp_response: await this.handleMcpControlRequest(U.server_name, U, V)
            };
            else {
                if (V.onmessage) V.onmessage(U.message);
                return {
                    mcp_response: {
                        jsonrpc: "2.0",
                        result: {},
                        id: 0
                    }
                }
            }
        }
        throw Error("Unsupported control request subtype: " + v.request.subtype)
    }
    async * readSdkMessages() {
        for await (let v of this.inputStream) yield v
    }
    async initialize() {
        let v;
        if (this.hooks) {
            v = {};
            for (let [V, N] of Object.entries(this.hooks))
                if (N.length > 0) v[V] = N.map((K) => {
                    let x = [];
                    for (let j of K.hooks) {
                        let B = `hook_${this.nextCallbackId++}`;
                        this.hookCallbacks.set(B, j), x.push(B)
                    }
                    return {
                        matcher: K.matcher,
                        hookCallbackIds: x,
                        timeout: K.timeout
                    }
                })
        }
        let z = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0,
            U = {
                subtype: "initialize",
                hooks: v,
                sdkMcpServers: z,
                jsonSchema: this.jsonSchema,
                systemPrompt: this.initConfig?.systemPrompt,
                appendSystemPrompt: this.initConfig?.appendSystemPrompt,
                agents: this.initConfig?.agents
            };
        return (await this.request(U)).response
    }
    async interrupt() {
        await this.request({
            subtype: "interrupt"
        })
    }
    async setPermissionMode(v) {
        await this.request({
            subtype: "set_permission_mode",
            mode: v
        })
    }
    async setModel(v) {
        await this.request({
            subtype: "set_model",
            model: v
        })
    }
    async setMaxThinkingTokens(v) {
        await this.request({
            subtype: "set_max_thinking_tokens",
            max_thinking_tokens: v
        })
    }
    async rewindFiles(v, z) {
        return (await this.request({
            subtype: "rewind_files",
            user_message_id: v,
            dry_run: z?.dryRun
        })).response
    }
    async processPendingPermissionRequests(v) {
        for (let z of v)
            if (z.request.subtype === "can_use_tool") this.handleControlRequest(z).catch(() => {})
    }
    request(v) {
        let z = Math.random().toString(36).substring(2, 15),
            U = {
                request_id: z,
                type: "control_request",
                request: v
            };
        return new Promise((V, N) => {
            this.pendingControlResponses.set(z, {
                handler: (K) => {
                    if (this.pendingControlResponses.delete(z), K.subtype === "success") V(K);
                    else if (N(Error(K.error)), K.pending_permission_requests) this.processPendingPermissionRequests(K.pending_permission_requests)
                },
                reject: N
            }), Promise.resolve(this.transport.write(_8(U) + `
`))
        })
    }
    async initializationResult() {
        return this.initialization
    }
    async supportedCommands() {
        return (await this.initialization).commands
    }
    async supportedModels() {
        return (await this.initialization).models
    }
    async reconnectMcpServer(v) {
        await this.request({
            subtype: "mcp_reconnect",
            serverName: v
        })
    }
    async toggleMcpServer(v, z) {
        await this.request({
            subtype: "mcp_toggle",
            serverName: v,
            enabled: z
        })
    }
    async mcpServerStatus() {
        return (await this.request({
            subtype: "mcp_status"
        })).response.mcpServers
    }
    async setMcpServers(v) {
        let z = {},
            U = {};
        for (let [x, j] of Object.entries(v))
            if (j.type === "sdk" && "instance" in j) z[x] = j.instance;
            else U[x] = j;
        let V = new Set(this.sdkMcpServerInstances.keys()),
            N = new Set(Object.keys(z));
        for (let x of V)
            if (!N.has(x)) await this.disconnectSdkMcpServer(x);
        for (let [x, j] of Object.entries(z))
            if (!V.has(x)) this.connectSdkMcpServer(x, j);
        let K = {};
        for (let x of Object.keys(z)) K[x] = {
            type: "sdk",
            name: x
        };
        return (await this.request({
            subtype: "mcp_set_servers",
            servers: {
                ...U,
                ...K
            }
        })).response
    }
    async accountInfo() {
        return (await this.initialization).account
    }
    async streamInput(v) {
        c5("[Query.streamInput] Starting to process input stream");
        try {
            let z = 0;
            for await (let U of v) {
                if (z++, c5(`[Query.streamInput] Processing message ${z}: ${U.type}`), this.abortController?.signal.aborted) break;
                await Promise.resolve(this.transport.write(_8(U) + `
`))
            }
            if (c5(`[Query.streamInput] Finished processing ${z} messages from input stream`), z > 0 && this.hasBidirectionalNeeds()) c5("[Query.streamInput] Has bidirectional needs, waiting for first result"), await this.waitForFirstResult();
            c5("[Query] Calling transport.endInput() to close stdin to CLI process"), this.transport.endInput()
        } catch (z) {
            if (!(z instanceof Q7)) throw z
        }
    }
    waitForFirstResult() {
        if (this.firstResultReceived) return c5("[Query.waitForFirstResult] Result already received, returning immediately"), Promise.resolve();
        return new Promise((v) => {
            if (this.abortController?.signal.aborted) {
                v();
                return
            }
            this.abortController?.signal.addEventListener("abort", () => v(), {
                once: !0
            }), this.firstResultReceivedResolve = v
        })
    }
    handleHookCallbacks(v, z, U, V) {
        let N = this.hookCallbacks.get(v);
        if (!N) throw Error(`No hook callback found for ID: ${v}`);
        return N(z, U, {
            signal: V
        })
    }
    connectSdkMcpServer(v, z) {
        let U = new FW((V) => this.sendMcpServerMessageToCli(v, V));
        this.sdkMcpTransports.set(v, U), this.sdkMcpServerInstances.set(v, z), z.connect(U)
    }
    async disconnectSdkMcpServer(v) {
        let z = this.sdkMcpTransports.get(v);
        if (z) await z.close(), this.sdkMcpTransports.delete(v);
        this.sdkMcpServerInstances.delete(v)
    }
    sendMcpServerMessageToCli(v, z) {
        if ("id" in z && z.id !== null && z.id !== void 0) {
            let V = `${v}:${z.id}`,
                N = this.pendingMcpResponses.get(V);
            if (N) {
                N.resolve(z), this.pendingMcpResponses.delete(V);
                return
            }
        }
        let U = {
            type: "control_request",
            request_id: GW.randomUUID(),
            request: {
                subtype: "mcp_message",
                server_name: v,
                message: z
            }
        };
        this.transport.write(_8(U) + `
`)
    }
    handleMcpControlRequest(v, z, U) {
        let V = "id" in z.message ? z.message.id : null,
            N = `${v}:${V}`;
        return new Promise((K, x) => {
            let j = () => {
                    this.pendingMcpResponses.delete(N)
                },
                B = (J) => {
                    j(), K(J)
                },
                O = (J) => {
                    j(), x(J)
                };
            if (this.pendingMcpResponses.set(N, {
                    resolve: B,
                    reject: O
                }), U.onmessage) U.onmessage(z.message);
            else {
                j(), x(Error("No message handler registered"));
                return
            }
        })
    }
}
var A0;
(function(v) {
    v.assertEqual = (N) => {};

    function z(N) {}
    v.assertIs = z;

    function U(N) {
        throw Error()
    }
    v.assertNever = U, v.arrayToEnum = (N) => {
        let K = {};
        for (let x of N) K[x] = x;
        return K
    }, v.getValidEnumValues = (N) => {
        let K = v.objectKeys(N).filter((j) => typeof N[N[j]] !== "number"),
            x = {};
        for (let j of K) x[j] = N[j];
        return v.objectValues(x)
    }, v.objectValues = (N) => {
        return v.objectKeys(N).map(function(K) {
            return N[K]
        })
    }, v.objectKeys = typeof Object.keys === "function" ? (N) => Object.keys(N) : (N) => {
        let K = [];
        for (let x in N)
            if (Object.prototype.hasOwnProperty.call(N, x)) K.push(x);
        return K
    }, v.find = (N, K) => {
        for (let x of N)
            if (K(x)) return x;
        return
    }, v.isInteger = typeof Number.isInteger === "function" ? (N) => Number.isInteger(N) : (N) => typeof N === "number" && Number.isFinite(N) && Math.floor(N) === N;

    function V(N, K = " | ") {
        return N.map((x) => typeof x === "string" ? `'${x}'` : x).join(K)
    }
    v.joinValues = V, v.jsonStringifyReplacer = (N, K) => {
        if (typeof K === "bigint") return K.toString();
        return K
    }
})(A0 || (A0 = {}));
var xR;
(function(v) {
    v.mergeShapes = (z, U) => {
        return {
            ...z,
            ...U
        }
    }
})(xR || (xR = {}));
var w6 = A0.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
    l9 = (v) => {
        switch (typeof v) {
            case "undefined":
                return w6.undefined;
            case "string":
                return w6.string;
            case "number":
                return Number.isNaN(v) ? w6.nan : w6.number;
            case "boolean":
                return w6.boolean;
            case "function":
                return w6.function;
            case "bigint":
                return w6.bigint;
            case "symbol":
                return w6.symbol;
            case "object":
                if (Array.isArray(v)) return w6.array;
                if (v === null) return w6.null;
                if (v.then && typeof v.then === "function" && v.catch && typeof v.catch === "function") return w6.promise;
                if (typeof Map < "u" && v instanceof Map) return w6.map;
                if (typeof Set < "u" && v instanceof Set) return w6.set;
                if (typeof Date < "u" && v instanceof Date) return w6.date;
                return w6.object;
            default:
                return w6.unknown
        }
    },
    r = A0.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
class c3 extends Error {
    get errors() {
        return this.issues
    }
    constructor(v) {
        super();
        this.issues = [], this.addIssue = (U) => {
            this.issues = [...this.issues, U]
        }, this.addIssues = (U = []) => {
            this.issues = [...this.issues, ...U]
        };
        let z = new.target.prototype;
        if (Object.setPrototypeOf) Object.setPrototypeOf(this, z);
        else this.__proto__ = z;
        this.name = "ZodError", this.issues = v
    }
    format(v) {
        let z = v || function(N) {
                return N.message
            },
            U = {
                _errors: []
            },
            V = (N) => {
                for (let K of N.issues)
                    if (K.code === "invalid_union") K.unionErrors.map(V);
                    else if (K.code === "invalid_return_type") V(K.returnTypeError);
                else if (K.code === "invalid_arguments") V(K.argumentsError);
                else if (K.path.length === 0) U._errors.push(z(K));
                else {
                    let x = U,
                        j = 0;
                    while (j < K.path.length) {
                        let B = K.path[j];
                        if (j !== K.path.length - 1) x[B] = x[B] || {
                            _errors: []
                        };
                        else x[B] = x[B] || {
                            _errors: []
                        }, x[B]._errors.push(z(K));
                        x = x[B], j++
                    }
                }
            };
        return V(this), U
    }
    static assert(v) {
        if (!(v instanceof c3)) throw Error(`Not a ZodError: ${v}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, A0.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(v = (z) => z.message) {
        let z = {},
            U = [];
        for (let V of this.issues)
            if (V.path.length > 0) {
                let N = V.path[0];
                z[N] = z[N] || [], z[N].push(v(V))
            } else U.push(v(V));
        return {
            formErrors: U,
            fieldErrors: z
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
c3.create = (v) => {
    return new c3(v)
};
var Er = (v, z) => {
        let U;
        switch (v.code) {
            case r.invalid_type:
                if (v.received === w6.undefined) U = "Required";
                else U = `Expected ${v.expected}, received ${v.received}`;
                break;
            case r.invalid_literal:
                U = `Invalid literal value, expected ${JSON.stringify(v.expected,A0.jsonStringifyReplacer)}`;
                break;
            case r.unrecognized_keys:
                U = `Unrecognized key(s) in object: ${A0.joinValues(v.keys,", ")}`;
                break;
            case r.invalid_union:
                U = "Invalid input";
                break;
            case r.invalid_union_discriminator:
                U = `Invalid discriminator value. Expected ${A0.joinValues(v.options)}`;
                break;
            case r.invalid_enum_value:
                U = `Invalid enum value. Expected ${A0.joinValues(v.options)}, received '${v.received}'`;
                break;
            case r.invalid_arguments:
                U = "Invalid function arguments";
                break;
            case r.invalid_return_type:
                U = "Invalid function return type";
                break;
            case r.invalid_date:
                U = "Invalid date";
                break;
            case r.invalid_string:
                if (typeof v.validation === "object")
                    if ("includes" in v.validation) {
                        if (U = `Invalid input: must include "${v.validation.includes}"`, typeof v.validation.position === "number") U = `${U} at one or more positions greater than or equal to ${v.validation.position}`
                    } else if ("startsWith" in v.validation) U = `Invalid input: must start with "${v.validation.startsWith}"`;
                else if ("endsWith" in v.validation) U = `Invalid input: must end with "${v.validation.endsWith}"`;
                else A0.assertNever(v.validation);
                else if (v.validation !== "regex") U = `Invalid ${v.validation}`;
                else U = "Invalid";
                break;
            case r.too_small:
                if (v.type === "array") U = `Array must contain ${v.exact?"exactly":v.inclusive?"at least":"more than"} ${v.minimum} element(s)`;
                else if (v.type === "string") U = `String must contain ${v.exact?"exactly":v.inclusive?"at least":"over"} ${v.minimum} character(s)`;
                else if (v.type === "number") U = `Number must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${v.minimum}`;
                else if (v.type === "bigint") U = `Number must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${v.minimum}`;
                else if (v.type === "date") U = `Date must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(v.minimum))}`;
                else U = "Invalid input";
                break;
            case r.too_big:
                if (v.type === "array") U = `Array must contain ${v.exact?"exactly":v.inclusive?"at most":"less than"} ${v.maximum} element(s)`;
                else if (v.type === "string") U = `String must contain ${v.exact?"exactly":v.inclusive?"at most":"under"} ${v.maximum} character(s)`;
                else if (v.type === "number") U = `Number must be ${v.exact?"exactly":v.inclusive?"less than or equal to":"less than"} ${v.maximum}`;
                else if (v.type === "bigint") U = `BigInt must be ${v.exact?"exactly":v.inclusive?"less than or equal to":"less than"} ${v.maximum}`;
                else if (v.type === "date") U = `Date must be ${v.exact?"exactly":v.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(v.maximum))}`;
                else U = "Invalid input";
                break;
            case r.custom:
                U = "Invalid input";
                break;
            case r.invalid_intersection_types:
                U = "Intersection results could not be merged";
                break;
            case r.not_multiple_of:
                U = `Number must be a multiple of ${v.multipleOf}`;
                break;
            case r.not_finite:
                U = "Number must be finite";
                break;
            default:
                U = z.defaultError, A0.assertNever(v)
        }
        return {
            message: U
        }
    },
    Wz = Er,
    Sr = Wz;

function vH() {
    return Sr
}
var zH = (v) => {
    let {
        data: z,
        path: U,
        errorMaps: V,
        issueData: N
    } = v, K = [...U, ...N.path || []], x = {
        ...N,
        path: K
    };
    if (N.message !== void 0) return {
        ...N,
        path: K,
        message: N.message
    };
    let j = "",
        B = V.filter((O) => !!O).slice().reverse();
    for (let O of B) j = O(x, {
        data: z,
        defaultError: j
    }).message;
    return {
        ...N,
        path: K,
        message: j
    }
};

function O6(v, z) {
    let U = vH(),
        V = zH({
            issueData: z,
            data: v.data,
            path: v.path,
            errorMaps: [v.common.contextualErrorMap, v.schemaErrorMap, U, U === Wz ? void 0 : Wz].filter((N) => !!N)
        });
    v.common.issues.push(V)
}
class s4 {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty"
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted"
    }
    static mergeArray(v, z) {
        let U = [];
        for (let V of z) {
            if (V.status === "aborted") return c6;
            if (V.status === "dirty") v.dirty();
            U.push(V.value)
        }
        return {
            status: v.value,
            value: U
        }
    }
    static async mergeObjectAsync(v, z) {
        let U = [];
        for (let V of z) {
            let N = await V.key,
                K = await V.value;
            U.push({
                key: N,
                value: K
            })
        }
        return s4.mergeObjectSync(v, U)
    }
    static mergeObjectSync(v, z) {
        let U = {};
        for (let V of z) {
            let {
                key: N,
                value: K
            } = V;
            if (N.status === "aborted") return c6;
            if (K.status === "aborted") return c6;
            if (N.status === "dirty") v.dirty();
            if (K.status === "dirty") v.dirty();
            if (N.value !== "__proto__" && (typeof K.value < "u" || V.alwaysSet)) U[N.value] = K.value
        }
        return {
            status: v.value,
            value: U
        }
    }
}
var c6 = Object.freeze({
        status: "aborted"
    }),
    Lz = (v) => ({
        status: "dirty",
        value: v
    }),
    O3 = (v) => ({
        status: "valid",
        value: v
    }),
    jR = (v) => v.status === "aborted",
    BR = (v) => v.status === "dirty",
    o7 = (v) => v.status === "valid",
    DK = (v) => typeof Promise < "u" && v instanceof Promise,
    I6;
(function(v) {
    v.errToObj = (z) => typeof z === "string" ? {
        message: z
    } : z || {}, v.toString = (z) => typeof z === "string" ? z : z?.message
})(I6 || (I6 = {}));
class z8 {
    constructor(v, z, U, V) {
        this._cachedPath = [], this.parent = v, this.data = z, this._path = U, this._key = V
    }
    get path() {
        if (!this._cachedPath.length)
            if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
        return this._cachedPath
    }
}
var OR = (v, z) => {
    if (o7(z)) return {
        success: !0,
        data: z.value
    };
    else {
        if (!v.common.issues.length) throw Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error) return this._error;
                let U = new c3(v.common.issues);
                return this._error = U, this._error
            }
        }
    }
};

function r6(v) {
    if (!v) return {};
    let {
        errorMap: z,
        invalid_type_error: U,
        required_error: V,
        description: N
    } = v;
    if (z && (U || V)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    if (z) return {
        errorMap: z,
        description: N
    };
    return {
        errorMap: (K, x) => {
            let {
                message: j
            } = v;
            if (K.code === "invalid_enum_value") return {
                message: j ?? x.defaultError
            };
            if (typeof x.data > "u") return {
                message: j ?? V ?? x.defaultError
            };
            if (K.code !== "invalid_type") return {
                message: x.defaultError
            };
            return {
                message: j ?? U ?? x.defaultError
            }
        },
        description: N
    }
}
class N0 {
    get description() {
        return this._def.description
    }
    _getType(v) {
        return l9(v.data)
    }
    _getOrReturnCtx(v, z) {
        return z || {
            common: v.parent.common,
            data: v.data,
            parsedType: l9(v.data),
            schemaErrorMap: this._def.errorMap,
            path: v.path,
            parent: v.parent
        }
    }
    _processInputParams(v) {
        return {
            status: new s4,
            ctx: {
                common: v.parent.common,
                data: v.data,
                parsedType: l9(v.data),
                schemaErrorMap: this._def.errorMap,
                path: v.path,
                parent: v.parent
            }
        }
    }
    _parseSync(v) {
        let z = this._parse(v);
        if (DK(z)) throw Error("Synchronous parse encountered promise.");
        return z
    }
    _parseAsync(v) {
        let z = this._parse(v);
        return Promise.resolve(z)
    }
    parse(v, z) {
        let U = this.safeParse(v, z);
        if (U.success) return U.data;
        throw U.error
    }
    safeParse(v, z) {
        let U = {
                common: {
                    issues: [],
                    async: z?.async ?? !1,
                    contextualErrorMap: z?.errorMap
                },
                path: z?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: v,
                parsedType: l9(v)
            },
            V = this._parseSync({
                data: v,
                path: U.path,
                parent: U
            });
        return OR(U, V)
    }
    "~validate"(v) {
        let z = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: v,
            parsedType: l9(v)
        };
        if (!this["~standard"].async) try {
            let U = this._parseSync({
                data: v,
                path: [],
                parent: z
            });
            return o7(U) ? {
                value: U.value
            } : {
                issues: z.common.issues
            }
        } catch (U) {
            if (U?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = !0;
            z.common = {
                issues: [],
                async: !0
            }
        }
        return this._parseAsync({
            data: v,
            path: [],
            parent: z
        }).then((U) => o7(U) ? {
            value: U.value
        } : {
            issues: z.common.issues
        })
    }
    async parseAsync(v, z) {
        let U = await this.safeParseAsync(v, z);
        if (U.success) return U.data;
        throw U.error
    }
    async safeParseAsync(v, z) {
        let U = {
                common: {
                    issues: [],
                    contextualErrorMap: z?.errorMap,
                    async: !0
                },
                path: z?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: v,
                parsedType: l9(v)
            },
            V = this._parse({
                data: v,
                path: U.path,
                parent: U
            }),
            N = await (DK(V) ? V : Promise.resolve(V));
        return OR(U, N)
    }
    refine(v, z) {
        let U = (V) => {
            if (typeof z === "string" || typeof z > "u") return {
                message: z
            };
            else if (typeof z === "function") return z(V);
            else return z
        };
        return this._refinement((V, N) => {
            let K = v(V),
                x = () => N.addIssue({
                    code: r.custom,
                    ...U(V)
                });
            if (typeof Promise < "u" && K instanceof Promise) return K.then((j) => {
                if (!j) return x(), !1;
                else return !0
            });
            if (!K) return x(), !1;
            else return !0
        })
    }
    refinement(v, z) {
        return this._refinement((U, V) => {
            if (!v(U)) return V.addIssue(typeof z === "function" ? z(U, V) : z), !1;
            else return !0
        })
    }
    _refinement(v) {
        return new Y8({
            schema: this,
            typeName: t.ZodEffects,
            effect: {
                type: "refinement",
                refinement: v
            }
        })
    }
    superRefine(v) {
        return this._refinement(v)
    }
    constructor(v) {
        this.spa = this.safeParseAsync, this._def = v, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (z) => this["~validate"](z)
        }
    }
    optional() {
        return f8.create(this, this._def)
    }
    nullable() {
        return n9.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return C8.create(this)
    }
    promise() {
        return s7.create(this, this._def)
    }
    or(v) {
        return _z.create([this, v], this._def)
    }
    and(v) {
        return Cz.create(this, v, this._def)
    }
    transform(v) {
        return new Y8({
            ...r6(this._def),
            schema: this,
            typeName: t.ZodEffects,
            effect: {
                type: "transform",
                transform: v
            }
        })
    }
    default (v) {
        let z = typeof v === "function" ? v : () => v;
        return new uz({
            ...r6(this._def),
            innerType: this,
            defaultValue: z,
            typeName: t.ZodDefault
        })
    }
    brand() {
        return new RH({
            typeName: t.ZodBranded,
            type: this,
            ...r6(this._def)
        })
    } catch (v) {
        let z = typeof v === "function" ? v : () => v;
        return new yz({
            ...r6(this._def),
            innerType: this,
            catchValue: z,
            typeName: t.ZodCatch
        })
    }
    describe(v) {
        return new this.constructor({
            ...this._def,
            description: v
        })
    }
    pipe(v) {
        return YK.create(this, v)
    }
    readonly() {
        return kz.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
var Pr = /^c[^\s-]{8,}$/i,
    _r = /^[0-9a-z]+$/,
    Cr = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
    fr = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    Tr = /^[a-z0-9_-]{21}$/i,
    Yr = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
    ur = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    yr = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    kr = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    hq, mr = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    Xr = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    gr = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
    cr = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    ir = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    lr = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    MW = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
    hr = new RegExp(`^${MW}$`);

function bW(v) {
    let z = "[0-5]\\d";
    if (v.precision) z = `${z}\\.\\d{${v.precision}}`;
    else if (v.precision == null) z = `${z}(\\.\\d+)?`;
    let U = v.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${z})${U}`
}

function pr(v) {
    return new RegExp(`^${bW(v)}$`)
}

function nr(v) {
    let z = `${MW}T${bW(v)}`,
        U = [];
    if (U.push(v.local ? "Z?" : "Z"), v.offset) U.push("([+-]\\d{2}:?\\d{2})");
    return z = `${z}(${U.join("|")})`, new RegExp(`^${z}$`)
}

function Qr(v, z) {
    if ((z === "v4" || !z) && mr.test(v)) return !0;
    if ((z === "v6" || !z) && gr.test(v)) return !0;
    return !1
}

function dr(v, z) {
    if (!Yr.test(v)) return !1;
    try {
        let [U] = v.split(".");
        if (!U) return !1;
        let V = U.replace(/-/g, "+").replace(/_/g, "/").padEnd(U.length + (4 - U.length % 4) % 4, "="),
            N = JSON.parse(atob(V));
        if (typeof N !== "object" || N === null) return !1;
        if ("typ" in N && N?.typ !== "JWT") return !1;
        if (!N.alg) return !1;
        if (z && N.alg !== z) return !1;
        return !0
    } catch {
        return !1
    }
}

function or(v, z) {
    if ((z === "v4" || !z) && Xr.test(v)) return !0;
    if ((z === "v6" || !z) && cr.test(v)) return !0;
    return !1
}
class U9 extends N0 {
    _parse(v) {
        if (this._def.coerce) v.data = String(v.data);
        if (this._getType(v) !== w6.string) {
            let V = this._getOrReturnCtx(v);
            return O6(V, {
                code: r.invalid_type,
                expected: w6.string,
                received: V.parsedType
            }), c6
        }
        let z = new s4,
            U = void 0;
        for (let V of this._def.checks)
            if (V.kind === "min") {
                if (v.data.length < V.value) U = this._getOrReturnCtx(v, U), O6(U, {
                    code: r.too_small,
                    minimum: V.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: V.message
                }), z.dirty()
            } else if (V.kind === "max") {
            if (v.data.length > V.value) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.too_big,
                maximum: V.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "length") {
            let N = v.data.length > V.value,
                K = v.data.length < V.value;
            if (N || K) {
                if (U = this._getOrReturnCtx(v, U), N) O6(U, {
                    code: r.too_big,
                    maximum: V.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: V.message
                });
                else if (K) O6(U, {
                    code: r.too_small,
                    minimum: V.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: V.message
                });
                z.dirty()
            }
        } else if (V.kind === "email") {
            if (!yr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "email",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "emoji") {
            if (!hq) hq = new RegExp(kr, "u");
            if (!hq.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "emoji",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "uuid") {
            if (!fr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "uuid",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "nanoid") {
            if (!Tr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "nanoid",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "cuid") {
            if (!Pr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "cuid",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "cuid2") {
            if (!_r.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "cuid2",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "ulid") {
            if (!Cr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "ulid",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "url") try {
            new URL(v.data)
        } catch {
            U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "url",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "regex") {
            if (V.regex.lastIndex = 0, !V.regex.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "regex",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "trim") v.data = v.data.trim();
        else if (V.kind === "includes") {
            if (!v.data.includes(V.value, V.position)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: {
                    includes: V.value,
                    position: V.position
                },
                message: V.message
            }), z.dirty()
        } else if (V.kind === "toLowerCase") v.data = v.data.toLowerCase();
        else if (V.kind === "toUpperCase") v.data = v.data.toUpperCase();
        else if (V.kind === "startsWith") {
            if (!v.data.startsWith(V.value)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: {
                    startsWith: V.value
                },
                message: V.message
            }), z.dirty()
        } else if (V.kind === "endsWith") {
            if (!v.data.endsWith(V.value)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: {
                    endsWith: V.value
                },
                message: V.message
            }), z.dirty()
        } else if (V.kind === "datetime") {
            if (!nr(V).test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: "datetime",
                message: V.message
            }), z.dirty()
        } else if (V.kind === "date") {
            if (!hr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: "date",
                message: V.message
            }), z.dirty()
        } else if (V.kind === "time") {
            if (!pr(V).test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.invalid_string,
                validation: "time",
                message: V.message
            }), z.dirty()
        } else if (V.kind === "duration") {
            if (!ur.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "duration",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "ip") {
            if (!Qr(v.data, V.version)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "ip",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "jwt") {
            if (!dr(v.data, V.alg)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "jwt",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "cidr") {
            if (!or(v.data, V.version)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "cidr",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "base64") {
            if (!ir.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "base64",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else if (V.kind === "base64url") {
            if (!lr.test(v.data)) U = this._getOrReturnCtx(v, U), O6(U, {
                validation: "base64url",
                code: r.invalid_string,
                message: V.message
            }), z.dirty()
        } else A0.assertNever(V);
        return {
            status: z.value,
            value: v.data
        }
    }
    _regex(v, z, U) {
        return this.refinement((V) => v.test(V), {
            validation: z,
            code: r.invalid_string,
            ...I6.errToObj(U)
        })
    }
    _addCheck(v) {
        return new U9({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    email(v) {
        return this._addCheck({
            kind: "email",
            ...I6.errToObj(v)
        })
    }
    url(v) {
        return this._addCheck({
            kind: "url",
            ...I6.errToObj(v)
        })
    }
    emoji(v) {
        return this._addCheck({
            kind: "emoji",
            ...I6.errToObj(v)
        })
    }
    uuid(v) {
        return this._addCheck({
            kind: "uuid",
            ...I6.errToObj(v)
        })
    }
    nanoid(v) {
        return this._addCheck({
            kind: "nanoid",
            ...I6.errToObj(v)
        })
    }
    cuid(v) {
        return this._addCheck({
            kind: "cuid",
            ...I6.errToObj(v)
        })
    }
    cuid2(v) {
        return this._addCheck({
            kind: "cuid2",
            ...I6.errToObj(v)
        })
    }
    ulid(v) {
        return this._addCheck({
            kind: "ulid",
            ...I6.errToObj(v)
        })
    }
    base64(v) {
        return this._addCheck({
            kind: "base64",
            ...I6.errToObj(v)
        })
    }
    base64url(v) {
        return this._addCheck({
            kind: "base64url",
            ...I6.errToObj(v)
        })
    }
    jwt(v) {
        return this._addCheck({
            kind: "jwt",
            ...I6.errToObj(v)
        })
    }
    ip(v) {
        return this._addCheck({
            kind: "ip",
            ...I6.errToObj(v)
        })
    }
    cidr(v) {
        return this._addCheck({
            kind: "cidr",
            ...I6.errToObj(v)
        })
    }
    datetime(v) {
        if (typeof v === "string") return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: v
        });
        return this._addCheck({
            kind: "datetime",
            precision: typeof v?.precision > "u" ? null : v?.precision,
            offset: v?.offset ?? !1,
            local: v?.local ?? !1,
            ...I6.errToObj(v?.message)
        })
    }
    date(v) {
        return this._addCheck({
            kind: "date",
            message: v
        })
    }
    time(v) {
        if (typeof v === "string") return this._addCheck({
            kind: "time",
            precision: null,
            message: v
        });
        return this._addCheck({
            kind: "time",
            precision: typeof v?.precision > "u" ? null : v?.precision,
            ...I6.errToObj(v?.message)
        })
    }
    duration(v) {
        return this._addCheck({
            kind: "duration",
            ...I6.errToObj(v)
        })
    }
    regex(v, z) {
        return this._addCheck({
            kind: "regex",
            regex: v,
            ...I6.errToObj(z)
        })
    }
    includes(v, z) {
        return this._addCheck({
            kind: "includes",
            value: v,
            position: z?.position,
            ...I6.errToObj(z?.message)
        })
    }
    startsWith(v, z) {
        return this._addCheck({
            kind: "startsWith",
            value: v,
            ...I6.errToObj(z)
        })
    }
    endsWith(v, z) {
        return this._addCheck({
            kind: "endsWith",
            value: v,
            ...I6.errToObj(z)
        })
    }
    min(v, z) {
        return this._addCheck({
            kind: "min",
            value: v,
            ...I6.errToObj(z)
        })
    }
    max(v, z) {
        return this._addCheck({
            kind: "max",
            value: v,
            ...I6.errToObj(z)
        })
    }
    length(v, z) {
        return this._addCheck({
            kind: "length",
            value: v,
            ...I6.errToObj(z)
        })
    }
    nonempty(v) {
        return this.min(1, I6.errToObj(v))
    }
    trim() {
        return new U9({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new U9({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new U9({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find((v) => v.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find((v) => v.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find((v) => v.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find((v) => v.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find((v) => v.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find((v) => v.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find((v) => v.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find((v) => v.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find((v) => v.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find((v) => v.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find((v) => v.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find((v) => v.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find((v) => v.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find((v) => v.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find((v) => v.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find((v) => v.kind === "base64url")
    }
    get minLength() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxLength() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
}
U9.create = (v) => {
    return new U9({
        checks: [],
        typeName: t.ZodString,
        coerce: v?.coerce ?? !1,
        ...r6(v)
    })
};

function rr(v, z) {
    let U = (v.toString().split(".")[1] || "").length,
        V = (z.toString().split(".")[1] || "").length,
        N = U > V ? U : V,
        K = Number.parseInt(v.toFixed(N).replace(".", "")),
        x = Number.parseInt(z.toFixed(N).replace(".", ""));
    return K % x / 10 ** N
}
class r7 extends N0 {
    constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
    }
    _parse(v) {
        if (this._def.coerce) v.data = Number(v.data);
        if (this._getType(v) !== w6.number) {
            let V = this._getOrReturnCtx(v);
            return O6(V, {
                code: r.invalid_type,
                expected: w6.number,
                received: V.parsedType
            }), c6
        }
        let z = void 0,
            U = new s4;
        for (let V of this._def.checks)
            if (V.kind === "int") {
                if (!A0.isInteger(v.data)) z = this._getOrReturnCtx(v, z), O6(z, {
                    code: r.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: V.message
                }), U.dirty()
            } else if (V.kind === "min") {
            if (V.inclusive ? v.data < V.value : v.data <= V.value) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.too_small,
                minimum: V.value,
                type: "number",
                inclusive: V.inclusive,
                exact: !1,
                message: V.message
            }), U.dirty()
        } else if (V.kind === "max") {
            if (V.inclusive ? v.data > V.value : v.data >= V.value) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.too_big,
                maximum: V.value,
                type: "number",
                inclusive: V.inclusive,
                exact: !1,
                message: V.message
            }), U.dirty()
        } else if (V.kind === "multipleOf") {
            if (rr(v.data, V.value) !== 0) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.not_multiple_of,
                multipleOf: V.value,
                message: V.message
            }), U.dirty()
        } else if (V.kind === "finite") {
            if (!Number.isFinite(v.data)) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.not_finite,
                message: V.message
            }), U.dirty()
        } else A0.assertNever(V);
        return {
            status: U.value,
            value: v.data
        }
    }
    gte(v, z) {
        return this.setLimit("min", v, !0, I6.toString(z))
    }
    gt(v, z) {
        return this.setLimit("min", v, !1, I6.toString(z))
    }
    lte(v, z) {
        return this.setLimit("max", v, !0, I6.toString(z))
    }
    lt(v, z) {
        return this.setLimit("max", v, !1, I6.toString(z))
    }
    setLimit(v, z, U, V) {
        return new r7({
            ...this._def,
            checks: [...this._def.checks, {
                kind: v,
                value: z,
                inclusive: U,
                message: I6.toString(V)
            }]
        })
    }
    _addCheck(v) {
        return new r7({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    int(v) {
        return this._addCheck({
            kind: "int",
            message: I6.toString(v)
        })
    }
    positive(v) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: I6.toString(v)
        })
    }
    negative(v) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: I6.toString(v)
        })
    }
    nonpositive(v) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: I6.toString(v)
        })
    }
    nonnegative(v) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: I6.toString(v)
        })
    }
    multipleOf(v, z) {
        return this._addCheck({
            kind: "multipleOf",
            value: v,
            message: I6.toString(z)
        })
    }
    finite(v) {
        return this._addCheck({
            kind: "finite",
            message: I6.toString(v)
        })
    }
    safe(v) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: I6.toString(v)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: I6.toString(v)
        })
    }
    get minValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
    get isInt() {
        return !!this._def.checks.find((v) => v.kind === "int" || v.kind === "multipleOf" && A0.isInteger(v.value))
    }
    get isFinite() {
        let v = null,
            z = null;
        for (let U of this._def.checks)
            if (U.kind === "finite" || U.kind === "int" || U.kind === "multipleOf") return !0;
            else if (U.kind === "min") {
            if (z === null || U.value > z) z = U.value
        } else if (U.kind === "max") {
            if (v === null || U.value < v) v = U.value
        }
        return Number.isFinite(z) && Number.isFinite(v)
    }
}
r7.create = (v) => {
    return new r7({
        checks: [],
        typeName: t.ZodNumber,
        coerce: v?.coerce || !1,
        ...r6(v)
    })
};
class a7 extends N0 {
    constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte
    }
    _parse(v) {
        if (this._def.coerce) try {
            v.data = BigInt(v.data)
        } catch {
            return this._getInvalidInput(v)
        }
        if (this._getType(v) !== w6.bigint) return this._getInvalidInput(v);
        let z = void 0,
            U = new s4;
        for (let V of this._def.checks)
            if (V.kind === "min") {
                if (V.inclusive ? v.data < V.value : v.data <= V.value) z = this._getOrReturnCtx(v, z), O6(z, {
                    code: r.too_small,
                    type: "bigint",
                    minimum: V.value,
                    inclusive: V.inclusive,
                    message: V.message
                }), U.dirty()
            } else if (V.kind === "max") {
            if (V.inclusive ? v.data > V.value : v.data >= V.value) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.too_big,
                type: "bigint",
                maximum: V.value,
                inclusive: V.inclusive,
                message: V.message
            }), U.dirty()
        } else if (V.kind === "multipleOf") {
            if (v.data % V.value !== BigInt(0)) z = this._getOrReturnCtx(v, z), O6(z, {
                code: r.not_multiple_of,
                multipleOf: V.value,
                message: V.message
            }), U.dirty()
        } else A0.assertNever(V);
        return {
            status: U.value,
            value: v.data
        }
    }
    _getInvalidInput(v) {
        let z = this._getOrReturnCtx(v);
        return O6(z, {
            code: r.invalid_type,
            expected: w6.bigint,
            received: z.parsedType
        }), c6
    }
    gte(v, z) {
        return this.setLimit("min", v, !0, I6.toString(z))
    }
    gt(v, z) {
        return this.setLimit("min", v, !1, I6.toString(z))
    }
    lte(v, z) {
        return this.setLimit("max", v, !0, I6.toString(z))
    }
    lt(v, z) {
        return this.setLimit("max", v, !1, I6.toString(z))
    }
    setLimit(v, z, U, V) {
        return new a7({
            ...this._def,
            checks: [...this._def.checks, {
                kind: v,
                value: z,
                inclusive: U,
                message: I6.toString(V)
            }]
        })
    }
    _addCheck(v) {
        return new a7({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    positive(v) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: I6.toString(v)
        })
    }
    negative(v) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: I6.toString(v)
        })
    }
    nonpositive(v) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: I6.toString(v)
        })
    }
    nonnegative(v) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: I6.toString(v)
        })
    }
    multipleOf(v, z) {
        return this._addCheck({
            kind: "multipleOf",
            value: v,
            message: I6.toString(z)
        })
    }
    get minValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
}
a7.create = (v) => {
    return new a7({
        checks: [],
        typeName: t.ZodBigInt,
        coerce: v?.coerce ?? !1,
        ...r6(v)
    })
};
class AK extends N0 {
    _parse(v) {
        if (this._def.coerce) v.data = Boolean(v.data);
        if (this._getType(v) !== w6.boolean) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.boolean,
                received: z.parsedType
            }), c6
        }
        return O3(v.data)
    }
}
AK.create = (v) => {
    return new AK({
        typeName: t.ZodBoolean,
        coerce: v?.coerce || !1,
        ...r6(v)
    })
};
class Ez extends N0 {
    _parse(v) {
        if (this._def.coerce) v.data = new Date(v.data);
        if (this._getType(v) !== w6.date) {
            let V = this._getOrReturnCtx(v);
            return O6(V, {
                code: r.invalid_type,
                expected: w6.date,
                received: V.parsedType
            }), c6
        }
        if (Number.isNaN(v.data.getTime())) {
            let V = this._getOrReturnCtx(v);
            return O6(V, {
                code: r.invalid_date
            }), c6
        }
        let z = new s4,
            U = void 0;
        for (let V of this._def.checks)
            if (V.kind === "min") {
                if (v.data.getTime() < V.value) U = this._getOrReturnCtx(v, U), O6(U, {
                    code: r.too_small,
                    message: V.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: V.value,
                    type: "date"
                }), z.dirty()
            } else if (V.kind === "max") {
            if (v.data.getTime() > V.value) U = this._getOrReturnCtx(v, U), O6(U, {
                code: r.too_big,
                message: V.message,
                inclusive: !0,
                exact: !1,
                maximum: V.value,
                type: "date"
            }), z.dirty()
        } else A0.assertNever(V);
        return {
            status: z.value,
            value: new Date(v.data.getTime())
        }
    }
    _addCheck(v) {
        return new Ez({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    min(v, z) {
        return this._addCheck({
            kind: "min",
            value: v.getTime(),
            message: I6.toString(z)
        })
    }
    max(v, z) {
        return this._addCheck({
            kind: "max",
            value: v.getTime(),
            message: I6.toString(z)
        })
    }
    get minDate() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v != null ? new Date(v) : null
    }
    get maxDate() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v != null ? new Date(v) : null
    }
}
Ez.create = (v) => {
    return new Ez({
        checks: [],
        coerce: v?.coerce || !1,
        typeName: t.ZodDate,
        ...r6(v)
    })
};
class $K extends N0 {
    _parse(v) {
        if (this._getType(v) !== w6.symbol) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.symbol,
                received: z.parsedType
            }), c6
        }
        return O3(v.data)
    }
}
$K.create = (v) => {
    return new $K({
        typeName: t.ZodSymbol,
        ...r6(v)
    })
};
class Sz extends N0 {
    _parse(v) {
        if (this._getType(v) !== w6.undefined) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.undefined,
                received: z.parsedType
            }), c6
        }
        return O3(v.data)
    }
}
Sz.create = (v) => {
    return new Sz({
        typeName: t.ZodUndefined,
        ...r6(v)
    })
};
class Pz extends N0 {
    _parse(v) {
        if (this._getType(v) !== w6.null) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.null,
                received: z.parsedType
            }), c6
        }
        return O3(v.data)
    }
}
Pz.create = (v) => {
    return new Pz({
        typeName: t.ZodNull,
        ...r6(v)
    })
};
class wK extends N0 {
    constructor() {
        super(...arguments);
        this._any = !0
    }
    _parse(v) {
        return O3(v.data)
    }
}
wK.create = (v) => {
    return new wK({
        typeName: t.ZodAny,
        ...r6(v)
    })
};
class l5 extends N0 {
    constructor() {
        super(...arguments);
        this._unknown = !0
    }
    _parse(v) {
        return O3(v.data)
    }
}
l5.create = (v) => {
    return new l5({
        typeName: t.ZodUnknown,
        ...r6(v)
    })
};
class V9 extends N0 {
    _parse(v) {
        let z = this._getOrReturnCtx(v);
        return O6(z, {
            code: r.invalid_type,
            expected: w6.never,
            received: z.parsedType
        }), c6
    }
}
V9.create = (v) => {
    return new V9({
        typeName: t.ZodNever,
        ...r6(v)
    })
};
class ZK extends N0 {
    _parse(v) {
        if (this._getType(v) !== w6.undefined) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.void,
                received: z.parsedType
            }), c6
        }
        return O3(v.data)
    }
}
ZK.create = (v) => {
    return new ZK({
        typeName: t.ZodVoid,
        ...r6(v)
    })
};
class C8 extends N0 {
    _parse(v) {
        let {
            ctx: z,
            status: U
        } = this._processInputParams(v), V = this._def;
        if (z.parsedType !== w6.array) return O6(z, {
            code: r.invalid_type,
            expected: w6.array,
            received: z.parsedType
        }), c6;
        if (V.exactLength !== null) {
            let K = z.data.length > V.exactLength.value,
                x = z.data.length < V.exactLength.value;
            if (K || x) O6(z, {
                code: K ? r.too_big : r.too_small,
                minimum: x ? V.exactLength.value : void 0,
                maximum: K ? V.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: V.exactLength.message
            }), U.dirty()
        }
        if (V.minLength !== null) {
            if (z.data.length < V.minLength.value) O6(z, {
                code: r.too_small,
                minimum: V.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: V.minLength.message
            }), U.dirty()
        }
        if (V.maxLength !== null) {
            if (z.data.length > V.maxLength.value) O6(z, {
                code: r.too_big,
                maximum: V.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: V.maxLength.message
            }), U.dirty()
        }
        if (z.common.async) return Promise.all([...z.data].map((K, x) => {
            return V.type._parseAsync(new z8(z, K, z.path, x))
        })).then((K) => {
            return s4.mergeArray(U, K)
        });
        let N = [...z.data].map((K, x) => {
            return V.type._parseSync(new z8(z, K, z.path, x))
        });
        return s4.mergeArray(U, N)
    }
    get element() {
        return this._def.type
    }
    min(v, z) {
        return new C8({
            ...this._def,
            minLength: {
                value: v,
                message: I6.toString(z)
            }
        })
    }
    max(v, z) {
        return new C8({
            ...this._def,
            maxLength: {
                value: v,
                message: I6.toString(z)
            }
        })
    }
    length(v, z) {
        return new C8({
            ...this._def,
            exactLength: {
                value: v,
                message: I6.toString(z)
            }
        })
    }
    nonempty(v) {
        return this.min(1, v)
    }
}
C8.create = (v, z) => {
    return new C8({
        type: v,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: t.ZodArray,
        ...r6(z)
    })
};

function p7(v) {
    if (v instanceof s0) {
        let z = {};
        for (let U in v.shape) {
            let V = v.shape[U];
            z[U] = f8.create(p7(V))
        }
        return new s0({
            ...v._def,
            shape: () => z
        })
    } else if (v instanceof C8) return new C8({
        ...v._def,
        type: p7(v.element)
    });
    else if (v instanceof f8) return f8.create(p7(v.unwrap()));
    else if (v instanceof n9) return n9.create(p7(v.unwrap()));
    else if (v instanceof N9) return N9.create(v.items.map((z) => p7(z)));
    else return v
}
class s0 extends N0 {
    constructor() {
        super(...arguments);
        this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        let v = this._def.shape(),
            z = A0.objectKeys(v);
        return this._cached = {
            shape: v,
            keys: z
        }, this._cached
    }
    _parse(v) {
        if (this._getType(v) !== w6.object) {
            let j = this._getOrReturnCtx(v);
            return O6(j, {
                code: r.invalid_type,
                expected: w6.object,
                received: j.parsedType
            }), c6
        }
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v), {
            shape: V,
            keys: N
        } = this._getCached(), K = [];
        if (!(this._def.catchall instanceof V9 && this._def.unknownKeys === "strip")) {
            for (let j in U.data)
                if (!N.includes(j)) K.push(j)
        }
        let x = [];
        for (let j of N) {
            let B = V[j],
                O = U.data[j];
            x.push({
                key: {
                    status: "valid",
                    value: j
                },
                value: B._parse(new z8(U, O, U.path, j)),
                alwaysSet: j in U.data
            })
        }
        if (this._def.catchall instanceof V9) {
            let j = this._def.unknownKeys;
            if (j === "passthrough")
                for (let B of K) x.push({
                    key: {
                        status: "valid",
                        value: B
                    },
                    value: {
                        status: "valid",
                        value: U.data[B]
                    }
                });
            else if (j === "strict") {
                if (K.length > 0) O6(U, {
                    code: r.unrecognized_keys,
                    keys: K
                }), z.dirty()
            } else if (j === "strip");
            else throw Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            let j = this._def.catchall;
            for (let B of K) {
                let O = U.data[B];
                x.push({
                    key: {
                        status: "valid",
                        value: B
                    },
                    value: j._parse(new z8(U, O, U.path, B)),
                    alwaysSet: B in U.data
                })
            }
        }
        if (U.common.async) return Promise.resolve().then(async () => {
            let j = [];
            for (let B of x) {
                let O = await B.key,
                    J = await B.value;
                j.push({
                    key: O,
                    value: J,
                    alwaysSet: B.alwaysSet
                })
            }
            return j
        }).then((j) => {
            return s4.mergeObjectSync(z, j)
        });
        else return s4.mergeObjectSync(z, x)
    }
    get shape() {
        return this._def.shape()
    }
    strict(v) {
        return I6.errToObj, new s0({
            ...this._def,
            unknownKeys: "strict",
            ...v !== void 0 ? {
                errorMap: (z, U) => {
                    let V = this._def.errorMap?.(z, U).message ?? U.defaultError;
                    if (z.code === "unrecognized_keys") return {
                        message: I6.errToObj(v).message ?? V
                    };
                    return {
                        message: V
                    }
                }
            } : {}
        })
    }
    strip() {
        return new s0({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new s0({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(v) {
        return new s0({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...v
            })
        })
    }
    merge(v) {
        return new s0({
            unknownKeys: v._def.unknownKeys,
            catchall: v._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...v._def.shape()
            }),
            typeName: t.ZodObject
        })
    }
    setKey(v, z) {
        return this.augment({
            [v]: z
        })
    }
    catchall(v) {
        return new s0({
            ...this._def,
            catchall: v
        })
    }
    pick(v) {
        let z = {};
        for (let U of A0.objectKeys(v))
            if (v[U] && this.shape[U]) z[U] = this.shape[U];
        return new s0({
            ...this._def,
            shape: () => z
        })
    }
    omit(v) {
        let z = {};
        for (let U of A0.objectKeys(this.shape))
            if (!v[U]) z[U] = this.shape[U];
        return new s0({
            ...this._def,
            shape: () => z
        })
    }
    deepPartial() {
        return p7(this)
    }
    partial(v) {
        let z = {};
        for (let U of A0.objectKeys(this.shape)) {
            let V = this.shape[U];
            if (v && !v[U]) z[U] = V;
            else z[U] = V.optional()
        }
        return new s0({
            ...this._def,
            shape: () => z
        })
    }
    required(v) {
        let z = {};
        for (let U of A0.objectKeys(this.shape))
            if (v && !v[U]) z[U] = this.shape[U];
            else {
                let V = this.shape[U];
                while (V instanceof f8) V = V._def.innerType;
                z[U] = V
            } return new s0({
            ...this._def,
            shape: () => z
        })
    }
    keyof() {
        return RW(A0.objectKeys(this.shape))
    }
}
s0.create = (v, z) => {
    return new s0({
        shape: () => v,
        unknownKeys: "strip",
        catchall: V9.create(),
        typeName: t.ZodObject,
        ...r6(z)
    })
};
s0.strictCreate = (v, z) => {
    return new s0({
        shape: () => v,
        unknownKeys: "strict",
        catchall: V9.create(),
        typeName: t.ZodObject,
        ...r6(z)
    })
};
s0.lazycreate = (v, z) => {
    return new s0({
        shape: v,
        unknownKeys: "strip",
        catchall: V9.create(),
        typeName: t.ZodObject,
        ...r6(z)
    })
};
class _z extends N0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = this._def.options;

        function V(N) {
            for (let x of N)
                if (x.result.status === "valid") return x.result;
            for (let x of N)
                if (x.result.status === "dirty") return z.common.issues.push(...x.ctx.common.issues), x.result;
            let K = N.map((x) => new c3(x.ctx.common.issues));
            return O6(z, {
                code: r.invalid_union,
                unionErrors: K
            }), c6
        }
        if (z.common.async) return Promise.all(U.map(async (N) => {
            let K = {
                ...z,
                common: {
                    ...z.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await N._parseAsync({
                    data: z.data,
                    path: z.path,
                    parent: K
                }),
                ctx: K
            }
        })).then(V);
        else {
            let N = void 0,
                K = [];
            for (let j of U) {
                let B = {
                        ...z,
                        common: {
                            ...z.common,
                            issues: []
                        },
                        parent: null
                    },
                    O = j._parseSync({
                        data: z.data,
                        path: z.path,
                        parent: B
                    });
                if (O.status === "valid") return O;
                else if (O.status === "dirty" && !N) N = {
                    result: O,
                    ctx: B
                };
                if (B.common.issues.length) K.push(B.common.issues)
            }
            if (N) return z.common.issues.push(...N.ctx.common.issues), N.result;
            let x = K.map((j) => new c3(j));
            return O6(z, {
                code: r.invalid_union,
                unionErrors: x
            }), c6
        }
    }
    get options() {
        return this._def.options
    }
}
_z.create = (v, z) => {
    return new _z({
        options: v,
        typeName: t.ZodUnion,
        ...r6(z)
    })
};
var v9 = (v) => {
    if (v instanceof fz) return v9(v.schema);
    else if (v instanceof Y8) return v9(v.innerType());
    else if (v instanceof Tz) return [v.value];
    else if (v instanceof h5) return v.options;
    else if (v instanceof Yz) return A0.objectValues(v.enum);
    else if (v instanceof uz) return v9(v._def.innerType);
    else if (v instanceof Sz) return [void 0];
    else if (v instanceof Pz) return [null];
    else if (v instanceof f8) return [void 0, ...v9(v.unwrap())];
    else if (v instanceof n9) return [null, ...v9(v.unwrap())];
    else if (v instanceof RH) return v9(v.unwrap());
    else if (v instanceof kz) return v9(v.unwrap());
    else if (v instanceof yz) return v9(v._def.innerType);
    else return []
};
class bH extends N0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== w6.object) return O6(z, {
            code: r.invalid_type,
            expected: w6.object,
            received: z.parsedType
        }), c6;
        let U = this.discriminator,
            V = z.data[U],
            N = this.optionsMap.get(V);
        if (!N) return O6(z, {
            code: r.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [U]
        }), c6;
        if (z.common.async) return N._parseAsync({
            data: z.data,
            path: z.path,
            parent: z
        });
        else return N._parseSync({
            data: z.data,
            path: z.path,
            parent: z
        })
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(v, z, U) {
        let V = new Map;
        for (let N of z) {
            let K = v9(N.shape[v]);
            if (!K.length) throw Error(`A discriminator value for key \`${v}\` could not be extracted from all schema options`);
            for (let x of K) {
                if (V.has(x)) throw Error(`Discriminator property ${String(v)} has duplicate value ${String(x)}`);
                V.set(x, N)
            }
        }
        return new bH({
            typeName: t.ZodDiscriminatedUnion,
            discriminator: v,
            options: z,
            optionsMap: V,
            ...r6(U)
        })
    }
}

function UH(v, z) {
    let U = l9(v),
        V = l9(z);
    if (v === z) return {
        valid: !0,
        data: v
    };
    else if (U === w6.object && V === w6.object) {
        let N = A0.objectKeys(z),
            K = A0.objectKeys(v).filter((j) => N.indexOf(j) !== -1),
            x = {
                ...v,
                ...z
            };
        for (let j of K) {
            let B = UH(v[j], z[j]);
            if (!B.valid) return {
                valid: !1
            };
            x[j] = B.data
        }
        return {
            valid: !0,
            data: x
        }
    } else if (U === w6.array && V === w6.array) {
        if (v.length !== z.length) return {
            valid: !1
        };
        let N = [];
        for (let K = 0; K < v.length; K++) {
            let x = v[K],
                j = z[K],
                B = UH(x, j);
            if (!B.valid) return {
                valid: !1
            };
            N.push(B.data)
        }
        return {
            valid: !0,
            data: N
        }
    } else if (U === w6.date && V === w6.date && +v === +z) return {
        valid: !0,
        data: v
    };
    else return {
        valid: !1
    }
}
class Cz extends N0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v), V = (N, K) => {
            if (jR(N) || jR(K)) return c6;
            let x = UH(N.value, K.value);
            if (!x.valid) return O6(U, {
                code: r.invalid_intersection_types
            }), c6;
            if (BR(N) || BR(K)) z.dirty();
            return {
                status: z.value,
                value: x.data
            }
        };
        if (U.common.async) return Promise.all([this._def.left._parseAsync({
            data: U.data,
            path: U.path,
            parent: U
        }), this._def.right._parseAsync({
            data: U.data,
            path: U.path,
            parent: U
        })]).then(([N, K]) => V(N, K));
        else return V(this._def.left._parseSync({
            data: U.data,
            path: U.path,
            parent: U
        }), this._def.right._parseSync({
            data: U.data,
            path: U.path,
            parent: U
        }))
    }
}
Cz.create = (v, z, U) => {
    return new Cz({
        left: v,
        right: z,
        typeName: t.ZodIntersection,
        ...r6(U)
    })
};
class N9 extends N0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== w6.array) return O6(U, {
            code: r.invalid_type,
            expected: w6.array,
            received: U.parsedType
        }), c6;
        if (U.data.length < this._def.items.length) return O6(U, {
            code: r.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), c6;
        if (!this._def.rest && U.data.length > this._def.items.length) O6(U, {
            code: r.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), z.dirty();
        let V = [...U.data].map((N, K) => {
            let x = this._def.items[K] || this._def.rest;
            if (!x) return null;
            return x._parse(new z8(U, N, U.path, K))
        }).filter((N) => !!N);
        if (U.common.async) return Promise.all(V).then((N) => {
            return s4.mergeArray(z, N)
        });
        else return s4.mergeArray(z, V)
    }
    get items() {
        return this._def.items
    }
    rest(v) {
        return new N9({
            ...this._def,
            rest: v
        })
    }
}
N9.create = (v, z) => {
    if (!Array.isArray(v)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new N9({
        items: v,
        typeName: t.ZodTuple,
        rest: null,
        ...r6(z)
    })
};
class LK extends N0 {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== w6.object) return O6(U, {
            code: r.invalid_type,
            expected: w6.object,
            received: U.parsedType
        }), c6;
        let V = [],
            N = this._def.keyType,
            K = this._def.valueType;
        for (let x in U.data) V.push({
            key: N._parse(new z8(U, x, U.path, x)),
            value: K._parse(new z8(U, U.data[x], U.path, x)),
            alwaysSet: x in U.data
        });
        if (U.common.async) return s4.mergeObjectAsync(z, V);
        else return s4.mergeObjectSync(z, V)
    }
    get element() {
        return this._def.valueType
    }
    static create(v, z, U) {
        if (z instanceof N0) return new LK({
            keyType: v,
            valueType: z,
            typeName: t.ZodRecord,
            ...r6(U)
        });
        return new LK({
            keyType: U9.create(),
            valueType: v,
            typeName: t.ZodRecord,
            ...r6(z)
        })
    }
}
class FK extends N0 {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== w6.map) return O6(U, {
            code: r.invalid_type,
            expected: w6.map,
            received: U.parsedType
        }), c6;
        let V = this._def.keyType,
            N = this._def.valueType,
            K = [...U.data.entries()].map(([x, j], B) => {
                return {
                    key: V._parse(new z8(U, x, U.path, [B, "key"])),
                    value: N._parse(new z8(U, j, U.path, [B, "value"]))
                }
            });
        if (U.common.async) {
            let x = new Map;
            return Promise.resolve().then(async () => {
                for (let j of K) {
                    let B = await j.key,
                        O = await j.value;
                    if (B.status === "aborted" || O.status === "aborted") return c6;
                    if (B.status === "dirty" || O.status === "dirty") z.dirty();
                    x.set(B.value, O.value)
                }
                return {
                    status: z.value,
                    value: x
                }
            })
        } else {
            let x = new Map;
            for (let j of K) {
                let {
                    key: B,
                    value: O
                } = j;
                if (B.status === "aborted" || O.status === "aborted") return c6;
                if (B.status === "dirty" || O.status === "dirty") z.dirty();
                x.set(B.value, O.value)
            }
            return {
                status: z.value,
                value: x
            }
        }
    }
}
FK.create = (v, z, U) => {
    return new FK({
        valueType: z,
        keyType: v,
        typeName: t.ZodMap,
        ...r6(U)
    })
};
class t7 extends N0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== w6.set) return O6(U, {
            code: r.invalid_type,
            expected: w6.set,
            received: U.parsedType
        }), c6;
        let V = this._def;
        if (V.minSize !== null) {
            if (U.data.size < V.minSize.value) O6(U, {
                code: r.too_small,
                minimum: V.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: V.minSize.message
            }), z.dirty()
        }
        if (V.maxSize !== null) {
            if (U.data.size > V.maxSize.value) O6(U, {
                code: r.too_big,
                maximum: V.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: V.maxSize.message
            }), z.dirty()
        }
        let N = this._def.valueType;

        function K(j) {
            let B = new Set;
            for (let O of j) {
                if (O.status === "aborted") return c6;
                if (O.status === "dirty") z.dirty();
                B.add(O.value)
            }
            return {
                status: z.value,
                value: B
            }
        }
        let x = [...U.data.values()].map((j, B) => N._parse(new z8(U, j, U.path, B)));
        if (U.common.async) return Promise.all(x).then((j) => K(j));
        else return K(x)
    }
    min(v, z) {
        return new t7({
            ...this._def,
            minSize: {
                value: v,
                message: I6.toString(z)
            }
        })
    }
    max(v, z) {
        return new t7({
            ...this._def,
            maxSize: {
                value: v,
                message: I6.toString(z)
            }
        })
    }
    size(v, z) {
        return this.min(v, z).max(v, z)
    }
    nonempty(v) {
        return this.min(1, v)
    }
}
t7.create = (v, z) => {
    return new t7({
        valueType: v,
        minSize: null,
        maxSize: null,
        typeName: t.ZodSet,
        ...r6(z)
    })
};
class Iz extends N0 {
    constructor() {
        super(...arguments);
        this.validate = this.implement
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== w6.function) return O6(z, {
            code: r.invalid_type,
            expected: w6.function,
            received: z.parsedType
        }), c6;

        function U(x, j) {
            return zH({
                data: x,
                path: z.path,
                errorMaps: [z.common.contextualErrorMap, z.schemaErrorMap, vH(), Wz].filter((B) => !!B),
                issueData: {
                    code: r.invalid_arguments,
                    argumentsError: j
                }
            })
        }

        function V(x, j) {
            return zH({
                data: x,
                path: z.path,
                errorMaps: [z.common.contextualErrorMap, z.schemaErrorMap, vH(), Wz].filter((B) => !!B),
                issueData: {
                    code: r.invalid_return_type,
                    returnTypeError: j
                }
            })
        }
        let N = {
                errorMap: z.common.contextualErrorMap
            },
            K = z.data;
        if (this._def.returns instanceof s7) {
            let x = this;
            return O3(async function(...j) {
                let B = new c3([]),
                    O = await x._def.args.parseAsync(j, N).catch((q) => {
                        throw B.addIssue(U(j, q)), B
                    }),
                    J = await Reflect.apply(K, this, O);
                return await x._def.returns._def.type.parseAsync(J, N).catch((q) => {
                    throw B.addIssue(V(J, q)), B
                })
            })
        } else {
            let x = this;
            return O3(function(...j) {
                let B = x._def.args.safeParse(j, N);
                if (!B.success) throw new c3([U(j, B.error)]);
                let O = Reflect.apply(K, this, B.data),
                    J = x._def.returns.safeParse(O, N);
                if (!J.success) throw new c3([V(O, J.error)]);
                return J.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...v) {
        return new Iz({
            ...this._def,
            args: N9.create(v).rest(l5.create())
        })
    }
    returns(v) {
        return new Iz({
            ...this._def,
            returns: v
        })
    }
    implement(v) {
        return this.parse(v)
    }
    strictImplement(v) {
        return this.parse(v)
    }
    static create(v, z, U) {
        return new Iz({
            args: v ? v : N9.create([]).rest(l5.create()),
            returns: z || l5.create(),
            typeName: t.ZodFunction,
            ...r6(U)
        })
    }
}
class fz extends N0 {
    get schema() {
        return this._def.getter()
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        return this._def.getter()._parse({
            data: z.data,
            path: z.path,
            parent: z
        })
    }
}
fz.create = (v, z) => {
    return new fz({
        getter: v,
        typeName: t.ZodLazy,
        ...r6(z)
    })
};
class Tz extends N0 {
    _parse(v) {
        if (v.data !== this._def.value) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                received: z.data,
                code: r.invalid_literal,
                expected: this._def.value
            }), c6
        }
        return {
            status: "valid",
            value: v.data
        }
    }
    get value() {
        return this._def.value
    }
}
Tz.create = (v, z) => {
    return new Tz({
        value: v,
        typeName: t.ZodLiteral,
        ...r6(z)
    })
};

function RW(v, z) {
    return new h5({
        values: v,
        typeName: t.ZodEnum,
        ...r6(z)
    })
}
class h5 extends N0 {
    _parse(v) {
        if (typeof v.data !== "string") {
            let z = this._getOrReturnCtx(v),
                U = this._def.values;
            return O6(z, {
                expected: A0.joinValues(U),
                received: z.parsedType,
                code: r.invalid_type
            }), c6
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(v.data)) {
            let z = this._getOrReturnCtx(v),
                U = this._def.values;
            return O6(z, {
                received: z.data,
                code: r.invalid_enum_value,
                options: U
            }), c6
        }
        return O3(v.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    get Values() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    get Enum() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    extract(v, z = this._def) {
        return h5.create(v, {
            ...this._def,
            ...z
        })
    }
    exclude(v, z = this._def) {
        return h5.create(this.options.filter((U) => !v.includes(U)), {
            ...this._def,
            ...z
        })
    }
}
h5.create = RW;
class Yz extends N0 {
    _parse(v) {
        let z = A0.getValidEnumValues(this._def.values),
            U = this._getOrReturnCtx(v);
        if (U.parsedType !== w6.string && U.parsedType !== w6.number) {
            let V = A0.objectValues(z);
            return O6(U, {
                expected: A0.joinValues(V),
                received: U.parsedType,
                code: r.invalid_type
            }), c6
        }
        if (!this._cache) this._cache = new Set(A0.getValidEnumValues(this._def.values));
        if (!this._cache.has(v.data)) {
            let V = A0.objectValues(z);
            return O6(U, {
                received: U.data,
                code: r.invalid_enum_value,
                options: V
            }), c6
        }
        return O3(v.data)
    }
    get enum() {
        return this._def.values
    }
}
Yz.create = (v, z) => {
    return new Yz({
        values: v,
        typeName: t.ZodNativeEnum,
        ...r6(z)
    })
};
class s7 extends N0 {
    unwrap() {
        return this._def.type
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== w6.promise && z.common.async === !1) return O6(z, {
            code: r.invalid_type,
            expected: w6.promise,
            received: z.parsedType
        }), c6;
        let U = z.parsedType === w6.promise ? z.data : Promise.resolve(z.data);
        return O3(U.then((V) => {
            return this._def.type.parseAsync(V, {
                path: z.path,
                errorMap: z.common.contextualErrorMap
            })
        }))
    }
}
s7.create = (v, z) => {
    return new s7({
        type: v,
        typeName: t.ZodPromise,
        ...r6(z)
    })
};
class Y8 extends N0 {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === t.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v), V = this._def.effect || null, N = {
            addIssue: (K) => {
                if (O6(U, K), K.fatal) z.abort();
                else z.dirty()
            },
            get path() {
                return U.path
            }
        };
        if (N.addIssue = N.addIssue.bind(N), V.type === "preprocess") {
            let K = V.transform(U.data, N);
            if (U.common.async) return Promise.resolve(K).then(async (x) => {
                if (z.value === "aborted") return c6;
                let j = await this._def.schema._parseAsync({
                    data: x,
                    path: U.path,
                    parent: U
                });
                if (j.status === "aborted") return c6;
                if (j.status === "dirty") return Lz(j.value);
                if (z.value === "dirty") return Lz(j.value);
                return j
            });
            else {
                if (z.value === "aborted") return c6;
                let x = this._def.schema._parseSync({
                    data: K,
                    path: U.path,
                    parent: U
                });
                if (x.status === "aborted") return c6;
                if (x.status === "dirty") return Lz(x.value);
                if (z.value === "dirty") return Lz(x.value);
                return x
            }
        }
        if (V.type === "refinement") {
            let K = (x) => {
                let j = V.refinement(x, N);
                if (U.common.async) return Promise.resolve(j);
                if (j instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return x
            };
            if (U.common.async === !1) {
                let x = this._def.schema._parseSync({
                    data: U.data,
                    path: U.path,
                    parent: U
                });
                if (x.status === "aborted") return c6;
                if (x.status === "dirty") z.dirty();
                return K(x.value), {
                    status: z.value,
                    value: x.value
                }
            } else return this._def.schema._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            }).then((x) => {
                if (x.status === "aborted") return c6;
                if (x.status === "dirty") z.dirty();
                return K(x.value).then(() => {
                    return {
                        status: z.value,
                        value: x.value
                    }
                })
            })
        }
        if (V.type === "transform")
            if (U.common.async === !1) {
                let K = this._def.schema._parseSync({
                    data: U.data,
                    path: U.path,
                    parent: U
                });
                if (!o7(K)) return c6;
                let x = V.transform(K.value, N);
                if (x instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: z.value,
                    value: x
                }
            } else return this._def.schema._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            }).then((K) => {
                if (!o7(K)) return c6;
                return Promise.resolve(V.transform(K.value, N)).then((x) => ({
                    status: z.value,
                    value: x
                }))
            });
        A0.assertNever(V)
    }
}
Y8.create = (v, z, U) => {
    return new Y8({
        schema: v,
        typeName: t.ZodEffects,
        effect: z,
        ...r6(U)
    })
};
Y8.createWithPreprocess = (v, z, U) => {
    return new Y8({
        schema: z,
        effect: {
            type: "preprocess",
            transform: v
        },
        typeName: t.ZodEffects,
        ...r6(U)
    })
};
class f8 extends N0 {
    _parse(v) {
        if (this._getType(v) === w6.undefined) return O3(void 0);
        return this._def.innerType._parse(v)
    }
    unwrap() {
        return this._def.innerType
    }
}
f8.create = (v, z) => {
    return new f8({
        innerType: v,
        typeName: t.ZodOptional,
        ...r6(z)
    })
};
class n9 extends N0 {
    _parse(v) {
        if (this._getType(v) === w6.null) return O3(null);
        return this._def.innerType._parse(v)
    }
    unwrap() {
        return this._def.innerType
    }
}
n9.create = (v, z) => {
    return new n9({
        innerType: v,
        typeName: t.ZodNullable,
        ...r6(z)
    })
};
class uz extends N0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = z.data;
        if (z.parsedType === w6.undefined) U = this._def.defaultValue();
        return this._def.innerType._parse({
            data: U,
            path: z.path,
            parent: z
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
uz.create = (v, z) => {
    return new uz({
        innerType: v,
        typeName: t.ZodDefault,
        defaultValue: typeof z.default === "function" ? z.default : () => z.default,
        ...r6(z)
    })
};
class yz extends N0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = {
            ...z,
            common: {
                ...z.common,
                issues: []
            }
        }, V = this._def.innerType._parse({
            data: U.data,
            path: U.path,
            parent: {
                ...U
            }
        });
        if (DK(V)) return V.then((N) => {
            return {
                status: "valid",
                value: N.status === "valid" ? N.value : this._def.catchValue({
                    get error() {
                        return new c3(U.common.issues)
                    },
                    input: U.data
                })
            }
        });
        else return {
            status: "valid",
            value: V.status === "valid" ? V.value : this._def.catchValue({
                get error() {
                    return new c3(U.common.issues)
                },
                input: U.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
yz.create = (v, z) => {
    return new yz({
        innerType: v,
        typeName: t.ZodCatch,
        catchValue: typeof z.catch === "function" ? z.catch : () => z.catch,
        ...r6(z)
    })
};
class GK extends N0 {
    _parse(v) {
        if (this._getType(v) !== w6.nan) {
            let z = this._getOrReturnCtx(v);
            return O6(z, {
                code: r.invalid_type,
                expected: w6.nan,
                received: z.parsedType
            }), c6
        }
        return {
            status: "valid",
            value: v.data
        }
    }
}
GK.create = (v) => {
    return new GK({
        typeName: t.ZodNaN,
        ...r6(v)
    })
};
var hw6 = Symbol("zod_brand");
class RH extends N0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = z.data;
        return this._def.type._parse({
            data: U,
            path: z.path,
            parent: z
        })
    }
    unwrap() {
        return this._def.type
    }
}
class YK extends N0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.common.async) return (async () => {
            let V = await this._def.in._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            });
            if (V.status === "aborted") return c6;
            if (V.status === "dirty") return z.dirty(), Lz(V.value);
            else return this._def.out._parseAsync({
                data: V.value,
                path: U.path,
                parent: U
            })
        })();
        else {
            let V = this._def.in._parseSync({
                data: U.data,
                path: U.path,
                parent: U
            });
            if (V.status === "aborted") return c6;
            if (V.status === "dirty") return z.dirty(), {
                status: "dirty",
                value: V.value
            };
            else return this._def.out._parseSync({
                data: V.value,
                path: U.path,
                parent: U
            })
        }
    }
    static create(v, z) {
        return new YK({
            in: v,
            out: z,
            typeName: t.ZodPipeline
        })
    }
}
class kz extends N0 {
    _parse(v) {
        let z = this._def.innerType._parse(v),
            U = (V) => {
                if (o7(V)) V.value = Object.freeze(V.value);
                return V
            };
        return DK(z) ? z.then((V) => U(V)) : U(z)
    }
    unwrap() {
        return this._def.innerType
    }
}
kz.create = (v, z) => {
    return new kz({
        innerType: v,
        typeName: t.ZodReadonly,
        ...r6(z)
    })
};
var pw6 = {
        object: s0.lazycreate
    },
    t;
(function(v) {
    v.ZodString = "ZodString", v.ZodNumber = "ZodNumber", v.ZodNaN = "ZodNaN", v.ZodBigInt = "ZodBigInt", v.ZodBoolean = "ZodBoolean", v.ZodDate = "ZodDate", v.ZodSymbol = "ZodSymbol", v.ZodUndefined = "ZodUndefined", v.ZodNull = "ZodNull", v.ZodAny = "ZodAny", v.ZodUnknown = "ZodUnknown", v.ZodNever = "ZodNever", v.ZodVoid = "ZodVoid", v.ZodArray = "ZodArray", v.ZodObject = "ZodObject", v.ZodUnion = "ZodUnion", v.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", v.ZodIntersection = "ZodIntersection", v.ZodTuple = "ZodTuple", v.ZodRecord = "ZodRecord", v.ZodMap = "ZodMap", v.ZodSet = "ZodSet", v.ZodFunction = "ZodFunction", v.ZodLazy = "ZodLazy", v.ZodLiteral = "ZodLiteral", v.ZodEnum = "ZodEnum", v.ZodEffects = "ZodEffects", v.ZodNativeEnum = "ZodNativeEnum", v.ZodOptional = "ZodOptional", v.ZodNullable = "ZodNullable", v.ZodDefault = "ZodDefault", v.ZodCatch = "ZodCatch", v.ZodPromise = "ZodPromise", v.ZodBranded = "ZodBranded", v.ZodPipeline = "ZodPipeline", v.ZodReadonly = "ZodReadonly"
})(t || (t = {}));
var nw6 = U9.create,
    Qw6 = r7.create,
    dw6 = GK.create,
    ow6 = a7.create,
    rw6 = AK.create,
    aw6 = Ez.create,
    tw6 = $K.create,
    sw6 = Sz.create,
    ew6 = Pz.create,
    vZ6 = wK.create,
    zZ6 = l5.create,
    UZ6 = V9.create,
    VZ6 = ZK.create,
    NZ6 = C8.create,
    ar = s0.create,
    KZ6 = s0.strictCreate,
    xZ6 = _z.create,
    jZ6 = bH.create,
    BZ6 = Cz.create,
    OZ6 = N9.create,
    JZ6 = LK.create,
    qZ6 = FK.create,
    HZ6 = t7.create,
    DZ6 = Iz.create,
    AZ6 = fz.create,
    $Z6 = Tz.create,
    wZ6 = h5.create,
    ZZ6 = Yz.create,
    LZ6 = s7.create,
    FZ6 = Y8.create,
    GZ6 = f8.create,
    IZ6 = n9.create,
    MZ6 = Y8.createWithPreprocess,
    bZ6 = YK.create,
    RZ6 = Object.freeze({
        status: "aborted"
    });

function l(v, z, U) {
    function V(j, B) {
        var O;
        Object.defineProperty(j, "_zod", {
            value: j._zod ?? {},
            enumerable: !1
        }), (O = j._zod).traits ?? (O.traits = new Set), j._zod.traits.add(v), z(j, B);
        for (let J in x.prototype)
            if (!(J in j)) Object.defineProperty(j, J, {
                value: x.prototype[J].bind(j)
            });
        j._zod.constr = x, j._zod.def = B
    }
    let N = U?.Parent ?? Object;
    class K extends N {}
    Object.defineProperty(K, "name", {
        value: v
    });

    function x(j) {
        var B;
        let O = U?.Parent ? new K : this;
        V(O, j), (B = O._zod).deferred ?? (B.deferred = []);
        for (let J of O._zod.deferred) J();
        return O
    }
    return Object.defineProperty(x, "init", {
        value: V
    }), Object.defineProperty(x, Symbol.hasInstance, {
        value: (j) => {
            if (U?.Parent && j instanceof U.Parent) return !0;
            return j?._zod?.traits?.has(v)
        }
    }), Object.defineProperty(x, "name", {
        value: v
    }), x
}
var WZ6 = Symbol("zod_brand");
class e7 extends Error {
    constructor() {
        super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")
    }
}
var VH = {};

function K9(v) {
    if (v) Object.assign(VH, v);
    return VH
}
var E0 = {};
iR(E0, {
    unwrapMessage: () => Fz,
    stringifyPrimitive: () => PH,
    required: () => $a,
    randomString: () => Na,
    propertyKeyTypes: () => PW,
    promiseAllObject: () => Va,
    primitiveTypes: () => ja,
    prefixIssues: () => p9,
    pick: () => Ja,
    partial: () => Aa,
    optionalKeys: () => _W,
    omit: () => qa,
    numKeys: () => Ka,
    nullish: () => yK,
    normalizeParams: () => m6,
    merge: () => Da,
    jsonStringifyReplacer: () => WW,
    joinValues: () => NH,
    issue: () => fW,
    isPlainObject: () => Xz,
    isObject: () => mz,
    getSizableOrigin: () => wa,
    getParsedType: () => xa,
    getLengthableOrigin: () => mK,
    getEnumValues: () => WH,
    getElementAtPath: () => Ua,
    floatSafeRemainder: () => EW,
    finalizeIssue: () => x9,
    extend: () => Ha,
    escapeRegex: () => jv,
    esc: () => n7,
    defineLazy: () => k0,
    createTransparentProxy: () => Ba,
    clone: () => j9,
    cleanRegex: () => kK,
    cleanEnum: () => Za,
    captureStackTrace: () => SH,
    cached: () => uK,
    assignProp: () => EH,
    assertNotEqual: () => sr,
    assertNever: () => va,
    assertIs: () => er,
    assertEqual: () => tr,
    assert: () => za,
    allowsEval: () => SW,
    aborted: () => d7,
    NUMBER_FORMAT_RANGES: () => CW,
    Class: () => TW,
    BIGINT_FORMAT_RANGES: () => Oa
});

function tr(v) {
    return v
}

function sr(v) {
    return v
}

function er(v) {}

function va(v) {
    throw Error()
}

function za(v) {}

function WH(v) {
    let z = Object.values(v).filter((U) => typeof U === "number");
    return Object.entries(v).filter(([U, V]) => z.indexOf(+U) === -1).map(([U, V]) => V)
}

function NH(v, z = "|") {
    return v.map((U) => PH(U)).join(z)
}

function WW(v, z) {
    if (typeof z === "bigint") return z.toString();
    return z
}

function uK(v) {
    return {
        get value() {
            {
                let z = v();
                return Object.defineProperty(this, "value", {
                    value: z
                }), z
            }
            throw Error("cached value already set")
        }
    }
}

function yK(v) {
    return v === null || v === void 0
}

function kK(v) {
    let z = v.startsWith("^") ? 1 : 0,
        U = v.endsWith("$") ? v.length - 1 : v.length;
    return v.slice(z, U)
}

function EW(v, z) {
    let U = (v.toString().split(".")[1] || "").length,
        V = (z.toString().split(".")[1] || "").length,
        N = U > V ? U : V,
        K = Number.parseInt(v.toFixed(N).replace(".", "")),
        x = Number.parseInt(z.toFixed(N).replace(".", ""));
    return K % x / 10 ** N
}

function k0(v, z, U) {
    Object.defineProperty(v, z, {
        get() {
            {
                let V = U();
                return v[z] = V, V
            }
            throw Error("cached value already set")
        },
        set(V) {
            Object.defineProperty(v, z, {
                value: V
            })
        },
        configurable: !0
    })
}

function EH(v, z, U) {
    Object.defineProperty(v, z, {
        value: U,
        writable: !0,
        enumerable: !0,
        configurable: !0
    })
}

function Ua(v, z) {
    if (!z) return v;
    return z.reduce((U, V) => U?.[V], v)
}

function Va(v) {
    let z = Object.keys(v),
        U = z.map((V) => v[V]);
    return Promise.all(U).then((V) => {
        let N = {};
        for (let K = 0; K < z.length; K++) N[z[K]] = V[K];
        return N
    })
}

function Na(v = 10) {
    let z = "";
    for (let U = 0; U < v; U++) z += "abcdefghijklmnopqrstuvwxyz" [Math.floor(Math.random() * 26)];
    return z
}

function n7(v) {
    return JSON.stringify(v)
}
var SH = Error.captureStackTrace ? Error.captureStackTrace : (...v) => {};

function mz(v) {
    return typeof v === "object" && v !== null && !Array.isArray(v)
}
var SW = uK(() => {
    if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1;
    try {
        return Function(""), !0
    } catch (v) {
        return !1
    }
});

function Xz(v) {
    if (mz(v) === !1) return !1;
    let z = v.constructor;
    if (z === void 0) return !0;
    let U = z.prototype;
    if (mz(U) === !1) return !1;
    if (Object.prototype.hasOwnProperty.call(U, "isPrototypeOf") === !1) return !1;
    return !0
}

function Ka(v) {
    let z = 0;
    for (let U in v)
        if (Object.prototype.hasOwnProperty.call(v, U)) z++;
    return z
}
var xa = (v) => {
        let z = typeof v;
        switch (z) {
            case "undefined":
                return "undefined";
            case "string":
                return "string";
            case "number":
                return Number.isNaN(v) ? "nan" : "number";
            case "boolean":
                return "boolean";
            case "function":
                return "function";
            case "bigint":
                return "bigint";
            case "symbol":
                return "symbol";
            case "object":
                if (Array.isArray(v)) return "array";
                if (v === null) return "null";
                if (v.then && typeof v.then === "function" && v.catch && typeof v.catch === "function") return "promise";
                if (typeof Map < "u" && v instanceof Map) return "map";
                if (typeof Set < "u" && v instanceof Set) return "set";
                if (typeof Date < "u" && v instanceof Date) return "date";
                if (typeof File < "u" && v instanceof File) return "file";
                return "object";
            default:
                throw Error(`Unknown data type: ${z}`)
        }
    },
    PW = new Set(["string", "number", "symbol"]),
    ja = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);

function jv(v) {
    return v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function j9(v, z, U) {
    let V = new v._zod.constr(z ?? v._zod.def);
    if (!z || U?.parent) V._zod.parent = v;
    return V
}

function m6(v) {
    let z = v;
    if (!z) return {};
    if (typeof z === "string") return {
        error: () => z
    };
    if (z?.message !== void 0) {
        if (z?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
        z.error = z.message
    }
    if (delete z.message, typeof z.error === "string") return {
        ...z,
        error: () => z.error
    };
    return z
}

function Ba(v) {
    let z;
    return new Proxy({}, {
        get(U, V, N) {
            return z ?? (z = v()), Reflect.get(z, V, N)
        },
        set(U, V, N, K) {
            return z ?? (z = v()), Reflect.set(z, V, N, K)
        },
        has(U, V) {
            return z ?? (z = v()), Reflect.has(z, V)
        },
        deleteProperty(U, V) {
            return z ?? (z = v()), Reflect.deleteProperty(z, V)
        },
        ownKeys(U) {
            return z ?? (z = v()), Reflect.ownKeys(z)
        },
        getOwnPropertyDescriptor(U, V) {
            return z ?? (z = v()), Reflect.getOwnPropertyDescriptor(z, V)
        },
        defineProperty(U, V, N) {
            return z ?? (z = v()), Reflect.defineProperty(z, V, N)
        }
    })
}

function PH(v) {
    if (typeof v === "bigint") return v.toString() + "n";
    if (typeof v === "string") return `"${v}"`;
    return `${v}`
}

function _W(v) {
    return Object.keys(v).filter((z) => {
        return v[z]._zod.optin === "optional" && v[z]._zod.optout === "optional"
    })
}
var CW = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-2147483648, 2147483647],
        uint32: [0, 4294967295],
        float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    },
    Oa = {
        int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
        uint64: [BigInt(0), BigInt("18446744073709551615")]
    };

function Ja(v, z) {
    let U = {},
        V = v._zod.def;
    for (let N in z) {
        if (!(N in V.shape)) throw Error(`Unrecognized key: "${N}"`);
        if (!z[N]) continue;
        U[N] = V.shape[N]
    }
    return j9(v, {
        ...v._zod.def,
        shape: U,
        checks: []
    })
}

function qa(v, z) {
    let U = {
            ...v._zod.def.shape
        },
        V = v._zod.def;
    for (let N in z) {
        if (!(N in V.shape)) throw Error(`Unrecognized key: "${N}"`);
        if (!z[N]) continue;
        delete U[N]
    }
    return j9(v, {
        ...v._zod.def,
        shape: U,
        checks: []
    })
}

function Ha(v, z) {
    if (!Xz(z)) throw Error("Invalid input to extend: expected a plain object");
    let U = {
        ...v._zod.def,
        get shape() {
            let V = {
                ...v._zod.def.shape,
                ...z
            };
            return EH(this, "shape", V), V
        },
        checks: []
    };
    return j9(v, U)
}

function Da(v, z) {
    return j9(v, {
        ...v._zod.def,
        get shape() {
            let U = {
                ...v._zod.def.shape,
                ...z._zod.def.shape
            };
            return EH(this, "shape", U), U
        },
        catchall: z._zod.def.catchall,
        checks: []
    })
}

function Aa(v, z, U) {
    let V = z._zod.def.shape,
        N = {
            ...V
        };
    if (U)
        for (let K in U) {
            if (!(K in V)) throw Error(`Unrecognized key: "${K}"`);
            if (!U[K]) continue;
            N[K] = v ? new v({
                type: "optional",
                innerType: V[K]
            }) : V[K]
        } else
            for (let K in V) N[K] = v ? new v({
                type: "optional",
                innerType: V[K]
            }) : V[K];
    return j9(z, {
        ...z._zod.def,
        shape: N,
        checks: []
    })
}

function $a(v, z, U) {
    let V = z._zod.def.shape,
        N = {
            ...V
        };
    if (U)
        for (let K in U) {
            if (!(K in N)) throw Error(`Unrecognized key: "${K}"`);
            if (!U[K]) continue;
            N[K] = new v({
                type: "nonoptional",
                innerType: V[K]
            })
        } else
            for (let K in V) N[K] = new v({
                type: "nonoptional",
                innerType: V[K]
            });
    return j9(z, {
        ...z._zod.def,
        shape: N,
        checks: []
    })
}

function d7(v, z = 0) {
    for (let U = z; U < v.issues.length; U++)
        if (v.issues[U]?.continue !== !0) return !0;
    return !1
}

function p9(v, z) {
    return z.map((U) => {
        var V;
        return (V = U).path ?? (V.path = []), U.path.unshift(v), U
    })
}

function Fz(v) {
    return typeof v === "string" ? v : v?.message
}

function x9(v, z, U) {
    let V = {
        ...v,
        path: v.path ?? []
    };
    if (!v.message) {
        let N = Fz(v.inst?._zod.def?.error?.(v)) ?? Fz(z?.error?.(v)) ?? Fz(U.customError?.(v)) ?? Fz(U.localeError?.(v)) ?? "Invalid input";
        V.message = N
    }
    if (delete V.inst, delete V.continue, !z?.reportInput) delete V.input;
    return V
}

function wa(v) {
    if (v instanceof Set) return "set";
    if (v instanceof Map) return "map";
    if (v instanceof File) return "file";
    return "unknown"
}

function mK(v) {
    if (Array.isArray(v)) return "array";
    if (typeof v === "string") return "string";
    return "unknown"
}

function fW(...v) {
    let [z, U, V] = v;
    if (typeof z === "string") return {
        message: z,
        code: "custom",
        input: U,
        inst: V
    };
    return {
        ...z
    }
}

function Za(v) {
    return Object.entries(v).filter(([z, U]) => {
        return Number.isNaN(Number.parseInt(z, 10))
    }).map((z) => z[1])
}
class TW {
    constructor(...v) {}
}
var YW = (v, z) => {
        v.name = "$ZodError", Object.defineProperty(v, "_zod", {
            value: v._zod,
            enumerable: !1
        }), Object.defineProperty(v, "issues", {
            value: z,
            enumerable: !1
        }), Object.defineProperty(v, "message", {
            get() {
                return JSON.stringify(z, WW, 2)
            },
            enumerable: !0
        })
    },
    uW = l("$ZodError", YW),
    XK = l("$ZodError", YW, {
        Parent: Error
    });

function La(v, z = (U) => U.message) {
    let U = {},
        V = [];
    for (let N of v.issues)
        if (N.path.length > 0) U[N.path[0]] = U[N.path[0]] || [], U[N.path[0]].push(z(N));
        else V.push(z(N));
    return {
        formErrors: V,
        fieldErrors: U
    }
}

function Fa(v, z) {
    let U = z || function(K) {
            return K.message
        },
        V = {
            _errors: []
        },
        N = (K) => {
            for (let x of K.issues)
                if (x.code === "invalid_union" && x.errors.length) x.errors.map((j) => N({
                    issues: j
                }));
                else if (x.code === "invalid_key") N({
                issues: x.issues
            });
            else if (x.code === "invalid_element") N({
                issues: x.issues
            });
            else if (x.path.length === 0) V._errors.push(U(x));
            else {
                let j = V,
                    B = 0;
                while (B < x.path.length) {
                    let O = x.path[B];
                    if (B !== x.path.length - 1) j[O] = j[O] || {
                        _errors: []
                    };
                    else j[O] = j[O] || {
                        _errors: []
                    }, j[O]._errors.push(U(x));
                    j = j[O], B++
                }
            }
        };
    return N(v), V
}
var yW = (v) => (z, U, V, N) => {
        let K = V ? Object.assign(V, {
                async: !1
            }) : {
                async: !1
            },
            x = z._zod.run({
                value: U,
                issues: []
            }, K);
        if (x instanceof Promise) throw new e7;
        if (x.issues.length) {
            let j = new(N?.Err ?? v)(x.issues.map((B) => x9(B, K, K9())));
            throw SH(j, N?.callee), j
        }
        return x.value
    },
    Ga = yW(XK),
    kW = (v) => async (z, U, V, N) => {
        let K = V ? Object.assign(V, {
                async: !0
            }) : {
                async: !0
            },
            x = z._zod.run({
                value: U,
                issues: []
            }, K);
        if (x instanceof Promise) x = await x;
        if (x.issues.length) {
            let j = new(N?.Err ?? v)(x.issues.map((B) => x9(B, K, K9())));
            throw SH(j, N?.callee), j
        }
        return x.value
    }, Ia = kW(XK), mW = (v) => (z, U, V) => {
        let N = V ? {
                ...V,
                async: !1
            } : {
                async: !1
            },
            K = z._zod.run({
                value: U,
                issues: []
            }, N);
        if (K instanceof Promise) throw new e7;
        return K.issues.length ? {
            success: !1,
            error: new(v ?? uW)(K.issues.map((x) => x9(x, N, K9())))
        } : {
            success: !0,
            data: K.value
        }
    }, _H = mW(XK), XW = (v) => async (z, U, V) => {
        let N = V ? Object.assign(V, {
                async: !0
            }) : {
                async: !0
            },
            K = z._zod.run({
                value: U,
                issues: []
            }, N);
        if (K instanceof Promise) K = await K;
        return K.issues.length ? {
            success: !1,
            error: new v(K.issues.map((x) => x9(x, N, K9())))
        } : {
            success: !0,
            data: K.value
        }
    }, CH = XW(XK), Ma = /^[cC][^\s-]{8,}$/, ba = /^[0-9a-z]+$/, Ra = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Wa = /^[0-9a-vA-V]{20}$/, Ea = /^[A-Za-z0-9]{27}$/, Sa = /^[a-zA-Z0-9_-]{21}$/, Pa = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, _a = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, JR = (v) => {
        if (!v) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
        return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${v}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`)
    }, Ca = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;

function fa() {
    return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")
}
var Ta = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    Ya = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
    ua = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
    ya = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    ka = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
    gW = /^[A-Za-z0-9_-]*$/,
    ma = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
    Xa = /^\+(?:[0-9]){6,14}[0-9]$/,
    cW = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
    ga = new RegExp(`^${cW}$`);

function iW(v) {
    return typeof v.precision === "number" ? v.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : v.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${v.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?"
}

function ca(v) {
    return new RegExp(`^${iW(v)}$`)
}

function ia(v) {
    let z = iW({
            precision: v.precision
        }),
        U = ["Z"];
    if (v.local) U.push("");
    if (v.offset) U.push("([+-]\\d{2}:\\d{2})");
    let V = `${z}(?:${U.join("|")})`;
    return new RegExp(`^${cW}T(?:${V})$`)
}
var la = (v) => {
        let z = v ? `[\\s\\S]{${v?.minimum??0},${v?.maximum??""}}` : "[\\s\\S]*";
        return new RegExp(`^${z}$`)
    },
    ha = /^\d+$/,
    pa = /^-?\d+(?:\.\d+)?/i,
    na = /true|false/i,
    Qa = /null/i,
    da = /^[^A-Z]*$/,
    oa = /^[^a-z]*$/,
    q3 = l("$ZodCheck", (v, z) => {
        var U;
        v._zod ?? (v._zod = {}), v._zod.def = z, (U = v._zod).onattach ?? (U.onattach = [])
    }),
    lW = {
        number: "number",
        bigint: "bigint",
        object: "date"
    },
    hW = l("$ZodCheckLessThan", (v, z) => {
        q3.init(v, z);
        let U = lW[typeof z.value];
        v._zod.onattach.push((V) => {
            let N = V._zod.bag,
                K = (z.inclusive ? N.maximum : N.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
            if (z.value < K)
                if (z.inclusive) N.maximum = z.value;
                else N.exclusiveMaximum = z.value
        }), v._zod.check = (V) => {
            if (z.inclusive ? V.value <= z.value : V.value < z.value) return;
            V.issues.push({
                origin: U,
                code: "too_big",
                maximum: z.value,
                input: V.value,
                inclusive: z.inclusive,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    pW = l("$ZodCheckGreaterThan", (v, z) => {
        q3.init(v, z);
        let U = lW[typeof z.value];
        v._zod.onattach.push((V) => {
            let N = V._zod.bag,
                K = (z.inclusive ? N.minimum : N.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
            if (z.value > K)
                if (z.inclusive) N.minimum = z.value;
                else N.exclusiveMinimum = z.value
        }), v._zod.check = (V) => {
            if (z.inclusive ? V.value >= z.value : V.value > z.value) return;
            V.issues.push({
                origin: U,
                code: "too_small",
                minimum: z.value,
                input: V.value,
                inclusive: z.inclusive,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    ra = l("$ZodCheckMultipleOf", (v, z) => {
        q3.init(v, z), v._zod.onattach.push((U) => {
            var V;
            (V = U._zod.bag).multipleOf ?? (V.multipleOf = z.value)
        }), v._zod.check = (U) => {
            if (typeof U.value !== typeof z.value) throw Error("Cannot mix number and bigint in multiple_of check.");
            if (typeof U.value === "bigint" ? U.value % z.value === BigInt(0) : EW(U.value, z.value) === 0) return;
            U.issues.push({
                origin: typeof U.value,
                code: "not_multiple_of",
                divisor: z.value,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    aa = l("$ZodCheckNumberFormat", (v, z) => {
        q3.init(v, z), z.format = z.format || "float64";
        let U = z.format?.includes("int"),
            V = U ? "int" : "number",
            [N, K] = CW[z.format];
        v._zod.onattach.push((x) => {
            let j = x._zod.bag;
            if (j.format = z.format, j.minimum = N, j.maximum = K, U) j.pattern = ha
        }), v._zod.check = (x) => {
            let j = x.value;
            if (U) {
                if (!Number.isInteger(j)) {
                    x.issues.push({
                        expected: V,
                        format: z.format,
                        code: "invalid_type",
                        input: j,
                        inst: v
                    });
                    return
                }
                if (!Number.isSafeInteger(j)) {
                    if (j > 0) x.issues.push({
                        input: j,
                        code: "too_big",
                        maximum: Number.MAX_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst: v,
                        origin: V,
                        continue: !z.abort
                    });
                    else x.issues.push({
                        input: j,
                        code: "too_small",
                        minimum: Number.MIN_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst: v,
                        origin: V,
                        continue: !z.abort
                    });
                    return
                }
            }
            if (j < N) x.issues.push({
                origin: "number",
                input: j,
                code: "too_small",
                minimum: N,
                inclusive: !0,
                inst: v,
                continue: !z.abort
            });
            if (j > K) x.issues.push({
                origin: "number",
                input: j,
                code: "too_big",
                maximum: K,
                inst: v
            })
        }
    }),
    ta = l("$ZodCheckMaxLength", (v, z) => {
        q3.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !yK(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
            if (z.maximum < V) U._zod.bag.maximum = z.maximum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.length <= z.maximum) return;
            let N = mK(V);
            U.issues.push({
                origin: N,
                code: "too_big",
                maximum: z.maximum,
                inclusive: !0,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    sa = l("$ZodCheckMinLength", (v, z) => {
        q3.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !yK(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
            if (z.minimum > V) U._zod.bag.minimum = z.minimum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.length >= z.minimum) return;
            let N = mK(V);
            U.issues.push({
                origin: N,
                code: "too_small",
                minimum: z.minimum,
                inclusive: !0,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    ea = l("$ZodCheckLengthEquals", (v, z) => {
        q3.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !yK(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.minimum = z.length, V.maximum = z.length, V.length = z.length
        }), v._zod.check = (U) => {
            let V = U.value,
                N = V.length;
            if (N === z.length) return;
            let K = mK(V),
                x = N > z.length;
            U.issues.push({
                origin: K,
                ...x ? {
                    code: "too_big",
                    maximum: z.length
                } : {
                    code: "too_small",
                    minimum: z.length
                },
                inclusive: !0,
                exact: !0,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    gK = l("$ZodCheckStringFormat", (v, z) => {
        var U, V;
        if (q3.init(v, z), v._zod.onattach.push((N) => {
                let K = N._zod.bag;
                if (K.format = z.format, z.pattern) K.patterns ?? (K.patterns = new Set), K.patterns.add(z.pattern)
            }), z.pattern)(U = v._zod).check ?? (U.check = (N) => {
            if (z.pattern.lastIndex = 0, z.pattern.test(N.value)) return;
            N.issues.push({
                origin: "string",
                code: "invalid_format",
                format: z.format,
                input: N.value,
                ...z.pattern ? {
                    pattern: z.pattern.toString()
                } : {},
                inst: v,
                continue: !z.abort
            })
        });
        else(V = v._zod).check ?? (V.check = () => {})
    }),
    vt = l("$ZodCheckRegex", (v, z) => {
        gK.init(v, z), v._zod.check = (U) => {
            if (z.pattern.lastIndex = 0, z.pattern.test(U.value)) return;
            U.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "regex",
                input: U.value,
                pattern: z.pattern.toString(),
                inst: v,
                continue: !z.abort
            })
        }
    }),
    zt = l("$ZodCheckLowerCase", (v, z) => {
        z.pattern ?? (z.pattern = da), gK.init(v, z)
    }),
    Ut = l("$ZodCheckUpperCase", (v, z) => {
        z.pattern ?? (z.pattern = oa), gK.init(v, z)
    }),
    Vt = l("$ZodCheckIncludes", (v, z) => {
        q3.init(v, z);
        let U = jv(z.includes),
            V = new RegExp(typeof z.position === "number" ? `^.{${z.position}}${U}` : U);
        z.pattern = V, v._zod.onattach.push((N) => {
            let K = N._zod.bag;
            K.patterns ?? (K.patterns = new Set), K.patterns.add(V)
        }), v._zod.check = (N) => {
            if (N.value.includes(z.includes, z.position)) return;
            N.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "includes",
                includes: z.includes,
                input: N.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    Nt = l("$ZodCheckStartsWith", (v, z) => {
        q3.init(v, z);
        let U = new RegExp(`^${jv(z.prefix)}.*`);
        z.pattern ?? (z.pattern = U), v._zod.onattach.push((V) => {
            let N = V._zod.bag;
            N.patterns ?? (N.patterns = new Set), N.patterns.add(U)
        }), v._zod.check = (V) => {
            if (V.value.startsWith(z.prefix)) return;
            V.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "starts_with",
                prefix: z.prefix,
                input: V.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    Kt = l("$ZodCheckEndsWith", (v, z) => {
        q3.init(v, z);
        let U = new RegExp(`.*${jv(z.suffix)}$`);
        z.pattern ?? (z.pattern = U), v._zod.onattach.push((V) => {
            let N = V._zod.bag;
            N.patterns ?? (N.patterns = new Set), N.patterns.add(U)
        }), v._zod.check = (V) => {
            if (V.value.endsWith(z.suffix)) return;
            V.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "ends_with",
                suffix: z.suffix,
                input: V.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    xt = l("$ZodCheckOverwrite", (v, z) => {
        q3.init(v, z), v._zod.check = (U) => {
            U.value = z.tx(U.value)
        }
    });
class nW {
    constructor(v = []) {
        if (this.content = [], this.indent = 0, this) this.args = v
    }
    indented(v) {
        this.indent += 1, v(this), this.indent -= 1
    }
    write(v) {
        if (typeof v === "function") {
            v(this, {
                execution: "sync"
            }), v(this, {
                execution: "async"
            });
            return
        }
        let z = v.split(`
`).filter((N) => N),
            U = Math.min(...z.map((N) => N.length - N.trimStart().length)),
            V = z.map((N) => N.slice(U)).map((N) => " ".repeat(this.indent * 2) + N);
        for (let N of V) this.content.push(N)
    }
    compile() {
        let v = Function,
            z = this?.args,
            U = [...(this?.content ?? [""]).map((V) => `  ${V}`)];
        return new v(...z, U.join(`
`))
    }
}
var jt = {
        major: 4,
        minor: 0,
        patch: 0
    },
    Y0 = l("$ZodType", (v, z) => {
        var U;
        v ?? (v = {}), v._zod.def = z, v._zod.bag = v._zod.bag || {}, v._zod.version = jt;
        let V = [...v._zod.def.checks ?? []];
        if (v._zod.traits.has("$ZodCheck")) V.unshift(v);
        for (let N of V)
            for (let K of N._zod.onattach) K(v);
        if (V.length === 0)(U = v._zod).deferred ?? (U.deferred = []), v._zod.deferred?.push(() => {
            v._zod.run = v._zod.parse
        });
        else {
            let N = (K, x, j) => {
                let B = d7(K),
                    O;
                for (let J of x) {
                    if (J._zod.when) {
                        if (!J._zod.when(K)) continue
                    } else if (B) continue;
                    let q = K.issues.length,
                        H = J._zod.check(K);
                    if (H instanceof Promise && j?.async === !1) throw new e7;
                    if (O || H instanceof Promise) O = (O ?? Promise.resolve()).then(async () => {
                        if (await H, K.issues.length === q) return;
                        if (!B) B = d7(K, q)
                    });
                    else {
                        if (K.issues.length === q) continue;
                        if (!B) B = d7(K, q)
                    }
                }
                if (O) return O.then(() => {
                    return K
                });
                return K
            };
            v._zod.run = (K, x) => {
                let j = v._zod.parse(K, x);
                if (j instanceof Promise) {
                    if (x.async === !1) throw new e7;
                    return j.then((B) => N(B, V, x))
                }
                return N(j, V, x)
            }
        }
        v["~standard"] = {
            validate: (N) => {
                try {
                    let K = _H(v, N);
                    return K.success ? {
                        value: K.data
                    } : {
                        issues: K.error?.issues
                    }
                } catch (K) {
                    return CH(v, N).then((x) => x.success ? {
                        value: x.data
                    } : {
                        issues: x.error?.issues
                    })
                }
            },
            vendor: "zod",
            version: 1
        }
    }),
    fH = l("$ZodString", (v, z) => {
        Y0.init(v, z), v._zod.pattern = [...v?._zod.bag?.patterns ?? []].pop() ?? la(v._zod.bag), v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = String(U.value)
            } catch (N) {}
            if (typeof U.value === "string") return U;
            return U.issues.push({
                expected: "string",
                code: "invalid_type",
                input: U.value,
                inst: v
            }), U
        }
    }),
    c0 = l("$ZodStringFormat", (v, z) => {
        gK.init(v, z), fH.init(v, z)
    }),
    Bt = l("$ZodGUID", (v, z) => {
        z.pattern ?? (z.pattern = _a), c0.init(v, z)
    }),
    Ot = l("$ZodUUID", (v, z) => {
        if (z.version) {
            let U = {
                v1: 1,
                v2: 2,
                v3: 3,
                v4: 4,
                v5: 5,
                v6: 6,
                v7: 7,
                v8: 8
            } [z.version];
            if (U === void 0) throw Error(`Invalid UUID version: "${z.version}"`);
            z.pattern ?? (z.pattern = JR(U))
        } else z.pattern ?? (z.pattern = JR());
        c0.init(v, z)
    }),
    Jt = l("$ZodEmail", (v, z) => {
        z.pattern ?? (z.pattern = Ca), c0.init(v, z)
    }),
    qt = l("$ZodURL", (v, z) => {
        c0.init(v, z), v._zod.check = (U) => {
            try {
                let V = U.value,
                    N = new URL(V),
                    K = N.href;
                if (z.hostname) {
                    if (z.hostname.lastIndex = 0, !z.hostname.test(N.hostname)) U.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid hostname",
                        pattern: ma.source,
                        input: U.value,
                        inst: v,
                        continue: !z.abort
                    })
                }
                if (z.protocol) {
                    if (z.protocol.lastIndex = 0, !z.protocol.test(N.protocol.endsWith(":") ? N.protocol.slice(0, -1) : N.protocol)) U.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid protocol",
                        pattern: z.protocol.source,
                        input: U.value,
                        inst: v,
                        continue: !z.abort
                    })
                }
                if (!V.endsWith("/") && K.endsWith("/")) U.value = K.slice(0, -1);
                else U.value = K;
                return
            } catch (V) {
                U.issues.push({
                    code: "invalid_format",
                    format: "url",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    }),
    Ht = l("$ZodEmoji", (v, z) => {
        z.pattern ?? (z.pattern = fa()), c0.init(v, z)
    }),
    Dt = l("$ZodNanoID", (v, z) => {
        z.pattern ?? (z.pattern = Sa), c0.init(v, z)
    }),
    At = l("$ZodCUID", (v, z) => {
        z.pattern ?? (z.pattern = Ma), c0.init(v, z)
    }),
    $t = l("$ZodCUID2", (v, z) => {
        z.pattern ?? (z.pattern = ba), c0.init(v, z)
    }),
    wt = l("$ZodULID", (v, z) => {
        z.pattern ?? (z.pattern = Ra), c0.init(v, z)
    }),
    Zt = l("$ZodXID", (v, z) => {
        z.pattern ?? (z.pattern = Wa), c0.init(v, z)
    }),
    Lt = l("$ZodKSUID", (v, z) => {
        z.pattern ?? (z.pattern = Ea), c0.init(v, z)
    }),
    Ft = l("$ZodISODateTime", (v, z) => {
        z.pattern ?? (z.pattern = ia(z)), c0.init(v, z)
    }),
    Gt = l("$ZodISODate", (v, z) => {
        z.pattern ?? (z.pattern = ga), c0.init(v, z)
    }),
    It = l("$ZodISOTime", (v, z) => {
        z.pattern ?? (z.pattern = ca(z)), c0.init(v, z)
    }),
    Mt = l("$ZodISODuration", (v, z) => {
        z.pattern ?? (z.pattern = Pa), c0.init(v, z)
    }),
    bt = l("$ZodIPv4", (v, z) => {
        z.pattern ?? (z.pattern = Ta), c0.init(v, z), v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.format = "ipv4"
        })
    }),
    Rt = l("$ZodIPv6", (v, z) => {
        z.pattern ?? (z.pattern = Ya), c0.init(v, z), v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.format = "ipv6"
        }), v._zod.check = (U) => {
            try {
                new URL(`http://[${U.value}]`)
            } catch {
                U.issues.push({
                    code: "invalid_format",
                    format: "ipv6",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    }),
    Wt = l("$ZodCIDRv4", (v, z) => {
        z.pattern ?? (z.pattern = ua), c0.init(v, z)
    }),
    Et = l("$ZodCIDRv6", (v, z) => {
        z.pattern ?? (z.pattern = ya), c0.init(v, z), v._zod.check = (U) => {
            let [V, N] = U.value.split("/");
            try {
                if (!N) throw Error();
                let K = Number(N);
                if (`${K}` !== N) throw Error();
                if (K < 0 || K > 128) throw Error();
                new URL(`http://[${V}]`)
            } catch {
                U.issues.push({
                    code: "invalid_format",
                    format: "cidrv6",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    });

function QW(v) {
    if (v === "") return !0;
    if (v.length % 4 !== 0) return !1;
    try {
        return atob(v), !0
    } catch {
        return !1
    }
}
var St = l("$ZodBase64", (v, z) => {
    z.pattern ?? (z.pattern = ka), c0.init(v, z), v._zod.onattach.push((U) => {
        U._zod.bag.contentEncoding = "base64"
    }), v._zod.check = (U) => {
        if (QW(U.value)) return;
        U.issues.push({
            code: "invalid_format",
            format: "base64",
            input: U.value,
            inst: v,
            continue: !z.abort
        })
    }
});

function Pt(v) {
    if (!gW.test(v)) return !1;
    let z = v.replace(/[-_]/g, (V) => V === "-" ? "+" : "/"),
        U = z.padEnd(Math.ceil(z.length / 4) * 4, "=");
    return QW(U)
}
var _t = l("$ZodBase64URL", (v, z) => {
        z.pattern ?? (z.pattern = gW), c0.init(v, z), v._zod.onattach.push((U) => {
            U._zod.bag.contentEncoding = "base64url"
        }), v._zod.check = (U) => {
            if (Pt(U.value)) return;
            U.issues.push({
                code: "invalid_format",
                format: "base64url",
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    Ct = l("$ZodE164", (v, z) => {
        z.pattern ?? (z.pattern = Xa), c0.init(v, z)
    });

function ft(v, z = null) {
    try {
        let U = v.split(".");
        if (U.length !== 3) return !1;
        let [V] = U;
        if (!V) return !1;
        let N = JSON.parse(atob(V));
        if ("typ" in N && N?.typ !== "JWT") return !1;
        if (!N.alg) return !1;
        if (z && (!("alg" in N) || N.alg !== z)) return !1;
        return !0
    } catch {
        return !1
    }
}
var Tt = l("$ZodJWT", (v, z) => {
        c0.init(v, z), v._zod.check = (U) => {
            if (ft(U.value, z.alg)) return;
            U.issues.push({
                code: "invalid_format",
                format: "jwt",
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    dW = l("$ZodNumber", (v, z) => {
        Y0.init(v, z), v._zod.pattern = v._zod.bag.pattern ?? pa, v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = Number(U.value)
            } catch (x) {}
            let N = U.value;
            if (typeof N === "number" && !Number.isNaN(N) && Number.isFinite(N)) return U;
            let K = typeof N === "number" ? Number.isNaN(N) ? "NaN" : !Number.isFinite(N) ? "Infinity" : void 0 : void 0;
            return U.issues.push({
                expected: "number",
                code: "invalid_type",
                input: N,
                inst: v,
                ...K ? {
                    received: K
                } : {}
            }), U
        }
    }),
    Yt = l("$ZodNumber", (v, z) => {
        aa.init(v, z), dW.init(v, z)
    }),
    ut = l("$ZodBoolean", (v, z) => {
        Y0.init(v, z), v._zod.pattern = na, v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = Boolean(U.value)
            } catch (K) {}
            let N = U.value;
            if (typeof N === "boolean") return U;
            return U.issues.push({
                expected: "boolean",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    yt = l("$ZodNull", (v, z) => {
        Y0.init(v, z), v._zod.pattern = Qa, v._zod.values = new Set([null]), v._zod.parse = (U, V) => {
            let N = U.value;
            if (N === null) return U;
            return U.issues.push({
                expected: "null",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    kt = l("$ZodUnknown", (v, z) => {
        Y0.init(v, z), v._zod.parse = (U) => U
    }),
    mt = l("$ZodNever", (v, z) => {
        Y0.init(v, z), v._zod.parse = (U, V) => {
            return U.issues.push({
                expected: "never",
                code: "invalid_type",
                input: U.value,
                inst: v
            }), U
        }
    });

function qR(v, z, U) {
    if (v.issues.length) z.issues.push(...p9(U, v.issues));
    z.value[U] = v.value
}
var Xt = l("$ZodArray", (v, z) => {
    Y0.init(v, z), v._zod.parse = (U, V) => {
        let N = U.value;
        if (!Array.isArray(N)) return U.issues.push({
            expected: "array",
            code: "invalid_type",
            input: N,
            inst: v
        }), U;
        U.value = Array(N.length);
        let K = [];
        for (let x = 0; x < N.length; x++) {
            let j = N[x],
                B = z.element._zod.run({
                    value: j,
                    issues: []
                }, V);
            if (B instanceof Promise) K.push(B.then((O) => qR(O, U, x)));
            else qR(B, U, x)
        }
        if (K.length) return Promise.all(K).then(() => U);
        return U
    }
});

function jK(v, z, U) {
    if (v.issues.length) z.issues.push(...p9(U, v.issues));
    z.value[U] = v.value
}

function HR(v, z, U, V) {
    if (v.issues.length)
        if (V[U] === void 0)
            if (U in V) z.value[U] = void 0;
            else z.value[U] = v.value;
    else z.issues.push(...p9(U, v.issues));
    else if (v.value === void 0) {
        if (U in V) z.value[U] = void 0
    } else z.value[U] = v.value
}
var oW = l("$ZodObject", (v, z) => {
    Y0.init(v, z);
    let U = uK(() => {
        let J = Object.keys(z.shape);
        for (let H of J)
            if (!(z.shape[H] instanceof Y0)) throw Error(`Invalid element at key "${H}": expected a Zod schema`);
        let q = _W(z.shape);
        return {
            shape: z.shape,
            keys: J,
            keySet: new Set(J),
            numKeys: J.length,
            optionalKeys: new Set(q)
        }
    });
    k0(v._zod, "propValues", () => {
        let J = z.shape,
            q = {};
        for (let H in J) {
            let D = J[H]._zod;
            if (D.values) {
                q[H] ?? (q[H] = new Set);
                for (let A of D.values) q[H].add(A)
            }
        }
        return q
    });
    let V = (J) => {
            let q = new nW(["shape", "payload", "ctx"]),
                H = U.value,
                D = ($) => {
                    let F = n7($);
                    return `shape[${F}]._zod.run({ value: input[${F}], issues: [] }, ctx)`
                };
            q.write("const input = payload.value;");
            let A = Object.create(null),
                w = 0;
            for (let $ of H.keys) A[$] = `key_${w++}`;
            q.write("const newResult = {}");
            for (let $ of H.keys)
                if (H.optionalKeys.has($)) {
                    let F = A[$];
                    q.write(`const ${F} = ${D($)};`);
                    let L = n7($);
                    q.write(`
        if (${F}.issues.length) {
          if (input[${L}] === undefined) {
            if (${L} in input) {
              newResult[${L}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${F}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${L}, ...iss.path] : [${L}],
              }))
            );
          }
        } else if (${F}.value === undefined) {
          if (${L} in input) newResult[${L}] = undefined;
        } else {
          newResult[${L}] = ${F}.value;
        }
        `)
                } else {
                    let F = A[$];
                    q.write(`const ${F} = ${D($)};`), q.write(`
          if (${F}.issues.length) payload.issues = payload.issues.concat(${F}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${n7($)}, ...iss.path] : [${n7($)}]
          })));`), q.write(`newResult[${n7($)}] = ${F}.value`)
                } q.write("payload.value = newResult;"), q.write("return payload;");
            let Z = q.compile();
            return ($, F) => Z(J, $, F)
        },
        N, K = mz,
        x = !VH.jitless,
        j = x && SW.value,
        B = z.catchall,
        O;
    v._zod.parse = (J, q) => {
        O ?? (O = U.value);
        let H = J.value;
        if (!K(H)) return J.issues.push({
            expected: "object",
            code: "invalid_type",
            input: H,
            inst: v
        }), J;
        let D = [];
        if (x && j && q?.async === !1 && q.jitless !== !0) {
            if (!N) N = V(z.shape);
            J = N(J, q)
        } else {
            J.value = {};
            let F = O.shape;
            for (let L of O.keys) {
                let G = F[L],
                    I = G._zod.run({
                        value: H[L],
                        issues: []
                    }, q),
                    M = G._zod.optin === "optional" && G._zod.optout === "optional";
                if (I instanceof Promise) D.push(I.then((b) => M ? HR(b, J, L, H) : jK(b, J, L)));
                else if (M) HR(I, J, L, H);
                else jK(I, J, L)
            }
        }
        if (!B) return D.length ? Promise.all(D).then(() => J) : J;
        let A = [],
            w = O.keySet,
            Z = B._zod,
            $ = Z.def.type;
        for (let F of Object.keys(H)) {
            if (w.has(F)) continue;
            if ($ === "never") {
                A.push(F);
                continue
            }
            let L = Z.run({
                value: H[F],
                issues: []
            }, q);
            if (L instanceof Promise) D.push(L.then((G) => jK(G, J, F)));
            else jK(L, J, F)
        }
        if (A.length) J.issues.push({
            code: "unrecognized_keys",
            keys: A,
            input: H,
            inst: v
        });
        if (!D.length) return J;
        return Promise.all(D).then(() => {
            return J
        })
    }
});

function DR(v, z, U, V) {
    for (let N of v)
        if (N.issues.length === 0) return z.value = N.value, z;
    return z.issues.push({
        code: "invalid_union",
        input: z.value,
        inst: U,
        errors: v.map((N) => N.issues.map((K) => x9(K, V, K9())))
    }), z
}
var rW = l("$ZodUnion", (v, z) => {
        Y0.init(v, z), k0(v._zod, "optin", () => z.options.some((U) => U._zod.optin === "optional") ? "optional" : void 0), k0(v._zod, "optout", () => z.options.some((U) => U._zod.optout === "optional") ? "optional" : void 0), k0(v._zod, "values", () => {
            if (z.options.every((U) => U._zod.values)) return new Set(z.options.flatMap((U) => Array.from(U._zod.values)));
            return
        }), k0(v._zod, "pattern", () => {
            if (z.options.every((U) => U._zod.pattern)) {
                let U = z.options.map((V) => V._zod.pattern);
                return new RegExp(`^(${U.map((V)=>kK(V.source)).join("|")})$`)
            }
            return
        }), v._zod.parse = (U, V) => {
            let N = !1,
                K = [];
            for (let x of z.options) {
                let j = x._zod.run({
                    value: U.value,
                    issues: []
                }, V);
                if (j instanceof Promise) K.push(j), N = !0;
                else {
                    if (j.issues.length === 0) return j;
                    K.push(j)
                }
            }
            if (!N) return DR(K, U, v, V);
            return Promise.all(K).then((x) => {
                return DR(x, U, v, V)
            })
        }
    }),
    gt = l("$ZodDiscriminatedUnion", (v, z) => {
        rW.init(v, z);
        let U = v._zod.parse;
        k0(v._zod, "propValues", () => {
            let N = {};
            for (let K of z.options) {
                let x = K._zod.propValues;
                if (!x || Object.keys(x).length === 0) throw Error(`Invalid discriminated union option at index "${z.options.indexOf(K)}"`);
                for (let [j, B] of Object.entries(x)) {
                    if (!N[j]) N[j] = new Set;
                    for (let O of B) N[j].add(O)
                }
            }
            return N
        });
        let V = uK(() => {
            let N = z.options,
                K = new Map;
            for (let x of N) {
                let j = x._zod.propValues[z.discriminator];
                if (!j || j.size === 0) throw Error(`Invalid discriminated union option at index "${z.options.indexOf(x)}"`);
                for (let B of j) {
                    if (K.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
                    K.set(B, x)
                }
            }
            return K
        });
        v._zod.parse = (N, K) => {
            let x = N.value;
            if (!mz(x)) return N.issues.push({
                code: "invalid_type",
                expected: "object",
                input: x,
                inst: v
            }), N;
            let j = V.value.get(x?.[z.discriminator]);
            if (j) return j._zod.run(N, K);
            if (z.unionFallback) return U(N, K);
            return N.issues.push({
                code: "invalid_union",
                errors: [],
                note: "No matching discriminator",
                input: x,
                path: [z.discriminator],
                inst: v
            }), N
        }
    }),
    ct = l("$ZodIntersection", (v, z) => {
        Y0.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value,
                K = z.left._zod.run({
                    value: N,
                    issues: []
                }, V),
                x = z.right._zod.run({
                    value: N,
                    issues: []
                }, V);
            if (K instanceof Promise || x instanceof Promise) return Promise.all([K, x]).then(([j, B]) => {
                return AR(U, j, B)
            });
            return AR(U, K, x)
        }
    });

function KH(v, z) {
    if (v === z) return {
        valid: !0,
        data: v
    };
    if (v instanceof Date && z instanceof Date && +v === +z) return {
        valid: !0,
        data: v
    };
    if (Xz(v) && Xz(z)) {
        let U = Object.keys(z),
            V = Object.keys(v).filter((K) => U.indexOf(K) !== -1),
            N = {
                ...v,
                ...z
            };
        for (let K of V) {
            let x = KH(v[K], z[K]);
            if (!x.valid) return {
                valid: !1,
                mergeErrorPath: [K, ...x.mergeErrorPath]
            };
            N[K] = x.data
        }
        return {
            valid: !0,
            data: N
        }
    }
    if (Array.isArray(v) && Array.isArray(z)) {
        if (v.length !== z.length) return {
            valid: !1,
            mergeErrorPath: []
        };
        let U = [];
        for (let V = 0; V < v.length; V++) {
            let N = v[V],
                K = z[V],
                x = KH(N, K);
            if (!x.valid) return {
                valid: !1,
                mergeErrorPath: [V, ...x.mergeErrorPath]
            };
            U.push(x.data)
        }
        return {
            valid: !0,
            data: U
        }
    }
    return {
        valid: !1,
        mergeErrorPath: []
    }
}

function AR(v, z, U) {
    if (z.issues.length) v.issues.push(...z.issues);
    if (U.issues.length) v.issues.push(...U.issues);
    if (d7(v)) return v;
    let V = KH(z.value, U.value);
    if (!V.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(V.mergeErrorPath)}`);
    return v.value = V.data, v
}
var it = l("$ZodRecord", (v, z) => {
        Y0.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (!Xz(N)) return U.issues.push({
                expected: "record",
                code: "invalid_type",
                input: N,
                inst: v
            }), U;
            let K = [];
            if (z.keyType._zod.values) {
                let x = z.keyType._zod.values;
                U.value = {};
                for (let B of x)
                    if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
                        let O = z.valueType._zod.run({
                            value: N[B],
                            issues: []
                        }, V);
                        if (O instanceof Promise) K.push(O.then((J) => {
                            if (J.issues.length) U.issues.push(...p9(B, J.issues));
                            U.value[B] = J.value
                        }));
                        else {
                            if (O.issues.length) U.issues.push(...p9(B, O.issues));
                            U.value[B] = O.value
                        }
                    } let j;
                for (let B in N)
                    if (!x.has(B)) j = j ?? [], j.push(B);
                if (j && j.length > 0) U.issues.push({
                    code: "unrecognized_keys",
                    input: N,
                    inst: v,
                    keys: j
                })
            } else {
                U.value = {};
                for (let x of Reflect.ownKeys(N)) {
                    if (x === "__proto__") continue;
                    let j = z.keyType._zod.run({
                        value: x,
                        issues: []
                    }, V);
                    if (j instanceof Promise) throw Error("Async schemas not supported in object keys currently");
                    if (j.issues.length) {
                        U.issues.push({
                            origin: "record",
                            code: "invalid_key",
                            issues: j.issues.map((O) => x9(O, V, K9())),
                            input: x,
                            path: [x],
                            inst: v
                        }), U.value[j.value] = j.value;
                        continue
                    }
                    let B = z.valueType._zod.run({
                        value: N[x],
                        issues: []
                    }, V);
                    if (B instanceof Promise) K.push(B.then((O) => {
                        if (O.issues.length) U.issues.push(...p9(x, O.issues));
                        U.value[j.value] = O.value
                    }));
                    else {
                        if (B.issues.length) U.issues.push(...p9(x, B.issues));
                        U.value[j.value] = B.value
                    }
                }
            }
            if (K.length) return Promise.all(K).then(() => U);
            return U
        }
    }),
    lt = l("$ZodEnum", (v, z) => {
        Y0.init(v, z);
        let U = WH(z.entries);
        v._zod.values = new Set(U), v._zod.pattern = new RegExp(`^(${U.filter((V)=>PW.has(typeof V)).map((V)=>typeof V==="string"?jv(V):V.toString()).join("|")})$`), v._zod.parse = (V, N) => {
            let K = V.value;
            if (v._zod.values.has(K)) return V;
            return V.issues.push({
                code: "invalid_value",
                values: U,
                input: K,
                inst: v
            }), V
        }
    }),
    ht = l("$ZodLiteral", (v, z) => {
        Y0.init(v, z), v._zod.values = new Set(z.values), v._zod.pattern = new RegExp(`^(${z.values.map((U)=>typeof U==="string"?jv(U):U?U.toString():String(U)).join("|")})$`), v._zod.parse = (U, V) => {
            let N = U.value;
            if (v._zod.values.has(N)) return U;
            return U.issues.push({
                code: "invalid_value",
                values: z.values,
                input: N,
                inst: v
            }), U
        }
    }),
    pt = l("$ZodTransform", (v, z) => {
        Y0.init(v, z), v._zod.parse = (U, V) => {
            let N = z.transform(U.value, U);
            if (V.async) return (N instanceof Promise ? N : Promise.resolve(N)).then((K) => {
                return U.value = K, U
            });
            if (N instanceof Promise) throw new e7;
            return U.value = N, U
        }
    }),
    nt = l("$ZodOptional", (v, z) => {
        Y0.init(v, z), v._zod.optin = "optional", v._zod.optout = "optional", k0(v._zod, "values", () => {
            return z.innerType._zod.values ? new Set([...z.innerType._zod.values, void 0]) : void 0
        }), k0(v._zod, "pattern", () => {
            let U = z.innerType._zod.pattern;
            return U ? new RegExp(`^(${kK(U.source)})?$`) : void 0
        }), v._zod.parse = (U, V) => {
            if (z.innerType._zod.optin === "optional") return z.innerType._zod.run(U, V);
            if (U.value === void 0) return U;
            return z.innerType._zod.run(U, V)
        }
    }),
    Qt = l("$ZodNullable", (v, z) => {
        Y0.init(v, z), k0(v._zod, "optin", () => z.innerType._zod.optin), k0(v._zod, "optout", () => z.innerType._zod.optout), k0(v._zod, "pattern", () => {
            let U = z.innerType._zod.pattern;
            return U ? new RegExp(`^(${kK(U.source)}|null)$`) : void 0
        }), k0(v._zod, "values", () => {
            return z.innerType._zod.values ? new Set([...z.innerType._zod.values, null]) : void 0
        }), v._zod.parse = (U, V) => {
            if (U.value === null) return U;
            return z.innerType._zod.run(U, V)
        }
    }),
    dt = l("$ZodDefault", (v, z) => {
        Y0.init(v, z), v._zod.optin = "optional", k0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            if (U.value === void 0) return U.value = z.defaultValue, U;
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => $R(K, z));
            return $R(N, z)
        }
    });

function $R(v, z) {
    if (v.value === void 0) v.value = z.defaultValue;
    return v
}
var ot = l("$ZodPrefault", (v, z) => {
        Y0.init(v, z), v._zod.optin = "optional", k0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            if (U.value === void 0) U.value = z.defaultValue;
            return z.innerType._zod.run(U, V)
        }
    }),
    rt = l("$ZodNonOptional", (v, z) => {
        Y0.init(v, z), k0(v._zod, "values", () => {
            let U = z.innerType._zod.values;
            return U ? new Set([...U].filter((V) => V !== void 0)) : void 0
        }), v._zod.parse = (U, V) => {
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => wR(K, v));
            return wR(N, v)
        }
    });

function wR(v, z) {
    if (!v.issues.length && v.value === void 0) v.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: v.value,
        inst: z
    });
    return v
}
var at = l("$ZodCatch", (v, z) => {
        Y0.init(v, z), v._zod.optin = "optional", k0(v._zod, "optout", () => z.innerType._zod.optout), k0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => {
                if (U.value = K.value, K.issues.length) U.value = z.catchValue({
                    ...U,
                    error: {
                        issues: K.issues.map((x) => x9(x, V, K9()))
                    },
                    input: U.value
                }), U.issues = [];
                return U
            });
            if (U.value = N.value, N.issues.length) U.value = z.catchValue({
                ...U,
                error: {
                    issues: N.issues.map((K) => x9(K, V, K9()))
                },
                input: U.value
            }), U.issues = [];
            return U
        }
    }),
    tt = l("$ZodPipe", (v, z) => {
        Y0.init(v, z), k0(v._zod, "values", () => z.in._zod.values), k0(v._zod, "optin", () => z.in._zod.optin), k0(v._zod, "optout", () => z.out._zod.optout), v._zod.parse = (U, V) => {
            let N = z.in._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => ZR(K, z, V));
            return ZR(N, z, V)
        }
    });

function ZR(v, z, U) {
    if (d7(v)) return v;
    return z.out._zod.run({
        value: v.value,
        issues: v.issues
    }, U)
}
var st = l("$ZodReadonly", (v, z) => {
    Y0.init(v, z), k0(v._zod, "propValues", () => z.innerType._zod.propValues), k0(v._zod, "values", () => z.innerType._zod.values), k0(v._zod, "optin", () => z.innerType._zod.optin), k0(v._zod, "optout", () => z.innerType._zod.optout), v._zod.parse = (U, V) => {
        let N = z.innerType._zod.run(U, V);
        if (N instanceof Promise) return N.then(LR);
        return LR(N)
    }
});

function LR(v) {
    return v.value = Object.freeze(v.value), v
}
var et = l("$ZodCustom", (v, z) => {
    q3.init(v, z), Y0.init(v, z), v._zod.parse = (U, V) => {
        return U
    }, v._zod.check = (U) => {
        let V = U.value,
            N = z.fn(V);
        if (N instanceof Promise) return N.then((K) => FR(K, U, V, v));
        FR(N, U, V, v);
        return
    }
});

function FR(v, z, U, V) {
    if (!v) {
        let N = {
            code: "custom",
            input: U,
            inst: V,
            path: [...V._zod.def.path ?? []],
            continue: !V._zod.def.abort
        };
        if (V._zod.def.params) N.params = V._zod.def.params;
        z.issues.push(fW(N))
    }
}
var vs = (v) => {
        let z = typeof v;
        switch (z) {
            case "number":
                return Number.isNaN(v) ? "NaN" : "number";
            case "object": {
                if (Array.isArray(v)) return "array";
                if (v === null) return "null";
                if (Object.getPrototypeOf(v) !== Object.prototype && v.constructor) return v.constructor.name
            }
        }
        return z
    },
    zs = () => {
        let v = {
            string: {
                unit: "characters",
                verb: "to have"
            },
            file: {
                unit: "bytes",
                verb: "to have"
            },
            array: {
                unit: "items",
                verb: "to have"
            },
            set: {
                unit: "items",
                verb: "to have"
            }
        };

        function z(V) {
            return v[V] ?? null
        }
        let U = {
            regex: "input",
            email: "email address",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO datetime",
            date: "ISO date",
            time: "ISO time",
            duration: "ISO duration",
            ipv4: "IPv4 address",
            ipv6: "IPv6 address",
            cidrv4: "IPv4 range",
            cidrv6: "IPv6 range",
            base64: "base64-encoded string",
            base64url: "base64url-encoded string",
            json_string: "JSON string",
            e164: "E.164 number",
            jwt: "JWT",
            template_literal: "input"
        };
        return (V) => {
            switch (V.code) {
                case "invalid_type":
                    return `Invalid input: expected ${V.expected}, received ${vs(V.input)}`;
                case "invalid_value":
                    if (V.values.length === 1) return `Invalid input: expected ${PH(V.values[0])}`;
                    return `Invalid option: expected one of ${NH(V.values,"|")}`;
                case "too_big": {
                    let N = V.inclusive ? "<=" : "<",
                        K = z(V.origin);
                    if (K) return `Too big: expected ${V.origin??"value"} to have ${N}${V.maximum.toString()} ${K.unit??"elements"}`;
                    return `Too big: expected ${V.origin??"value"} to be ${N}${V.maximum.toString()}`
                }
                case "too_small": {
                    let N = V.inclusive ? ">=" : ">",
                        K = z(V.origin);
                    if (K) return `Too small: expected ${V.origin} to have ${N}${V.minimum.toString()} ${K.unit}`;
                    return `Too small: expected ${V.origin} to be ${N}${V.minimum.toString()}`
                }
                case "invalid_format": {
                    let N = V;
                    if (N.format === "starts_with") return `Invalid string: must start with "${N.prefix}"`;
                    if (N.format === "ends_with") return `Invalid string: must end with "${N.suffix}"`;
                    if (N.format === "includes") return `Invalid string: must include "${N.includes}"`;
                    if (N.format === "regex") return `Invalid string: must match pattern ${N.pattern}`;
                    return `Invalid ${U[N.format]??V.format}`
                }
                case "not_multiple_of":
                    return `Invalid number: must be a multiple of ${V.divisor}`;
                case "unrecognized_keys":
                    return `Unrecognized key${V.keys.length>1?"s":""}: ${NH(V.keys,", ")}`;
                case "invalid_key":
                    return `Invalid key in ${V.origin}`;
                case "invalid_union":
                    return "Invalid input";
                case "invalid_element":
                    return `Invalid value in ${V.origin}`;
                default:
                    return "Invalid input"
            }
        }
    };

function Us() {
    return {
        localeError: zs()
    }
}
var EZ6 = Symbol("ZodOutput"),
    SZ6 = Symbol("ZodInput");
class TH {
    constructor() {
        this._map = new WeakMap, this._idmap = new Map
    }
    add(v, ...z) {
        let U = z[0];
        if (this._map.set(v, U), U && typeof U === "object" && "id" in U) {
            if (this._idmap.has(U.id)) throw Error(`ID ${U.id} already exists in the registry`);
            this._idmap.set(U.id, v)
        }
        return this
    }
    remove(v) {
        return this._map.delete(v), this
    }
    get(v) {
        let z = v._zod.parent;
        if (z) {
            let U = {
                ...this.get(z) ?? {}
            };
            return delete U.id, {
                ...U,
                ...this._map.get(v)
            }
        }
        return this._map.get(v)
    }
    has(v) {
        return this._map.has(v)
    }
}

function Vs() {
    return new TH
}
var Gz = Vs();

function Ns(v, z) {
    return new v({
        type: "string",
        ...m6(z)
    })
}

function Ks(v, z) {
    return new v({
        type: "string",
        format: "email",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function GR(v, z) {
    return new v({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function xs(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function js(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v4",
        ...m6(z)
    })
}

function Bs(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v6",
        ...m6(z)
    })
}

function Os(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v7",
        ...m6(z)
    })
}

function Js(v, z) {
    return new v({
        type: "string",
        format: "url",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function qs(v, z) {
    return new v({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Hs(v, z) {
    return new v({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Ds(v, z) {
    return new v({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function As(v, z) {
    return new v({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function $s(v, z) {
    return new v({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function ws(v, z) {
    return new v({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Zs(v, z) {
    return new v({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Ls(v, z) {
    return new v({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Fs(v, z) {
    return new v({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Gs(v, z) {
    return new v({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Is(v, z) {
    return new v({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Ms(v, z) {
    return new v({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function bs(v, z) {
    return new v({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Rs(v, z) {
    return new v({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Ws(v, z) {
    return new v({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: !1,
        ...m6(z)
    })
}

function Es(v, z) {
    return new v({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: !1,
        local: !1,
        precision: null,
        ...m6(z)
    })
}

function Ss(v, z) {
    return new v({
        type: "string",
        format: "date",
        check: "string_format",
        ...m6(z)
    })
}

function Ps(v, z) {
    return new v({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...m6(z)
    })
}

function _s(v, z) {
    return new v({
        type: "string",
        format: "duration",
        check: "string_format",
        ...m6(z)
    })
}

function Cs(v, z) {
    return new v({
        type: "number",
        checks: [],
        ...m6(z)
    })
}

function fs(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "safeint",
        ...m6(z)
    })
}

function Ts(v, z) {
    return new v({
        type: "boolean",
        ...m6(z)
    })
}

function Ys(v, z) {
    return new v({
        type: "null",
        ...m6(z)
    })
}

function us(v) {
    return new v({
        type: "unknown"
    })
}

function ys(v, z) {
    return new v({
        type: "never",
        ...m6(z)
    })
}

function IR(v, z) {
    return new hW({
        check: "less_than",
        ...m6(z),
        value: v,
        inclusive: !1
    })
}

function pq(v, z) {
    return new hW({
        check: "less_than",
        ...m6(z),
        value: v,
        inclusive: !0
    })
}

function MR(v, z) {
    return new pW({
        check: "greater_than",
        ...m6(z),
        value: v,
        inclusive: !1
    })
}

function nq(v, z) {
    return new pW({
        check: "greater_than",
        ...m6(z),
        value: v,
        inclusive: !0
    })
}

function bR(v, z) {
    return new ra({
        check: "multiple_of",
        ...m6(z),
        value: v
    })
}

function aW(v, z) {
    return new ta({
        check: "max_length",
        ...m6(z),
        maximum: v
    })
}

function IK(v, z) {
    return new sa({
        check: "min_length",
        ...m6(z),
        minimum: v
    })
}

function tW(v, z) {
    return new ea({
        check: "length_equals",
        ...m6(z),
        length: v
    })
}

function ks(v, z) {
    return new vt({
        check: "string_format",
        format: "regex",
        ...m6(z),
        pattern: v
    })
}

function ms(v) {
    return new zt({
        check: "string_format",
        format: "lowercase",
        ...m6(v)
    })
}

function Xs(v) {
    return new Ut({
        check: "string_format",
        format: "uppercase",
        ...m6(v)
    })
}

function gs(v, z) {
    return new Vt({
        check: "string_format",
        format: "includes",
        ...m6(z),
        includes: v
    })
}

function cs(v, z) {
    return new Nt({
        check: "string_format",
        format: "starts_with",
        ...m6(z),
        prefix: v
    })
}

function is(v, z) {
    return new Kt({
        check: "string_format",
        format: "ends_with",
        ...m6(z),
        suffix: v
    })
}

function gz(v) {
    return new xt({
        check: "overwrite",
        tx: v
    })
}

function ls(v) {
    return gz((z) => z.normalize(v))
}

function hs() {
    return gz((v) => v.trim())
}

function ps() {
    return gz((v) => v.toLowerCase())
}

function ns() {
    return gz((v) => v.toUpperCase())
}

function Qs(v, z, U) {
    return new v({
        type: "array",
        element: z,
        ...m6(U)
    })
}

function ds(v, z, U) {
    let V = m6(U);
    return V.abort ?? (V.abort = !0), new v({
        type: "custom",
        check: "custom",
        fn: z,
        ...V
    })
}

function os(v, z, U) {
    return new v({
        type: "custom",
        check: "custom",
        fn: z,
        ...m6(U)
    })
}
class xH {
    constructor(v) {
        this.counter = 0, this.metadataRegistry = v?.metadata ?? Gz, this.target = v?.target ?? "draft-2020-12", this.unrepresentable = v?.unrepresentable ?? "throw", this.override = v?.override ?? (() => {}), this.io = v?.io ?? "output", this.seen = new Map
    }
    process(v, z = {
        path: [],
        schemaPath: []
    }) {
        var U;
        let V = v._zod.def,
            N = {
                guid: "uuid",
                url: "uri",
                datetime: "date-time",
                json_string: "json-string",
                regex: ""
            },
            K = this.seen.get(v);
        if (K) {
            if (K.count++, z.schemaPath.includes(v)) K.cycle = z.path;
            return K.schema
        }
        let x = {
            schema: {},
            count: 1,
            cycle: void 0,
            path: z.path
        };
        this.seen.set(v, x);
        let j = v._zod.toJSONSchema?.();
        if (j) x.schema = j;
        else {
            let O = {
                    ...z,
                    schemaPath: [...z.schemaPath, v],
                    path: z.path
                },
                J = v._zod.parent;
            if (J) x.ref = J, this.process(J, O), this.seen.get(J).isParent = !0;
            else {
                let q = x.schema;
                switch (V.type) {
                    case "string": {
                        let H = q;
                        H.type = "string";
                        let {
                            minimum: D,
                            maximum: A,
                            format: w,
                            patterns: Z,
                            contentEncoding: $
                        } = v._zod.bag;
                        if (typeof D === "number") H.minLength = D;
                        if (typeof A === "number") H.maxLength = A;
                        if (w) {
                            if (H.format = N[w] ?? w, H.format === "") delete H.format
                        }
                        if ($) H.contentEncoding = $;
                        if (Z && Z.size > 0) {
                            let F = [...Z];
                            if (F.length === 1) H.pattern = F[0].source;
                            else if (F.length > 1) x.schema.allOf = [...F.map((L) => ({
                                ...this.target === "draft-7" ? {
                                    type: "string"
                                } : {},
                                pattern: L.source
                            }))]
                        }
                        break
                    }
                    case "number": {
                        let H = q,
                            {
                                minimum: D,
                                maximum: A,
                                format: w,
                                multipleOf: Z,
                                exclusiveMaximum: $,
                                exclusiveMinimum: F
                            } = v._zod.bag;
                        if (typeof w === "string" && w.includes("int")) H.type = "integer";
                        else H.type = "number";
                        if (typeof F === "number") H.exclusiveMinimum = F;
                        if (typeof D === "number") {
                            if (H.minimum = D, typeof F === "number")
                                if (F >= D) delete H.minimum;
                                else delete H.exclusiveMinimum
                        }
                        if (typeof $ === "number") H.exclusiveMaximum = $;
                        if (typeof A === "number") {
                            if (H.maximum = A, typeof $ === "number")
                                if ($ <= A) delete H.maximum;
                                else delete H.exclusiveMaximum
                        }
                        if (typeof Z === "number") H.multipleOf = Z;
                        break
                    }
                    case "boolean": {
                        let H = q;
                        H.type = "boolean";
                        break
                    }
                    case "bigint": {
                        if (this.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
                        break
                    }
                    case "symbol": {
                        if (this.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
                        break
                    }
                    case "null": {
                        q.type = "null";
                        break
                    }
                    case "any":
                        break;
                    case "unknown":
                        break;
                    case "undefined":
                    case "never": {
                        q.not = {};
                        break
                    }
                    case "void": {
                        if (this.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
                        break
                    }
                    case "date": {
                        if (this.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
                        break
                    }
                    case "array": {
                        let H = q,
                            {
                                minimum: D,
                                maximum: A
                            } = v._zod.bag;
                        if (typeof D === "number") H.minItems = D;
                        if (typeof A === "number") H.maxItems = A;
                        H.type = "array", H.items = this.process(V.element, {
                            ...O,
                            path: [...O.path, "items"]
                        });
                        break
                    }
                    case "object": {
                        let H = q;
                        H.type = "object", H.properties = {};
                        let D = V.shape;
                        for (let Z in D) H.properties[Z] = this.process(D[Z], {
                            ...O,
                            path: [...O.path, "properties", Z]
                        });
                        let A = new Set(Object.keys(D)),
                            w = new Set([...A].filter((Z) => {
                                let $ = V.shape[Z]._zod;
                                if (this.io === "input") return $.optin === void 0;
                                else return $.optout === void 0
                            }));
                        if (w.size > 0) H.required = Array.from(w);
                        if (V.catchall?._zod.def.type === "never") H.additionalProperties = !1;
                        else if (!V.catchall) {
                            if (this.io === "output") H.additionalProperties = !1
                        } else if (V.catchall) H.additionalProperties = this.process(V.catchall, {
                            ...O,
                            path: [...O.path, "additionalProperties"]
                        });
                        break
                    }
                    case "union": {
                        let H = q;
                        H.anyOf = V.options.map((D, A) => this.process(D, {
                            ...O,
                            path: [...O.path, "anyOf", A]
                        }));
                        break
                    }
                    case "intersection": {
                        let H = q,
                            D = this.process(V.left, {
                                ...O,
                                path: [...O.path, "allOf", 0]
                            }),
                            A = this.process(V.right, {
                                ...O,
                                path: [...O.path, "allOf", 1]
                            }),
                            w = ($) => ("allOf" in $) && Object.keys($).length === 1,
                            Z = [...w(D) ? D.allOf : [D], ...w(A) ? A.allOf : [A]];
                        H.allOf = Z;
                        break
                    }
                    case "tuple": {
                        let H = q;
                        H.type = "array";
                        let D = V.items.map((Z, $) => this.process(Z, {
                            ...O,
                            path: [...O.path, "prefixItems", $]
                        }));
                        if (this.target === "draft-2020-12") H.prefixItems = D;
                        else H.items = D;
                        if (V.rest) {
                            let Z = this.process(V.rest, {
                                ...O,
                                path: [...O.path, "items"]
                            });
                            if (this.target === "draft-2020-12") H.items = Z;
                            else H.additionalItems = Z
                        }
                        if (V.rest) H.items = this.process(V.rest, {
                            ...O,
                            path: [...O.path, "items"]
                        });
                        let {
                            minimum: A,
                            maximum: w
                        } = v._zod.bag;
                        if (typeof A === "number") H.minItems = A;
                        if (typeof w === "number") H.maxItems = w;
                        break
                    }
                    case "record": {
                        let H = q;
                        H.type = "object", H.propertyNames = this.process(V.keyType, {
                            ...O,
                            path: [...O.path, "propertyNames"]
                        }), H.additionalProperties = this.process(V.valueType, {
                            ...O,
                            path: [...O.path, "additionalProperties"]
                        });
                        break
                    }
                    case "map": {
                        if (this.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
                        break
                    }
                    case "set": {
                        if (this.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
                        break
                    }
                    case "enum": {
                        let H = q,
                            D = WH(V.entries);
                        if (D.every((A) => typeof A === "number")) H.type = "number";
                        if (D.every((A) => typeof A === "string")) H.type = "string";
                        H.enum = D;
                        break
                    }
                    case "literal": {
                        let H = q,
                            D = [];
                        for (let A of V.values)
                            if (A === void 0) {
                                if (this.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema")
                            } else if (typeof A === "bigint")
                            if (this.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
                            else D.push(Number(A));
                        else D.push(A);
                        if (D.length === 0);
                        else if (D.length === 1) {
                            let A = D[0];
                            H.type = A === null ? "null" : typeof A, H.const = A
                        } else {
                            if (D.every((A) => typeof A === "number")) H.type = "number";
                            if (D.every((A) => typeof A === "string")) H.type = "string";
                            if (D.every((A) => typeof A === "boolean")) H.type = "string";
                            if (D.every((A) => A === null)) H.type = "null";
                            H.enum = D
                        }
                        break
                    }
                    case "file": {
                        let H = q,
                            D = {
                                type: "string",
                                format: "binary",
                                contentEncoding: "binary"
                            },
                            {
                                minimum: A,
                                maximum: w,
                                mime: Z
                            } = v._zod.bag;
                        if (A !== void 0) D.minLength = A;
                        if (w !== void 0) D.maxLength = w;
                        if (Z)
                            if (Z.length === 1) D.contentMediaType = Z[0], Object.assign(H, D);
                            else H.anyOf = Z.map(($) => {
                                return {
                                    ...D,
                                    contentMediaType: $
                                }
                            });
                        else Object.assign(H, D);
                        break
                    }
                    case "transform": {
                        if (this.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
                        break
                    }
                    case "nullable": {
                        let H = this.process(V.innerType, O);
                        q.anyOf = [H, {
                            type: "null"
                        }];
                        break
                    }
                    case "nonoptional": {
                        this.process(V.innerType, O), x.ref = V.innerType;
                        break
                    }
                    case "success": {
                        let H = q;
                        H.type = "boolean";
                        break
                    }
                    case "default": {
                        this.process(V.innerType, O), x.ref = V.innerType, q.default = JSON.parse(JSON.stringify(V.defaultValue));
                        break
                    }
                    case "prefault": {
                        if (this.process(V.innerType, O), x.ref = V.innerType, this.io === "input") q._prefault = JSON.parse(JSON.stringify(V.defaultValue));
                        break
                    }
                    case "catch": {
                        this.process(V.innerType, O), x.ref = V.innerType;
                        let H;
                        try {
                            H = V.catchValue(void 0)
                        } catch {
                            throw Error("Dynamic catch values are not supported in JSON Schema")
                        }
                        q.default = H;
                        break
                    }
                    case "nan": {
                        if (this.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
                        break
                    }
                    case "template_literal": {
                        let H = q,
                            D = v._zod.pattern;
                        if (!D) throw Error("Pattern not found in template literal");
                        H.type = "string", H.pattern = D.source;
                        break
                    }
                    case "pipe": {
                        let H = this.io === "input" ? V.in._zod.def.type === "transform" ? V.out : V.in : V.out;
                        this.process(H, O), x.ref = H;
                        break
                    }
                    case "readonly": {
                        this.process(V.innerType, O), x.ref = V.innerType, q.readOnly = !0;
                        break
                    }
                    case "promise": {
                        this.process(V.innerType, O), x.ref = V.innerType;
                        break
                    }
                    case "optional": {
                        this.process(V.innerType, O), x.ref = V.innerType;
                        break
                    }
                    case "lazy": {
                        let H = v._zod.innerType;
                        this.process(H, O), x.ref = H;
                        break
                    }
                    case "custom": {
                        if (this.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
                        break
                    }
                    default:
                }
            }
        }
        let B = this.metadataRegistry.get(v);
        if (B) Object.assign(x.schema, B);
        if (this.io === "input" && H4(v)) delete x.schema.examples, delete x.schema.default;
        if (this.io === "input" && x.schema._prefault)(U = x.schema).default ?? (U.default = x.schema._prefault);
        return delete x.schema._prefault, this.seen.get(v).schema
    }
    emit(v, z) {
        let U = {
                cycles: z?.cycles ?? "ref",
                reused: z?.reused ?? "inline",
                external: z?.external ?? void 0
            },
            V = this.seen.get(v);
        if (!V) throw Error("Unprocessed schema. This is a bug in Zod.");
        let N = (O) => {
                let J = this.target === "draft-2020-12" ? "$defs" : "definitions";
                if (U.external) {
                    let D = U.external.registry.get(O[0])?.id;
                    if (D) return {
                        ref: U.external.uri(D)
                    };
                    let A = O[1].defId ?? O[1].schema.id ?? `schema${this.counter++}`;
                    return O[1].defId = A, {
                        defId: A,
                        ref: `${U.external.uri("__shared")}#/${J}/${A}`
                    }
                }
                if (O[1] === V) return {
                    ref: "#"
                };
                let q = `#/${J}/`,
                    H = O[1].schema.id ?? `__schema${this.counter++}`;
                return {
                    defId: H,
                    ref: q + H
                }
            },
            K = (O) => {
                if (O[1].schema.$ref) return;
                let J = O[1],
                    {
                        ref: q,
                        defId: H
                    } = N(O);
                if (J.def = {
                        ...J.schema
                    }, H) J.defId = H;
                let D = J.schema;
                for (let A in D) delete D[A];
                D.$ref = q
            };
        for (let O of this.seen.entries()) {
            let J = O[1];
            if (v === O[0]) {
                K(O);
                continue
            }
            if (U.external) {
                let q = U.external.registry.get(O[0])?.id;
                if (v !== O[0] && q) {
                    K(O);
                    continue
                }
            }
            if (this.metadataRegistry.get(O[0])?.id) {
                K(O);
                continue
            }
            if (J.cycle) {
                if (U.cycles === "throw") throw Error(`Cycle detected: #/${J.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
                else if (U.cycles === "ref") K(O);
                continue
            }
            if (J.count > 1) {
                if (U.reused === "ref") {
                    K(O);
                    continue
                }
            }
        }
        let x = (O, J) => {
            let q = this.seen.get(O),
                H = q.def ?? q.schema,
                D = {
                    ...H
                };
            if (q.ref === null) return;
            let A = q.ref;
            if (q.ref = null, A) {
                x(A, J);
                let w = this.seen.get(A).schema;
                if (w.$ref && J.target === "draft-7") H.allOf = H.allOf ?? [], H.allOf.push(w);
                else Object.assign(H, w), Object.assign(H, D)
            }
            if (!q.isParent) this.override({
                zodSchema: O,
                jsonSchema: H,
                path: q.path ?? []
            })
        };
        for (let O of [...this.seen.entries()].reverse()) x(O[0], {
            target: this.target
        });
        let j = {};
        if (this.target === "draft-2020-12") j.$schema = "https://json-schema.org/draft/2020-12/schema";
        else if (this.target === "draft-7") j.$schema = "http://json-schema.org/draft-07/schema#";
        else console.warn(`Invalid target: ${this.target}`);
        Object.assign(j, V.def);
        let B = U.external?.defs ?? {};
        for (let O of this.seen.entries()) {
            let J = O[1];
            if (J.def && J.defId) B[J.defId] = J.def
        }
        if (!U.external && Object.keys(B).length > 0)
            if (this.target === "draft-2020-12") j.$defs = B;
            else j.definitions = B;
        try {
            return JSON.parse(JSON.stringify(j))
        } catch (O) {
            throw Error("Error converting schema to JSON.")
        }
    }
}

function rs(v, z) {
    if (v instanceof TH) {
        let V = new xH(z),
            N = {};
        for (let j of v._idmap.entries()) {
            let [B, O] = j;
            V.process(O)
        }
        let K = {},
            x = {
                registry: v,
                uri: z?.uri || ((j) => j),
                defs: N
            };
        for (let j of v._idmap.entries()) {
            let [B, O] = j;
            K[B] = V.emit(O, {
                ...z,
                external: x
            })
        }
        if (Object.keys(N).length > 0) {
            let j = V.target === "draft-2020-12" ? "$defs" : "definitions";
            K.__shared = {
                [j]: N
            }
        }
        return {
            schemas: K
        }
    }
    let U = new xH(z);
    return U.process(v), U.emit(v, z)
}

function H4(v, z) {
    let U = z ?? {
        seen: new Set
    };
    if (U.seen.has(v)) return !1;
    U.seen.add(v);
    let V = v._zod.def;
    switch (V.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
            return !1;
        case "array":
            return H4(V.element, U);
        case "object": {
            for (let N in V.shape)
                if (H4(V.shape[N], U)) return !0;
            return !1
        }
        case "union": {
            for (let N of V.options)
                if (H4(N, U)) return !0;
            return !1
        }
        case "intersection":
            return H4(V.left, U) || H4(V.right, U);
        case "tuple": {
            for (let N of V.items)
                if (H4(N, U)) return !0;
            if (V.rest && H4(V.rest, U)) return !0;
            return !1
        }
        case "record":
            return H4(V.keyType, U) || H4(V.valueType, U);
        case "map":
            return H4(V.keyType, U) || H4(V.valueType, U);
        case "set":
            return H4(V.valueType, U);
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
            return H4(V.innerType, U);
        case "lazy":
            return H4(V.getter(), U);
        case "default":
            return H4(V.innerType, U);
        case "prefault":
            return H4(V.innerType, U);
        case "custom":
            return !1;
        case "transform":
            return !0;
        case "pipe":
            return H4(V.in, U) || H4(V.out, U);
        case "success":
            return !1;
        case "catch":
            return !1;
        default:
    }
    throw Error(`Unknown schema type: ${V.type}`)
}
var as = l("ZodMiniType", (v, z) => {
        if (!v._zod) throw Error("Uninitialized schema in ZodMiniType.");
        Y0.init(v, z), v.def = z, v.parse = (U, V) => Ga(v, U, V, {
            callee: v.parse
        }), v.safeParse = (U, V) => _H(v, U, V), v.parseAsync = async (U, V) => Ia(v, U, V, {
            callee: v.parseAsync
        }), v.safeParseAsync = async (U, V) => CH(v, U, V), v.check = (...U) => {
            return v.clone({
                ...z,
                checks: [...z.checks ?? [], ...U.map((V) => typeof V === "function" ? {
                    _zod: {
                        check: V,
                        def: {
                            check: "custom"
                        },
                        onattach: []
                    }
                } : V)]
            })
        }, v.clone = (U, V) => j9(v, U, V), v.brand = () => v, v.register = (U, V) => {
            return U.add(v, V), v
        }
    }),
    ts = l("ZodMiniObject", (v, z) => {
        oW.init(v, z), as.init(v, z), E0.defineLazy(v, "shape", () => z.shape)
    });

function RR(v, z) {
    let U = {
        type: "object",
        get shape() {
            return E0.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        ...E0.normalizeParams(z)
    };
    return new ts(U)
}

function U8(v) {
    return !!v._zod
}

function Mz(v) {
    let z = Object.values(v);
    if (z.length === 0) return RR({});
    let U = z.every(U8),
        V = z.every((N) => !U8(N));
    if (U) return RR(v);
    if (V) return ar(v);
    throw Error("Mixed Zod versions detected in object shape.")
}

function bz(v, z) {
    if (U8(v)) return _H(v, z);
    return v.safeParse(z)
}
async function Qq(v, z) {
    if (U8(v)) return await CH(v, z);
    return await v.safeParseAsync(z)
}

function cz(v) {
    var z, U;
    if (!v) return;
    let V;
    if (U8(v)) V = (U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.shape;
    else V = v.shape;
    if (!V) return;
    if (typeof V === "function") try {
        return V()
    } catch (N) {
        return
    }
    return V
}

function wz(v) {
    var z;
    if (!v) return;
    if (typeof v === "object") {
        let U = v,
            V = v;
        if (!U._def && !V._zod) {
            let N = Object.values(v);
            if (N.length > 0 && N.every((K) => typeof K === "object" && K !== null && (K._def !== void 0 || K._zod !== void 0 || typeof K.parse === "function"))) return Mz(v)
        }
    }
    if (U8(v)) {
        let U = (z = v._zod) === null || z === void 0 ? void 0 : z.def;
        if (U && (U.type === "object" || U.shape !== void 0)) return v
    } else if (v.shape !== void 0) return v;
    return
}

function dq(v) {
    if (v && typeof v === "object") {
        if ("message" in v && typeof v.message === "string") return v.message;
        if ("issues" in v && Array.isArray(v.issues) && v.issues.length > 0) {
            let z = v.issues[0];
            if (z && typeof z === "object" && "message" in z) return String(z.message)
        }
        try {
            return JSON.stringify(v)
        } catch (z) {
            return String(v)
        }
    }
    return String(v)
}

function ss(v) {
    var z, U, V, N;
    if (U8(v)) return (U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.description;
    let K = v;
    return (V = v.description) !== null && V !== void 0 ? V : (N = K._def) === null || N === void 0 ? void 0 : N.description
}

function es(v) {
    var z, U, V;
    if (U8(v)) return ((U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.type) === "optional";
    let N = v;
    if (typeof v.isOptional === "function") return v.isOptional();
    return ((V = N._def) === null || V === void 0 ? void 0 : V.typeName) === "ZodOptional"
}

function sW(v) {
    var z;
    if (U8(v)) {
        let N = (z = v._zod) === null || z === void 0 ? void 0 : z.def;
        if (N) {
            if (N.value !== void 0) return N.value;
            if (Array.isArray(N.values) && N.values.length > 0) return N.values[0]
        }
    }
    let U = v._def;
    if (U) {
        if (U.value !== void 0) return U.value;
        if (Array.isArray(U.values) && U.values.length > 0) return U.values[0]
    }
    let V = v.value;
    if (V !== void 0) return V;
    return
}
var eW = {};
iR(eW, {
    time: () => KE,
    duration: () => jE,
    datetime: () => zE,
    date: () => VE,
    ZodISOTime: () => NE,
    ZodISODuration: () => xE,
    ZodISODateTime: () => vE,
    ZodISODate: () => UE
});
var vE = l("ZodISODateTime", (v, z) => {
    Ft.init(v, z), d0.init(v, z)
});

function zE(v) {
    return Es(vE, v)
}
var UE = l("ZodISODate", (v, z) => {
    Gt.init(v, z), d0.init(v, z)
});

function VE(v) {
    return Ss(UE, v)
}
var NE = l("ZodISOTime", (v, z) => {
    It.init(v, z), d0.init(v, z)
});

function KE(v) {
    return Ps(NE, v)
}
var xE = l("ZodISODuration", (v, z) => {
    Mt.init(v, z), d0.init(v, z)
});

function jE(v) {
    return _s(xE, v)
}
var BE = (v, z) => {
        uW.init(v, z), v.name = "ZodError", Object.defineProperties(v, {
            format: {
                value: (U) => Fa(v, U)
            },
            flatten: {
                value: (U) => La(v, U)
            },
            addIssue: {
                value: (U) => v.issues.push(U)
            },
            addIssues: {
                value: (U) => v.issues.push(...U)
            },
            isEmpty: {
                get() {
                    return v.issues.length === 0
                }
            }
        })
    },
    PZ6 = l("ZodError", BE),
    cK = l("ZodError", BE, {
        Parent: Error
    }),
    ve = yW(cK),
    ze = kW(cK),
    Ue = mW(cK),
    Ve = XW(cK),
    Q0 = l("ZodType", (v, z) => {
        return Y0.init(v, z), v.def = z, Object.defineProperty(v, "_def", {
            value: z
        }), v.check = (...U) => {
            return v.clone({
                ...z,
                checks: [...z.checks ?? [], ...U.map((V) => typeof V === "function" ? {
                    _zod: {
                        check: V,
                        def: {
                            check: "custom"
                        },
                        onattach: []
                    }
                } : V)]
            })
        }, v.clone = (U, V) => j9(v, U, V), v.brand = () => v, v.register = (U, V) => {
            return U.add(v, V), v
        }, v.parse = (U, V) => ve(v, U, V, {
            callee: v.parse
        }), v.safeParse = (U, V) => Ue(v, U, V), v.parseAsync = async (U, V) => ze(v, U, V, {
            callee: v.parseAsync
        }), v.safeParseAsync = async (U, V) => Ve(v, U, V), v.spa = v.safeParseAsync, v.refine = (U, V) => v.check(de(U, V)), v.superRefine = (U) => v.check(oe(U)), v.overwrite = (U) => v.check(gz(U)), v.optional = () => W6(v), v.nullable = () => SR(v), v.nullish = () => W6(SR(v)), v.nonoptional = (U) => ge(v, U), v.array = () => q0(v), v.or = (U) => i0([v, U]), v.and = (U) => YH(v, U), v.transform = (U) => BH(v, $E(U)), v.default = (U) => ke(v, U), v.prefault = (U) => Xe(v, U), v.catch = (U) => ie(v, U), v.pipe = (U) => BH(v, U), v.readonly = () => pe(v), v.describe = (U) => {
            let V = v.clone();
            return Gz.add(V, {
                description: U
            }), V
        }, Object.defineProperty(v, "description", {
            get() {
                return Gz.get(v)?.description
            },
            configurable: !0
        }), v.meta = (...U) => {
            if (U.length === 0) return Gz.get(v);
            let V = v.clone();
            return Gz.add(V, U[0]), V
        }, v.isOptional = () => v.safeParse(void 0).success, v.isNullable = () => v.safeParse(null).success, v
    }),
    OE = l("_ZodString", (v, z) => {
        fH.init(v, z), Q0.init(v, z);
        let U = v._zod.bag;
        v.format = U.format ?? null, v.minLength = U.minimum ?? null, v.maxLength = U.maximum ?? null, v.regex = (...V) => v.check(ks(...V)), v.includes = (...V) => v.check(gs(...V)), v.startsWith = (...V) => v.check(cs(...V)), v.endsWith = (...V) => v.check(is(...V)), v.min = (...V) => v.check(IK(...V)), v.max = (...V) => v.check(aW(...V)), v.length = (...V) => v.check(tW(...V)), v.nonempty = (...V) => v.check(IK(1, ...V)), v.lowercase = (V) => v.check(ms(V)), v.uppercase = (V) => v.check(Xs(V)), v.trim = () => v.check(hs()), v.normalize = (...V) => v.check(ls(...V)), v.toLowerCase = () => v.check(ps()), v.toUpperCase = () => v.check(ns())
    }),
    Ne = l("ZodString", (v, z) => {
        fH.init(v, z), OE.init(v, z), v.email = (U) => v.check(Ks(Ke, U)), v.url = (U) => v.check(Js(xe, U)), v.jwt = (U) => v.check(Ws(Ie, U)), v.emoji = (U) => v.check(qs(je, U)), v.guid = (U) => v.check(GR(WR, U)), v.uuid = (U) => v.check(xs(BK, U)), v.uuidv4 = (U) => v.check(js(BK, U)), v.uuidv6 = (U) => v.check(Bs(BK, U)), v.uuidv7 = (U) => v.check(Os(BK, U)), v.nanoid = (U) => v.check(Hs(Be, U)), v.guid = (U) => v.check(GR(WR, U)), v.cuid = (U) => v.check(Ds(Oe, U)), v.cuid2 = (U) => v.check(As(Je, U)), v.ulid = (U) => v.check($s(qe, U)), v.base64 = (U) => v.check(Ms(Le, U)), v.base64url = (U) => v.check(bs(Fe, U)), v.xid = (U) => v.check(ws(He, U)), v.ksuid = (U) => v.check(Zs(De, U)), v.ipv4 = (U) => v.check(Ls(Ae, U)), v.ipv6 = (U) => v.check(Fs($e, U)), v.cidrv4 = (U) => v.check(Gs(we, U)), v.cidrv6 = (U) => v.check(Is(Ze, U)), v.e164 = (U) => v.check(Rs(Ge, U)), v.datetime = (U) => v.check(zE(U)), v.date = (U) => v.check(VE(U)), v.time = (U) => v.check(KE(U)), v.duration = (U) => v.check(jE(U))
    });

function i(v) {
    return Ns(Ne, v)
}
var d0 = l("ZodStringFormat", (v, z) => {
        c0.init(v, z), OE.init(v, z)
    }),
    Ke = l("ZodEmail", (v, z) => {
        Jt.init(v, z), d0.init(v, z)
    }),
    WR = l("ZodGUID", (v, z) => {
        Bt.init(v, z), d0.init(v, z)
    }),
    BK = l("ZodUUID", (v, z) => {
        Ot.init(v, z), d0.init(v, z)
    }),
    xe = l("ZodURL", (v, z) => {
        qt.init(v, z), d0.init(v, z)
    }),
    je = l("ZodEmoji", (v, z) => {
        Ht.init(v, z), d0.init(v, z)
    }),
    Be = l("ZodNanoID", (v, z) => {
        Dt.init(v, z), d0.init(v, z)
    }),
    Oe = l("ZodCUID", (v, z) => {
        At.init(v, z), d0.init(v, z)
    }),
    Je = l("ZodCUID2", (v, z) => {
        $t.init(v, z), d0.init(v, z)
    }),
    qe = l("ZodULID", (v, z) => {
        wt.init(v, z), d0.init(v, z)
    }),
    He = l("ZodXID", (v, z) => {
        Zt.init(v, z), d0.init(v, z)
    }),
    De = l("ZodKSUID", (v, z) => {
        Lt.init(v, z), d0.init(v, z)
    }),
    Ae = l("ZodIPv4", (v, z) => {
        bt.init(v, z), d0.init(v, z)
    }),
    $e = l("ZodIPv6", (v, z) => {
        Rt.init(v, z), d0.init(v, z)
    }),
    we = l("ZodCIDRv4", (v, z) => {
        Wt.init(v, z), d0.init(v, z)
    }),
    Ze = l("ZodCIDRv6", (v, z) => {
        Et.init(v, z), d0.init(v, z)
    }),
    Le = l("ZodBase64", (v, z) => {
        St.init(v, z), d0.init(v, z)
    }),
    Fe = l("ZodBase64URL", (v, z) => {
        _t.init(v, z), d0.init(v, z)
    }),
    Ge = l("ZodE164", (v, z) => {
        Ct.init(v, z), d0.init(v, z)
    }),
    Ie = l("ZodJWT", (v, z) => {
        Tt.init(v, z), d0.init(v, z)
    }),
    JE = l("ZodNumber", (v, z) => {
        dW.init(v, z), Q0.init(v, z), v.gt = (V, N) => v.check(MR(V, N)), v.gte = (V, N) => v.check(nq(V, N)), v.min = (V, N) => v.check(nq(V, N)), v.lt = (V, N) => v.check(IR(V, N)), v.lte = (V, N) => v.check(pq(V, N)), v.max = (V, N) => v.check(pq(V, N)), v.int = (V) => v.check(ER(V)), v.safe = (V) => v.check(ER(V)), v.positive = (V) => v.check(MR(0, V)), v.nonnegative = (V) => v.check(nq(0, V)), v.negative = (V) => v.check(IR(0, V)), v.nonpositive = (V) => v.check(pq(0, V)), v.multipleOf = (V, N) => v.check(bR(V, N)), v.step = (V, N) => v.check(bR(V, N)), v.finite = () => v;
        let U = v._zod.bag;
        v.minValue = Math.max(U.minimum ?? Number.NEGATIVE_INFINITY, U.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, v.maxValue = Math.min(U.maximum ?? Number.POSITIVE_INFINITY, U.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, v.isInt = (U.format ?? "").includes("int") || Number.isSafeInteger(U.multipleOf ?? 0.5), v.isFinite = !0, v.format = U.format ?? null
    });

function T0(v) {
    return Cs(JE, v)
}
var Me = l("ZodNumberFormat", (v, z) => {
    Yt.init(v, z), JE.init(v, z)
});

function ER(v) {
    return fs(Me, v)
}
var be = l("ZodBoolean", (v, z) => {
    ut.init(v, z), Q0.init(v, z)
});

function c4(v) {
    return Ts(be, v)
}
var Re = l("ZodNull", (v, z) => {
    yt.init(v, z), Q0.init(v, z)
});

function qE(v) {
    return Ys(Re, v)
}
var We = l("ZodUnknown", (v, z) => {
    kt.init(v, z), Q0.init(v, z)
});

function D4() {
    return us(We)
}
var Ee = l("ZodNever", (v, z) => {
    mt.init(v, z), Q0.init(v, z)
});

function Se(v) {
    return ys(Ee, v)
}
var Pe = l("ZodArray", (v, z) => {
    Xt.init(v, z), Q0.init(v, z), v.element = z.element, v.min = (U, V) => v.check(IK(U, V)), v.nonempty = (U) => v.check(IK(1, U)), v.max = (U, V) => v.check(aW(U, V)), v.length = (U, V) => v.check(tW(U, V)), v.unwrap = () => v.element
});

function q0(v, z) {
    return Qs(Pe, v, z)
}
var HE = l("ZodObject", (v, z) => {
    oW.init(v, z), Q0.init(v, z), E0.defineLazy(v, "shape", () => z.shape), v.keyof = () => i4(Object.keys(v._zod.def.shape)), v.catchall = (U) => v.clone({
        ...v._zod.def,
        catchall: U
    }), v.passthrough = () => v.clone({
        ...v._zod.def,
        catchall: D4()
    }), v.loose = () => v.clone({
        ...v._zod.def,
        catchall: D4()
    }), v.strict = () => v.clone({
        ...v._zod.def,
        catchall: Se()
    }), v.strip = () => v.clone({
        ...v._zod.def,
        catchall: void 0
    }), v.extend = (U) => {
        return E0.extend(v, U)
    }, v.merge = (U) => E0.merge(v, U), v.pick = (U) => E0.pick(v, U), v.omit = (U) => E0.omit(v, U), v.partial = (...U) => E0.partial(wE, v, U[0]), v.required = (...U) => E0.required(ZE, v, U[0])
});

function N6(v, z) {
    let U = {
        type: "object",
        get shape() {
            return E0.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        ...E0.normalizeParams(z)
    };
    return new HE(U)
}

function V8(v, z) {
    return new HE({
        type: "object",
        get shape() {
            return E0.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        catchall: D4(),
        ...E0.normalizeParams(z)
    })
}
var DE = l("ZodUnion", (v, z) => {
    rW.init(v, z), Q0.init(v, z), v.options = z.options
});

function i0(v, z) {
    return new DE({
        type: "union",
        options: v,
        ...E0.normalizeParams(z)
    })
}
var _e = l("ZodDiscriminatedUnion", (v, z) => {
    DE.init(v, z), gt.init(v, z)
});

function AE(v, z, U) {
    return new _e({
        type: "union",
        options: z,
        discriminator: v,
        ...E0.normalizeParams(U)
    })
}
var Ce = l("ZodIntersection", (v, z) => {
    ct.init(v, z), Q0.init(v, z)
});

function YH(v, z) {
    return new Ce({
        type: "intersection",
        left: v,
        right: z
    })
}
var fe = l("ZodRecord", (v, z) => {
    it.init(v, z), Q0.init(v, z), v.keyType = z.keyType, v.valueType = z.valueType
});

function A4(v, z, U) {
    return new fe({
        type: "record",
        keyType: v,
        valueType: z,
        ...E0.normalizeParams(U)
    })
}
var jH = l("ZodEnum", (v, z) => {
    lt.init(v, z), Q0.init(v, z), v.enum = z.entries, v.options = Object.values(z.entries);
    let U = new Set(Object.keys(z.entries));
    v.extract = (V, N) => {
        let K = {};
        for (let x of V)
            if (U.has(x)) K[x] = z.entries[x];
            else throw Error(`Key ${x} not found in enum`);
        return new jH({
            ...z,
            checks: [],
            ...E0.normalizeParams(N),
            entries: K
        })
    }, v.exclude = (V, N) => {
        let K = {
            ...z.entries
        };
        for (let x of V)
            if (U.has(x)) delete K[x];
            else throw Error(`Key ${x} not found in enum`);
        return new jH({
            ...z,
            checks: [],
            ...E0.normalizeParams(N),
            entries: K
        })
    }
});

function i4(v, z) {
    let U = Array.isArray(v) ? Object.fromEntries(v.map((V) => [V, V])) : v;
    return new jH({
        type: "enum",
        entries: U,
        ...E0.normalizeParams(z)
    })
}
var Te = l("ZodLiteral", (v, z) => {
    ht.init(v, z), Q0.init(v, z), v.values = new Set(z.values), Object.defineProperty(v, "value", {
        get() {
            if (z.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
            return z.values[0]
        }
    })
});

function E6(v, z) {
    return new Te({
        type: "literal",
        values: Array.isArray(v) ? v : [v],
        ...E0.normalizeParams(z)
    })
}
var Ye = l("ZodTransform", (v, z) => {
    pt.init(v, z), Q0.init(v, z), v._zod.parse = (U, V) => {
        U.addIssue = (K) => {
            if (typeof K === "string") U.issues.push(E0.issue(K, U.value, z));
            else {
                let x = K;
                if (x.fatal) x.continue = !1;
                x.code ?? (x.code = "custom"), x.input ?? (x.input = U.value), x.inst ?? (x.inst = v), x.continue ?? (x.continue = !0), U.issues.push(E0.issue(x))
            }
        };
        let N = z.transform(U.value, U);
        if (N instanceof Promise) return N.then((K) => {
            return U.value = K, U
        });
        return U.value = N, U
    }
});

function $E(v) {
    return new Ye({
        type: "transform",
        transform: v
    })
}
var wE = l("ZodOptional", (v, z) => {
    nt.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function W6(v) {
    return new wE({
        type: "optional",
        innerType: v
    })
}
var ue = l("ZodNullable", (v, z) => {
    Qt.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function SR(v) {
    return new ue({
        type: "nullable",
        innerType: v
    })
}
var ye = l("ZodDefault", (v, z) => {
    dt.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType, v.removeDefault = v.unwrap
});

function ke(v, z) {
    return new ye({
        type: "default",
        innerType: v,
        get defaultValue() {
            return typeof z === "function" ? z() : z
        }
    })
}
var me = l("ZodPrefault", (v, z) => {
    ot.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function Xe(v, z) {
    return new me({
        type: "prefault",
        innerType: v,
        get defaultValue() {
            return typeof z === "function" ? z() : z
        }
    })
}
var ZE = l("ZodNonOptional", (v, z) => {
    rt.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function ge(v, z) {
    return new ZE({
        type: "nonoptional",
        innerType: v,
        ...E0.normalizeParams(z)
    })
}
var ce = l("ZodCatch", (v, z) => {
    at.init(v, z), Q0.init(v, z), v.unwrap = () => v._zod.def.innerType, v.removeCatch = v.unwrap
});

function ie(v, z) {
    return new ce({
        type: "catch",
        innerType: v,
        catchValue: typeof z === "function" ? z : () => z
    })
}
var le = l("ZodPipe", (v, z) => {
    tt.init(v, z), Q0.init(v, z), v.in = z.in, v.out = z.out
});

function BH(v, z) {
    return new le({
        type: "pipe",
        in: v,
        out: z
    })
}
var he = l("ZodReadonly", (v, z) => {
    st.init(v, z), Q0.init(v, z)
});

function pe(v) {
    return new he({
        type: "readonly",
        innerType: v
    })
}
var LE = l("ZodCustom", (v, z) => {
    et.init(v, z), Q0.init(v, z)
});

function ne(v, z) {
    let U = new q3({
        check: "custom",
        ...E0.normalizeParams(z)
    });
    return U._zod.check = v, U
}

function Qe(v, z) {
    return ds(LE, v ?? (() => !0), z)
}

function de(v, z = {}) {
    return os(LE, v, z)
}

function oe(v, z) {
    let U = ne((V) => {
        return V.addIssue = (N) => {
            if (typeof N === "string") V.issues.push(E0.issue(N, V.value, U._zod.def));
            else {
                let K = N;
                if (K.fatal) K.continue = !1;
                K.code ?? (K.code = "custom"), K.input ?? (K.input = V.value), K.inst ?? (K.inst = U), K.continue ?? (K.continue = !U._zod.def.abort), V.issues.push(E0.issue(K))
            }
        }, v(V.value, V)
    }, z);
    return U
}

function FE(v, z) {
    return BH($E(v), z)
}
K9(Us());
var GE = "2025-11-25",
    re = [GE, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"],
    z9 = "io.modelcontextprotocol/related-task",
    iK = "2.0",
    T8 = Qe((v) => v !== null && (typeof v === "object" || typeof v === "function")),
    IE = i0([i(), T0().int()]),
    ME = i(),
    ae = V8({
        ttl: i0([T0(), qE()]).optional(),
        pollInterval: T0().optional()
    }),
    uH = V8({
        taskId: i()
    }),
    te = V8({
        progressToken: IE.optional(),
        [z9]: uH.optional()
    }),
    H3 = V8({
        task: ae.optional(),
        _meta: te.optional()
    }),
    T4 = N6({
        method: i(),
        params: H3.optional()
    }),
    p5 = V8({
        _meta: N6({
            [z9]: W6(uH)
        }).passthrough().optional()
    }),
    i3 = N6({
        method: i(),
        params: p5.optional()
    }),
    l4 = V8({
        _meta: V8({
            [z9]: uH.optional()
        }).optional()
    }),
    lK = i0([i(), T0().int()]),
    bE = N6({
        jsonrpc: E6(iK),
        id: lK,
        ...T4.shape
    }).strict(),
    PR = (v) => bE.safeParse(v).success,
    RE = N6({
        jsonrpc: E6(iK),
        ...i3.shape
    }).strict(),
    se = (v) => RE.safeParse(v).success,
    WE = N6({
        jsonrpc: E6(iK),
        id: lK,
        result: l4
    }).strict(),
    OK = (v) => WE.safeParse(v).success,
    y6;
(function(v) {
    v[v.ConnectionClosed = -32000] = "ConnectionClosed", v[v.RequestTimeout = -32001] = "RequestTimeout", v[v.ParseError = -32700] = "ParseError", v[v.InvalidRequest = -32600] = "InvalidRequest", v[v.MethodNotFound = -32601] = "MethodNotFound", v[v.InvalidParams = -32602] = "InvalidParams", v[v.InternalError = -32603] = "InternalError", v[v.UrlElicitationRequired = -32042] = "UrlElicitationRequired"
})(y6 || (y6 = {}));
var EE = N6({
        jsonrpc: E6(iK),
        id: lK,
        error: N6({
            code: T0().int(),
            message: i(),
            data: W6(D4())
        })
    }).strict(),
    ee = (v) => EE.safeParse(v).success,
    _Z6 = i0([bE, RE, WE, EE]),
    yH = l4.strict(),
    v66 = p5.extend({
        requestId: lK,
        reason: i().optional()
    }),
    kH = i3.extend({
        method: E6("notifications/cancelled"),
        params: v66
    }),
    z66 = N6({
        src: i(),
        mimeType: i().optional(),
        sizes: q0(i()).optional()
    }),
    iz = N6({
        icons: q0(z66).optional()
    }),
    vv = N6({
        name: i(),
        title: i().optional()
    }),
    SE = vv.extend({
        ...vv.shape,
        ...iz.shape,
        version: i(),
        websiteUrl: i().optional()
    }),
    U66 = YH(N6({
        applyDefaults: c4().optional()
    }), A4(i(), D4())),
    V66 = FE((v) => {
        if (v && typeof v === "object" && !Array.isArray(v)) {
            if (Object.keys(v).length === 0) return {
                form: {}
            }
        }
        return v
    }, YH(N6({
        form: U66.optional(),
        url: T8.optional()
    }), A4(i(), D4()).optional())),
    N66 = N6({
        list: W6(N6({}).passthrough()),
        cancel: W6(N6({}).passthrough()),
        requests: W6(N6({
            sampling: W6(N6({
                createMessage: W6(N6({}).passthrough())
            }).passthrough()),
            elicitation: W6(N6({
                create: W6(N6({}).passthrough())
            }).passthrough())
        }).passthrough())
    }).passthrough(),
    K66 = N6({
        list: W6(N6({}).passthrough()),
        cancel: W6(N6({}).passthrough()),
        requests: W6(N6({
            tools: W6(N6({
                call: W6(N6({}).passthrough())
            }).passthrough())
        }).passthrough())
    }).passthrough(),
    x66 = N6({
        experimental: A4(i(), T8).optional(),
        sampling: N6({
            context: T8.optional(),
            tools: T8.optional()
        }).optional(),
        elicitation: V66.optional(),
        roots: N6({
            listChanged: c4().optional()
        }).optional(),
        tasks: W6(N66)
    }),
    j66 = H3.extend({
        protocolVersion: i(),
        capabilities: x66,
        clientInfo: SE
    }),
    PE = T4.extend({
        method: E6("initialize"),
        params: j66
    }),
    B66 = N6({
        experimental: A4(i(), T8).optional(),
        logging: T8.optional(),
        completions: T8.optional(),
        prompts: W6(N6({
            listChanged: W6(c4())
        })),
        resources: N6({
            subscribe: c4().optional(),
            listChanged: c4().optional()
        }).optional(),
        tools: N6({
            listChanged: c4().optional()
        }).optional(),
        tasks: W6(K66)
    }).passthrough(),
    O66 = l4.extend({
        protocolVersion: i(),
        capabilities: B66,
        serverInfo: SE,
        instructions: i().optional()
    }),
    _E = i3.extend({
        method: E6("notifications/initialized")
    }),
    mH = T4.extend({
        method: E6("ping")
    }),
    J66 = N6({
        progress: T0(),
        total: W6(T0()),
        message: W6(i())
    }),
    q66 = N6({
        ...p5.shape,
        ...J66.shape,
        progressToken: IE
    }),
    XH = i3.extend({
        method: E6("notifications/progress"),
        params: q66
    }),
    H66 = H3.extend({
        cursor: ME.optional()
    }),
    lz = T4.extend({
        params: H66.optional()
    }),
    hz = l4.extend({
        nextCursor: W6(ME)
    }),
    pz = N6({
        taskId: i(),
        status: i4(["working", "input_required", "completed", "failed", "cancelled"]),
        ttl: i0([T0(), qE()]),
        createdAt: i(),
        lastUpdatedAt: i(),
        pollInterval: W6(T0()),
        statusMessage: W6(i())
    }),
    hK = l4.extend({
        task: pz
    }),
    D66 = p5.merge(pz),
    MK = i3.extend({
        method: E6("notifications/tasks/status"),
        params: D66
    }),
    gH = T4.extend({
        method: E6("tasks/get"),
        params: H3.extend({
            taskId: i()
        })
    }),
    cH = l4.merge(pz),
    iH = T4.extend({
        method: E6("tasks/result"),
        params: H3.extend({
            taskId: i()
        })
    }),
    lH = lz.extend({
        method: E6("tasks/list")
    }),
    hH = hz.extend({
        tasks: q0(pz)
    }),
    A66 = T4.extend({
        method: E6("tasks/cancel"),
        params: H3.extend({
            taskId: i()
        })
    }),
    $66 = l4.merge(pz),
    CE = N6({
        uri: i(),
        mimeType: W6(i()),
        _meta: A4(i(), D4()).optional()
    }),
    fE = CE.extend({
        text: i()
    }),
    pH = i().refine((v) => {
        try {
            return atob(v), !0
        } catch (z) {
            return !1
        }
    }, {
        message: "Invalid Base64 string"
    }),
    TE = CE.extend({
        blob: pH
    }),
    Bv = N6({
        audience: q0(i4(["user", "assistant"])).optional(),
        priority: T0().min(0).max(1).optional(),
        lastModified: eW.datetime({
            offset: !0
        }).optional()
    }),
    YE = N6({
        ...vv.shape,
        ...iz.shape,
        uri: i(),
        description: W6(i()),
        mimeType: W6(i()),
        annotations: Bv.optional(),
        _meta: W6(V8({}))
    }),
    w66 = N6({
        ...vv.shape,
        ...iz.shape,
        uriTemplate: i(),
        description: W6(i()),
        mimeType: W6(i()),
        annotations: Bv.optional(),
        _meta: W6(V8({}))
    }),
    OH = lz.extend({
        method: E6("resources/list")
    }),
    Z66 = hz.extend({
        resources: q0(YE)
    }),
    JH = lz.extend({
        method: E6("resources/templates/list")
    }),
    L66 = hz.extend({
        resourceTemplates: q0(w66)
    }),
    nH = H3.extend({
        uri: i()
    }),
    F66 = nH,
    qH = T4.extend({
        method: E6("resources/read"),
        params: F66
    }),
    G66 = l4.extend({
        contents: q0(i0([fE, TE]))
    }),
    I66 = i3.extend({
        method: E6("notifications/resources/list_changed")
    }),
    M66 = nH,
    b66 = T4.extend({
        method: E6("resources/subscribe"),
        params: M66
    }),
    R66 = nH,
    W66 = T4.extend({
        method: E6("resources/unsubscribe"),
        params: R66
    }),
    E66 = p5.extend({
        uri: i()
    }),
    S66 = i3.extend({
        method: E6("notifications/resources/updated"),
        params: E66
    }),
    P66 = N6({
        name: i(),
        description: W6(i()),
        required: W6(c4())
    }),
    _66 = N6({
        ...vv.shape,
        ...iz.shape,
        description: W6(i()),
        arguments: W6(q0(P66)),
        _meta: W6(V8({}))
    }),
    HH = lz.extend({
        method: E6("prompts/list")
    }),
    C66 = hz.extend({
        prompts: q0(_66)
    }),
    f66 = H3.extend({
        name: i(),
        arguments: A4(i(), i()).optional()
    }),
    DH = T4.extend({
        method: E6("prompts/get"),
        params: f66
    }),
    QH = N6({
        type: E6("text"),
        text: i(),
        annotations: Bv.optional(),
        _meta: A4(i(), D4()).optional()
    }),
    dH = N6({
        type: E6("image"),
        data: pH,
        mimeType: i(),
        annotations: Bv.optional(),
        _meta: A4(i(), D4()).optional()
    }),
    oH = N6({
        type: E6("audio"),
        data: pH,
        mimeType: i(),
        annotations: Bv.optional(),
        _meta: A4(i(), D4()).optional()
    }),
    T66 = N6({
        type: E6("tool_use"),
        name: i(),
        id: i(),
        input: N6({}).passthrough(),
        _meta: W6(N6({}).passthrough())
    }).passthrough(),
    Y66 = N6({
        type: E6("resource"),
        resource: i0([fE, TE]),
        annotations: Bv.optional(),
        _meta: A4(i(), D4()).optional()
    }),
    u66 = YE.extend({
        type: E6("resource_link")
    }),
    rH = i0([QH, dH, oH, u66, Y66]),
    y66 = N6({
        role: i4(["user", "assistant"]),
        content: rH
    }),
    k66 = l4.extend({
        description: W6(i()),
        messages: q0(y66)
    }),
    m66 = i3.extend({
        method: E6("notifications/prompts/list_changed")
    }),
    X66 = N6({
        title: i().optional(),
        readOnlyHint: c4().optional(),
        destructiveHint: c4().optional(),
        idempotentHint: c4().optional(),
        openWorldHint: c4().optional()
    }),
    g66 = N6({
        taskSupport: i4(["required", "optional", "forbidden"]).optional()
    }),
    uE = N6({
        ...vv.shape,
        ...iz.shape,
        description: i().optional(),
        inputSchema: N6({
            type: E6("object"),
            properties: A4(i(), T8).optional(),
            required: q0(i()).optional()
        }).catchall(D4()),
        outputSchema: N6({
            type: E6("object"),
            properties: A4(i(), T8).optional(),
            required: q0(i()).optional()
        }).catchall(D4()).optional(),
        annotations: W6(X66),
        execution: W6(g66),
        _meta: A4(i(), D4()).optional()
    }),
    AH = lz.extend({
        method: E6("tools/list")
    }),
    c66 = hz.extend({
        tools: q0(uE)
    }),
    aH = l4.extend({
        content: q0(rH).default([]),
        structuredContent: A4(i(), D4()).optional(),
        isError: W6(c4())
    }),
    CZ6 = aH.or(l4.extend({
        toolResult: D4()
    })),
    i66 = H3.extend({
        name: i(),
        arguments: W6(A4(i(), D4()))
    }),
    bK = T4.extend({
        method: E6("tools/call"),
        params: i66
    }),
    l66 = i3.extend({
        method: E6("notifications/tools/list_changed")
    }),
    RK = i4(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]),
    h66 = H3.extend({
        level: RK
    }),
    yE = T4.extend({
        method: E6("logging/setLevel"),
        params: h66
    }),
    p66 = p5.extend({
        level: RK,
        logger: i().optional(),
        data: D4()
    }),
    n66 = i3.extend({
        method: E6("notifications/message"),
        params: p66
    }),
    Q66 = N6({
        name: i().optional()
    }),
    d66 = N6({
        hints: W6(q0(Q66)),
        costPriority: W6(T0().min(0).max(1)),
        speedPriority: W6(T0().min(0).max(1)),
        intelligencePriority: W6(T0().min(0).max(1))
    }),
    o66 = N6({
        mode: W6(i4(["auto", "required", "none"]))
    }),
    r66 = N6({
        type: E6("tool_result"),
        toolUseId: i().describe("The unique identifier for the corresponding tool call."),
        content: q0(rH).default([]),
        structuredContent: N6({}).passthrough().optional(),
        isError: W6(c4()),
        _meta: W6(N6({}).passthrough())
    }).passthrough(),
    a66 = AE("type", [QH, dH, oH]),
    WK = AE("type", [QH, dH, oH, T66, r66]),
    t66 = N6({
        role: i4(["user", "assistant"]),
        content: i0([WK, q0(WK)]),
        _meta: W6(N6({}).passthrough())
    }).passthrough(),
    s66 = H3.extend({
        messages: q0(t66),
        modelPreferences: d66.optional(),
        systemPrompt: i().optional(),
        includeContext: i4(["none", "thisServer", "allServers"]).optional(),
        temperature: T0().optional(),
        maxTokens: T0().int(),
        stopSequences: q0(i()).optional(),
        metadata: T8.optional(),
        tools: W6(q0(uE)),
        toolChoice: W6(o66)
    }),
    e66 = T4.extend({
        method: E6("sampling/createMessage"),
        params: s66
    }),
    kE = l4.extend({
        model: i(),
        stopReason: W6(i4(["endTurn", "stopSequence", "maxTokens"]).or(i())),
        role: i4(["user", "assistant"]),
        content: a66
    }),
    mE = l4.extend({
        model: i(),
        stopReason: W6(i4(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(i())),
        role: i4(["user", "assistant"]),
        content: i0([WK, q0(WK)])
    }),
    v06 = N6({
        type: E6("boolean"),
        title: i().optional(),
        description: i().optional(),
        default: c4().optional()
    }),
    z06 = N6({
        type: E6("string"),
        title: i().optional(),
        description: i().optional(),
        minLength: T0().optional(),
        maxLength: T0().optional(),
        format: i4(["email", "uri", "date", "date-time"]).optional(),
        default: i().optional()
    }),
    U06 = N6({
        type: i4(["number", "integer"]),
        title: i().optional(),
        description: i().optional(),
        minimum: T0().optional(),
        maximum: T0().optional(),
        default: T0().optional()
    }),
    V06 = N6({
        type: E6("string"),
        title: i().optional(),
        description: i().optional(),
        enum: q0(i()),
        default: i().optional()
    }),
    N06 = N6({
        type: E6("string"),
        title: i().optional(),
        description: i().optional(),
        oneOf: q0(N6({
            const: i(),
            title: i()
        })),
        default: i().optional()
    }),
    K06 = N6({
        type: E6("string"),
        title: i().optional(),
        description: i().optional(),
        enum: q0(i()),
        enumNames: q0(i()).optional(),
        default: i().optional()
    }),
    x06 = i0([V06, N06]),
    j06 = N6({
        type: E6("array"),
        title: i().optional(),
        description: i().optional(),
        minItems: T0().optional(),
        maxItems: T0().optional(),
        items: N6({
            type: E6("string"),
            enum: q0(i())
        }),
        default: q0(i()).optional()
    }),
    B06 = N6({
        type: E6("array"),
        title: i().optional(),
        description: i().optional(),
        minItems: T0().optional(),
        maxItems: T0().optional(),
        items: N6({
            anyOf: q0(N6({
                const: i(),
                title: i()
            }))
        }),
        default: q0(i()).optional()
    }),
    O06 = i0([j06, B06]),
    J06 = i0([K06, x06, O06]),
    q06 = i0([J06, v06, z06, U06]),
    H06 = H3.extend({
        mode: E6("form").optional(),
        message: i(),
        requestedSchema: N6({
            type: E6("object"),
            properties: A4(i(), q06),
            required: q0(i()).optional()
        })
    }),
    D06 = H3.extend({
        mode: E6("url"),
        message: i(),
        elicitationId: i(),
        url: i().url()
    }),
    A06 = i0([H06, D06]),
    $06 = T4.extend({
        method: E6("elicitation/create"),
        params: A06
    }),
    w06 = p5.extend({
        elicitationId: i()
    }),
    Z06 = i3.extend({
        method: E6("notifications/elicitation/complete"),
        params: w06
    }),
    $H = l4.extend({
        action: i4(["accept", "decline", "cancel"]),
        content: FE((v) => v === null ? void 0 : v, A4(i(), i0([i(), T0(), c4(), q0(i())])).optional())
    }),
    L06 = N6({
        type: E6("ref/resource"),
        uri: i()
    }),
    F06 = N6({
        type: E6("ref/prompt"),
        name: i()
    }),
    G06 = H3.extend({
        ref: i0([F06, L06]),
        argument: N6({
            name: i(),
            value: i()
        }),
        context: N6({
            arguments: A4(i(), i()).optional()
        }).optional()
    }),
    wH = T4.extend({
        method: E6("completion/complete"),
        params: G06
    });

function I06(v) {
    if (v.params.ref.type !== "ref/prompt") throw TypeError(`Expected CompleteRequestPrompt, but got ${v.params.ref.type}`)
}

function M06(v) {
    if (v.params.ref.type !== "ref/resource") throw TypeError(`Expected CompleteRequestResourceTemplate, but got ${v.params.ref.type}`)
}
var b06 = l4.extend({
        completion: V8({
            values: q0(i()).max(100),
            total: W6(T0().int()),
            hasMore: W6(c4())
        })
    }),
    R06 = N6({
        uri: i().startsWith("file://"),
        name: i().optional(),
        _meta: A4(i(), D4()).optional()
    }),
    W06 = T4.extend({
        method: E6("roots/list")
    }),
    XE = l4.extend({
        roots: q0(R06)
    }),
    E06 = i3.extend({
        method: E6("notifications/roots/list_changed")
    }),
    fZ6 = i0([mH, PE, wH, yE, DH, HH, OH, JH, qH, b66, W66, bK, AH, gH, iH, lH]),
    TZ6 = i0([kH, XH, _E, E06, MK]),
    YZ6 = i0([yH, kE, mE, $H, XE, cH, hH, hK]),
    uZ6 = i0([mH, e66, $06, W06, gH, iH, lH]),
    yZ6 = i0([kH, XH, n66, S66, I66, l66, m66, MK, Z06]),
    kZ6 = i0([yH, O66, b06, k66, C66, Z66, L66, G66, aH, c66, cH, hH, hK]);
class S6 extends Error {
    constructor(v, z, U) {
        super(`MCP error ${v}: ${z}`);
        this.code = v, this.data = U, this.name = "McpError"
    }
    static fromError(v, z, U) {
        if (v === y6.UrlElicitationRequired && U) {
            let V = U;
            if (V.elicitations) return new gE(V.elicitations, z)
        }
        return new S6(v, z, U)
    }
}
class gE extends S6 {
    constructor(v, z = `URL elicitation${v.length>1?"s":""} required`) {
        super(y6.UrlElicitationRequired, z, {
            elicitations: v
        })
    }
    get elicitations() {
        var v, z;
        return (z = (v = this.data) === null || v === void 0 ? void 0 : v.elicitations) !== null && z !== void 0 ? z : []
    }
}

function i5(v) {
    return v === "completed" || v === "failed" || v === "cancelled"
}
var S06 = Symbol("Let zodToJsonSchema decide on which parser to use"),
    _R = {
        name: void 0,
        $refStrategy: "root",
        basePath: ["#"],
        effectStrategy: "input",
        pipeStrategy: "all",
        dateStrategy: "format:date-time",
        mapStrategy: "entries",
        removeAdditionalStrategy: "passthrough",
        allowedAdditionalProperties: !0,
        rejectedAdditionalProperties: !1,
        definitionPath: "definitions",
        target: "jsonSchema7",
        strictUnions: !1,
        definitions: {},
        errorMessages: !1,
        markdownDescription: !1,
        patternStrategy: "escape",
        applyRegexFlags: !1,
        emailStrategy: "format:email",
        base64Strategy: "contentEncoding:base64",
        nameStrategy: "ref",
        openAiAnyTypeName: "OpenAiAnyType"
    },
    P06 = (v) => typeof v === "string" ? {
        ..._R,
        name: v
    } : {
        ..._R,
        ...v
    },
    _06 = (v) => {
        let z = P06(v),
            U = z.name !== void 0 ? [...z.basePath, z.definitionPath, z.name] : z.basePath;
        return {
            ...z,
            flags: {
                hasReferencedOpenAiAnyType: !1
            },
            currentPath: U,
            propertyPath: void 0,
            seen: new Map(Object.entries(z.definitions).map(([V, N]) => [N._def, {
                def: N._def,
                path: [...z.basePath, z.definitionPath, V],
                jsonSchema: void 0
            }]))
        }
    };

function cE(v, z, U, V) {
    if (!V?.errorMessages) return;
    if (U) v.errorMessage = {
        ...v.errorMessage,
        [z]: U
    }
}

function b0(v, z, U, V, N) {
    v[z] = U, cE(v, z, V, N)
}
var iE = (v, z) => {
    let U = 0;
    for (; U < v.length && U < z.length; U++)
        if (v[U] !== z[U]) break;
    return [(v.length - U).toString(), ...z.slice(U)].join("/")
};

function J3(v) {
    if (v.target !== "openAi") return {};
    let z = [...v.basePath, v.definitionPath, v.openAiAnyTypeName];
    return v.flags.hasReferencedOpenAiAnyType = !0, {
        $ref: v.$refStrategy === "relative" ? iE(z, v.currentPath) : z.join("/")
    }
}

function C06(v, z) {
    let U = {
        type: "array"
    };
    if (v.type?._def && v.type?._def?.typeName !== t.ZodAny) U.items = F0(v.type._def, {
        ...z,
        currentPath: [...z.currentPath, "items"]
    });
    if (v.minLength) b0(U, "minItems", v.minLength.value, v.minLength.message, z);
    if (v.maxLength) b0(U, "maxItems", v.maxLength.value, v.maxLength.message, z);
    if (v.exactLength) b0(U, "minItems", v.exactLength.value, v.exactLength.message, z), b0(U, "maxItems", v.exactLength.value, v.exactLength.message, z);
    return U
}

function f06(v, z) {
    let U = {
        type: "integer",
        format: "int64"
    };
    if (!v.checks) return U;
    for (let V of v.checks) switch (V.kind) {
        case "min":
            if (z.target === "jsonSchema7")
                if (V.inclusive) b0(U, "minimum", V.value, V.message, z);
                else b0(U, "exclusiveMinimum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMinimum = !0;
                b0(U, "minimum", V.value, V.message, z)
            }
            break;
        case "max":
            if (z.target === "jsonSchema7")
                if (V.inclusive) b0(U, "maximum", V.value, V.message, z);
                else b0(U, "exclusiveMaximum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMaximum = !0;
                b0(U, "maximum", V.value, V.message, z)
            }
            break;
        case "multipleOf":
            b0(U, "multipleOf", V.value, V.message, z);
            break
    }
    return U
}

function T06() {
    return {
        type: "boolean"
    }
}

function lE(v, z) {
    return F0(v.type._def, z)
}
var Y06 = (v, z) => {
    return F0(v.innerType._def, z)
};

function hE(v, z, U) {
    let V = U ?? z.dateStrategy;
    if (Array.isArray(V)) return {
        anyOf: V.map((N, K) => hE(v, z, N))
    };
    switch (V) {
        case "string":
        case "format:date-time":
            return {
                type: "string", format: "date-time"
            };
        case "format:date":
            return {
                type: "string", format: "date"
            };
        case "integer":
            return u06(v, z)
    }
}
var u06 = (v, z) => {
    let U = {
        type: "integer",
        format: "unix-time"
    };
    if (z.target === "openApi3") return U;
    for (let V of v.checks) switch (V.kind) {
        case "min":
            b0(U, "minimum", V.value, V.message, z);
            break;
        case "max":
            b0(U, "maximum", V.value, V.message, z);
            break
    }
    return U
};

function y06(v, z) {
    return {
        ...F0(v.innerType._def, z),
        default: v.defaultValue()
    }
}

function k06(v, z) {
    return z.effectStrategy === "input" ? F0(v.schema._def, z) : J3(z)
}

function m06(v) {
    return {
        type: "string",
        enum: Array.from(v.values)
    }
}
var X06 = (v) => {
    if ("type" in v && v.type === "string") return !1;
    return "allOf" in v
};

function g06(v, z) {
    let U = [F0(v.left._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", "0"]
        }), F0(v.right._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", "1"]
        })].filter((K) => !!K),
        V = z.target === "jsonSchema2019-09" ? {
            unevaluatedProperties: !1
        } : void 0,
        N = [];
    return U.forEach((K) => {
        if (X06(K)) {
            if (N.push(...K.allOf), K.unevaluatedProperties === void 0) V = void 0
        } else {
            let x = K;
            if ("additionalProperties" in K && K.additionalProperties === !1) {
                let {
                    additionalProperties: j,
                    ...B
                } = K;
                x = B
            } else V = void 0;
            N.push(x)
        }
    }), N.length ? {
        allOf: N,
        ...V
    } : void 0
}

function c06(v, z) {
    let U = typeof v.value;
    if (U !== "bigint" && U !== "number" && U !== "boolean" && U !== "string") return {
        type: Array.isArray(v.value) ? "array" : "object"
    };
    if (z.target === "openApi3") return {
        type: U === "bigint" ? "integer" : U,
        enum: [v.value]
    };
    return {
        type: U === "bigint" ? "integer" : U,
        const: v.value
    }
}
var oq = void 0,
    e3 = {
        cuid: /^[cC][^\s-]{8,}$/,
        cuid2: /^[0-9a-z]+$/,
        ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
        email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
        emoji: () => {
            if (oq === void 0) oq = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
            return oq
        },
        uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
        ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
        ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
        base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
        nanoid: /^[a-zA-Z0-9_-]{21}$/,
        jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };

function pE(v, z) {
    let U = {
        type: "string"
    };
    if (v.checks)
        for (let V of v.checks) switch (V.kind) {
            case "min":
                b0(U, "minLength", typeof U.minLength === "number" ? Math.max(U.minLength, V.value) : V.value, V.message, z);
                break;
            case "max":
                b0(U, "maxLength", typeof U.maxLength === "number" ? Math.min(U.maxLength, V.value) : V.value, V.message, z);
                break;
            case "email":
                switch (z.emailStrategy) {
                    case "format:email":
                        v8(U, "email", V.message, z);
                        break;
                    case "format:idn-email":
                        v8(U, "idn-email", V.message, z);
                        break;
                    case "pattern:zod":
                        t4(U, e3.email, V.message, z);
                        break
                }
                break;
            case "url":
                v8(U, "uri", V.message, z);
                break;
            case "uuid":
                v8(U, "uuid", V.message, z);
                break;
            case "regex":
                t4(U, V.regex, V.message, z);
                break;
            case "cuid":
                t4(U, e3.cuid, V.message, z);
                break;
            case "cuid2":
                t4(U, e3.cuid2, V.message, z);
                break;
            case "startsWith":
                t4(U, RegExp(`^${rq(V.value,z)}`), V.message, z);
                break;
            case "endsWith":
                t4(U, RegExp(`${rq(V.value,z)}$`), V.message, z);
                break;
            case "datetime":
                v8(U, "date-time", V.message, z);
                break;
            case "date":
                v8(U, "date", V.message, z);
                break;
            case "time":
                v8(U, "time", V.message, z);
                break;
            case "duration":
                v8(U, "duration", V.message, z);
                break;
            case "length":
                b0(U, "minLength", typeof U.minLength === "number" ? Math.max(U.minLength, V.value) : V.value, V.message, z), b0(U, "maxLength", typeof U.maxLength === "number" ? Math.min(U.maxLength, V.value) : V.value, V.message, z);
                break;
            case "includes": {
                t4(U, RegExp(rq(V.value, z)), V.message, z);
                break
            }
            case "ip": {
                if (V.version !== "v6") v8(U, "ipv4", V.message, z);
                if (V.version !== "v4") v8(U, "ipv6", V.message, z);
                break
            }
            case "base64url":
                t4(U, e3.base64url, V.message, z);
                break;
            case "jwt":
                t4(U, e3.jwt, V.message, z);
                break;
            case "cidr": {
                if (V.version !== "v6") t4(U, e3.ipv4Cidr, V.message, z);
                if (V.version !== "v4") t4(U, e3.ipv6Cidr, V.message, z);
                break
            }
            case "emoji":
                t4(U, e3.emoji(), V.message, z);
                break;
            case "ulid": {
                t4(U, e3.ulid, V.message, z);
                break
            }
            case "base64": {
                switch (z.base64Strategy) {
                    case "format:binary": {
                        v8(U, "binary", V.message, z);
                        break
                    }
                    case "contentEncoding:base64": {
                        b0(U, "contentEncoding", "base64", V.message, z);
                        break
                    }
                    case "pattern:zod": {
                        t4(U, e3.base64, V.message, z);
                        break
                    }
                }
                break
            }
            case "nanoid":
                t4(U, e3.nanoid, V.message, z);
            case "toLowerCase":
            case "toUpperCase":
            case "trim":
                break;
            default:
                ((N) => {})(V)
        }
    return U
}

function rq(v, z) {
    return z.patternStrategy === "escape" ? l06(v) : v
}
var i06 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

function l06(v) {
    let z = "";
    for (let U = 0; U < v.length; U++) {
        if (!i06.has(v[U])) z += "\\";
        z += v[U]
    }
    return z
}

function v8(v, z, U, V) {
    if (v.format || v.anyOf?.some((N) => N.format)) {
        if (!v.anyOf) v.anyOf = [];
        if (v.format) {
            if (v.anyOf.push({
                    format: v.format,
                    ...v.errorMessage && V.errorMessages && {
                        errorMessage: {
                            format: v.errorMessage.format
                        }
                    }
                }), delete v.format, v.errorMessage) {
                if (delete v.errorMessage.format, Object.keys(v.errorMessage).length === 0) delete v.errorMessage
            }
        }
        v.anyOf.push({
            format: z,
            ...U && V.errorMessages && {
                errorMessage: {
                    format: U
                }
            }
        })
    } else b0(v, "format", z, U, V)
}

function t4(v, z, U, V) {
    if (v.pattern || v.allOf?.some((N) => N.pattern)) {
        if (!v.allOf) v.allOf = [];
        if (v.pattern) {
            if (v.allOf.push({
                    pattern: v.pattern,
                    ...v.errorMessage && V.errorMessages && {
                        errorMessage: {
                            pattern: v.errorMessage.pattern
                        }
                    }
                }), delete v.pattern, v.errorMessage) {
                if (delete v.errorMessage.pattern, Object.keys(v.errorMessage).length === 0) delete v.errorMessage
            }
        }
        v.allOf.push({
            pattern: CR(z, V),
            ...U && V.errorMessages && {
                errorMessage: {
                    pattern: U
                }
            }
        })
    } else b0(v, "pattern", CR(z, V), U, V)
}

function CR(v, z) {
    if (!z.applyRegexFlags || !v.flags) return v.source;
    let U = {
            i: v.flags.includes("i"),
            m: v.flags.includes("m"),
            s: v.flags.includes("s")
        },
        V = U.i ? v.source.toLowerCase() : v.source,
        N = "",
        K = !1,
        x = !1,
        j = !1;
    for (let B = 0; B < V.length; B++) {
        if (K) {
            N += V[B], K = !1;
            continue
        }
        if (U.i) {
            if (x) {
                if (V[B].match(/[a-z]/)) {
                    if (j) N += V[B], N += `${V[B-2]}-${V[B]}`.toUpperCase(), j = !1;
                    else if (V[B + 1] === "-" && V[B + 2]?.match(/[a-z]/)) N += V[B], j = !0;
                    else N += `${V[B]}${V[B].toUpperCase()}`;
                    continue
                }
            } else if (V[B].match(/[a-z]/)) {
                N += `[${V[B]}${V[B].toUpperCase()}]`;
                continue
            }
        }
        if (U.m) {
            if (V[B] === "^") {
                N += `(^|(?<=[\r
]))`;
                continue
            } else if (V[B] === "$") {
                N += `($|(?=[\r
]))`;
                continue
            }
        }
        if (U.s && V[B] === ".") {
            N += x ? `${V[B]}\r
` : `[${V[B]}\r
]`;
            continue
        }
        if (N += V[B], V[B] === "\\") K = !0;
        else if (x && V[B] === "]") x = !1;
        else if (!x && V[B] === "[") x = !0
    }
    try {
        new RegExp(N)
    } catch {
        return console.warn(`Could not convert regex pattern at ${z.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), v.source
    }
    return N
}

function nE(v, z) {
    if (z.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    if (z.target === "openApi3" && v.keyType?._def.typeName === t.ZodEnum) return {
        type: "object",
        required: v.keyType._def.values,
        properties: v.keyType._def.values.reduce((V, N) => ({
            ...V,
            [N]: F0(v.valueType._def, {
                ...z,
                currentPath: [...z.currentPath, "properties", N]
            }) ?? J3(z)
        }), {}),
        additionalProperties: z.rejectedAdditionalProperties
    };
    let U = {
        type: "object",
        additionalProperties: F0(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "additionalProperties"]
        }) ?? z.allowedAdditionalProperties
    };
    if (z.target === "openApi3") return U;
    if (v.keyType?._def.typeName === t.ZodString && v.keyType._def.checks?.length) {
        let {
            type: V,
            ...N
        } = pE(v.keyType._def, z);
        return {
            ...U,
            propertyNames: N
        }
    } else if (v.keyType?._def.typeName === t.ZodEnum) return {
        ...U,
        propertyNames: {
            enum: v.keyType._def.values
        }
    };
    else if (v.keyType?._def.typeName === t.ZodBranded && v.keyType._def.type._def.typeName === t.ZodString && v.keyType._def.type._def.checks?.length) {
        let {
            type: V,
            ...N
        } = lE(v.keyType._def, z);
        return {
            ...U,
            propertyNames: N
        }
    }
    return U
}

function h06(v, z) {
    if (z.mapStrategy === "record") return nE(v, z);
    let U = F0(v.keyType._def, {
            ...z,
            currentPath: [...z.currentPath, "items", "items", "0"]
        }) || J3(z),
        V = F0(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "items", "items", "1"]
        }) || J3(z);
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [U, V],
            minItems: 2,
            maxItems: 2
        }
    }
}

function p06(v) {
    let z = v.values,
        U = Object.keys(v.values).filter((N) => {
            return typeof z[z[N]] !== "number"
        }).map((N) => z[N]),
        V = Array.from(new Set(U.map((N) => typeof N)));
    return {
        type: V.length === 1 ? V[0] === "string" ? "string" : "number" : ["string", "number"],
        enum: U
    }
}

function n06(v) {
    return v.target === "openAi" ? void 0 : {
        not: J3({
            ...v,
            currentPath: [...v.currentPath, "not"]
        })
    }
}

function Q06(v) {
    return v.target === "openApi3" ? {
        enum: ["null"],
        nullable: !0
    } : {
        type: "null"
    }
}
var EK = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};

function d06(v, z) {
    if (z.target === "openApi3") return fR(v, z);
    let U = v.options instanceof Map ? Array.from(v.options.values()) : v.options;
    if (U.every((V) => (V._def.typeName in EK) && (!V._def.checks || !V._def.checks.length))) {
        let V = U.reduce((N, K) => {
            let x = EK[K._def.typeName];
            return x && !N.includes(x) ? [...N, x] : N
        }, []);
        return {
            type: V.length > 1 ? V : V[0]
        }
    } else if (U.every((V) => V._def.typeName === "ZodLiteral" && !V.description)) {
        let V = U.reduce((N, K) => {
            let x = typeof K._def.value;
            switch (x) {
                case "string":
                case "number":
                case "boolean":
                    return [...N, x];
                case "bigint":
                    return [...N, "integer"];
                case "object":
                    if (K._def.value === null) return [...N, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return N
            }
        }, []);
        if (V.length === U.length) {
            let N = V.filter((K, x, j) => j.indexOf(K) === x);
            return {
                type: N.length > 1 ? N : N[0],
                enum: U.reduce((K, x) => {
                    return K.includes(x._def.value) ? K : [...K, x._def.value]
                }, [])
            }
        }
    } else if (U.every((V) => V._def.typeName === "ZodEnum")) return {
        type: "string",
        enum: U.reduce((V, N) => [...V, ...N._def.values.filter((K) => !V.includes(K))], [])
    };
    return fR(v, z)
}
var fR = (v, z) => {
    let U = (v.options instanceof Map ? Array.from(v.options.values()) : v.options).map((V, N) => F0(V._def, {
        ...z,
        currentPath: [...z.currentPath, "anyOf", `${N}`]
    })).filter((V) => !!V && (!z.strictUnions || typeof V === "object" && Object.keys(V).length > 0));
    return U.length ? {
        anyOf: U
    } : void 0
};

function o06(v, z) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(v.innerType._def.typeName) && (!v.innerType._def.checks || !v.innerType._def.checks.length)) {
        if (z.target === "openApi3") return {
            type: EK[v.innerType._def.typeName],
            nullable: !0
        };
        return {
            type: [EK[v.innerType._def.typeName], "null"]
        }
    }
    if (z.target === "openApi3") {
        let V = F0(v.innerType._def, {
            ...z,
            currentPath: [...z.currentPath]
        });
        if (V && "$ref" in V) return {
            allOf: [V],
            nullable: !0
        };
        return V && {
            ...V,
            nullable: !0
        }
    }
    let U = F0(v.innerType._def, {
        ...z,
        currentPath: [...z.currentPath, "anyOf", "0"]
    });
    return U && {
        anyOf: [U, {
            type: "null"
        }]
    }
}

function r06(v, z) {
    let U = {
        type: "number"
    };
    if (!v.checks) return U;
    for (let V of v.checks) switch (V.kind) {
        case "int":
            U.type = "integer", cE(U, "type", V.message, z);
            break;
        case "min":
            if (z.target === "jsonSchema7")
                if (V.inclusive) b0(U, "minimum", V.value, V.message, z);
                else b0(U, "exclusiveMinimum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMinimum = !0;
                b0(U, "minimum", V.value, V.message, z)
            }
            break;
        case "max":
            if (z.target === "jsonSchema7")
                if (V.inclusive) b0(U, "maximum", V.value, V.message, z);
                else b0(U, "exclusiveMaximum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMaximum = !0;
                b0(U, "maximum", V.value, V.message, z)
            }
            break;
        case "multipleOf":
            b0(U, "multipleOf", V.value, V.message, z);
            break
    }
    return U
}

function a06(v, z) {
    let U = z.target === "openAi",
        V = {
            type: "object",
            properties: {}
        },
        N = [],
        K = v.shape();
    for (let j in K) {
        let B = K[j];
        if (B === void 0 || B._def === void 0) continue;
        let O = s06(B);
        if (O && U) {
            if (B._def.typeName === "ZodOptional") B = B._def.innerType;
            if (!B.isNullable()) B = B.nullable();
            O = !1
        }
        let J = F0(B._def, {
            ...z,
            currentPath: [...z.currentPath, "properties", j],
            propertyPath: [...z.currentPath, "properties", j]
        });
        if (J === void 0) continue;
        if (V.properties[j] = J, !O) N.push(j)
    }
    if (N.length) V.required = N;
    let x = t06(v, z);
    if (x !== void 0) V.additionalProperties = x;
    return V
}

function t06(v, z) {
    if (v.catchall._def.typeName !== "ZodNever") return F0(v.catchall._def, {
        ...z,
        currentPath: [...z.currentPath, "additionalProperties"]
    });
    switch (v.unknownKeys) {
        case "passthrough":
            return z.allowedAdditionalProperties;
        case "strict":
            return z.rejectedAdditionalProperties;
        case "strip":
            return z.removeAdditionalStrategy === "strict" ? z.allowedAdditionalProperties : z.rejectedAdditionalProperties
    }
}

function s06(v) {
    try {
        return v.isOptional()
    } catch {
        return !0
    }
}
var e06 = (v, z) => {
        if (z.currentPath.toString() === z.propertyPath?.toString()) return F0(v.innerType._def, z);
        let U = F0(v.innerType._def, {
            ...z,
            currentPath: [...z.currentPath, "anyOf", "1"]
        });
        return U ? {
            anyOf: [{
                not: J3(z)
            }, U]
        } : J3(z)
    },
    v46 = (v, z) => {
        if (z.pipeStrategy === "input") return F0(v.in._def, z);
        else if (z.pipeStrategy === "output") return F0(v.out._def, z);
        let U = F0(v.in._def, {
                ...z,
                currentPath: [...z.currentPath, "allOf", "0"]
            }),
            V = F0(v.out._def, {
                ...z,
                currentPath: [...z.currentPath, "allOf", U ? "1" : "0"]
            });
        return {
            allOf: [U, V].filter((N) => N !== void 0)
        }
    };

function z46(v, z) {
    return F0(v.type._def, z)
}

function U46(v, z) {
    let U = {
        type: "array",
        uniqueItems: !0,
        items: F0(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "items"]
        })
    };
    if (v.minSize) b0(U, "minItems", v.minSize.value, v.minSize.message, z);
    if (v.maxSize) b0(U, "maxItems", v.maxSize.value, v.maxSize.message, z);
    return U
}

function V46(v, z) {
    if (v.rest) return {
        type: "array",
        minItems: v.items.length,
        items: v.items.map((U, V) => F0(U._def, {
            ...z,
            currentPath: [...z.currentPath, "items", `${V}`]
        })).reduce((U, V) => V === void 0 ? U : [...U, V], []),
        additionalItems: F0(v.rest._def, {
            ...z,
            currentPath: [...z.currentPath, "additionalItems"]
        })
    };
    else return {
        type: "array",
        minItems: v.items.length,
        maxItems: v.items.length,
        items: v.items.map((U, V) => F0(U._def, {
            ...z,
            currentPath: [...z.currentPath, "items", `${V}`]
        })).reduce((U, V) => V === void 0 ? U : [...U, V], [])
    }
}

function N46(v) {
    return {
        not: J3(v)
    }
}

function K46(v) {
    return J3(v)
}
var x46 = (v, z) => {
        return F0(v.innerType._def, z)
    },
    j46 = (v, z, U) => {
        switch (z) {
            case t.ZodString:
                return pE(v, U);
            case t.ZodNumber:
                return r06(v, U);
            case t.ZodObject:
                return a06(v, U);
            case t.ZodBigInt:
                return f06(v, U);
            case t.ZodBoolean:
                return T06();
            case t.ZodDate:
                return hE(v, U);
            case t.ZodUndefined:
                return N46(U);
            case t.ZodNull:
                return Q06(U);
            case t.ZodArray:
                return C06(v, U);
            case t.ZodUnion:
            case t.ZodDiscriminatedUnion:
                return d06(v, U);
            case t.ZodIntersection:
                return g06(v, U);
            case t.ZodTuple:
                return V46(v, U);
            case t.ZodRecord:
                return nE(v, U);
            case t.ZodLiteral:
                return c06(v, U);
            case t.ZodEnum:
                return m06(v);
            case t.ZodNativeEnum:
                return p06(v);
            case t.ZodNullable:
                return o06(v, U);
            case t.ZodOptional:
                return e06(v, U);
            case t.ZodMap:
                return h06(v, U);
            case t.ZodSet:
                return U46(v, U);
            case t.ZodLazy:
                return () => v.getter()._def;
            case t.ZodPromise:
                return z46(v, U);
            case t.ZodNaN:
            case t.ZodNever:
                return n06(U);
            case t.ZodEffects:
                return k06(v, U);
            case t.ZodAny:
                return J3(U);
            case t.ZodUnknown:
                return K46(U);
            case t.ZodDefault:
                return y06(v, U);
            case t.ZodBranded:
                return lE(v, U);
            case t.ZodReadonly:
                return x46(v, U);
            case t.ZodCatch:
                return Y06(v, U);
            case t.ZodPipeline:
                return v46(v, U);
            case t.ZodFunction:
            case t.ZodVoid:
            case t.ZodSymbol:
                return;
            default:
                return ((V) => {
                    return
                })(z)
        }
    };

function F0(v, z, U = !1) {
    let V = z.seen.get(v);
    if (z.override) {
        let j = z.override?.(v, z, V, U);
        if (j !== S06) return j
    }
    if (V && !U) {
        let j = B46(V, z);
        if (j !== void 0) return j
    }
    let N = {
        def: v,
        path: z.currentPath,
        jsonSchema: void 0
    };
    z.seen.set(v, N);
    let K = j46(v, v.typeName, z),
        x = typeof K === "function" ? F0(K(), z) : K;
    if (x) O46(v, z, x);
    if (z.postProcess) {
        let j = z.postProcess(x, v, z);
        return N.jsonSchema = x, j
    }
    return N.jsonSchema = x, x
}
var B46 = (v, z) => {
        switch (z.$refStrategy) {
            case "root":
                return {
                    $ref: v.path.join("/")
                };
            case "relative":
                return {
                    $ref: iE(z.currentPath, v.path)
                };
            case "none":
            case "seen": {
                if (v.path.length < z.currentPath.length && v.path.every((U, V) => z.currentPath[V] === U)) return console.warn(`Recursive reference detected at ${z.currentPath.join("/")}! Defaulting to any`), J3(z);
                return z.$refStrategy === "seen" ? J3(z) : void 0
            }
        }
    },
    O46 = (v, z, U) => {
        if (v.description) {
            if (U.description = v.description, z.markdownDescription) U.markdownDescription = v.description
        }
        return U
    },
    J46 = (v, z) => {
        let U = _06(z),
            V = typeof z === "object" && z.definitions ? Object.entries(z.definitions).reduce((B, [O, J]) => ({
                ...B,
                [O]: F0(J._def, {
                    ...U,
                    currentPath: [...U.basePath, U.definitionPath, O]
                }, !0) ?? J3(U)
            }), {}) : void 0,
            N = typeof z === "string" ? z : z?.nameStrategy === "title" ? void 0 : z?.name,
            K = F0(v._def, N === void 0 ? U : {
                ...U,
                currentPath: [...U.basePath, U.definitionPath, N]
            }, !1) ?? J3(U),
            x = typeof z === "object" && z.name !== void 0 && z.nameStrategy === "title" ? z.name : void 0;
        if (x !== void 0) K.title = x;
        if (U.flags.hasReferencedOpenAiAnyType) {
            if (!V) V = {};
            if (!V[U.openAiAnyTypeName]) V[U.openAiAnyTypeName] = {
                type: ["string", "number", "integer", "boolean", "array", "null"],
                items: {
                    $ref: U.$refStrategy === "relative" ? "1" : [...U.basePath, U.definitionPath, U.openAiAnyTypeName].join("/")
                }
            }
        }
        let j = N === void 0 ? V ? {
            ...K,
            [U.definitionPath]: V
        } : K : {
            $ref: [...U.$refStrategy === "relative" ? [] : U.basePath, U.definitionPath, N].join("/"),
            [U.definitionPath]: {
                ...V,
                [N]: K
            }
        };
        if (U.target === "jsonSchema7") j.$schema = "http://json-schema.org/draft-07/schema#";
        else if (U.target === "jsonSchema2019-09" || U.target === "openAi") j.$schema = "https://json-schema.org/draft/2019-09/schema#";
        if (U.target === "openAi" && (("anyOf" in j) || ("oneOf" in j) || ("allOf" in j) || ("type" in j) && Array.isArray(j.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
        return j
    };

function q46(v) {
    if (!v) return "draft-7";
    if (v === "jsonSchema7" || v === "draft-7") return "draft-7";
    if (v === "jsonSchema2019-09" || v === "draft-2020-12") return "draft-2020-12";
    return "draft-7"
}

function TR(v, z) {
    var U, V, N;
    if (U8(v)) return rs(v, {
        target: q46(z === null || z === void 0 ? void 0 : z.target),
        io: (U = z === null || z === void 0 ? void 0 : z.pipeStrategy) !== null && U !== void 0 ? U : "input"
    });
    return J46(v, {
        strictUnions: (V = z === null || z === void 0 ? void 0 : z.strictUnions) !== null && V !== void 0 ? V : !0,
        pipeStrategy: (N = z === null || z === void 0 ? void 0 : z.pipeStrategy) !== null && N !== void 0 ? N : "input"
    })
}

function YR(v) {
    let z = cz(v),
        U = z === null || z === void 0 ? void 0 : z.method;
    if (!U) throw Error("Schema is missing a method literal");
    let V = sW(U);
    if (typeof V !== "string") throw Error("Schema method literal must be a string");
    return V
}

function uR(v, z) {
    let U = bz(v, z);
    if (!U.success) throw U.error;
    return U.data
}
var H46 = 60000;
class QE {
    constructor(v) {
        if (this._options = v, this._requestMessageId = 0, this._requestHandlers = new Map, this._requestHandlerAbortControllers = new Map, this._notificationHandlers = new Map, this._responseHandlers = new Map, this._progressHandlers = new Map, this._timeoutInfo = new Map, this._pendingDebouncedNotifications = new Set, this._taskProgressTokens = new Map, this._requestResolvers = new Map, this.setNotificationHandler(kH, (z) => {
                this._oncancel(z)
            }), this.setNotificationHandler(XH, (z) => {
                this._onprogress(z)
            }), this.setRequestHandler(mH, (z) => ({})), this._taskStore = v === null || v === void 0 ? void 0 : v.taskStore, this._taskMessageQueue = v === null || v === void 0 ? void 0 : v.taskMessageQueue, this._taskStore) this.setRequestHandler(gH, async (z, U) => {
            let V = await this._taskStore.getTask(z.params.taskId, U.sessionId);
            if (!V) throw new S6(y6.InvalidParams, "Failed to retrieve task: Task not found");
            return {
                ...V
            }
        }), this.setRequestHandler(iH, async (z, U) => {
            let V = async () => {
                var N;
                let K = z.params.taskId;
                if (this._taskMessageQueue) {
                    let j;
                    while (j = await this._taskMessageQueue.dequeue(K, U.sessionId)) {
                        if (j.type === "response" || j.type === "error") {
                            let B = j.message,
                                O = B.id,
                                J = this._requestResolvers.get(O);
                            if (J)
                                if (this._requestResolvers.delete(O), j.type === "response") J(B);
                                else {
                                    let q = B,
                                        H = new S6(q.error.code, q.error.message, q.error.data);
                                    J(H)
                                }
                            else {
                                let q = j.type === "response" ? "Response" : "Error";
                                this._onerror(Error(`${q} handler missing for request ${O}`))
                            }
                            continue
                        }
                        await ((N = this._transport) === null || N === void 0 ? void 0 : N.send(j.message, {
                            relatedRequestId: U.requestId
                        }))
                    }
                }
                let x = await this._taskStore.getTask(K, U.sessionId);
                if (!x) throw new S6(y6.InvalidParams, `Task not found: ${K}`);
                if (!i5(x.status)) return await this._waitForTaskUpdate(K, U.signal), await V();
                if (i5(x.status)) {
                    let j = await this._taskStore.getTaskResult(K, U.sessionId);
                    return this._clearTaskQueue(K), {
                        ...j,
                        _meta: {
                            ...j._meta,
                            [z9]: {
                                taskId: K
                            }
                        }
                    }
                }
                return await V()
            };
            return await V()
        }), this.setRequestHandler(lH, async (z, U) => {
            var V;
            try {
                let {
                    tasks: N,
                    nextCursor: K
                } = await this._taskStore.listTasks((V = z.params) === null || V === void 0 ? void 0 : V.cursor, U.sessionId);
                return {
                    tasks: N,
                    nextCursor: K,
                    _meta: {}
                }
            } catch (N) {
                throw new S6(y6.InvalidParams, `Failed to list tasks: ${N instanceof Error?N.message:String(N)}`)
            }
        }), this.setRequestHandler(A66, async (z, U) => {
            try {
                let V = await this._taskStore.getTask(z.params.taskId, U.sessionId);
                if (!V) throw new S6(y6.InvalidParams, `Task not found: ${z.params.taskId}`);
                if (i5(V.status)) throw new S6(y6.InvalidParams, `Cannot cancel task in terminal status: ${V.status}`);
                await this._taskStore.updateTaskStatus(z.params.taskId, "cancelled", "Client cancelled task execution.", U.sessionId), this._clearTaskQueue(z.params.taskId);
                let N = await this._taskStore.getTask(z.params.taskId, U.sessionId);
                if (!N) throw new S6(y6.InvalidParams, `Task not found after cancellation: ${z.params.taskId}`);
                return {
                    _meta: {},
                    ...N
                }
            } catch (V) {
                if (V instanceof S6) throw V;
                throw new S6(y6.InvalidRequest, `Failed to cancel task: ${V instanceof Error?V.message:String(V)}`)
            }
        })
    }
    async _oncancel(v) {
        let z = this._requestHandlerAbortControllers.get(v.params.requestId);
        z === null || z === void 0 || z.abort(v.params.reason)
    }
    _setupTimeout(v, z, U, V, N = !1) {
        this._timeoutInfo.set(v, {
            timeoutId: setTimeout(V, z),
            startTime: Date.now(),
            timeout: z,
            maxTotalTimeout: U,
            resetTimeoutOnProgress: N,
            onTimeout: V
        })
    }
    _resetTimeout(v) {
        let z = this._timeoutInfo.get(v);
        if (!z) return !1;
        let U = Date.now() - z.startTime;
        if (z.maxTotalTimeout && U >= z.maxTotalTimeout) throw this._timeoutInfo.delete(v), S6.fromError(y6.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: z.maxTotalTimeout,
            totalElapsed: U
        });
        return clearTimeout(z.timeoutId), z.timeoutId = setTimeout(z.onTimeout, z.timeout), !0
    }
    _cleanupTimeout(v) {
        let z = this._timeoutInfo.get(v);
        if (z) clearTimeout(z.timeoutId), this._timeoutInfo.delete(v)
    }
    async connect(v) {
        var z, U, V;
        this._transport = v;
        let N = (z = this.transport) === null || z === void 0 ? void 0 : z.onclose;
        this._transport.onclose = () => {
            N === null || N === void 0 || N(), this._onclose()
        };
        let K = (U = this.transport) === null || U === void 0 ? void 0 : U.onerror;
        this._transport.onerror = (j) => {
            K === null || K === void 0 || K(j), this._onerror(j)
        };
        let x = (V = this._transport) === null || V === void 0 ? void 0 : V.onmessage;
        this._transport.onmessage = (j, B) => {
            if (x === null || x === void 0 || x(j, B), OK(j) || ee(j)) this._onresponse(j);
            else if (PR(j)) this._onrequest(j, B);
            else if (se(j)) this._onnotification(j);
            else this._onerror(Error(`Unknown message type: ${JSON.stringify(j)}`))
        }, await this._transport.start()
    }
    _onclose() {
        var v;
        let z = this._responseHandlers;
        this._responseHandlers = new Map, this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
        let U = S6.fromError(y6.ConnectionClosed, "Connection closed");
        this._transport = void 0, (v = this.onclose) === null || v === void 0 || v.call(this);
        for (let V of z.values()) V(U)
    }
    _onerror(v) {
        var z;
        (z = this.onerror) === null || z === void 0 || z.call(this, v)
    }
    _onnotification(v) {
        var z;
        let U = (z = this._notificationHandlers.get(v.method)) !== null && z !== void 0 ? z : this.fallbackNotificationHandler;
        if (U === void 0) return;
        Promise.resolve().then(() => U(v)).catch((V) => this._onerror(Error(`Uncaught error in notification handler: ${V}`)))
    }
    _onrequest(v, z) {
        var U, V, N, K, x, j;
        let B = (U = this._requestHandlers.get(v.method)) !== null && U !== void 0 ? U : this.fallbackRequestHandler,
            O = this._transport,
            J = (K = (N = (V = v.params) === null || V === void 0 ? void 0 : V._meta) === null || N === void 0 ? void 0 : N[z9]) === null || K === void 0 ? void 0 : K.taskId;
        if (B === void 0) {
            let w = {
                jsonrpc: "2.0",
                id: v.id,
                error: {
                    code: y6.MethodNotFound,
                    message: "Method not found"
                }
            };
            if (J && this._taskMessageQueue) this._enqueueTaskMessage(J, {
                type: "error",
                message: w,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId).catch((Z) => this._onerror(Error(`Failed to enqueue error response: ${Z}`)));
            else O === null || O === void 0 || O.send(w).catch((Z) => this._onerror(Error(`Failed to send an error response: ${Z}`)));
            return
        }
        let q = new AbortController;
        this._requestHandlerAbortControllers.set(v.id, q);
        let H = (x = v.params) === null || x === void 0 ? void 0 : x.task,
            D = this._taskStore ? this.requestTaskStore(v, O === null || O === void 0 ? void 0 : O.sessionId) : void 0,
            A = {
                signal: q.signal,
                sessionId: O === null || O === void 0 ? void 0 : O.sessionId,
                _meta: (j = v.params) === null || j === void 0 ? void 0 : j._meta,
                sendNotification: async (w) => {
                    let Z = {
                        relatedRequestId: v.id
                    };
                    if (J) Z.relatedTask = {
                        taskId: J
                    };
                    await this.notification(w, Z)
                },
                sendRequest: async (w, Z, $) => {
                    var F, L;
                    let G = {
                        ...$,
                        relatedRequestId: v.id
                    };
                    if (J && !G.relatedTask) G.relatedTask = {
                        taskId: J
                    };
                    let I = (L = (F = G.relatedTask) === null || F === void 0 ? void 0 : F.taskId) !== null && L !== void 0 ? L : J;
                    if (I && D) await D.updateTaskStatus(I, "input_required");
                    return await this.request(w, Z, G)
                },
                authInfo: z === null || z === void 0 ? void 0 : z.authInfo,
                requestId: v.id,
                requestInfo: z === null || z === void 0 ? void 0 : z.requestInfo,
                taskId: J,
                taskStore: D,
                taskRequestedTtl: H === null || H === void 0 ? void 0 : H.ttl,
                closeSSEStream: z === null || z === void 0 ? void 0 : z.closeSSEStream,
                closeStandaloneSSEStream: z === null || z === void 0 ? void 0 : z.closeStandaloneSSEStream
            };
        Promise.resolve().then(() => {
            if (H) this.assertTaskHandlerCapability(v.method)
        }).then(() => B(v, A)).then(async (w) => {
            if (q.signal.aborted) return;
            let Z = {
                result: w,
                jsonrpc: "2.0",
                id: v.id
            };
            if (J && this._taskMessageQueue) await this._enqueueTaskMessage(J, {
                type: "response",
                message: Z,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId);
            else await (O === null || O === void 0 ? void 0 : O.send(Z))
        }, async (w) => {
            var Z;
            if (q.signal.aborted) return;
            let $ = {
                jsonrpc: "2.0",
                id: v.id,
                error: {
                    code: Number.isSafeInteger(w.code) ? w.code : y6.InternalError,
                    message: (Z = w.message) !== null && Z !== void 0 ? Z : "Internal error",
                    ...w.data !== void 0 && {
                        data: w.data
                    }
                }
            };
            if (J && this._taskMessageQueue) await this._enqueueTaskMessage(J, {
                type: "error",
                message: $,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId);
            else await (O === null || O === void 0 ? void 0 : O.send($))
        }).catch((w) => this._onerror(Error(`Failed to send response: ${w}`))).finally(() => {
            this._requestHandlerAbortControllers.delete(v.id)
        })
    }
    _onprogress(v) {
        let {
            progressToken: z,
            ...U
        } = v.params, V = Number(z), N = this._progressHandlers.get(V);
        if (!N) {
            this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(v)}`));
            return
        }
        let K = this._responseHandlers.get(V),
            x = this._timeoutInfo.get(V);
        if (x && K && x.resetTimeoutOnProgress) try {
            this._resetTimeout(V)
        } catch (j) {
            this._responseHandlers.delete(V), this._progressHandlers.delete(V), this._cleanupTimeout(V), K(j);
            return
        }
        N(U)
    }
    _onresponse(v) {
        let z = Number(v.id),
            U = this._requestResolvers.get(z);
        if (U) {
            if (this._requestResolvers.delete(z), OK(v)) U(v);
            else {
                let K = new S6(v.error.code, v.error.message, v.error.data);
                U(K)
            }
            return
        }
        let V = this._responseHandlers.get(z);
        if (V === void 0) {
            this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(v)}`));
            return
        }
        this._responseHandlers.delete(z), this._cleanupTimeout(z);
        let N = !1;
        if (OK(v) && v.result && typeof v.result === "object") {
            let K = v.result;
            if (K.task && typeof K.task === "object") {
                let x = K.task;
                if (typeof x.taskId === "string") N = !0, this._taskProgressTokens.set(x.taskId, z)
            }
        }
        if (!N) this._progressHandlers.delete(z);
        if (OK(v)) V(v);
        else {
            let K = S6.fromError(v.error.code, v.error.message, v.error.data);
            V(K)
        }
    }
    get transport() {
        return this._transport
    }
    async close() {
        var v;
        await ((v = this._transport) === null || v === void 0 ? void 0 : v.close())
    }
    async * requestStream(v, z, U) {
        var V, N, K, x;
        let {
            task: j
        } = U !== null && U !== void 0 ? U : {};
        if (!j) {
            try {
                yield {
                    type: "result",
                    result: await this.request(v, z, U)
                }
            } catch (O) {
                yield {
                    type: "error",
                    error: O instanceof S6 ? O : new S6(y6.InternalError, String(O))
                }
            }
            return
        }
        let B;
        try {
            let O = await this.request(v, hK, U);
            if (O.task) B = O.task.taskId, yield {
                type: "taskCreated",
                task: O.task
            };
            else throw new S6(y6.InternalError, "Task creation did not return a task");
            while (!0) {
                let J = await this.getTask({
                    taskId: B
                }, U);
                if (yield {
                        type: "taskStatus",
                        task: J
                    }, i5(J.status)) {
                    if (J.status === "completed") yield {
                        type: "result",
                        result: await this.getTaskResult({
                            taskId: B
                        }, z, U)
                    };
                    else if (J.status === "failed") yield {
                        type: "error",
                        error: new S6(y6.InternalError, `Task ${B} failed`)
                    };
                    else if (J.status === "cancelled") yield {
                        type: "error",
                        error: new S6(y6.InternalError, `Task ${B} was cancelled`)
                    };
                    return
                }
                if (J.status === "input_required") {
                    yield {
                        type: "result",
                        result: await this.getTaskResult({
                            taskId: B
                        }, z, U)
                    };
                    return
                }
                let q = (K = (V = J.pollInterval) !== null && V !== void 0 ? V : (N = this._options) === null || N === void 0 ? void 0 : N.defaultTaskPollInterval) !== null && K !== void 0 ? K : 1000;
                await new Promise((H) => setTimeout(H, q)), (x = U === null || U === void 0 ? void 0 : U.signal) === null || x === void 0 || x.throwIfAborted()
            }
        } catch (O) {
            yield {
                type: "error",
                error: O instanceof S6 ? O : new S6(y6.InternalError, String(O))
            }
        }
    }
    request(v, z, U) {
        let {
            relatedRequestId: V,
            resumptionToken: N,
            onresumptiontoken: K,
            task: x,
            relatedTask: j
        } = U !== null && U !== void 0 ? U : {};
        return new Promise((B, O) => {
            var J, q, H, D, A, w, Z;
            let $ = (W) => {
                O(W)
            };
            if (!this._transport) {
                $(Error("Not connected"));
                return
            }
            if (((J = this._options) === null || J === void 0 ? void 0 : J.enforceStrictCapabilities) === !0) try {
                if (this.assertCapabilityForMethod(v.method), x) this.assertTaskCapability(v.method)
            } catch (W) {
                $(W);
                return
            }(q = U === null || U === void 0 ? void 0 : U.signal) === null || q === void 0 || q.throwIfAborted();
            let F = this._requestMessageId++,
                L = {
                    ...v,
                    jsonrpc: "2.0",
                    id: F
                };
            if (U === null || U === void 0 ? void 0 : U.onprogress) this._progressHandlers.set(F, U.onprogress), L.params = {
                ...v.params,
                _meta: {
                    ...((H = v.params) === null || H === void 0 ? void 0 : H._meta) || {},
                    progressToken: F
                }
            };
            if (x) L.params = {
                ...L.params,
                task: x
            };
            if (j) L.params = {
                ...L.params,
                _meta: {
                    ...((D = L.params) === null || D === void 0 ? void 0 : D._meta) || {},
                    [z9]: j
                }
            };
            let G = (W) => {
                var E;
                this._responseHandlers.delete(F), this._progressHandlers.delete(F), this._cleanupTimeout(F), (E = this._transport) === null || E === void 0 || E.send({
                    jsonrpc: "2.0",
                    method: "notifications/cancelled",
                    params: {
                        requestId: F,
                        reason: String(W)
                    }
                }, {
                    relatedRequestId: V,
                    resumptionToken: N,
                    onresumptiontoken: K
                }).catch((T) => this._onerror(Error(`Failed to send cancellation: ${T}`)));
                let y = W instanceof S6 ? W : new S6(y6.RequestTimeout, String(W));
                O(y)
            };
            this._responseHandlers.set(F, (W) => {
                var E;
                if ((E = U === null || U === void 0 ? void 0 : U.signal) === null || E === void 0 ? void 0 : E.aborted) return;
                if (W instanceof Error) return O(W);
                try {
                    let y = bz(z, W.result);
                    if (!y.success) O(y.error);
                    else B(y.data)
                } catch (y) {
                    O(y)
                }
            }), (A = U === null || U === void 0 ? void 0 : U.signal) === null || A === void 0 || A.addEventListener("abort", () => {
                var W;
                G((W = U === null || U === void 0 ? void 0 : U.signal) === null || W === void 0 ? void 0 : W.reason)
            });
            let I = (w = U === null || U === void 0 ? void 0 : U.timeout) !== null && w !== void 0 ? w : H46,
                M = () => G(S6.fromError(y6.RequestTimeout, "Request timed out", {
                    timeout: I
                }));
            this._setupTimeout(F, I, U === null || U === void 0 ? void 0 : U.maxTotalTimeout, M, (Z = U === null || U === void 0 ? void 0 : U.resetTimeoutOnProgress) !== null && Z !== void 0 ? Z : !1);
            let b = j === null || j === void 0 ? void 0 : j.taskId;
            if (b) {
                let W = (E) => {
                    let y = this._responseHandlers.get(F);
                    if (y) y(E);
                    else this._onerror(Error(`Response handler missing for side-channeled request ${F}`))
                };
                this._requestResolvers.set(F, W), this._enqueueTaskMessage(b, {
                    type: "request",
                    message: L,
                    timestamp: Date.now()
                }).catch((E) => {
                    this._cleanupTimeout(F), O(E)
                })
            } else this._transport.send(L, {
                relatedRequestId: V,
                resumptionToken: N,
                onresumptiontoken: K
            }).catch((W) => {
                this._cleanupTimeout(F), O(W)
            })
        })
    }
    async getTask(v, z) {
        return this.request({
            method: "tasks/get",
            params: v
        }, cH, z)
    }
    async getTaskResult(v, z, U) {
        return this.request({
            method: "tasks/result",
            params: v
        }, z, U)
    }
    async listTasks(v, z) {
        return this.request({
            method: "tasks/list",
            params: v
        }, hH, z)
    }
    async cancelTask(v, z) {
        return this.request({
            method: "tasks/cancel",
            params: v
        }, $66, z)
    }
    async notification(v, z) {
        var U, V, N, K, x;
        if (!this._transport) throw Error("Not connected");
        this.assertNotificationCapability(v.method);
        let j = (U = z === null || z === void 0 ? void 0 : z.relatedTask) === null || U === void 0 ? void 0 : U.taskId;
        if (j) {
            let O = {
                ...v,
                jsonrpc: "2.0",
                params: {
                    ...v.params,
                    _meta: {
                        ...((V = v.params) === null || V === void 0 ? void 0 : V._meta) || {},
                        [z9]: z.relatedTask
                    }
                }
            };
            await this._enqueueTaskMessage(j, {
                type: "notification",
                message: O,
                timestamp: Date.now()
            });
            return
        }
        if (((K = (N = this._options) === null || N === void 0 ? void 0 : N.debouncedNotificationMethods) !== null && K !== void 0 ? K : []).includes(v.method) && !v.params && !(z === null || z === void 0 ? void 0 : z.relatedRequestId) && !(z === null || z === void 0 ? void 0 : z.relatedTask)) {
            if (this._pendingDebouncedNotifications.has(v.method)) return;
            this._pendingDebouncedNotifications.add(v.method), Promise.resolve().then(() => {
                var O, J;
                if (this._pendingDebouncedNotifications.delete(v.method), !this._transport) return;
                let q = {
                    ...v,
                    jsonrpc: "2.0"
                };
                if (z === null || z === void 0 ? void 0 : z.relatedTask) q = {
                    ...q,
                    params: {
                        ...q.params,
                        _meta: {
                            ...((O = q.params) === null || O === void 0 ? void 0 : O._meta) || {},
                            [z9]: z.relatedTask
                        }
                    }
                };
                (J = this._transport) === null || J === void 0 || J.send(q, z).catch((H) => this._onerror(H))
            });
            return
        }
        let B = {
            ...v,
            jsonrpc: "2.0"
        };
        if (z === null || z === void 0 ? void 0 : z.relatedTask) B = {
            ...B,
            params: {
                ...B.params,
                _meta: {
                    ...((x = B.params) === null || x === void 0 ? void 0 : x._meta) || {},
                    [z9]: z.relatedTask
                }
            }
        };
        await this._transport.send(B, z)
    }
    setRequestHandler(v, z) {
        let U = YR(v);
        this.assertRequestHandlerCapability(U), this._requestHandlers.set(U, (V, N) => {
            let K = uR(v, V);
            return Promise.resolve(z(K, N))
        })
    }
    removeRequestHandler(v) {
        this._requestHandlers.delete(v)
    }
    assertCanSetRequestHandler(v) {
        if (this._requestHandlers.has(v)) throw Error(`A request handler for ${v} already exists, which would be overridden`)
    }
    setNotificationHandler(v, z) {
        let U = YR(v);
        this._notificationHandlers.set(U, (V) => {
            let N = uR(v, V);
            return Promise.resolve(z(N))
        })
    }
    removeNotificationHandler(v) {
        this._notificationHandlers.delete(v)
    }
    _cleanupTaskProgressHandler(v) {
        let z = this._taskProgressTokens.get(v);
        if (z !== void 0) this._progressHandlers.delete(z), this._taskProgressTokens.delete(v)
    }
    async _enqueueTaskMessage(v, z, U) {
        var V;
        if (!this._taskStore || !this._taskMessageQueue) throw Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
        let N = (V = this._options) === null || V === void 0 ? void 0 : V.maxTaskQueueSize;
        await this._taskMessageQueue.enqueue(v, z, U, N)
    }
    async _clearTaskQueue(v, z) {
        if (this._taskMessageQueue) {
            let U = await this._taskMessageQueue.dequeueAll(v, z);
            for (let V of U)
                if (V.type === "request" && PR(V.message)) {
                    let N = V.message.id,
                        K = this._requestResolvers.get(N);
                    if (K) K(new S6(y6.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(N);
                    else this._onerror(Error(`Resolver missing for request ${N} during task ${v} cleanup`))
                }
        }
    }
    async _waitForTaskUpdate(v, z) {
        var U, V, N;
        let K = (V = (U = this._options) === null || U === void 0 ? void 0 : U.defaultTaskPollInterval) !== null && V !== void 0 ? V : 1000;
        try {
            let x = await ((N = this._taskStore) === null || N === void 0 ? void 0 : N.getTask(v));
            if (x === null || x === void 0 ? void 0 : x.pollInterval) K = x.pollInterval
        } catch (x) {}
        return new Promise((x, j) => {
            if (z.aborted) {
                j(new S6(y6.InvalidRequest, "Request cancelled"));
                return
            }
            let B = setTimeout(x, K);
            z.addEventListener("abort", () => {
                clearTimeout(B), j(new S6(y6.InvalidRequest, "Request cancelled"))
            }, {
                once: !0
            })
        })
    }
    requestTaskStore(v, z) {
        let U = this._taskStore;
        if (!U) throw Error("No task store configured");
        return {
            createTask: async (V) => {
                if (!v) throw Error("No request provided");
                return await U.createTask(V, v.id, {
                    method: v.method,
                    params: v.params
                }, z)
            },
            getTask: async (V) => {
                let N = await U.getTask(V, z);
                if (!N) throw new S6(y6.InvalidParams, "Failed to retrieve task: Task not found");
                return N
            },
            storeTaskResult: async (V, N, K) => {
                await U.storeTaskResult(V, N, K, z);
                let x = await U.getTask(V, z);
                if (x) {
                    let j = MK.parse({
                        method: "notifications/tasks/status",
                        params: x
                    });
                    if (await this.notification(j), i5(x.status)) this._cleanupTaskProgressHandler(V)
                }
            },
            getTaskResult: (V) => {
                return U.getTaskResult(V, z)
            },
            updateTaskStatus: async (V, N, K) => {
                let x = await U.getTask(V, z);
                if (!x) throw new S6(y6.InvalidParams, `Task "${V}" not found - it may have been cleaned up`);
                if (i5(x.status)) throw new S6(y6.InvalidParams, `Cannot update task "${V}" from terminal status "${x.status}" to "${N}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
                await U.updateTaskStatus(V, N, K, z);
                let j = await U.getTask(V, z);
                if (j) {
                    let B = MK.parse({
                        method: "notifications/tasks/status",
                        params: j
                    });
                    if (await this.notification(B), i5(j.status)) this._cleanupTaskProgressHandler(V)
                }
            },
            listTasks: (V) => {
                return U.listTasks(V, z)
            }
        }
    }
}

function yR(v) {
    return v !== null && typeof v === "object" && !Array.isArray(v)
}

function D46(v, z) {
    let U = {
        ...v
    };
    for (let V in z) {
        let N = V,
            K = z[N];
        if (K === void 0) continue;
        let x = U[N];
        if (yR(x) && yR(K)) U[N] = {
            ...x,
            ...K
        };
        else U[N] = K
    }
    return U
}
var A46 = cR(oR(), 1),
    $46 = cR(wd(), 1);

function w46() {
    let v = new A46.Ajv({
        strict: !1,
        validateFormats: !0,
        validateSchema: !1,
        allErrors: !0
    });
    return $46.default(v), v
}
class dE {
    constructor(v) {
        this._ajv = v !== null && v !== void 0 ? v : w46()
    }
    getValidator(v) {
        var z;
        let U = "$id" in v && typeof v.$id === "string" ? (z = this._ajv.getSchema(v.$id)) !== null && z !== void 0 ? z : this._ajv.compile(v) : this._ajv.compile(v);
        return (V) => {
            if (U(V)) return {
                valid: !0,
                data: V,
                errorMessage: void 0
            };
            else return {
                valid: !1,
                data: void 0,
                errorMessage: this._ajv.errorsText(U.errors)
            }
        }
    }
}
class oE {
    constructor(v) {
        this._server = v
    }
    requestStream(v, z, U) {
        return this._server.requestStream(v, z, U)
    }
    async getTask(v, z) {
        return this._server.getTask({
            taskId: v
        }, z)
    }
    async getTaskResult(v, z, U) {
        return this._server.getTaskResult({
            taskId: v
        }, z, U)
    }
    async listTasks(v, z) {
        return this._server.listTasks(v ? {
            cursor: v
        } : void 0, z)
    }
    async cancelTask(v, z) {
        return this._server.cancelTask({
            taskId: v
        }, z)
    }
}

function Z46(v, z, U) {
    var V;
    if (!v) throw Error(`${U} does not support task creation (required for ${z})`);
    switch (z) {
        case "tools/call":
            if (!((V = v.tools) === null || V === void 0 ? void 0 : V.call)) throw Error(`${U} does not support task creation for tools/call (required for ${z})`);
            break;
        default:
            break
    }
}

function L46(v, z, U) {
    var V, N;
    if (!v) throw Error(`${U} does not support task creation (required for ${z})`);
    switch (z) {
        case "sampling/createMessage":
            if (!((V = v.sampling) === null || V === void 0 ? void 0 : V.createMessage)) throw Error(`${U} does not support task creation for sampling/createMessage (required for ${z})`);
            break;
        case "elicitation/create":
            if (!((N = v.elicitation) === null || N === void 0 ? void 0 : N.create)) throw Error(`${U} does not support task creation for elicitation/create (required for ${z})`);
            break;
        default:
            break
    }
}
class rE extends QE {
    constructor(v, z) {
        var U, V;
        super(z);
        if (this._serverInfo = v, this._loggingLevels = new Map, this.LOG_LEVEL_SEVERITY = new Map(RK.options.map((N, K) => [N, K])), this.isMessageIgnored = (N, K) => {
                let x = this._loggingLevels.get(K);
                return x ? this.LOG_LEVEL_SEVERITY.get(N) < this.LOG_LEVEL_SEVERITY.get(x) : !1
            }, this._capabilities = (U = z === null || z === void 0 ? void 0 : z.capabilities) !== null && U !== void 0 ? U : {}, this._instructions = z === null || z === void 0 ? void 0 : z.instructions, this._jsonSchemaValidator = (V = z === null || z === void 0 ? void 0 : z.jsonSchemaValidator) !== null && V !== void 0 ? V : new dE, this.setRequestHandler(PE, (N) => this._oninitialize(N)), this.setNotificationHandler(_E, () => {
                var N;
                return (N = this.oninitialized) === null || N === void 0 ? void 0 : N.call(this)
            }), this._capabilities.logging) this.setRequestHandler(yE, async (N, K) => {
            var x;
            let j = K.sessionId || ((x = K.requestInfo) === null || x === void 0 ? void 0 : x.headers["mcp-session-id"]) || void 0,
                {
                    level: B
                } = N.params,
                O = RK.safeParse(B);
            if (O.success) this._loggingLevels.set(j, O.data);
            return {}
        })
    }
    get experimental() {
        if (!this._experimental) this._experimental = {
            tasks: new oE(this)
        };
        return this._experimental
    }
    registerCapabilities(v) {
        if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
        this._capabilities = D46(this._capabilities, v)
    }
    setRequestHandler(v, z) {
        var U, V, N;
        let K = cz(v),
            x = K === null || K === void 0 ? void 0 : K.method;
        if (!x) throw Error("Schema is missing a method literal");
        let j;
        if (U8(x)) {
            let B = x,
                O = (U = B._zod) === null || U === void 0 ? void 0 : U.def;
            j = (V = O === null || O === void 0 ? void 0 : O.value) !== null && V !== void 0 ? V : B.value
        } else {
            let B = x,
                O = B._def;
            j = (N = O === null || O === void 0 ? void 0 : O.value) !== null && N !== void 0 ? N : B.value
        }
        if (typeof j !== "string") throw Error("Schema method literal must be a string");
        if (j === "tools/call") {
            let B = async (O, J) => {
                let q = bz(bK, O);
                if (!q.success) {
                    let w = q.error instanceof Error ? q.error.message : String(q.error);
                    throw new S6(y6.InvalidParams, `Invalid tools/call request: ${w}`)
                }
                let {
                    params: H
                } = q.data, D = await Promise.resolve(z(O, J));
                if (H.task) {
                    let w = bz(hK, D);
                    if (!w.success) {
                        let Z = w.error instanceof Error ? w.error.message : String(w.error);
                        throw new S6(y6.InvalidParams, `Invalid task creation result: ${Z}`)
                    }
                    return w.data
                }
                let A = bz(aH, D);
                if (!A.success) {
                    let w = A.error instanceof Error ? A.error.message : String(A.error);
                    throw new S6(y6.InvalidParams, `Invalid tools/call result: ${w}`)
                }
                return A.data
            };
            return super.setRequestHandler(v, B)
        }
        return super.setRequestHandler(v, z)
    }
    assertCapabilityForMethod(v) {
        var z, U, V;
        switch (v) {
            case "sampling/createMessage":
                if (!((z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.sampling)) throw Error(`Client does not support sampling (required for ${v})`);
                break;
            case "elicitation/create":
                if (!((U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.elicitation)) throw Error(`Client does not support elicitation (required for ${v})`);
                break;
            case "roots/list":
                if (!((V = this._clientCapabilities) === null || V === void 0 ? void 0 : V.roots)) throw Error(`Client does not support listing roots (required for ${v})`);
                break;
            case "ping":
                break
        }
    }
    assertNotificationCapability(v) {
        var z, U;
        switch (v) {
            case "notifications/message":
                if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${v})`);
                break;
            case "notifications/resources/updated":
            case "notifications/resources/list_changed":
                if (!this._capabilities.resources) throw Error(`Server does not support notifying about resources (required for ${v})`);
                break;
            case "notifications/tools/list_changed":
                if (!this._capabilities.tools) throw Error(`Server does not support notifying of tool list changes (required for ${v})`);
                break;
            case "notifications/prompts/list_changed":
                if (!this._capabilities.prompts) throw Error(`Server does not support notifying of prompt list changes (required for ${v})`);
                break;
            case "notifications/elicitation/complete":
                if (!((U = (z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.elicitation) === null || U === void 0 ? void 0 : U.url)) throw Error(`Client does not support URL elicitation (required for ${v})`);
                break;
            case "notifications/cancelled":
                break;
            case "notifications/progress":
                break
        }
    }
    assertRequestHandlerCapability(v) {
        if (!this._capabilities) return;
        switch (v) {
            case "completion/complete":
                if (!this._capabilities.completions) throw Error(`Server does not support completions (required for ${v})`);
                break;
            case "logging/setLevel":
                if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${v})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!this._capabilities.prompts) throw Error(`Server does not support prompts (required for ${v})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
                if (!this._capabilities.resources) throw Error(`Server does not support resources (required for ${v})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!this._capabilities.tools) throw Error(`Server does not support tools (required for ${v})`);
                break;
            case "tasks/get":
            case "tasks/list":
            case "tasks/result":
            case "tasks/cancel":
                if (!this._capabilities.tasks) throw Error(`Server does not support tasks capability (required for ${v})`);
                break;
            case "ping":
            case "initialize":
                break
        }
    }
    assertTaskCapability(v) {
        var z, U;
        L46((U = (z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.tasks) === null || U === void 0 ? void 0 : U.requests, v, "Client")
    }
    assertTaskHandlerCapability(v) {
        var z;
        if (!this._capabilities) return;
        Z46((z = this._capabilities.tasks) === null || z === void 0 ? void 0 : z.requests, v, "Server")
    }
    async _oninitialize(v) {
        let z = v.params.protocolVersion;
        return this._clientCapabilities = v.params.capabilities, this._clientVersion = v.params.clientInfo, {
            protocolVersion: re.includes(z) ? z : GE,
            capabilities: this.getCapabilities(),
            serverInfo: this._serverInfo,
            ...this._instructions && {
                instructions: this._instructions
            }
        }
    }
    getClientCapabilities() {
        return this._clientCapabilities
    }
    getClientVersion() {
        return this._clientVersion
    }
    getCapabilities() {
        return this._capabilities
    }
    async ping() {
        return this.request({
            method: "ping"
        }, yH)
    }
    async createMessage(v, z) {
        var U, V;
        if (v.tools || v.toolChoice) {
            if (!((V = (U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.sampling) === null || V === void 0 ? void 0 : V.tools)) throw Error("Client does not support sampling tools capability.")
        }
        if (v.messages.length > 0) {
            let N = v.messages[v.messages.length - 1],
                K = Array.isArray(N.content) ? N.content : [N.content],
                x = K.some((J) => J.type === "tool_result"),
                j = v.messages.length > 1 ? v.messages[v.messages.length - 2] : void 0,
                B = j ? Array.isArray(j.content) ? j.content : [j.content] : [],
                O = B.some((J) => J.type === "tool_use");
            if (x) {
                if (K.some((J) => J.type !== "tool_result")) throw Error("The last message must contain only tool_result content if any is present");
                if (!O) throw Error("tool_result blocks are not matching any tool_use from the previous message")
            }
            if (O) {
                let J = new Set(B.filter((H) => H.type === "tool_use").map((H) => H.id)),
                    q = new Set(K.filter((H) => H.type === "tool_result").map((H) => H.toolUseId));
                if (J.size !== q.size || ![...J].every((H) => q.has(H))) throw Error("ids of tool_result blocks and tool_use blocks from previous message do not match")
            }
        }
        if (v.tools) return this.request({
            method: "sampling/createMessage",
            params: v
        }, mE, z);
        return this.request({
            method: "sampling/createMessage",
            params: v
        }, kE, z)
    }
    async elicitInput(v, z) {
        var U, V, N, K, x;
        switch ((U = v.mode) !== null && U !== void 0 ? U : "form") {
            case "url": {
                if (!((N = (V = this._clientCapabilities) === null || V === void 0 ? void 0 : V.elicitation) === null || N === void 0 ? void 0 : N.url)) throw Error("Client does not support url elicitation.");
                let j = v;
                return this.request({
                    method: "elicitation/create",
                    params: j
                }, $H, z)
            }
            case "form": {
                if (!((x = (K = this._clientCapabilities) === null || K === void 0 ? void 0 : K.elicitation) === null || x === void 0 ? void 0 : x.form)) throw Error("Client does not support form elicitation.");
                let j = v.mode === "form" ? v : {
                        ...v,
                        mode: "form"
                    },
                    B = await this.request({
                        method: "elicitation/create",
                        params: j
                    }, $H, z);
                if (B.action === "accept" && B.content && j.requestedSchema) try {
                    let O = this._jsonSchemaValidator.getValidator(j.requestedSchema)(B.content);
                    if (!O.valid) throw new S6(y6.InvalidParams, `Elicitation response content does not match requested schema: ${O.errorMessage}`)
                } catch (O) {
                    if (O instanceof S6) throw O;
                    throw new S6(y6.InternalError, `Error validating elicitation response: ${O instanceof Error?O.message:String(O)}`)
                }
                return B
            }
        }
    }
    createElicitationCompletionNotifier(v, z) {
        var U, V;
        if (!((V = (U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.elicitation) === null || V === void 0 ? void 0 : V.url)) throw Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
        return () => this.notification({
            method: "notifications/elicitation/complete",
            params: {
                elicitationId: v
            }
        }, z)
    }
    async listRoots(v, z) {
        return this.request({
            method: "roots/list",
            params: v
        }, XE, z)
    }
    async sendLoggingMessage(v, z) {
        if (this._capabilities.logging) {
            if (!this.isMessageIgnored(v.level, z)) return this.notification({
                method: "notifications/message",
                params: v
            })
        }
    }
    async sendResourceUpdated(v) {
        return this.notification({
            method: "notifications/resources/updated",
            params: v
        })
    }
    async sendResourceListChanged() {
        return this.notification({
            method: "notifications/resources/list_changed"
        })
    }
    async sendToolListChanged() {
        return this.notification({
            method: "notifications/tools/list_changed"
        })
    }
    async sendPromptListChanged() {
        return this.notification({
            method: "notifications/prompts/list_changed"
        })
    }
}
var aE = Symbol.for("mcp.completable");

function F46(v) {
    return !!v && typeof v === "object" && aE in v
}

function G46(v) {
    let z = v[aE];
    return z === null || z === void 0 ? void 0 : z.complete
}
var kR;
(function(v) {
    v.Completable = "McpCompletable"
})(kR || (kR = {}));
var I46 = /^[A-Za-z0-9._-]{1,128}$/;

function M46(v) {
    let z = [];
    if (v.length === 0) return {
        isValid: !1,
        warnings: ["Tool name cannot be empty"]
    };
    if (v.length > 128) return {
        isValid: !1,
        warnings: [`Tool name exceeds maximum length of 128 characters (current: ${v.length})`]
    };
    if (v.includes(" ")) z.push("Tool name contains spaces, which may cause parsing issues");
    if (v.includes(",")) z.push("Tool name contains commas, which may cause parsing issues");
    if (v.startsWith("-") || v.endsWith("-")) z.push("Tool name starts or ends with a dash, which may cause parsing issues in some contexts");
    if (v.startsWith(".") || v.endsWith(".")) z.push("Tool name starts or ends with a dot, which may cause parsing issues in some contexts");
    if (!I46.test(v)) {
        let U = v.split("").filter((V) => !/[A-Za-z0-9._-]/.test(V)).filter((V, N, K) => K.indexOf(V) === N);
        return z.push(`Tool name contains invalid characters: ${U.map((V)=>`"${V}"`).join(", ")}`, "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)"), {
            isValid: !1,
            warnings: z
        }
    }
    return {
        isValid: !0,
        warnings: z
    }
}

function b46(v, z) {
    if (z.length > 0) {
        console.warn(`Tool name validation warning for "${v}":`);
        for (let U of z) console.warn(`  - ${U}`);
        console.warn("Tool registration will proceed, but this may cause compatibility issues."), console.warn("Consider updating the tool name to conform to the MCP tool naming standard."), console.warn("See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.")
    }
}

function mR(v) {
    let z = M46(v);
    return b46(v, z.warnings), z.isValid
}
class tE {
    constructor(v) {
        this._mcpServer = v
    }
    registerToolTask(v, z, U) {
        let V = {
            taskSupport: "required",
            ...z.execution
        };
        if (V.taskSupport === "forbidden") throw Error(`Cannot register task-based tool '${v}' with taskSupport 'forbidden'. Use registerTool() instead.`);
        return this._mcpServer._createRegisteredTool(v, z.title, z.description, z.inputSchema, z.outputSchema, z.annotations, V, z._meta, U)
    }
}
class sE {
    constructor(v, z) {
        this._registeredResources = {}, this._registeredResourceTemplates = {}, this._registeredTools = {}, this._registeredPrompts = {}, this._toolHandlersInitialized = !1, this._completionHandlerInitialized = !1, this._resourceHandlersInitialized = !1, this._promptHandlersInitialized = !1, this.server = new rE(v, z)
    }
    get experimental() {
        if (!this._experimental) this._experimental = {
            tasks: new tE(this)
        };
        return this._experimental
    }
    async connect(v) {
        return await this.server.connect(v)
    }
    async close() {
        await this.server.close()
    }
    setToolRequestHandlers() {
        if (this._toolHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(i9(AH)), this.server.assertCanSetRequestHandler(i9(bK)), this.server.registerCapabilities({
            tools: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(AH, () => ({
            tools: Object.entries(this._registeredTools).filter(([, v]) => v.enabled).map(([v, z]) => {
                let U = {
                    name: v,
                    title: z.title,
                    description: z.description,
                    inputSchema: (() => {
                        let V = wz(z.inputSchema);
                        return V ? TR(V, {
                            strictUnions: !0,
                            pipeStrategy: "input"
                        }) : R46
                    })(),
                    annotations: z.annotations,
                    execution: z.execution,
                    _meta: z._meta
                };
                if (z.outputSchema) {
                    let V = wz(z.outputSchema);
                    if (V) U.outputSchema = TR(V, {
                        strictUnions: !0,
                        pipeStrategy: "output"
                    })
                }
                return U
            })
        })), this.server.setRequestHandler(bK, async (v, z) => {
            var U;
            try {
                let V = this._registeredTools[v.params.name];
                if (!V) throw new S6(y6.InvalidParams, `Tool ${v.params.name} not found`);
                if (!V.enabled) throw new S6(y6.InvalidParams, `Tool ${v.params.name} disabled`);
                let N = !!v.params.task,
                    K = (U = V.execution) === null || U === void 0 ? void 0 : U.taskSupport,
                    x = "createTask" in V.handler;
                if ((K === "required" || K === "optional") && !x) throw new S6(y6.InternalError, `Tool ${v.params.name} has taskSupport '${K}' but was not registered with registerToolTask`);
                if (K === "required" && !N) throw new S6(y6.MethodNotFound, `Tool ${v.params.name} requires task augmentation (taskSupport: 'required')`);
                if (K === "optional" && !N && x) return await this.handleAutomaticTaskPolling(V, v, z);
                let j = await this.validateToolInput(V, v.params.arguments, v.params.name),
                    B = await this.executeToolHandler(V, j, z);
                if (N) return B;
                return await this.validateToolOutput(V, B, v.params.name), B
            } catch (V) {
                if (V instanceof S6) {
                    if (V.code === y6.UrlElicitationRequired) throw V
                }
                return this.createToolError(V instanceof Error ? V.message : String(V))
            }
        }), this._toolHandlersInitialized = !0
    }
    createToolError(v) {
        return {
            content: [{
                type: "text",
                text: v
            }],
            isError: !0
        }
    }
    async validateToolInput(v, z, U) {
        if (!v.inputSchema) return;
        let V = wz(v.inputSchema),
            N = V !== null && V !== void 0 ? V : v.inputSchema,
            K = await Qq(N, z);
        if (!K.success) {
            let x = "error" in K ? K.error : "Unknown error",
                j = dq(x);
            throw new S6(y6.InvalidParams, `Input validation error: Invalid arguments for tool ${U}: ${j}`)
        }
        return K.data
    }
    async validateToolOutput(v, z, U) {
        if (!v.outputSchema) return;
        if (!("content" in z)) return;
        if (z.isError) return;
        if (!z.structuredContent) throw new S6(y6.InvalidParams, `Output validation error: Tool ${U} has an output schema but no structured content was provided`);
        let V = wz(v.outputSchema),
            N = await Qq(V, z.structuredContent);
        if (!N.success) {
            let K = "error" in N ? N.error : "Unknown error",
                x = dq(K);
            throw new S6(y6.InvalidParams, `Output validation error: Invalid structured content for tool ${U}: ${x}`)
        }
    }
    async executeToolHandler(v, z, U) {
        let V = v.handler;
        if ("createTask" in V) {
            if (!U.taskStore) throw Error("No task store provided.");
            let N = {
                ...U,
                taskStore: U.taskStore
            };
            if (v.inputSchema) return await Promise.resolve(V.createTask(z, N));
            else return await Promise.resolve(V.createTask(N))
        }
        if (v.inputSchema) return await Promise.resolve(V(z, U));
        else return await Promise.resolve(V(U))
    }
    async handleAutomaticTaskPolling(v, z, U) {
        var V;
        if (!U.taskStore) throw Error("No task store provided for task-capable tool.");
        let N = await this.validateToolInput(v, z.params.arguments, z.params.name),
            K = v.handler,
            x = {
                ...U,
                taskStore: U.taskStore
            },
            j = N ? await Promise.resolve(K.createTask(N, x)) : await Promise.resolve(K.createTask(x)),
            B = j.task.taskId,
            O = j.task,
            J = (V = O.pollInterval) !== null && V !== void 0 ? V : 5000;
        while (O.status !== "completed" && O.status !== "failed" && O.status !== "cancelled") {
            await new Promise((H) => setTimeout(H, J));
            let q = await U.taskStore.getTask(B);
            if (!q) throw new S6(y6.InternalError, `Task ${B} not found during polling`);
            O = q
        }
        return await U.taskStore.getTaskResult(B)
    }
    setCompletionRequestHandler() {
        if (this._completionHandlerInitialized) return;
        this.server.assertCanSetRequestHandler(i9(wH)), this.server.registerCapabilities({
            completions: {}
        }), this.server.setRequestHandler(wH, async (v) => {
            switch (v.params.ref.type) {
                case "ref/prompt":
                    return I06(v), this.handlePromptCompletion(v, v.params.ref);
                case "ref/resource":
                    return M06(v), this.handleResourceCompletion(v, v.params.ref);
                default:
                    throw new S6(y6.InvalidParams, `Invalid completion reference: ${v.params.ref}`)
            }
        }), this._completionHandlerInitialized = !0
    }
    async handlePromptCompletion(v, z) {
        let U = this._registeredPrompts[z.name];
        if (!U) throw new S6(y6.InvalidParams, `Prompt ${z.name} not found`);
        if (!U.enabled) throw new S6(y6.InvalidParams, `Prompt ${z.name} disabled`);
        if (!U.argsSchema) return Zz;
        let V = cz(U.argsSchema),
            N = V === null || V === void 0 ? void 0 : V[v.params.argument.name];
        if (!F46(N)) return Zz;
        let K = G46(N);
        if (!K) return Zz;
        let x = await K(v.params.argument.value, v.params.context);
        return gR(x)
    }
    async handleResourceCompletion(v, z) {
        let U = Object.values(this._registeredResourceTemplates).find((K) => K.resourceTemplate.uriTemplate.toString() === z.uri);
        if (!U) {
            if (this._registeredResources[z.uri]) return Zz;
            throw new S6(y6.InvalidParams, `Resource template ${v.params.ref.uri} not found`)
        }
        let V = U.resourceTemplate.completeCallback(v.params.argument.name);
        if (!V) return Zz;
        let N = await V(v.params.argument.value, v.params.context);
        return gR(N)
    }
    setResourceRequestHandlers() {
        if (this._resourceHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(i9(OH)), this.server.assertCanSetRequestHandler(i9(JH)), this.server.assertCanSetRequestHandler(i9(qH)), this.server.registerCapabilities({
            resources: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(OH, async (v, z) => {
            let U = Object.entries(this._registeredResources).filter(([N, K]) => K.enabled).map(([N, K]) => ({
                    uri: N,
                    name: K.name,
                    ...K.metadata
                })),
                V = [];
            for (let N of Object.values(this._registeredResourceTemplates)) {
                if (!N.resourceTemplate.listCallback) continue;
                let K = await N.resourceTemplate.listCallback(z);
                for (let x of K.resources) V.push({
                    ...N.metadata,
                    ...x
                })
            }
            return {
                resources: [...U, ...V]
            }
        }), this.server.setRequestHandler(JH, async () => {
            return {
                resourceTemplates: Object.entries(this._registeredResourceTemplates).map(([v, z]) => ({
                    name: v,
                    uriTemplate: z.resourceTemplate.uriTemplate.toString(),
                    ...z.metadata
                }))
            }
        }), this.server.setRequestHandler(qH, async (v, z) => {
            let U = new URL(v.params.uri),
                V = this._registeredResources[U.toString()];
            if (V) {
                if (!V.enabled) throw new S6(y6.InvalidParams, `Resource ${U} disabled`);
                return V.readCallback(U, z)
            }
            for (let N of Object.values(this._registeredResourceTemplates)) {
                let K = N.resourceTemplate.uriTemplate.match(U.toString());
                if (K) return N.readCallback(U, K, z)
            }
            throw new S6(y6.InvalidParams, `Resource ${U} not found`)
        }), this.setCompletionRequestHandler(), this._resourceHandlersInitialized = !0
    }
    setPromptRequestHandlers() {
        if (this._promptHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(i9(HH)), this.server.assertCanSetRequestHandler(i9(DH)), this.server.registerCapabilities({
            prompts: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(HH, () => ({
            prompts: Object.entries(this._registeredPrompts).filter(([, v]) => v.enabled).map(([v, z]) => {
                return {
                    name: v,
                    title: z.title,
                    description: z.description,
                    arguments: z.argsSchema ? E46(z.argsSchema) : void 0
                }
            })
        })), this.server.setRequestHandler(DH, async (v, z) => {
            let U = this._registeredPrompts[v.params.name];
            if (!U) throw new S6(y6.InvalidParams, `Prompt ${v.params.name} not found`);
            if (!U.enabled) throw new S6(y6.InvalidParams, `Prompt ${v.params.name} disabled`);
            if (U.argsSchema) {
                let V = wz(U.argsSchema),
                    N = await Qq(V, v.params.arguments);
                if (!N.success) {
                    let j = "error" in N ? N.error : "Unknown error",
                        B = dq(j);
                    throw new S6(y6.InvalidParams, `Invalid arguments for prompt ${v.params.name}: ${B}`)
                }
                let K = N.data,
                    x = U.callback;
                return await Promise.resolve(x(K, z))
            } else {
                let V = U.callback;
                return await Promise.resolve(V(z))
            }
        }), this.setCompletionRequestHandler(), this._promptHandlersInitialized = !0
    }
    resource(v, z, ...U) {
        let V;
        if (typeof U[0] === "object") V = U.shift();
        let N = U[0];
        if (typeof z === "string") {
            if (this._registeredResources[z]) throw Error(`Resource ${z} is already registered`);
            let K = this._createRegisteredResource(v, void 0, z, V, N);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), K
        } else {
            if (this._registeredResourceTemplates[v]) throw Error(`Resource template ${v} is already registered`);
            let K = this._createRegisteredResourceTemplate(v, void 0, z, V, N);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), K
        }
    }
    registerResource(v, z, U, V) {
        if (typeof z === "string") {
            if (this._registeredResources[z]) throw Error(`Resource ${z} is already registered`);
            let N = this._createRegisteredResource(v, U.title, z, U, V);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), N
        } else {
            if (this._registeredResourceTemplates[v]) throw Error(`Resource template ${v} is already registered`);
            let N = this._createRegisteredResourceTemplate(v, U.title, z, U, V);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), N
        }
    }
    _createRegisteredResource(v, z, U, V, N) {
        let K = {
            name: v,
            title: z,
            metadata: V,
            readCallback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                uri: null
            }),
            update: (x) => {
                if (typeof x.uri < "u" && x.uri !== U) {
                    if (delete this._registeredResources[U], x.uri) this._registeredResources[x.uri] = K
                }
                if (typeof x.name < "u") K.name = x.name;
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.metadata < "u") K.metadata = x.metadata;
                if (typeof x.callback < "u") K.readCallback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendResourceListChanged()
            }
        };
        return this._registeredResources[U] = K, K
    }
    _createRegisteredResourceTemplate(v, z, U, V, N) {
        let K = {
            resourceTemplate: U,
            title: z,
            metadata: V,
            readCallback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                name: null
            }),
            update: (x) => {
                if (typeof x.name < "u" && x.name !== v) {
                    if (delete this._registeredResourceTemplates[v], x.name) this._registeredResourceTemplates[x.name] = K
                }
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.template < "u") K.resourceTemplate = x.template;
                if (typeof x.metadata < "u") K.metadata = x.metadata;
                if (typeof x.callback < "u") K.readCallback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendResourceListChanged()
            }
        };
        return this._registeredResourceTemplates[v] = K, K
    }
    _createRegisteredPrompt(v, z, U, V, N) {
        let K = {
            title: z,
            description: U,
            argsSchema: V === void 0 ? void 0 : Mz(V),
            callback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                name: null
            }),
            update: (x) => {
                if (typeof x.name < "u" && x.name !== v) {
                    if (delete this._registeredPrompts[v], x.name) this._registeredPrompts[x.name] = K
                }
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.description < "u") K.description = x.description;
                if (typeof x.argsSchema < "u") K.argsSchema = Mz(x.argsSchema);
                if (typeof x.callback < "u") K.callback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendPromptListChanged()
            }
        };
        return this._registeredPrompts[v] = K, K
    }
    _createRegisteredTool(v, z, U, V, N, K, x, j, B) {
        mR(v);
        let O = {
            title: z,
            description: U,
            inputSchema: XR(V),
            outputSchema: XR(N),
            annotations: K,
            execution: x,
            _meta: j,
            handler: B,
            enabled: !0,
            disable: () => O.update({
                enabled: !1
            }),
            enable: () => O.update({
                enabled: !0
            }),
            remove: () => O.update({
                name: null
            }),
            update: (J) => {
                if (typeof J.name < "u" && J.name !== v) {
                    if (typeof J.name === "string") mR(J.name);
                    if (delete this._registeredTools[v], J.name) this._registeredTools[J.name] = O
                }
                if (typeof J.title < "u") O.title = J.title;
                if (typeof J.description < "u") O.description = J.description;
                if (typeof J.paramsSchema < "u") O.inputSchema = Mz(J.paramsSchema);
                if (typeof J.callback < "u") O.handler = J.callback;
                if (typeof J.annotations < "u") O.annotations = J.annotations;
                if (typeof J._meta < "u") O._meta = J._meta;
                if (typeof J.enabled < "u") O.enabled = J.enabled;
                this.sendToolListChanged()
            }
        };
        return this._registeredTools[v] = O, this.setToolRequestHandlers(), this.sendToolListChanged(), O
    }
    tool(v, ...z) {
        if (this._registeredTools[v]) throw Error(`Tool ${v} is already registered`);
        let U, V, N, K;
        if (typeof z[0] === "string") U = z.shift();
        if (z.length > 1) {
            let j = z[0];
            if (ZH(j)) {
                if (V = z.shift(), z.length > 1 && typeof z[0] === "object" && z[0] !== null && !ZH(z[0])) K = z.shift()
            } else if (typeof j === "object" && j !== null) K = z.shift()
        }
        let x = z[0];
        return this._createRegisteredTool(v, void 0, U, V, N, K, {
            taskSupport: "forbidden"
        }, void 0, x)
    }
    registerTool(v, z, U) {
        if (this._registeredTools[v]) throw Error(`Tool ${v} is already registered`);
        let {
            title: V,
            description: N,
            inputSchema: K,
            outputSchema: x,
            annotations: j,
            _meta: B
        } = z;
        return this._createRegisteredTool(v, V, N, K, x, j, {
            taskSupport: "forbidden"
        }, B, U)
    }
    prompt(v, ...z) {
        if (this._registeredPrompts[v]) throw Error(`Prompt ${v} is already registered`);
        let U;
        if (typeof z[0] === "string") U = z.shift();
        let V;
        if (z.length > 1) V = z.shift();
        let N = z[0],
            K = this._createRegisteredPrompt(v, void 0, U, V, N);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), K
    }
    registerPrompt(v, z, U) {
        if (this._registeredPrompts[v]) throw Error(`Prompt ${v} is already registered`);
        let {
            title: V,
            description: N,
            argsSchema: K
        } = z, x = this._createRegisteredPrompt(v, V, N, K, U);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), x
    }
    isConnected() {
        return this.server.transport !== void 0
    }
    async sendLoggingMessage(v, z) {
        return this.server.sendLoggingMessage(v, z)
    }
    sendResourceListChanged() {
        if (this.isConnected()) this.server.sendResourceListChanged()
    }
    sendToolListChanged() {
        if (this.isConnected()) this.server.sendToolListChanged()
    }
    sendPromptListChanged() {
        if (this.isConnected()) this.server.sendPromptListChanged()
    }
}
var R46 = {
    type: "object",
    properties: {}
};

function eE(v) {
    return v !== null && typeof v === "object" && "parse" in v && typeof v.parse === "function" && "safeParse" in v && typeof v.safeParse === "function"
}

function W46(v) {
    return "_def" in v || "_zod" in v || eE(v)
}

function ZH(v) {
    if (typeof v !== "object" || v === null) return !1;
    if (W46(v)) return !1;
    if (Object.keys(v).length === 0) return !0;
    return Object.values(v).some(eE)
}

function XR(v) {
    if (!v) return;
    if (ZH(v)) return Mz(v);
    return v
}

function E46(v) {
    let z = cz(v);
    if (!z) return [];
    return Object.entries(z).map(([U, V]) => {
        let N = ss(V),
            K = es(V);
        return {
            name: U,
            description: N,
            required: !K
        }
    })
}

function i9(v) {
    let z = cz(v),
        U = z === null || z === void 0 ? void 0 : z.method;
    if (!U) throw Error("Schema is missing a method literal");
    let V = sW(U);
    if (typeof V === "string") return V;
    throw Error("Schema method literal must be a string")
}

function gR(v) {
    return {
        completion: {
            values: v.slice(0, 100),
            total: v.length,
            hasMore: v.length > 100
        }
    }
}
var Zz = {
    completion: {
        values: [],
        hasMore: !1
    }
};

function pK(v) {
    let z = new sE({
        name: v.name,
        version: v.version ?? "1.0.0"
    }, {
        capabilities: {
            tools: v.tools ? {} : void 0
        }
    });
    if (v.tools) v.tools.forEach((U) => {
        z.registerTool(U.name, {
            description: U.description,
            inputSchema: U.inputSchema,
            annotations: U.annotations
        }, U.handler)
    });
    return {
        type: "sdk",
        name: v.name,
        instance: z
    }
}

function nK({
    prompt: v,
    options: z
}) {
    let {
        systemPrompt: U,
        settingSources: V,
        sandbox: N,
        ...K
    } = z ?? {}, x, j;
    if (U === void 0) x = "";
    else if (typeof U === "string") x = U;
    else if (U.type === "preset") j = U.append;
    let B = K.pathToClaudeCodeExecutable;
    if (!B) {
        let U4 = rR.fileURLToPath("file:///home/runner/work/claude-cli-internal/claude-cli-internal/build-agent-sdk/sdk.mjs"),
            g0 = tq.join(U4, "..");
        B = tq.join(g0, "cli.js")
    }
    process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.42";
    let {
        abortController: O = tR(),
        additionalDirectories: J = [],
        agent: q,
        agents: H,
        allowedTools: D = [],
        betas: A,
        canUseTool: w,
        continue: Z,
        cwd: $,
        debug: F,
        debugFile: L,
        disallowedTools: G = [],
        tools: I,
        env: M,
        executable: b = $W() ? "bun" : "node",
        executableArgs: W = [],
        extraArgs: E = {},
        fallbackModel: y,
        enableFileCheckpointing: T,
        forkSession: X,
        hooks: Q,
        includePartialMessages: m,
        persistSession: P6,
        thinking: F6,
        effort: q6,
        maxThinkingTokens: Z6,
        maxTurns: T6,
        maxBudgetUsd: C,
        mcpServers: u,
        model: p,
        outputFormat: R,
        permissionMode: S = "default",
        allowDangerouslySkipPermissions: k = !1,
        permissionPromptToolName: D6,
        plugins: f6,
        resume: Y6,
        resumeSessionAt: X6,
        sessionId: t0,
        stderr: t3,
        strictMcpConfig: P
    } = K, g = R?.type === "json_schema" ? R.schema : void 0, n = M;
    if (!n) n = {
        ...process.env
    };
    if (!n.CLAUDE_CODE_ENTRYPOINT) n.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
    if (T) n.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
    if (!B) throw Error("pathToClaudeCodeExecutable is required");
    let _6 = {},
        u6 = new Map;
    if (u)
        for (let [U4, g0] of Object.entries(u))
            if (g0.type === "sdk" && "instance" in g0) u6.set(U4, g0.instance), _6[U4] = {
                type: "sdk",
                name: U4
            };
            else _6[U4] = g0;
    let s6 = typeof v === "string",
        z4 = Z6;
    if (F6) switch (F6.type) {
        case "adaptive":
            if (!z4) z4 = 32000;
            break;
        case "enabled":
            z4 = F6.budgetTokens;
            break;
        case "disabled":
            z4 = 0;
            break
    }
    let m4 = new ZW({
            abortController: O,
            additionalDirectories: J,
            agent: q,
            betas: A,
            cwd: $,
            debug: F,
            debugFile: L,
            executable: b,
            executableArgs: W,
            extraArgs: E,
            pathToClaudeCodeExecutable: B,
            env: n,
            forkSession: X,
            stderr: t3,
            maxThinkingTokens: z4,
            effort: q6,
            maxTurns: T6,
            maxBudgetUsd: C,
            model: p,
            fallbackModel: y,
            jsonSchema: g,
            permissionMode: S,
            allowDangerouslySkipPermissions: k,
            permissionPromptToolName: D6,
            continueConversation: Z,
            resume: Y6,
            resumeSessionAt: X6,
            sessionId: t0,
            settingSources: V ?? [],
            allowedTools: D,
            disallowedTools: G,
            tools: I,
            mcpServers: _6,
            strictMcpConfig: P,
            canUseTool: !!w,
            hooks: !!Q,
            includePartialMessages: m,
            persistSession: P6,
            plugins: f6,
            sandbox: N,
            spawnClaudeCodeProcess: K.spawnClaudeCodeProcess
        }),
        W3 = new IW(m4, s6, w, Q, O, u6, g, {
            systemPrompt: x,
            appendSystemPrompt: j,
            agents: H
        });
    if (typeof v === "string") m4.write(_8({
        type: "user",
        session_id: "",
        message: {
            role: "user",
            content: [{
                type: "text",
                text: v
            }]
        },
        parent_tool_use_id: null
    }) + `
`);
    else W3.streamInput(v);
    return W3
}
var zS = require("child_process");
var S46 = `You suggest what a developer might want to do next based on their current work.

Study the diff carefully. What is this person actually building? What's the next meaningful piece of work?

Suggest real work, not tiny fixes:
- "Add error handling to the processOrder function" is a code review comment
- "Add error handling throughout the order processing flow" is real work
- Think about what would actually move the project forward, not just polish one line

Your suggestions should be honest and specific to THIS code:
- Reference actual function names, files, or patterns you see in the diff
- If something looks incomplete, offer to help finish it - not just point it out
- If you see a pattern emerging, offer to extend it to related areas

What makes a good suggestion:
- It's meaningful work that would actually help, not a nitpick
- It shows you understand what they're building
- The developer thinks "yes, that would be useful"

Think about the product, not just the code:
- What would make this feature better for users?
- Is there a related capability that would be natural to add?
- What might users expect that isn't there yet?

What to avoid:
- Tiny incremental fixes that read like code review line comments
- Generic suggestions that could apply to any codebase
- Suggesting "commit" just because there are changes
- Overpromising - be realistic about scope

Aim to delight:
- A suggestion that makes them think "oh, I hadn't thought of that but yes!"
- Noticing something clever they could do, not just the obvious next step
- Showing genuine insight into their work, not just pattern matching

If you see non-trivial changes, offering to review the approach can be valuable.

Respond with a JSON array (0-4 suggestions, fewer is fine, empty if nothing clearly helpful):
[
  {
    "title": "Short title (5-10 words)",
    "description": "What this involves, referencing their specific code",
    "prompt": "Direct prompt for this task"
  }
]

Only output the JSON array.`;
async function d9(v, z, U) {
    return new Promise((V) => {
        let N = "",
            K = zS.spawn(v, z, {
                cwd: U,
                shell: !1
            });
        K.stdout.on("data", (x) => {
            N += x.toString()
        }), K.on("close", (x) => {
            V({
                stdout: N,
                exitCode: x ?? 0
            })
        }), K.on("error", () => {
            V({
                stdout: "",
                exitCode: 1
            })
        })
    })
}
var P46 = 8000,
    _46 = 2000,
    C46 = 2000,
    vS = 200;

function nz(v, z, U) {
    if (v.length <= z) return v;
    return v.slice(0, z) + `
... (${U} truncated)`
}
async function f46(v) {
    let U = (await d9("git", ["config", "user.email"], v).catch(() => ({
            stdout: "",
            exitCode: 1
        }))).stdout.trim(),
        [V, N, K, x, j] = await Promise.all([d9("git", ["status", "--porcelain"], v).catch(() => ({
            stdout: "",
            exitCode: 1
        })), d9("git", ["rev-parse", "--abbrev-ref", "HEAD"], v).catch(() => ({
            stdout: "",
            exitCode: 1
        })), d9("git", ["log", "--oneline", "-10", ...U ? ["--author", U] : []], v).catch(() => ({
            stdout: "",
            exitCode: 1
        })), (async () => {
            if (!U) return d9("git", ["diff", "--stat", "HEAD~5..HEAD"], v);
            let H = (await d9("git", ["log", "--oneline", "-5", "--author", U, "--format=%H"], v).catch(() => ({
                stdout: "",
                exitCode: 1
            }))).stdout.trim().split(`
`).filter(Boolean);
            if (H.length === 0) return {
                stdout: "",
                exitCode: 0
            };
            let D = H[H.length - 1];
            return d9("git", ["diff", "--stat", `${D}^..HEAD`], v).catch(() => ({
                stdout: "",
                exitCode: 1
            }))
        })(), d9("git", ["diff", "HEAD"], v).catch(() => ({
            stdout: "",
            exitCode: 1
        }))]),
        B = V.stdout.trim() || "No uncommitted changes",
        O = x.stdout.trim() || "No recent changes",
        J = j.stdout.trim();
    return {
        status: nz(B, _46, "status"),
        branch: N.stdout.trim() || "unknown",
        recentCommits: K.stdout.trim() || "No recent commits",
        diff: nz(O, C46, "diff stat"),
        workingTreeDiff: nz(J, P46, "diff")
    }
}
async function T46(v, z) {
    try {
        let N = (await (await B3.load(v, z)).fetchSessions()).filter((j) => !j.isSidechain).sort((j, B) => B.lastModified - j.lastModified).slice(0, 5),
            K = N.map((j) => j.summary).filter((j) => j && j !== "No prompt").map((j) => nz(j, vS, "prompt")),
            x = N[0]?.summary ? nz(N[0].summary, vS, "summary") : null;
        return {
            recentPrompts: K,
            lastSessionSummary: x
        }
    } catch (U) {
        return z.warn(`Failed to gather recent activity: ${U}`), {
            recentPrompts: [],
            lastSessionSummary: null
        }
    }
}

function Y46(v, z) {
    let U = [];
    if (U.push("## Current Git State"), U.push(`Branch: ${v.branch}`), U.push(`
Uncommitted changes:
${v.status}`), U.push(`
Recent commits by this user:
${v.recentCommits}`), v.diff) U.push(`
Recent changes summary (this user's work):
${v.diff}`);
    if (v.workingTreeDiff) U.push(`
## Current Uncommitted Changes (diff)`), U.push("This shows the actual code changes in progress. Use this to understand what the developer is working on:"), U.push("```diff"), U.push(v.workingTreeDiff), U.push("```");
    if (z.recentPrompts.length > 0) U.push(`
## Recent Conversation Topics`), z.recentPrompts.forEach((V, N) => {
        U.push(`${N+1}. ${V}`)
    });
    return U.push(`
## Task`), U.push("Based on this context, suggest up to 4 helpful next steps the developer is likely to want to take. Only include suggestions you are confident about - fewer is better."), U.join(`
`)
}

function u46(v) {
    try {
        let z = v.match(/\[[\s\S]*\]/);
        if (!z) return [];
        let U = JSON.parse(z[0]);
        if (!Array.isArray(U)) return [];
        return U.filter((V) => typeof V === "object" && V !== null && typeof V.title === "string" && typeof V.description === "string" && typeof V.prompt === "string").slice(0, 4)
    } catch {
        return []
    }
}
async function US(v) {
    let {
        cwd: z,
        logger: U,
        pathToClaudeCodeExecutable: V,
        executableArgs: N,
        env: K
    } = v;
    try {
        let [x, j] = await Promise.all([f46(z), T46(z, U)]), B = Y46(x, j), O = nK({
            prompt: B,
            options: {
                cwd: z,
                permissionMode: "default",
                model: "claude-haiku-4-5-20251001",
                systemPrompt: S46,
                maxThinkingTokens: 0,
                pathToClaudeCodeExecutable: V,
                executableArgs: N,
                env: K,
                persistSession: !1,
                stderr: (H) => {
                    U.warn(`[Claude STDERR] ${H}`)
                }
            }
        }), J = "";
        for await (let H of O) if (H.type === "assistant" && H.message.content) {
            for (let D of H.message.content)
                if (D.type === "text") J += D.text
        }
        return {
            suggestions: u46(J)
        }
    } catch (x) {
        return U.error(`Failed to generate suggestions: ${x}`), {
            suggestions: []
        }
    }
}
var s = {};
S8(s, {
    void: () => L36,
    util: () => x0,
    unknown: () => w36,
    union: () => I36,
    undefined: () => D36,
    tuple: () => R36,
    transformer: () => u36,
    symbol: () => H36,
    string: () => qS,
    strictObject: () => G36,
    setErrorMap: () => m46,
    set: () => S36,
    record: () => W36,
    quotelessJson: () => y46,
    promise: () => Y36,
    preprocess: () => m36,
    pipeline: () => X36,
    ostring: () => g36,
    optional: () => y36,
    onumber: () => c36,
    oboolean: () => i36,
    objectUtil: () => tH,
    object: () => vD,
    number: () => HS,
    nullable: () => k36,
    null: () => A36,
    never: () => Z36,
    nativeEnum: () => T36,
    nan: () => O36,
    map: () => E36,
    makeIssue: () => Qz,
    literal: () => C36,
    lazy: () => _36,
    late: () => j36,
    isValid: () => o9,
    isDirty: () => dK,
    isAsync: () => Jv,
    isAborted: () => QK,
    intersection: () => b36,
    instanceof: () => B36,
    getParsedType: () => u8,
    getErrorMap: () => Ov,
    function: () => P36,
    enum: () => f36,
    effect: () => u36,
    discriminatedUnion: () => M36,
    defaultErrorMap: () => B9,
    datetimeRegex: () => BS,
    date: () => q36,
    custom: () => JS,
    coerce: () => l36,
    boolean: () => DS,
    bigint: () => J36,
    array: () => F36,
    any: () => $36,
    addIssueToContext: () => j6,
    ZodVoid: () => oz,
    ZodUnknown: () => r9,
    ZodUnion: () => wv,
    ZodUndefined: () => Av,
    ZodType: () => z0,
    ZodTuple: () => k8,
    ZodTransformer: () => O8,
    ZodSymbol: () => dz,
    ZodString: () => K8,
    ZodSet: () => o5,
    ZodSchema: () => z0,
    ZodRecord: () => rz,
    ZodReadonly: () => bv,
    ZodPromise: () => r5,
    ZodPipeline: () => sz,
    ZodParsedType: () => U6,
    ZodOptional: () => j8,
    ZodObject: () => o0,
    ZodNumber: () => a9,
    ZodNullable: () => J9,
    ZodNull: () => $v,
    ZodNever: () => y8,
    ZodNativeEnum: () => Gv,
    ZodNaN: () => tz,
    ZodMap: () => az,
    ZodLiteral: () => Fv,
    ZodLazy: () => Lv,
    ZodIssueCode: () => d,
    ZodIntersection: () => Zv,
    ZodFunction: () => Hv,
    ZodFirstPartyTypeKind: () => a,
    ZodError: () => D3,
    ZodEnum: () => s9,
    ZodEffects: () => O8,
    ZodDiscriminatedUnion: () => oK,
    ZodDefault: () => Iv,
    ZodDate: () => Q5,
    ZodCatch: () => Mv,
    ZodBranded: () => rK,
    ZodBoolean: () => Dv,
    ZodBigInt: () => t9,
    ZodArray: () => x8,
    ZodAny: () => d5,
    Schema: () => z0,
    ParseStatus: () => Y4,
    OK: () => h4,
    NEVER: () => h36,
    INVALID: () => k6,
    EMPTY_PATH: () => X46,
    DIRTY: () => n5,
    BRAND: () => x36
});
var x0;
(function(v) {
    v.assertEqual = (N) => {};

    function z(N) {}
    v.assertIs = z;

    function U(N) {
        throw Error()
    }
    v.assertNever = U, v.arrayToEnum = (N) => {
        let K = {};
        for (let x of N) K[x] = x;
        return K
    }, v.getValidEnumValues = (N) => {
        let K = v.objectKeys(N).filter((j) => typeof N[N[j]] !== "number"),
            x = {};
        for (let j of K) x[j] = N[j];
        return v.objectValues(x)
    }, v.objectValues = (N) => {
        return v.objectKeys(N).map(function(K) {
            return N[K]
        })
    }, v.objectKeys = typeof Object.keys === "function" ? (N) => Object.keys(N) : (N) => {
        let K = [];
        for (let x in N)
            if (Object.prototype.hasOwnProperty.call(N, x)) K.push(x);
        return K
    }, v.find = (N, K) => {
        for (let x of N)
            if (K(x)) return x;
        return
    }, v.isInteger = typeof Number.isInteger === "function" ? (N) => Number.isInteger(N) : (N) => typeof N === "number" && Number.isFinite(N) && Math.floor(N) === N;

    function V(N, K = " | ") {
        return N.map((x) => typeof x === "string" ? `'${x}'` : x).join(K)
    }
    v.joinValues = V, v.jsonStringifyReplacer = (N, K) => {
        if (typeof K === "bigint") return K.toString();
        return K
    }
})(x0 || (x0 = {}));
var tH;
(function(v) {
    v.mergeShapes = (z, U) => {
        return {
            ...z,
            ...U
        }
    }
})(tH || (tH = {}));
var U6 = x0.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
    u8 = (v) => {
        switch (typeof v) {
            case "undefined":
                return U6.undefined;
            case "string":
                return U6.string;
            case "number":
                return Number.isNaN(v) ? U6.nan : U6.number;
            case "boolean":
                return U6.boolean;
            case "function":
                return U6.function;
            case "bigint":
                return U6.bigint;
            case "symbol":
                return U6.symbol;
            case "object":
                if (Array.isArray(v)) return U6.array;
                if (v === null) return U6.null;
                if (v.then && typeof v.then === "function" && v.catch && typeof v.catch === "function") return U6.promise;
                if (typeof Map < "u" && v instanceof Map) return U6.map;
                if (typeof Set < "u" && v instanceof Set) return U6.set;
                if (typeof Date < "u" && v instanceof Date) return U6.date;
                return U6.object;
            default:
                return U6.unknown
        }
    };
var d = x0.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
    y46 = (v) => {
        return JSON.stringify(v, null, 2).replace(/"([^"]+)":/g, "$1:")
    };
class D3 extends Error {
    get errors() {
        return this.issues
    }
    constructor(v) {
        super();
        this.issues = [], this.addIssue = (U) => {
            this.issues = [...this.issues, U]
        }, this.addIssues = (U = []) => {
            this.issues = [...this.issues, ...U]
        };
        let z = new.target.prototype;
        if (Object.setPrototypeOf) Object.setPrototypeOf(this, z);
        else this.__proto__ = z;
        this.name = "ZodError", this.issues = v
    }
    format(v) {
        let z = v || function(N) {
                return N.message
            },
            U = {
                _errors: []
            },
            V = (N) => {
                for (let K of N.issues)
                    if (K.code === "invalid_union") K.unionErrors.map(V);
                    else if (K.code === "invalid_return_type") V(K.returnTypeError);
                else if (K.code === "invalid_arguments") V(K.argumentsError);
                else if (K.path.length === 0) U._errors.push(z(K));
                else {
                    let x = U,
                        j = 0;
                    while (j < K.path.length) {
                        let B = K.path[j];
                        if (j !== K.path.length - 1) x[B] = x[B] || {
                            _errors: []
                        };
                        else x[B] = x[B] || {
                            _errors: []
                        }, x[B]._errors.push(z(K));
                        x = x[B], j++
                    }
                }
            };
        return V(this), U
    }
    static assert(v) {
        if (!(v instanceof D3)) throw Error(`Not a ZodError: ${v}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, x0.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(v = (z) => z.message) {
        let z = {},
            U = [];
        for (let V of this.issues)
            if (V.path.length > 0) {
                let N = V.path[0];
                z[N] = z[N] || [], z[N].push(v(V))
            } else U.push(v(V));
        return {
            formErrors: U,
            fieldErrors: z
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
D3.create = (v) => {
    return new D3(v)
};
var k46 = (v, z) => {
        let U;
        switch (v.code) {
            case d.invalid_type:
                if (v.received === U6.undefined) U = "Required";
                else U = `Expected ${v.expected}, received ${v.received}`;
                break;
            case d.invalid_literal:
                U = `Invalid literal value, expected ${JSON.stringify(v.expected,x0.jsonStringifyReplacer)}`;
                break;
            case d.unrecognized_keys:
                U = `Unrecognized key(s) in object: ${x0.joinValues(v.keys,", ")}`;
                break;
            case d.invalid_union:
                U = "Invalid input";
                break;
            case d.invalid_union_discriminator:
                U = `Invalid discriminator value. Expected ${x0.joinValues(v.options)}`;
                break;
            case d.invalid_enum_value:
                U = `Invalid enum value. Expected ${x0.joinValues(v.options)}, received '${v.received}'`;
                break;
            case d.invalid_arguments:
                U = "Invalid function arguments";
                break;
            case d.invalid_return_type:
                U = "Invalid function return type";
                break;
            case d.invalid_date:
                U = "Invalid date";
                break;
            case d.invalid_string:
                if (typeof v.validation === "object")
                    if ("includes" in v.validation) {
                        if (U = `Invalid input: must include "${v.validation.includes}"`, typeof v.validation.position === "number") U = `${U} at one or more positions greater than or equal to ${v.validation.position}`
                    } else if ("startsWith" in v.validation) U = `Invalid input: must start with "${v.validation.startsWith}"`;
                else if ("endsWith" in v.validation) U = `Invalid input: must end with "${v.validation.endsWith}"`;
                else x0.assertNever(v.validation);
                else if (v.validation !== "regex") U = `Invalid ${v.validation}`;
                else U = "Invalid";
                break;
            case d.too_small:
                if (v.type === "array") U = `Array must contain ${v.exact?"exactly":v.inclusive?"at least":"more than"} ${v.minimum} element(s)`;
                else if (v.type === "string") U = `String must contain ${v.exact?"exactly":v.inclusive?"at least":"over"} ${v.minimum} character(s)`;
                else if (v.type === "number") U = `Number must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${v.minimum}`;
                else if (v.type === "bigint") U = `Number must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${v.minimum}`;
                else if (v.type === "date") U = `Date must be ${v.exact?"exactly equal to ":v.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(v.minimum))}`;
                else U = "Invalid input";
                break;
            case d.too_big:
                if (v.type === "array") U = `Array must contain ${v.exact?"exactly":v.inclusive?"at most":"less than"} ${v.maximum} element(s)`;
                else if (v.type === "string") U = `String must contain ${v.exact?"exactly":v.inclusive?"at most":"under"} ${v.maximum} character(s)`;
                else if (v.type === "number") U = `Number must be ${v.exact?"exactly":v.inclusive?"less than or equal to":"less than"} ${v.maximum}`;
                else if (v.type === "bigint") U = `BigInt must be ${v.exact?"exactly":v.inclusive?"less than or equal to":"less than"} ${v.maximum}`;
                else if (v.type === "date") U = `Date must be ${v.exact?"exactly":v.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(v.maximum))}`;
                else U = "Invalid input";
                break;
            case d.custom:
                U = "Invalid input";
                break;
            case d.invalid_intersection_types:
                U = "Intersection results could not be merged";
                break;
            case d.not_multiple_of:
                U = `Number must be a multiple of ${v.multipleOf}`;
                break;
            case d.not_finite:
                U = "Number must be finite";
                break;
            default:
                U = z.defaultError, x0.assertNever(v)
        }
        return {
            message: U
        }
    },
    B9 = k46;
var VS = B9;

function m46(v) {
    VS = v
}

function Ov() {
    return VS
}
var Qz = (v) => {
        let {
            data: z,
            path: U,
            errorMaps: V,
            issueData: N
        } = v, K = [...U, ...N.path || []], x = {
            ...N,
            path: K
        };
        if (N.message !== void 0) return {
            ...N,
            path: K,
            message: N.message
        };
        let j = "",
            B = V.filter((O) => !!O).slice().reverse();
        for (let O of B) j = O(x, {
            data: z,
            defaultError: j
        }).message;
        return {
            ...N,
            path: K,
            message: j
        }
    },
    X46 = [];

function j6(v, z) {
    let U = Ov(),
        V = Qz({
            issueData: z,
            data: v.data,
            path: v.path,
            errorMaps: [v.common.contextualErrorMap, v.schemaErrorMap, U, U === B9 ? void 0 : B9].filter((N) => !!N)
        });
    v.common.issues.push(V)
}
class Y4 {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty"
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted"
    }
    static mergeArray(v, z) {
        let U = [];
        for (let V of z) {
            if (V.status === "aborted") return k6;
            if (V.status === "dirty") v.dirty();
            U.push(V.value)
        }
        return {
            status: v.value,
            value: U
        }
    }
    static async mergeObjectAsync(v, z) {
        let U = [];
        for (let V of z) {
            let N = await V.key,
                K = await V.value;
            U.push({
                key: N,
                value: K
            })
        }
        return Y4.mergeObjectSync(v, U)
    }
    static mergeObjectSync(v, z) {
        let U = {};
        for (let V of z) {
            let {
                key: N,
                value: K
            } = V;
            if (N.status === "aborted") return k6;
            if (K.status === "aborted") return k6;
            if (N.status === "dirty") v.dirty();
            if (K.status === "dirty") v.dirty();
            if (N.value !== "__proto__" && (typeof K.value < "u" || V.alwaysSet)) U[N.value] = K.value
        }
        return {
            status: v.value,
            value: U
        }
    }
}
var k6 = Object.freeze({
        status: "aborted"
    }),
    n5 = (v) => ({
        status: "dirty",
        value: v
    }),
    h4 = (v) => ({
        status: "valid",
        value: v
    }),
    QK = (v) => v.status === "aborted",
    dK = (v) => v.status === "dirty",
    o9 = (v) => v.status === "valid",
    Jv = (v) => typeof Promise < "u" && v instanceof Promise;
var G6;
(function(v) {
    v.errToObj = (z) => typeof z === "string" ? {
        message: z
    } : z || {}, v.toString = (z) => typeof z === "string" ? z : z?.message
})(G6 || (G6 = {}));
class B8 {
    constructor(v, z, U, V) {
        this._cachedPath = [], this.parent = v, this.data = z, this._path = U, this._key = V
    }
    get path() {
        if (!this._cachedPath.length)
            if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
        return this._cachedPath
    }
}
var NS = (v, z) => {
    if (o9(z)) return {
        success: !0,
        data: z.value
    };
    else {
        if (!v.common.issues.length) throw Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error) return this._error;
                let U = new D3(v.common.issues);
                return this._error = U, this._error
            }
        }
    }
};

function a6(v) {
    if (!v) return {};
    let {
        errorMap: z,
        invalid_type_error: U,
        required_error: V,
        description: N
    } = v;
    if (z && (U || V)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    if (z) return {
        errorMap: z,
        description: N
    };
    return {
        errorMap: (x, j) => {
            let {
                message: B
            } = v;
            if (x.code === "invalid_enum_value") return {
                message: B ?? j.defaultError
            };
            if (typeof j.data > "u") return {
                message: B ?? V ?? j.defaultError
            };
            if (x.code !== "invalid_type") return {
                message: j.defaultError
            };
            return {
                message: B ?? U ?? j.defaultError
            }
        },
        description: N
    }
}
class z0 {
    get description() {
        return this._def.description
    }
    _getType(v) {
        return u8(v.data)
    }
    _getOrReturnCtx(v, z) {
        return z || {
            common: v.parent.common,
            data: v.data,
            parsedType: u8(v.data),
            schemaErrorMap: this._def.errorMap,
            path: v.path,
            parent: v.parent
        }
    }
    _processInputParams(v) {
        return {
            status: new Y4,
            ctx: {
                common: v.parent.common,
                data: v.data,
                parsedType: u8(v.data),
                schemaErrorMap: this._def.errorMap,
                path: v.path,
                parent: v.parent
            }
        }
    }
    _parseSync(v) {
        let z = this._parse(v);
        if (Jv(z)) throw Error("Synchronous parse encountered promise.");
        return z
    }
    _parseAsync(v) {
        let z = this._parse(v);
        return Promise.resolve(z)
    }
    parse(v, z) {
        let U = this.safeParse(v, z);
        if (U.success) return U.data;
        throw U.error
    }
    safeParse(v, z) {
        let U = {
                common: {
                    issues: [],
                    async: z?.async ?? !1,
                    contextualErrorMap: z?.errorMap
                },
                path: z?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: v,
                parsedType: u8(v)
            },
            V = this._parseSync({
                data: v,
                path: U.path,
                parent: U
            });
        return NS(U, V)
    }
    "~validate"(v) {
        let z = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: v,
            parsedType: u8(v)
        };
        if (!this["~standard"].async) try {
            let U = this._parseSync({
                data: v,
                path: [],
                parent: z
            });
            return o9(U) ? {
                value: U.value
            } : {
                issues: z.common.issues
            }
        } catch (U) {
            if (U?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = !0;
            z.common = {
                issues: [],
                async: !0
            }
        }
        return this._parseAsync({
            data: v,
            path: [],
            parent: z
        }).then((U) => o9(U) ? {
            value: U.value
        } : {
            issues: z.common.issues
        })
    }
    async parseAsync(v, z) {
        let U = await this.safeParseAsync(v, z);
        if (U.success) return U.data;
        throw U.error
    }
    async safeParseAsync(v, z) {
        let U = {
                common: {
                    issues: [],
                    contextualErrorMap: z?.errorMap,
                    async: !0
                },
                path: z?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: v,
                parsedType: u8(v)
            },
            V = this._parse({
                data: v,
                path: U.path,
                parent: U
            }),
            N = await (Jv(V) ? V : Promise.resolve(V));
        return NS(U, N)
    }
    refine(v, z) {
        let U = (V) => {
            if (typeof z === "string" || typeof z > "u") return {
                message: z
            };
            else if (typeof z === "function") return z(V);
            else return z
        };
        return this._refinement((V, N) => {
            let K = v(V),
                x = () => N.addIssue({
                    code: d.custom,
                    ...U(V)
                });
            if (typeof Promise < "u" && K instanceof Promise) return K.then((j) => {
                if (!j) return x(), !1;
                else return !0
            });
            if (!K) return x(), !1;
            else return !0
        })
    }
    refinement(v, z) {
        return this._refinement((U, V) => {
            if (!v(U)) return V.addIssue(typeof z === "function" ? z(U, V) : z), !1;
            else return !0
        })
    }
    _refinement(v) {
        return new O8({
            schema: this,
            typeName: a.ZodEffects,
            effect: {
                type: "refinement",
                refinement: v
            }
        })
    }
    superRefine(v) {
        return this._refinement(v)
    }
    constructor(v) {
        this.spa = this.safeParseAsync, this._def = v, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (z) => this["~validate"](z)
        }
    }
    optional() {
        return j8.create(this, this._def)
    }
    nullable() {
        return J9.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return x8.create(this)
    }
    promise() {
        return r5.create(this, this._def)
    }
    or(v) {
        return wv.create([this, v], this._def)
    }
    and(v) {
        return Zv.create(this, v, this._def)
    }
    transform(v) {
        return new O8({
            ...a6(this._def),
            schema: this,
            typeName: a.ZodEffects,
            effect: {
                type: "transform",
                transform: v
            }
        })
    }
    default (v) {
        let z = typeof v === "function" ? v : () => v;
        return new Iv({
            ...a6(this._def),
            innerType: this,
            defaultValue: z,
            typeName: a.ZodDefault
        })
    }
    brand() {
        return new rK({
            typeName: a.ZodBranded,
            type: this,
            ...a6(this._def)
        })
    } catch (v) {
        let z = typeof v === "function" ? v : () => v;
        return new Mv({
            ...a6(this._def),
            innerType: this,
            catchValue: z,
            typeName: a.ZodCatch
        })
    }
    describe(v) {
        return new this.constructor({
            ...this._def,
            description: v
        })
    }
    pipe(v) {
        return sz.create(this, v)
    }
    readonly() {
        return bv.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
var g46 = /^c[^\s-]{8,}$/i,
    c46 = /^[0-9a-z]+$/,
    i46 = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
    l46 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    h46 = /^[a-z0-9_-]{21}$/i,
    p46 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
    n46 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    Q46 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    d46 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    sH, o46 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    r46 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    a46 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
    t46 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    s46 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    e46 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    xS = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
    v36 = new RegExp(`^${xS}$`);

function jS(v) {
    let z = "[0-5]\\d";
    if (v.precision) z = `${z}\\.\\d{${v.precision}}`;
    else if (v.precision == null) z = `${z}(\\.\\d+)?`;
    let U = v.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${z})${U}`
}

function z36(v) {
    return new RegExp(`^${jS(v)}$`)
}

function BS(v) {
    let z = `${xS}T${jS(v)}`,
        U = [];
    if (U.push(v.local ? "Z?" : "Z"), v.offset) U.push("([+-]\\d{2}:?\\d{2})");
    return z = `${z}(${U.join("|")})`, new RegExp(`^${z}$`)
}

function U36(v, z) {
    if ((z === "v4" || !z) && o46.test(v)) return !0;
    if ((z === "v6" || !z) && a46.test(v)) return !0;
    return !1
}

function V36(v, z) {
    if (!p46.test(v)) return !1;
    try {
        let [U] = v.split(".");
        if (!U) return !1;
        let V = U.replace(/-/g, "+").replace(/_/g, "/").padEnd(U.length + (4 - U.length % 4) % 4, "="),
            N = JSON.parse(atob(V));
        if (typeof N !== "object" || N === null) return !1;
        if ("typ" in N && N?.typ !== "JWT") return !1;
        if (!N.alg) return !1;
        if (z && N.alg !== z) return !1;
        return !0
    } catch {
        return !1
    }
}

function N36(v, z) {
    if ((z === "v4" || !z) && r46.test(v)) return !0;
    if ((z === "v6" || !z) && t46.test(v)) return !0;
    return !1
}
class K8 extends z0 {
    _parse(v) {
        if (this._def.coerce) v.data = String(v.data);
        if (this._getType(v) !== U6.string) {
            let N = this._getOrReturnCtx(v);
            return j6(N, {
                code: d.invalid_type,
                expected: U6.string,
                received: N.parsedType
            }), k6
        }
        let U = new Y4,
            V = void 0;
        for (let N of this._def.checks)
            if (N.kind === "min") {
                if (v.data.length < N.value) V = this._getOrReturnCtx(v, V), j6(V, {
                    code: d.too_small,
                    minimum: N.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: N.message
                }), U.dirty()
            } else if (N.kind === "max") {
            if (v.data.length > N.value) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.too_big,
                maximum: N.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "length") {
            let K = v.data.length > N.value,
                x = v.data.length < N.value;
            if (K || x) {
                if (V = this._getOrReturnCtx(v, V), K) j6(V, {
                    code: d.too_big,
                    maximum: N.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: N.message
                });
                else if (x) j6(V, {
                    code: d.too_small,
                    minimum: N.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: N.message
                });
                U.dirty()
            }
        } else if (N.kind === "email") {
            if (!Q46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "email",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "emoji") {
            if (!sH) sH = new RegExp(d46, "u");
            if (!sH.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "emoji",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "uuid") {
            if (!l46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "uuid",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "nanoid") {
            if (!h46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "nanoid",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "cuid") {
            if (!g46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "cuid",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "cuid2") {
            if (!c46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "cuid2",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "ulid") {
            if (!i46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "ulid",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "url") try {
            new URL(v.data)
        } catch {
            V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "url",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "regex") {
            if (N.regex.lastIndex = 0, !N.regex.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "regex",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "trim") v.data = v.data.trim();
        else if (N.kind === "includes") {
            if (!v.data.includes(N.value, N.position)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: {
                    includes: N.value,
                    position: N.position
                },
                message: N.message
            }), U.dirty()
        } else if (N.kind === "toLowerCase") v.data = v.data.toLowerCase();
        else if (N.kind === "toUpperCase") v.data = v.data.toUpperCase();
        else if (N.kind === "startsWith") {
            if (!v.data.startsWith(N.value)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: {
                    startsWith: N.value
                },
                message: N.message
            }), U.dirty()
        } else if (N.kind === "endsWith") {
            if (!v.data.endsWith(N.value)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: {
                    endsWith: N.value
                },
                message: N.message
            }), U.dirty()
        } else if (N.kind === "datetime") {
            if (!BS(N).test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: "datetime",
                message: N.message
            }), U.dirty()
        } else if (N.kind === "date") {
            if (!v36.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: "date",
                message: N.message
            }), U.dirty()
        } else if (N.kind === "time") {
            if (!z36(N).test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.invalid_string,
                validation: "time",
                message: N.message
            }), U.dirty()
        } else if (N.kind === "duration") {
            if (!n46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "duration",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "ip") {
            if (!U36(v.data, N.version)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "ip",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "jwt") {
            if (!V36(v.data, N.alg)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "jwt",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "cidr") {
            if (!N36(v.data, N.version)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "cidr",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "base64") {
            if (!s46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "base64",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else if (N.kind === "base64url") {
            if (!e46.test(v.data)) V = this._getOrReturnCtx(v, V), j6(V, {
                validation: "base64url",
                code: d.invalid_string,
                message: N.message
            }), U.dirty()
        } else x0.assertNever(N);
        return {
            status: U.value,
            value: v.data
        }
    }
    _regex(v, z, U) {
        return this.refinement((V) => v.test(V), {
            validation: z,
            code: d.invalid_string,
            ...G6.errToObj(U)
        })
    }
    _addCheck(v) {
        return new K8({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    email(v) {
        return this._addCheck({
            kind: "email",
            ...G6.errToObj(v)
        })
    }
    url(v) {
        return this._addCheck({
            kind: "url",
            ...G6.errToObj(v)
        })
    }
    emoji(v) {
        return this._addCheck({
            kind: "emoji",
            ...G6.errToObj(v)
        })
    }
    uuid(v) {
        return this._addCheck({
            kind: "uuid",
            ...G6.errToObj(v)
        })
    }
    nanoid(v) {
        return this._addCheck({
            kind: "nanoid",
            ...G6.errToObj(v)
        })
    }
    cuid(v) {
        return this._addCheck({
            kind: "cuid",
            ...G6.errToObj(v)
        })
    }
    cuid2(v) {
        return this._addCheck({
            kind: "cuid2",
            ...G6.errToObj(v)
        })
    }
    ulid(v) {
        return this._addCheck({
            kind: "ulid",
            ...G6.errToObj(v)
        })
    }
    base64(v) {
        return this._addCheck({
            kind: "base64",
            ...G6.errToObj(v)
        })
    }
    base64url(v) {
        return this._addCheck({
            kind: "base64url",
            ...G6.errToObj(v)
        })
    }
    jwt(v) {
        return this._addCheck({
            kind: "jwt",
            ...G6.errToObj(v)
        })
    }
    ip(v) {
        return this._addCheck({
            kind: "ip",
            ...G6.errToObj(v)
        })
    }
    cidr(v) {
        return this._addCheck({
            kind: "cidr",
            ...G6.errToObj(v)
        })
    }
    datetime(v) {
        if (typeof v === "string") return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: v
        });
        return this._addCheck({
            kind: "datetime",
            precision: typeof v?.precision > "u" ? null : v?.precision,
            offset: v?.offset ?? !1,
            local: v?.local ?? !1,
            ...G6.errToObj(v?.message)
        })
    }
    date(v) {
        return this._addCheck({
            kind: "date",
            message: v
        })
    }
    time(v) {
        if (typeof v === "string") return this._addCheck({
            kind: "time",
            precision: null,
            message: v
        });
        return this._addCheck({
            kind: "time",
            precision: typeof v?.precision > "u" ? null : v?.precision,
            ...G6.errToObj(v?.message)
        })
    }
    duration(v) {
        return this._addCheck({
            kind: "duration",
            ...G6.errToObj(v)
        })
    }
    regex(v, z) {
        return this._addCheck({
            kind: "regex",
            regex: v,
            ...G6.errToObj(z)
        })
    }
    includes(v, z) {
        return this._addCheck({
            kind: "includes",
            value: v,
            position: z?.position,
            ...G6.errToObj(z?.message)
        })
    }
    startsWith(v, z) {
        return this._addCheck({
            kind: "startsWith",
            value: v,
            ...G6.errToObj(z)
        })
    }
    endsWith(v, z) {
        return this._addCheck({
            kind: "endsWith",
            value: v,
            ...G6.errToObj(z)
        })
    }
    min(v, z) {
        return this._addCheck({
            kind: "min",
            value: v,
            ...G6.errToObj(z)
        })
    }
    max(v, z) {
        return this._addCheck({
            kind: "max",
            value: v,
            ...G6.errToObj(z)
        })
    }
    length(v, z) {
        return this._addCheck({
            kind: "length",
            value: v,
            ...G6.errToObj(z)
        })
    }
    nonempty(v) {
        return this.min(1, G6.errToObj(v))
    }
    trim() {
        return new K8({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new K8({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new K8({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find((v) => v.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find((v) => v.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find((v) => v.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find((v) => v.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find((v) => v.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find((v) => v.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find((v) => v.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find((v) => v.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find((v) => v.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find((v) => v.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find((v) => v.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find((v) => v.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find((v) => v.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find((v) => v.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find((v) => v.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find((v) => v.kind === "base64url")
    }
    get minLength() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxLength() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
}
K8.create = (v) => {
    return new K8({
        checks: [],
        typeName: a.ZodString,
        coerce: v?.coerce ?? !1,
        ...a6(v)
    })
};

function K36(v, z) {
    let U = (v.toString().split(".")[1] || "").length,
        V = (z.toString().split(".")[1] || "").length,
        N = U > V ? U : V,
        K = Number.parseInt(v.toFixed(N).replace(".", "")),
        x = Number.parseInt(z.toFixed(N).replace(".", ""));
    return K % x / 10 ** N
}
class a9 extends z0 {
    constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
    }
    _parse(v) {
        if (this._def.coerce) v.data = Number(v.data);
        if (this._getType(v) !== U6.number) {
            let N = this._getOrReturnCtx(v);
            return j6(N, {
                code: d.invalid_type,
                expected: U6.number,
                received: N.parsedType
            }), k6
        }
        let U = void 0,
            V = new Y4;
        for (let N of this._def.checks)
            if (N.kind === "int") {
                if (!x0.isInteger(v.data)) U = this._getOrReturnCtx(v, U), j6(U, {
                    code: d.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: N.message
                }), V.dirty()
            } else if (N.kind === "min") {
            if (N.inclusive ? v.data < N.value : v.data <= N.value) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.too_small,
                minimum: N.value,
                type: "number",
                inclusive: N.inclusive,
                exact: !1,
                message: N.message
            }), V.dirty()
        } else if (N.kind === "max") {
            if (N.inclusive ? v.data > N.value : v.data >= N.value) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.too_big,
                maximum: N.value,
                type: "number",
                inclusive: N.inclusive,
                exact: !1,
                message: N.message
            }), V.dirty()
        } else if (N.kind === "multipleOf") {
            if (K36(v.data, N.value) !== 0) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.not_multiple_of,
                multipleOf: N.value,
                message: N.message
            }), V.dirty()
        } else if (N.kind === "finite") {
            if (!Number.isFinite(v.data)) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.not_finite,
                message: N.message
            }), V.dirty()
        } else x0.assertNever(N);
        return {
            status: V.value,
            value: v.data
        }
    }
    gte(v, z) {
        return this.setLimit("min", v, !0, G6.toString(z))
    }
    gt(v, z) {
        return this.setLimit("min", v, !1, G6.toString(z))
    }
    lte(v, z) {
        return this.setLimit("max", v, !0, G6.toString(z))
    }
    lt(v, z) {
        return this.setLimit("max", v, !1, G6.toString(z))
    }
    setLimit(v, z, U, V) {
        return new a9({
            ...this._def,
            checks: [...this._def.checks, {
                kind: v,
                value: z,
                inclusive: U,
                message: G6.toString(V)
            }]
        })
    }
    _addCheck(v) {
        return new a9({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    int(v) {
        return this._addCheck({
            kind: "int",
            message: G6.toString(v)
        })
    }
    positive(v) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: G6.toString(v)
        })
    }
    negative(v) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: G6.toString(v)
        })
    }
    nonpositive(v) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: G6.toString(v)
        })
    }
    nonnegative(v) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: G6.toString(v)
        })
    }
    multipleOf(v, z) {
        return this._addCheck({
            kind: "multipleOf",
            value: v,
            message: G6.toString(z)
        })
    }
    finite(v) {
        return this._addCheck({
            kind: "finite",
            message: G6.toString(v)
        })
    }
    safe(v) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: G6.toString(v)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: G6.toString(v)
        })
    }
    get minValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
    get isInt() {
        return !!this._def.checks.find((v) => v.kind === "int" || v.kind === "multipleOf" && x0.isInteger(v.value))
    }
    get isFinite() {
        let v = null,
            z = null;
        for (let U of this._def.checks)
            if (U.kind === "finite" || U.kind === "int" || U.kind === "multipleOf") return !0;
            else if (U.kind === "min") {
            if (z === null || U.value > z) z = U.value
        } else if (U.kind === "max") {
            if (v === null || U.value < v) v = U.value
        }
        return Number.isFinite(z) && Number.isFinite(v)
    }
}
a9.create = (v) => {
    return new a9({
        checks: [],
        typeName: a.ZodNumber,
        coerce: v?.coerce || !1,
        ...a6(v)
    })
};
class t9 extends z0 {
    constructor() {
        super(...arguments);
        this.min = this.gte, this.max = this.lte
    }
    _parse(v) {
        if (this._def.coerce) try {
            v.data = BigInt(v.data)
        } catch {
            return this._getInvalidInput(v)
        }
        if (this._getType(v) !== U6.bigint) return this._getInvalidInput(v);
        let U = void 0,
            V = new Y4;
        for (let N of this._def.checks)
            if (N.kind === "min") {
                if (N.inclusive ? v.data < N.value : v.data <= N.value) U = this._getOrReturnCtx(v, U), j6(U, {
                    code: d.too_small,
                    type: "bigint",
                    minimum: N.value,
                    inclusive: N.inclusive,
                    message: N.message
                }), V.dirty()
            } else if (N.kind === "max") {
            if (N.inclusive ? v.data > N.value : v.data >= N.value) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.too_big,
                type: "bigint",
                maximum: N.value,
                inclusive: N.inclusive,
                message: N.message
            }), V.dirty()
        } else if (N.kind === "multipleOf") {
            if (v.data % N.value !== BigInt(0)) U = this._getOrReturnCtx(v, U), j6(U, {
                code: d.not_multiple_of,
                multipleOf: N.value,
                message: N.message
            }), V.dirty()
        } else x0.assertNever(N);
        return {
            status: V.value,
            value: v.data
        }
    }
    _getInvalidInput(v) {
        let z = this._getOrReturnCtx(v);
        return j6(z, {
            code: d.invalid_type,
            expected: U6.bigint,
            received: z.parsedType
        }), k6
    }
    gte(v, z) {
        return this.setLimit("min", v, !0, G6.toString(z))
    }
    gt(v, z) {
        return this.setLimit("min", v, !1, G6.toString(z))
    }
    lte(v, z) {
        return this.setLimit("max", v, !0, G6.toString(z))
    }
    lt(v, z) {
        return this.setLimit("max", v, !1, G6.toString(z))
    }
    setLimit(v, z, U, V) {
        return new t9({
            ...this._def,
            checks: [...this._def.checks, {
                kind: v,
                value: z,
                inclusive: U,
                message: G6.toString(V)
            }]
        })
    }
    _addCheck(v) {
        return new t9({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    positive(v) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: G6.toString(v)
        })
    }
    negative(v) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: G6.toString(v)
        })
    }
    nonpositive(v) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: G6.toString(v)
        })
    }
    nonnegative(v) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: G6.toString(v)
        })
    }
    multipleOf(v, z) {
        return this._addCheck({
            kind: "multipleOf",
            value: v,
            message: G6.toString(z)
        })
    }
    get minValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v
    }
    get maxValue() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v
    }
}
t9.create = (v) => {
    return new t9({
        checks: [],
        typeName: a.ZodBigInt,
        coerce: v?.coerce ?? !1,
        ...a6(v)
    })
};
class Dv extends z0 {
    _parse(v) {
        if (this._def.coerce) v.data = Boolean(v.data);
        if (this._getType(v) !== U6.boolean) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.boolean,
                received: U.parsedType
            }), k6
        }
        return h4(v.data)
    }
}
Dv.create = (v) => {
    return new Dv({
        typeName: a.ZodBoolean,
        coerce: v?.coerce || !1,
        ...a6(v)
    })
};
class Q5 extends z0 {
    _parse(v) {
        if (this._def.coerce) v.data = new Date(v.data);
        if (this._getType(v) !== U6.date) {
            let N = this._getOrReturnCtx(v);
            return j6(N, {
                code: d.invalid_type,
                expected: U6.date,
                received: N.parsedType
            }), k6
        }
        if (Number.isNaN(v.data.getTime())) {
            let N = this._getOrReturnCtx(v);
            return j6(N, {
                code: d.invalid_date
            }), k6
        }
        let U = new Y4,
            V = void 0;
        for (let N of this._def.checks)
            if (N.kind === "min") {
                if (v.data.getTime() < N.value) V = this._getOrReturnCtx(v, V), j6(V, {
                    code: d.too_small,
                    message: N.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: N.value,
                    type: "date"
                }), U.dirty()
            } else if (N.kind === "max") {
            if (v.data.getTime() > N.value) V = this._getOrReturnCtx(v, V), j6(V, {
                code: d.too_big,
                message: N.message,
                inclusive: !0,
                exact: !1,
                maximum: N.value,
                type: "date"
            }), U.dirty()
        } else x0.assertNever(N);
        return {
            status: U.value,
            value: new Date(v.data.getTime())
        }
    }
    _addCheck(v) {
        return new Q5({
            ...this._def,
            checks: [...this._def.checks, v]
        })
    }
    min(v, z) {
        return this._addCheck({
            kind: "min",
            value: v.getTime(),
            message: G6.toString(z)
        })
    }
    max(v, z) {
        return this._addCheck({
            kind: "max",
            value: v.getTime(),
            message: G6.toString(z)
        })
    }
    get minDate() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "min") {
                if (v === null || z.value > v) v = z.value
            } return v != null ? new Date(v) : null
    }
    get maxDate() {
        let v = null;
        for (let z of this._def.checks)
            if (z.kind === "max") {
                if (v === null || z.value < v) v = z.value
            } return v != null ? new Date(v) : null
    }
}
Q5.create = (v) => {
    return new Q5({
        checks: [],
        coerce: v?.coerce || !1,
        typeName: a.ZodDate,
        ...a6(v)
    })
};
class dz extends z0 {
    _parse(v) {
        if (this._getType(v) !== U6.symbol) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.symbol,
                received: U.parsedType
            }), k6
        }
        return h4(v.data)
    }
}
dz.create = (v) => {
    return new dz({
        typeName: a.ZodSymbol,
        ...a6(v)
    })
};
class Av extends z0 {
    _parse(v) {
        if (this._getType(v) !== U6.undefined) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.undefined,
                received: U.parsedType
            }), k6
        }
        return h4(v.data)
    }
}
Av.create = (v) => {
    return new Av({
        typeName: a.ZodUndefined,
        ...a6(v)
    })
};
class $v extends z0 {
    _parse(v) {
        if (this._getType(v) !== U6.null) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.null,
                received: U.parsedType
            }), k6
        }
        return h4(v.data)
    }
}
$v.create = (v) => {
    return new $v({
        typeName: a.ZodNull,
        ...a6(v)
    })
};
class d5 extends z0 {
    constructor() {
        super(...arguments);
        this._any = !0
    }
    _parse(v) {
        return h4(v.data)
    }
}
d5.create = (v) => {
    return new d5({
        typeName: a.ZodAny,
        ...a6(v)
    })
};
class r9 extends z0 {
    constructor() {
        super(...arguments);
        this._unknown = !0
    }
    _parse(v) {
        return h4(v.data)
    }
}
r9.create = (v) => {
    return new r9({
        typeName: a.ZodUnknown,
        ...a6(v)
    })
};
class y8 extends z0 {
    _parse(v) {
        let z = this._getOrReturnCtx(v);
        return j6(z, {
            code: d.invalid_type,
            expected: U6.never,
            received: z.parsedType
        }), k6
    }
}
y8.create = (v) => {
    return new y8({
        typeName: a.ZodNever,
        ...a6(v)
    })
};
class oz extends z0 {
    _parse(v) {
        if (this._getType(v) !== U6.undefined) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.void,
                received: U.parsedType
            }), k6
        }
        return h4(v.data)
    }
}
oz.create = (v) => {
    return new oz({
        typeName: a.ZodVoid,
        ...a6(v)
    })
};
class x8 extends z0 {
    _parse(v) {
        let {
            ctx: z,
            status: U
        } = this._processInputParams(v), V = this._def;
        if (z.parsedType !== U6.array) return j6(z, {
            code: d.invalid_type,
            expected: U6.array,
            received: z.parsedType
        }), k6;
        if (V.exactLength !== null) {
            let K = z.data.length > V.exactLength.value,
                x = z.data.length < V.exactLength.value;
            if (K || x) j6(z, {
                code: K ? d.too_big : d.too_small,
                minimum: x ? V.exactLength.value : void 0,
                maximum: K ? V.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: V.exactLength.message
            }), U.dirty()
        }
        if (V.minLength !== null) {
            if (z.data.length < V.minLength.value) j6(z, {
                code: d.too_small,
                minimum: V.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: V.minLength.message
            }), U.dirty()
        }
        if (V.maxLength !== null) {
            if (z.data.length > V.maxLength.value) j6(z, {
                code: d.too_big,
                maximum: V.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: V.maxLength.message
            }), U.dirty()
        }
        if (z.common.async) return Promise.all([...z.data].map((K, x) => {
            return V.type._parseAsync(new B8(z, K, z.path, x))
        })).then((K) => {
            return Y4.mergeArray(U, K)
        });
        let N = [...z.data].map((K, x) => {
            return V.type._parseSync(new B8(z, K, z.path, x))
        });
        return Y4.mergeArray(U, N)
    }
    get element() {
        return this._def.type
    }
    min(v, z) {
        return new x8({
            ...this._def,
            minLength: {
                value: v,
                message: G6.toString(z)
            }
        })
    }
    max(v, z) {
        return new x8({
            ...this._def,
            maxLength: {
                value: v,
                message: G6.toString(z)
            }
        })
    }
    length(v, z) {
        return new x8({
            ...this._def,
            exactLength: {
                value: v,
                message: G6.toString(z)
            }
        })
    }
    nonempty(v) {
        return this.min(1, v)
    }
}
x8.create = (v, z) => {
    return new x8({
        type: v,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: a.ZodArray,
        ...a6(z)
    })
};

function qv(v) {
    if (v instanceof o0) {
        let z = {};
        for (let U in v.shape) {
            let V = v.shape[U];
            z[U] = j8.create(qv(V))
        }
        return new o0({
            ...v._def,
            shape: () => z
        })
    } else if (v instanceof x8) return new x8({
        ...v._def,
        type: qv(v.element)
    });
    else if (v instanceof j8) return j8.create(qv(v.unwrap()));
    else if (v instanceof J9) return J9.create(qv(v.unwrap()));
    else if (v instanceof k8) return k8.create(v.items.map((z) => qv(z)));
    else return v
}
class o0 extends z0 {
    constructor() {
        super(...arguments);
        this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        let v = this._def.shape(),
            z = x0.objectKeys(v);
        return this._cached = {
            shape: v,
            keys: z
        }, this._cached
    }
    _parse(v) {
        if (this._getType(v) !== U6.object) {
            let B = this._getOrReturnCtx(v);
            return j6(B, {
                code: d.invalid_type,
                expected: U6.object,
                received: B.parsedType
            }), k6
        }
        let {
            status: U,
            ctx: V
        } = this._processInputParams(v), {
            shape: N,
            keys: K
        } = this._getCached(), x = [];
        if (!(this._def.catchall instanceof y8 && this._def.unknownKeys === "strip")) {
            for (let B in V.data)
                if (!K.includes(B)) x.push(B)
        }
        let j = [];
        for (let B of K) {
            let O = N[B],
                J = V.data[B];
            j.push({
                key: {
                    status: "valid",
                    value: B
                },
                value: O._parse(new B8(V, J, V.path, B)),
                alwaysSet: B in V.data
            })
        }
        if (this._def.catchall instanceof y8) {
            let B = this._def.unknownKeys;
            if (B === "passthrough")
                for (let O of x) j.push({
                    key: {
                        status: "valid",
                        value: O
                    },
                    value: {
                        status: "valid",
                        value: V.data[O]
                    }
                });
            else if (B === "strict") {
                if (x.length > 0) j6(V, {
                    code: d.unrecognized_keys,
                    keys: x
                }), U.dirty()
            } else if (B === "strip");
            else throw Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            let B = this._def.catchall;
            for (let O of x) {
                let J = V.data[O];
                j.push({
                    key: {
                        status: "valid",
                        value: O
                    },
                    value: B._parse(new B8(V, J, V.path, O)),
                    alwaysSet: O in V.data
                })
            }
        }
        if (V.common.async) return Promise.resolve().then(async () => {
            let B = [];
            for (let O of j) {
                let J = await O.key,
                    q = await O.value;
                B.push({
                    key: J,
                    value: q,
                    alwaysSet: O.alwaysSet
                })
            }
            return B
        }).then((B) => {
            return Y4.mergeObjectSync(U, B)
        });
        else return Y4.mergeObjectSync(U, j)
    }
    get shape() {
        return this._def.shape()
    }
    strict(v) {
        return G6.errToObj, new o0({
            ...this._def,
            unknownKeys: "strict",
            ...v !== void 0 ? {
                errorMap: (z, U) => {
                    let V = this._def.errorMap?.(z, U).message ?? U.defaultError;
                    if (z.code === "unrecognized_keys") return {
                        message: G6.errToObj(v).message ?? V
                    };
                    return {
                        message: V
                    }
                }
            } : {}
        })
    }
    strip() {
        return new o0({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new o0({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(v) {
        return new o0({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...v
            })
        })
    }
    merge(v) {
        return new o0({
            unknownKeys: v._def.unknownKeys,
            catchall: v._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...v._def.shape()
            }),
            typeName: a.ZodObject
        })
    }
    setKey(v, z) {
        return this.augment({
            [v]: z
        })
    }
    catchall(v) {
        return new o0({
            ...this._def,
            catchall: v
        })
    }
    pick(v) {
        let z = {};
        for (let U of x0.objectKeys(v))
            if (v[U] && this.shape[U]) z[U] = this.shape[U];
        return new o0({
            ...this._def,
            shape: () => z
        })
    }
    omit(v) {
        let z = {};
        for (let U of x0.objectKeys(this.shape))
            if (!v[U]) z[U] = this.shape[U];
        return new o0({
            ...this._def,
            shape: () => z
        })
    }
    deepPartial() {
        return qv(this)
    }
    partial(v) {
        let z = {};
        for (let U of x0.objectKeys(this.shape)) {
            let V = this.shape[U];
            if (v && !v[U]) z[U] = V;
            else z[U] = V.optional()
        }
        return new o0({
            ...this._def,
            shape: () => z
        })
    }
    required(v) {
        let z = {};
        for (let U of x0.objectKeys(this.shape))
            if (v && !v[U]) z[U] = this.shape[U];
            else {
                let N = this.shape[U];
                while (N instanceof j8) N = N._def.innerType;
                z[U] = N
            } return new o0({
            ...this._def,
            shape: () => z
        })
    }
    keyof() {
        return OS(x0.objectKeys(this.shape))
    }
}
o0.create = (v, z) => {
    return new o0({
        shape: () => v,
        unknownKeys: "strip",
        catchall: y8.create(),
        typeName: a.ZodObject,
        ...a6(z)
    })
};
o0.strictCreate = (v, z) => {
    return new o0({
        shape: () => v,
        unknownKeys: "strict",
        catchall: y8.create(),
        typeName: a.ZodObject,
        ...a6(z)
    })
};
o0.lazycreate = (v, z) => {
    return new o0({
        shape: v,
        unknownKeys: "strip",
        catchall: y8.create(),
        typeName: a.ZodObject,
        ...a6(z)
    })
};
class wv extends z0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = this._def.options;

        function V(N) {
            for (let x of N)
                if (x.result.status === "valid") return x.result;
            for (let x of N)
                if (x.result.status === "dirty") return z.common.issues.push(...x.ctx.common.issues), x.result;
            let K = N.map((x) => new D3(x.ctx.common.issues));
            return j6(z, {
                code: d.invalid_union,
                unionErrors: K
            }), k6
        }
        if (z.common.async) return Promise.all(U.map(async (N) => {
            let K = {
                ...z,
                common: {
                    ...z.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await N._parseAsync({
                    data: z.data,
                    path: z.path,
                    parent: K
                }),
                ctx: K
            }
        })).then(V);
        else {
            let N = void 0,
                K = [];
            for (let j of U) {
                let B = {
                        ...z,
                        common: {
                            ...z.common,
                            issues: []
                        },
                        parent: null
                    },
                    O = j._parseSync({
                        data: z.data,
                        path: z.path,
                        parent: B
                    });
                if (O.status === "valid") return O;
                else if (O.status === "dirty" && !N) N = {
                    result: O,
                    ctx: B
                };
                if (B.common.issues.length) K.push(B.common.issues)
            }
            if (N) return z.common.issues.push(...N.ctx.common.issues), N.result;
            let x = K.map((j) => new D3(j));
            return j6(z, {
                code: d.invalid_union,
                unionErrors: x
            }), k6
        }
    }
    get options() {
        return this._def.options
    }
}
wv.create = (v, z) => {
    return new wv({
        options: v,
        typeName: a.ZodUnion,
        ...a6(z)
    })
};
var O9 = (v) => {
    if (v instanceof Lv) return O9(v.schema);
    else if (v instanceof O8) return O9(v.innerType());
    else if (v instanceof Fv) return [v.value];
    else if (v instanceof s9) return v.options;
    else if (v instanceof Gv) return x0.objectValues(v.enum);
    else if (v instanceof Iv) return O9(v._def.innerType);
    else if (v instanceof Av) return [void 0];
    else if (v instanceof $v) return [null];
    else if (v instanceof j8) return [void 0, ...O9(v.unwrap())];
    else if (v instanceof J9) return [null, ...O9(v.unwrap())];
    else if (v instanceof rK) return O9(v.unwrap());
    else if (v instanceof bv) return O9(v.unwrap());
    else if (v instanceof Mv) return O9(v._def.innerType);
    else return []
};
class oK extends z0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== U6.object) return j6(z, {
            code: d.invalid_type,
            expected: U6.object,
            received: z.parsedType
        }), k6;
        let U = this.discriminator,
            V = z.data[U],
            N = this.optionsMap.get(V);
        if (!N) return j6(z, {
            code: d.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [U]
        }), k6;
        if (z.common.async) return N._parseAsync({
            data: z.data,
            path: z.path,
            parent: z
        });
        else return N._parseSync({
            data: z.data,
            path: z.path,
            parent: z
        })
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(v, z, U) {
        let V = new Map;
        for (let N of z) {
            let K = O9(N.shape[v]);
            if (!K.length) throw Error(`A discriminator value for key \`${v}\` could not be extracted from all schema options`);
            for (let x of K) {
                if (V.has(x)) throw Error(`Discriminator property ${String(v)} has duplicate value ${String(x)}`);
                V.set(x, N)
            }
        }
        return new oK({
            typeName: a.ZodDiscriminatedUnion,
            discriminator: v,
            options: z,
            optionsMap: V,
            ...a6(U)
        })
    }
}

function eH(v, z) {
    let U = u8(v),
        V = u8(z);
    if (v === z) return {
        valid: !0,
        data: v
    };
    else if (U === U6.object && V === U6.object) {
        let N = x0.objectKeys(z),
            K = x0.objectKeys(v).filter((j) => N.indexOf(j) !== -1),
            x = {
                ...v,
                ...z
            };
        for (let j of K) {
            let B = eH(v[j], z[j]);
            if (!B.valid) return {
                valid: !1
            };
            x[j] = B.data
        }
        return {
            valid: !0,
            data: x
        }
    } else if (U === U6.array && V === U6.array) {
        if (v.length !== z.length) return {
            valid: !1
        };
        let N = [];
        for (let K = 0; K < v.length; K++) {
            let x = v[K],
                j = z[K],
                B = eH(x, j);
            if (!B.valid) return {
                valid: !1
            };
            N.push(B.data)
        }
        return {
            valid: !0,
            data: N
        }
    } else if (U === U6.date && V === U6.date && +v === +z) return {
        valid: !0,
        data: v
    };
    else return {
        valid: !1
    }
}
class Zv extends z0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v), V = (N, K) => {
            if (QK(N) || QK(K)) return k6;
            let x = eH(N.value, K.value);
            if (!x.valid) return j6(U, {
                code: d.invalid_intersection_types
            }), k6;
            if (dK(N) || dK(K)) z.dirty();
            return {
                status: z.value,
                value: x.data
            }
        };
        if (U.common.async) return Promise.all([this._def.left._parseAsync({
            data: U.data,
            path: U.path,
            parent: U
        }), this._def.right._parseAsync({
            data: U.data,
            path: U.path,
            parent: U
        })]).then(([N, K]) => V(N, K));
        else return V(this._def.left._parseSync({
            data: U.data,
            path: U.path,
            parent: U
        }), this._def.right._parseSync({
            data: U.data,
            path: U.path,
            parent: U
        }))
    }
}
Zv.create = (v, z, U) => {
    return new Zv({
        left: v,
        right: z,
        typeName: a.ZodIntersection,
        ...a6(U)
    })
};
class k8 extends z0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== U6.array) return j6(U, {
            code: d.invalid_type,
            expected: U6.array,
            received: U.parsedType
        }), k6;
        if (U.data.length < this._def.items.length) return j6(U, {
            code: d.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), k6;
        if (!this._def.rest && U.data.length > this._def.items.length) j6(U, {
            code: d.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), z.dirty();
        let N = [...U.data].map((K, x) => {
            let j = this._def.items[x] || this._def.rest;
            if (!j) return null;
            return j._parse(new B8(U, K, U.path, x))
        }).filter((K) => !!K);
        if (U.common.async) return Promise.all(N).then((K) => {
            return Y4.mergeArray(z, K)
        });
        else return Y4.mergeArray(z, N)
    }
    get items() {
        return this._def.items
    }
    rest(v) {
        return new k8({
            ...this._def,
            rest: v
        })
    }
}
k8.create = (v, z) => {
    if (!Array.isArray(v)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new k8({
        items: v,
        typeName: a.ZodTuple,
        rest: null,
        ...a6(z)
    })
};
class rz extends z0 {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== U6.object) return j6(U, {
            code: d.invalid_type,
            expected: U6.object,
            received: U.parsedType
        }), k6;
        let V = [],
            N = this._def.keyType,
            K = this._def.valueType;
        for (let x in U.data) V.push({
            key: N._parse(new B8(U, x, U.path, x)),
            value: K._parse(new B8(U, U.data[x], U.path, x)),
            alwaysSet: x in U.data
        });
        if (U.common.async) return Y4.mergeObjectAsync(z, V);
        else return Y4.mergeObjectSync(z, V)
    }
    get element() {
        return this._def.valueType
    }
    static create(v, z, U) {
        if (z instanceof z0) return new rz({
            keyType: v,
            valueType: z,
            typeName: a.ZodRecord,
            ...a6(U)
        });
        return new rz({
            keyType: K8.create(),
            valueType: v,
            typeName: a.ZodRecord,
            ...a6(z)
        })
    }
}
class az extends z0 {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== U6.map) return j6(U, {
            code: d.invalid_type,
            expected: U6.map,
            received: U.parsedType
        }), k6;
        let V = this._def.keyType,
            N = this._def.valueType,
            K = [...U.data.entries()].map(([x, j], B) => {
                return {
                    key: V._parse(new B8(U, x, U.path, [B, "key"])),
                    value: N._parse(new B8(U, j, U.path, [B, "value"]))
                }
            });
        if (U.common.async) {
            let x = new Map;
            return Promise.resolve().then(async () => {
                for (let j of K) {
                    let B = await j.key,
                        O = await j.value;
                    if (B.status === "aborted" || O.status === "aborted") return k6;
                    if (B.status === "dirty" || O.status === "dirty") z.dirty();
                    x.set(B.value, O.value)
                }
                return {
                    status: z.value,
                    value: x
                }
            })
        } else {
            let x = new Map;
            for (let j of K) {
                let {
                    key: B,
                    value: O
                } = j;
                if (B.status === "aborted" || O.status === "aborted") return k6;
                if (B.status === "dirty" || O.status === "dirty") z.dirty();
                x.set(B.value, O.value)
            }
            return {
                status: z.value,
                value: x
            }
        }
    }
}
az.create = (v, z, U) => {
    return new az({
        valueType: z,
        keyType: v,
        typeName: a.ZodMap,
        ...a6(U)
    })
};
class o5 extends z0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.parsedType !== U6.set) return j6(U, {
            code: d.invalid_type,
            expected: U6.set,
            received: U.parsedType
        }), k6;
        let V = this._def;
        if (V.minSize !== null) {
            if (U.data.size < V.minSize.value) j6(U, {
                code: d.too_small,
                minimum: V.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: V.minSize.message
            }), z.dirty()
        }
        if (V.maxSize !== null) {
            if (U.data.size > V.maxSize.value) j6(U, {
                code: d.too_big,
                maximum: V.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: V.maxSize.message
            }), z.dirty()
        }
        let N = this._def.valueType;

        function K(j) {
            let B = new Set;
            for (let O of j) {
                if (O.status === "aborted") return k6;
                if (O.status === "dirty") z.dirty();
                B.add(O.value)
            }
            return {
                status: z.value,
                value: B
            }
        }
        let x = [...U.data.values()].map((j, B) => N._parse(new B8(U, j, U.path, B)));
        if (U.common.async) return Promise.all(x).then((j) => K(j));
        else return K(x)
    }
    min(v, z) {
        return new o5({
            ...this._def,
            minSize: {
                value: v,
                message: G6.toString(z)
            }
        })
    }
    max(v, z) {
        return new o5({
            ...this._def,
            maxSize: {
                value: v,
                message: G6.toString(z)
            }
        })
    }
    size(v, z) {
        return this.min(v, z).max(v, z)
    }
    nonempty(v) {
        return this.min(1, v)
    }
}
o5.create = (v, z) => {
    return new o5({
        valueType: v,
        minSize: null,
        maxSize: null,
        typeName: a.ZodSet,
        ...a6(z)
    })
};
class Hv extends z0 {
    constructor() {
        super(...arguments);
        this.validate = this.implement
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== U6.function) return j6(z, {
            code: d.invalid_type,
            expected: U6.function,
            received: z.parsedType
        }), k6;

        function U(x, j) {
            return Qz({
                data: x,
                path: z.path,
                errorMaps: [z.common.contextualErrorMap, z.schemaErrorMap, Ov(), B9].filter((B) => !!B),
                issueData: {
                    code: d.invalid_arguments,
                    argumentsError: j
                }
            })
        }

        function V(x, j) {
            return Qz({
                data: x,
                path: z.path,
                errorMaps: [z.common.contextualErrorMap, z.schemaErrorMap, Ov(), B9].filter((B) => !!B),
                issueData: {
                    code: d.invalid_return_type,
                    returnTypeError: j
                }
            })
        }
        let N = {
                errorMap: z.common.contextualErrorMap
            },
            K = z.data;
        if (this._def.returns instanceof r5) {
            let x = this;
            return h4(async function(...j) {
                let B = new D3([]),
                    O = await x._def.args.parseAsync(j, N).catch((H) => {
                        throw B.addIssue(U(j, H)), B
                    }),
                    J = await Reflect.apply(K, this, O);
                return await x._def.returns._def.type.parseAsync(J, N).catch((H) => {
                    throw B.addIssue(V(J, H)), B
                })
            })
        } else {
            let x = this;
            return h4(function(...j) {
                let B = x._def.args.safeParse(j, N);
                if (!B.success) throw new D3([U(j, B.error)]);
                let O = Reflect.apply(K, this, B.data),
                    J = x._def.returns.safeParse(O, N);
                if (!J.success) throw new D3([V(O, J.error)]);
                return J.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...v) {
        return new Hv({
            ...this._def,
            args: k8.create(v).rest(r9.create())
        })
    }
    returns(v) {
        return new Hv({
            ...this._def,
            returns: v
        })
    }
    implement(v) {
        return this.parse(v)
    }
    strictImplement(v) {
        return this.parse(v)
    }
    static create(v, z, U) {
        return new Hv({
            args: v ? v : k8.create([]).rest(r9.create()),
            returns: z || r9.create(),
            typeName: a.ZodFunction,
            ...a6(U)
        })
    }
}
class Lv extends z0 {
    get schema() {
        return this._def.getter()
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        return this._def.getter()._parse({
            data: z.data,
            path: z.path,
            parent: z
        })
    }
}
Lv.create = (v, z) => {
    return new Lv({
        getter: v,
        typeName: a.ZodLazy,
        ...a6(z)
    })
};
class Fv extends z0 {
    _parse(v) {
        if (v.data !== this._def.value) {
            let z = this._getOrReturnCtx(v);
            return j6(z, {
                received: z.data,
                code: d.invalid_literal,
                expected: this._def.value
            }), k6
        }
        return {
            status: "valid",
            value: v.data
        }
    }
    get value() {
        return this._def.value
    }
}
Fv.create = (v, z) => {
    return new Fv({
        value: v,
        typeName: a.ZodLiteral,
        ...a6(z)
    })
};

function OS(v, z) {
    return new s9({
        values: v,
        typeName: a.ZodEnum,
        ...a6(z)
    })
}
class s9 extends z0 {
    _parse(v) {
        if (typeof v.data !== "string") {
            let z = this._getOrReturnCtx(v),
                U = this._def.values;
            return j6(z, {
                expected: x0.joinValues(U),
                received: z.parsedType,
                code: d.invalid_type
            }), k6
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(v.data)) {
            let z = this._getOrReturnCtx(v),
                U = this._def.values;
            return j6(z, {
                received: z.data,
                code: d.invalid_enum_value,
                options: U
            }), k6
        }
        return h4(v.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    get Values() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    get Enum() {
        let v = {};
        for (let z of this._def.values) v[z] = z;
        return v
    }
    extract(v, z = this._def) {
        return s9.create(v, {
            ...this._def,
            ...z
        })
    }
    exclude(v, z = this._def) {
        return s9.create(this.options.filter((U) => !v.includes(U)), {
            ...this._def,
            ...z
        })
    }
}
s9.create = OS;
class Gv extends z0 {
    _parse(v) {
        let z = x0.getValidEnumValues(this._def.values),
            U = this._getOrReturnCtx(v);
        if (U.parsedType !== U6.string && U.parsedType !== U6.number) {
            let V = x0.objectValues(z);
            return j6(U, {
                expected: x0.joinValues(V),
                received: U.parsedType,
                code: d.invalid_type
            }), k6
        }
        if (!this._cache) this._cache = new Set(x0.getValidEnumValues(this._def.values));
        if (!this._cache.has(v.data)) {
            let V = x0.objectValues(z);
            return j6(U, {
                received: U.data,
                code: d.invalid_enum_value,
                options: V
            }), k6
        }
        return h4(v.data)
    }
    get enum() {
        return this._def.values
    }
}
Gv.create = (v, z) => {
    return new Gv({
        values: v,
        typeName: a.ZodNativeEnum,
        ...a6(z)
    })
};
class r5 extends z0 {
    unwrap() {
        return this._def.type
    }
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v);
        if (z.parsedType !== U6.promise && z.common.async === !1) return j6(z, {
            code: d.invalid_type,
            expected: U6.promise,
            received: z.parsedType
        }), k6;
        let U = z.parsedType === U6.promise ? z.data : Promise.resolve(z.data);
        return h4(U.then((V) => {
            return this._def.type.parseAsync(V, {
                path: z.path,
                errorMap: z.common.contextualErrorMap
            })
        }))
    }
}
r5.create = (v, z) => {
    return new r5({
        type: v,
        typeName: a.ZodPromise,
        ...a6(z)
    })
};
class O8 extends z0 {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === a.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v), V = this._def.effect || null, N = {
            addIssue: (K) => {
                if (j6(U, K), K.fatal) z.abort();
                else z.dirty()
            },
            get path() {
                return U.path
            }
        };
        if (N.addIssue = N.addIssue.bind(N), V.type === "preprocess") {
            let K = V.transform(U.data, N);
            if (U.common.async) return Promise.resolve(K).then(async (x) => {
                if (z.value === "aborted") return k6;
                let j = await this._def.schema._parseAsync({
                    data: x,
                    path: U.path,
                    parent: U
                });
                if (j.status === "aborted") return k6;
                if (j.status === "dirty") return n5(j.value);
                if (z.value === "dirty") return n5(j.value);
                return j
            });
            else {
                if (z.value === "aborted") return k6;
                let x = this._def.schema._parseSync({
                    data: K,
                    path: U.path,
                    parent: U
                });
                if (x.status === "aborted") return k6;
                if (x.status === "dirty") return n5(x.value);
                if (z.value === "dirty") return n5(x.value);
                return x
            }
        }
        if (V.type === "refinement") {
            let K = (x) => {
                let j = V.refinement(x, N);
                if (U.common.async) return Promise.resolve(j);
                if (j instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return x
            };
            if (U.common.async === !1) {
                let x = this._def.schema._parseSync({
                    data: U.data,
                    path: U.path,
                    parent: U
                });
                if (x.status === "aborted") return k6;
                if (x.status === "dirty") z.dirty();
                return K(x.value), {
                    status: z.value,
                    value: x.value
                }
            } else return this._def.schema._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            }).then((x) => {
                if (x.status === "aborted") return k6;
                if (x.status === "dirty") z.dirty();
                return K(x.value).then(() => {
                    return {
                        status: z.value,
                        value: x.value
                    }
                })
            })
        }
        if (V.type === "transform")
            if (U.common.async === !1) {
                let K = this._def.schema._parseSync({
                    data: U.data,
                    path: U.path,
                    parent: U
                });
                if (!o9(K)) return k6;
                let x = V.transform(K.value, N);
                if (x instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: z.value,
                    value: x
                }
            } else return this._def.schema._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            }).then((K) => {
                if (!o9(K)) return k6;
                return Promise.resolve(V.transform(K.value, N)).then((x) => ({
                    status: z.value,
                    value: x
                }))
            });
        x0.assertNever(V)
    }
}
O8.create = (v, z, U) => {
    return new O8({
        schema: v,
        typeName: a.ZodEffects,
        effect: z,
        ...a6(U)
    })
};
O8.createWithPreprocess = (v, z, U) => {
    return new O8({
        schema: z,
        effect: {
            type: "preprocess",
            transform: v
        },
        typeName: a.ZodEffects,
        ...a6(U)
    })
};
class j8 extends z0 {
    _parse(v) {
        if (this._getType(v) === U6.undefined) return h4(void 0);
        return this._def.innerType._parse(v)
    }
    unwrap() {
        return this._def.innerType
    }
}
j8.create = (v, z) => {
    return new j8({
        innerType: v,
        typeName: a.ZodOptional,
        ...a6(z)
    })
};
class J9 extends z0 {
    _parse(v) {
        if (this._getType(v) === U6.null) return h4(null);
        return this._def.innerType._parse(v)
    }
    unwrap() {
        return this._def.innerType
    }
}
J9.create = (v, z) => {
    return new J9({
        innerType: v,
        typeName: a.ZodNullable,
        ...a6(z)
    })
};
class Iv extends z0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = z.data;
        if (z.parsedType === U6.undefined) U = this._def.defaultValue();
        return this._def.innerType._parse({
            data: U,
            path: z.path,
            parent: z
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
Iv.create = (v, z) => {
    return new Iv({
        innerType: v,
        typeName: a.ZodDefault,
        defaultValue: typeof z.default === "function" ? z.default : () => z.default,
        ...a6(z)
    })
};
class Mv extends z0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = {
            ...z,
            common: {
                ...z.common,
                issues: []
            }
        }, V = this._def.innerType._parse({
            data: U.data,
            path: U.path,
            parent: {
                ...U
            }
        });
        if (Jv(V)) return V.then((N) => {
            return {
                status: "valid",
                value: N.status === "valid" ? N.value : this._def.catchValue({
                    get error() {
                        return new D3(U.common.issues)
                    },
                    input: U.data
                })
            }
        });
        else return {
            status: "valid",
            value: V.status === "valid" ? V.value : this._def.catchValue({
                get error() {
                    return new D3(U.common.issues)
                },
                input: U.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
Mv.create = (v, z) => {
    return new Mv({
        innerType: v,
        typeName: a.ZodCatch,
        catchValue: typeof z.catch === "function" ? z.catch : () => z.catch,
        ...a6(z)
    })
};
class tz extends z0 {
    _parse(v) {
        if (this._getType(v) !== U6.nan) {
            let U = this._getOrReturnCtx(v);
            return j6(U, {
                code: d.invalid_type,
                expected: U6.nan,
                received: U.parsedType
            }), k6
        }
        return {
            status: "valid",
            value: v.data
        }
    }
}
tz.create = (v) => {
    return new tz({
        typeName: a.ZodNaN,
        ...a6(v)
    })
};
var x36 = Symbol("zod_brand");
class rK extends z0 {
    _parse(v) {
        let {
            ctx: z
        } = this._processInputParams(v), U = z.data;
        return this._def.type._parse({
            data: U,
            path: z.path,
            parent: z
        })
    }
    unwrap() {
        return this._def.type
    }
}
class sz extends z0 {
    _parse(v) {
        let {
            status: z,
            ctx: U
        } = this._processInputParams(v);
        if (U.common.async) return (async () => {
            let N = await this._def.in._parseAsync({
                data: U.data,
                path: U.path,
                parent: U
            });
            if (N.status === "aborted") return k6;
            if (N.status === "dirty") return z.dirty(), n5(N.value);
            else return this._def.out._parseAsync({
                data: N.value,
                path: U.path,
                parent: U
            })
        })();
        else {
            let V = this._def.in._parseSync({
                data: U.data,
                path: U.path,
                parent: U
            });
            if (V.status === "aborted") return k6;
            if (V.status === "dirty") return z.dirty(), {
                status: "dirty",
                value: V.value
            };
            else return this._def.out._parseSync({
                data: V.value,
                path: U.path,
                parent: U
            })
        }
    }
    static create(v, z) {
        return new sz({
            in: v,
            out: z,
            typeName: a.ZodPipeline
        })
    }
}
class bv extends z0 {
    _parse(v) {
        let z = this._def.innerType._parse(v),
            U = (V) => {
                if (o9(V)) V.value = Object.freeze(V.value);
                return V
            };
        return Jv(z) ? z.then((V) => U(V)) : U(z)
    }
    unwrap() {
        return this._def.innerType
    }
}
bv.create = (v, z) => {
    return new bv({
        innerType: v,
        typeName: a.ZodReadonly,
        ...a6(z)
    })
};

function KS(v, z) {
    let U = typeof v === "function" ? v(z) : typeof v === "string" ? {
        message: v
    } : v;
    return typeof U === "string" ? {
        message: U
    } : U
}

function JS(v, z = {}, U) {
    if (v) return d5.create().superRefine((V, N) => {
        let K = v(V);
        if (K instanceof Promise) return K.then((x) => {
            if (!x) {
                let j = KS(z, V),
                    B = j.fatal ?? U ?? !0;
                N.addIssue({
                    code: "custom",
                    ...j,
                    fatal: B
                })
            }
        });
        if (!K) {
            let x = KS(z, V),
                j = x.fatal ?? U ?? !0;
            N.addIssue({
                code: "custom",
                ...x,
                fatal: j
            })
        }
        return
    });
    return d5.create()
}
var j36 = {
        object: o0.lazycreate
    },
    a;
(function(v) {
    v.ZodString = "ZodString", v.ZodNumber = "ZodNumber", v.ZodNaN = "ZodNaN", v.ZodBigInt = "ZodBigInt", v.ZodBoolean = "ZodBoolean", v.ZodDate = "ZodDate", v.ZodSymbol = "ZodSymbol", v.ZodUndefined = "ZodUndefined", v.ZodNull = "ZodNull", v.ZodAny = "ZodAny", v.ZodUnknown = "ZodUnknown", v.ZodNever = "ZodNever", v.ZodVoid = "ZodVoid", v.ZodArray = "ZodArray", v.ZodObject = "ZodObject", v.ZodUnion = "ZodUnion", v.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", v.ZodIntersection = "ZodIntersection", v.ZodTuple = "ZodTuple", v.ZodRecord = "ZodRecord", v.ZodMap = "ZodMap", v.ZodSet = "ZodSet", v.ZodFunction = "ZodFunction", v.ZodLazy = "ZodLazy", v.ZodLiteral = "ZodLiteral", v.ZodEnum = "ZodEnum", v.ZodEffects = "ZodEffects", v.ZodNativeEnum = "ZodNativeEnum", v.ZodOptional = "ZodOptional", v.ZodNullable = "ZodNullable", v.ZodDefault = "ZodDefault", v.ZodCatch = "ZodCatch", v.ZodPromise = "ZodPromise", v.ZodBranded = "ZodBranded", v.ZodPipeline = "ZodPipeline", v.ZodReadonly = "ZodReadonly"
})(a || (a = {}));
var B36 = (v, z = {
        message: `Input not instance of ${v.name}`
    }) => JS((U) => U instanceof v, z),
    qS = K8.create,
    HS = a9.create,
    O36 = tz.create,
    J36 = t9.create,
    DS = Dv.create,
    q36 = Q5.create,
    H36 = dz.create,
    D36 = Av.create,
    A36 = $v.create,
    $36 = d5.create,
    w36 = r9.create,
    Z36 = y8.create,
    L36 = oz.create,
    F36 = x8.create,
    vD = o0.create,
    G36 = o0.strictCreate,
    I36 = wv.create,
    M36 = oK.create,
    b36 = Zv.create,
    R36 = k8.create,
    W36 = rz.create,
    E36 = az.create,
    S36 = o5.create,
    P36 = Hv.create,
    _36 = Lv.create,
    C36 = Fv.create,
    f36 = s9.create,
    T36 = Gv.create,
    Y36 = r5.create,
    u36 = O8.create,
    y36 = j8.create,
    k36 = J9.create,
    m36 = O8.createWithPreprocess,
    X36 = sz.create,
    g36 = () => qS().optional(),
    c36 = () => HS().optional(),
    i36 = () => DS().optional(),
    l36 = {
        string: (v) => K8.create({
            ...v,
            coerce: !0
        }),
        number: (v) => a9.create({
            ...v,
            coerce: !0
        }),
        boolean: (v) => Dv.create({
            ...v,
            coerce: !0
        }),
        bigint: (v) => t9.create({
            ...v,
            coerce: !0
        }),
        date: (v) => Q5.create({
            ...v,
            coerce: !0
        })
    };
var h36 = k6;
var p36 = s.object({
        method: s.literal("experiment_gates"),
        params: s.object({
            gates: s.record(s.string(), s.boolean())
        })
    }),
    $L6 = s.object({
        method: s.literal("file_updated"),
        params: s.object({
            filePath: s.string(),
            oldContent: s.string().nullable(),
            newContent: s.string().nullable()
        })
    });

function AS(v, z) {
    let U = pK({
        name: "claude-vscode",
        version: "2.1.42",
        tools: []
    });
    return U.instance.server.setNotificationHandler(p36, async (V) => {
        let {
            gates: N
        } = V.params;
        v(N)
    }), U
}

function $S(v, z, U) {
    v.instance.server.notification({
        method: "log_event",
        params: {
            eventName: z,
            eventData: U
        }
    })
}

function ez(v, z) {
    return function() {
        return v.apply(z, arguments)
    }
}
var {
    toString: n36
} = Object.prototype, {
    getPrototypeOf: UD
} = Object, tK = ((v) => (z) => {
    let U = n36.call(z);
    return v[U] || (v[U] = U.slice(8, -1).toLowerCase())
})(Object.create(null)), J8 = (v) => {
    return v = v.toLowerCase(), (z) => tK(z) === v
}, sK = (v) => (z) => typeof z === v, {
    isArray: Rv
} = Array, vU = sK("undefined");

function Q36(v) {
    return v !== null && !vU(v) && v.constructor !== null && !vU(v.constructor) && P3(v.constructor.isBuffer) && v.constructor.isBuffer(v)
}
var ZS = J8("ArrayBuffer");

function d36(v) {
    let z;
    if (typeof ArrayBuffer < "u" && ArrayBuffer.isView) z = ArrayBuffer.isView(v);
    else z = v && v.buffer && ZS(v.buffer);
    return z
}
var o36 = sK("string"),
    P3 = sK("function"),
    LS = sK("number"),
    eK = (v) => v !== null && typeof v === "object",
    r36 = (v) => v === !0 || v === !1,
    aK = (v) => {
        if (tK(v) !== "object") return !1;
        let z = UD(v);
        return (z === null || z === Object.prototype || Object.getPrototypeOf(z) === null) && !(Symbol.toStringTag in v) && !(Symbol.iterator in v)
    },
    a36 = J8("Date"),
    t36 = J8("File"),
    s36 = J8("Blob"),
    e36 = J8("FileList"),
    v86 = (v) => eK(v) && P3(v.pipe),
    z86 = (v) => {
        let z;
        return v && (typeof FormData === "function" && v instanceof FormData || P3(v.append) && ((z = tK(v)) === "formdata" || z === "object" && P3(v.toString) && v.toString() === "[object FormData]"))
    },
    U86 = J8("URLSearchParams"),
    [V86, N86, K86, x86] = ["ReadableStream", "Request", "Response", "Headers"].map(J8),
    j86 = (v) => v.trim ? v.trim() : v.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function zU(v, z, {
    allOwnKeys: U = !1
} = {}) {
    if (v === null || typeof v > "u") return;
    let V, N;
    if (typeof v !== "object") v = [v];
    if (Rv(v))
        for (V = 0, N = v.length; V < N; V++) z.call(null, v[V], V, v);
    else {
        let K = U ? Object.getOwnPropertyNames(v) : Object.keys(v),
            x = K.length,
            j;
        for (V = 0; V < x; V++) j = K[V], z.call(null, v[j], j, v)
    }
}

function FS(v, z) {
    z = z.toLowerCase();
    let U = Object.keys(v),
        V = U.length,
        N;
    while (V-- > 0)
        if (N = U[V], z === N.toLowerCase()) return N;
    return null
}
var a5 = (() => {
        if (typeof globalThis < "u") return globalThis;
        return typeof self < "u" ? self : typeof window < "u" ? window : global
    })(),
    GS = (v) => !vU(v) && v !== a5;

function zD() {
    let {
        caseless: v
    } = GS(this) && this || {}, z = {}, U = (V, N) => {
        let K = v && FS(z, N) || N;
        if (aK(z[K]) && aK(V)) z[K] = zD(z[K], V);
        else if (aK(V)) z[K] = zD({}, V);
        else if (Rv(V)) z[K] = V.slice();
        else z[K] = V
    };
    for (let V = 0, N = arguments.length; V < N; V++) arguments[V] && zU(arguments[V], U);
    return z
}
var B86 = (v, z, U, {
        allOwnKeys: V
    } = {}) => {
        return zU(z, (N, K) => {
            if (U && P3(N)) v[K] = ez(N, U);
            else v[K] = N
        }, {
            allOwnKeys: V
        }), v
    },
    O86 = (v) => {
        if (v.charCodeAt(0) === 65279) v = v.slice(1);
        return v
    },
    J86 = (v, z, U, V) => {
        v.prototype = Object.create(z.prototype, V), v.prototype.constructor = v, Object.defineProperty(v, "super", {
            value: z.prototype
        }), U && Object.assign(v.prototype, U)
    },
    q86 = (v, z, U, V) => {
        let N, K, x, j = {};
        if (z = z || {}, v == null) return z;
        do {
            N = Object.getOwnPropertyNames(v), K = N.length;
            while (K-- > 0)
                if (x = N[K], (!V || V(x, v, z)) && !j[x]) z[x] = v[x], j[x] = !0;
            v = U !== !1 && UD(v)
        } while (v && (!U || U(v, z)) && v !== Object.prototype);
        return z
    },
    H86 = (v, z, U) => {
        if (v = String(v), U === void 0 || U > v.length) U = v.length;
        U -= z.length;
        let V = v.indexOf(z, U);
        return V !== -1 && V === U
    },
    D86 = (v) => {
        if (!v) return null;
        if (Rv(v)) return v;
        let z = v.length;
        if (!LS(z)) return null;
        let U = Array(z);
        while (z-- > 0) U[z] = v[z];
        return U
    },
    A86 = ((v) => {
        return (z) => {
            return v && z instanceof v
        }
    })(typeof Uint8Array < "u" && UD(Uint8Array)),
    $86 = (v, z) => {
        let V = (v && v[Symbol.iterator]).call(v),
            N;
        while ((N = V.next()) && !N.done) {
            let K = N.value;
            z.call(v, K[0], K[1])
        }
    },
    w86 = (v, z) => {
        let U, V = [];
        while ((U = v.exec(z)) !== null) V.push(U);
        return V
    },
    Z86 = J8("HTMLFormElement"),
    L86 = (v) => {
        return v.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(U, V, N) {
            return V.toUpperCase() + N
        })
    },
    wS = (({
        hasOwnProperty: v
    }) => (z, U) => v.call(z, U))(Object.prototype),
    F86 = J8("RegExp"),
    IS = (v, z) => {
        let U = Object.getOwnPropertyDescriptors(v),
            V = {};
        zU(U, (N, K) => {
            let x;
            if ((x = z(N, K, v)) !== !1) V[K] = x || N
        }), Object.defineProperties(v, V)
    },
    G86 = (v) => {
        IS(v, (z, U) => {
            if (P3(v) && ["arguments", "caller", "callee"].indexOf(U) !== -1) return !1;
            let V = v[U];
            if (!P3(V)) return;
            if (z.enumerable = !1, "writable" in z) {
                z.writable = !1;
                return
            }
            if (!z.set) z.set = () => {
                throw Error("Can not rewrite read-only method '" + U + "'")
            }
        })
    },
    I86 = (v, z) => {
        let U = {},
            V = (N) => {
                N.forEach((K) => {
                    U[K] = !0
                })
            };
        return Rv(v) ? V(v) : V(String(v).split(z)), U
    },
    M86 = () => {},
    b86 = (v, z) => {
        return v != null && Number.isFinite(v = +v) ? v : z
    };

function R86(v) {
    return !!(v && P3(v.append) && v[Symbol.toStringTag] === "FormData" && v[Symbol.iterator])
}
var W86 = (v) => {
        let z = [, , , , , , , , , , ],
            U = (V, N) => {
                if (eK(V)) {
                    if (z.indexOf(V) >= 0) return;
                    if (!("toJSON" in V)) {
                        z[N] = V;
                        let K = Rv(V) ? [] : {};
                        return zU(V, (x, j) => {
                            let B = U(x, N + 1);
                            !vU(B) && (K[j] = B)
                        }), z[N] = void 0, K
                    }
                }
                return V
            };
        return U(v, 0)
    },
    E86 = J8("AsyncFunction"),
    S86 = (v) => v && (eK(v) || P3(v)) && P3(v.then) && P3(v.catch),
    MS = ((v, z) => {
        if (v) return setImmediate;
        return z ? ((U, V) => {
            return a5.addEventListener("message", ({
                source: N,
                data: K
            }) => {
                if (N === a5 && K === U) V.length && V.shift()()
            }, !1), (N) => {
                V.push(N), a5.postMessage(U, "*")
            }
        })(`axios@${Math.random()}`, []) : (U) => setTimeout(U)
    })(typeof setImmediate === "function", P3(a5.postMessage)),
    P86 = typeof queueMicrotask < "u" ? queueMicrotask.bind(a5) : typeof process < "u" && process.nextTick || MS,
    f = {
        isArray: Rv,
        isArrayBuffer: ZS,
        isBuffer: Q36,
        isFormData: z86,
        isArrayBufferView: d36,
        isString: o36,
        isNumber: LS,
        isBoolean: r36,
        isObject: eK,
        isPlainObject: aK,
        isReadableStream: V86,
        isRequest: N86,
        isResponse: K86,
        isHeaders: x86,
        isUndefined: vU,
        isDate: a36,
        isFile: t36,
        isBlob: s36,
        isRegExp: F86,
        isFunction: P3,
        isStream: v86,
        isURLSearchParams: U86,
        isTypedArray: A86,
        isFileList: e36,
        forEach: zU,
        merge: zD,
        extend: B86,
        trim: j86,
        stripBOM: O86,
        inherits: J86,
        toFlatObject: q86,
        kindOf: tK,
        kindOfTest: J8,
        endsWith: H86,
        toArray: D86,
        forEachEntry: $86,
        matchAll: w86,
        isHTMLForm: Z86,
        hasOwnProperty: wS,
        hasOwnProp: wS,
        reduceDescriptors: IS,
        freezeMethods: G86,
        toObjectSet: I86,
        toCamelCase: L86,
        noop: M86,
        toFiniteNumber: b86,
        findKey: FS,
        global: a5,
        isContextDefined: GS,
        isSpecCompliantForm: R86,
        toJSONObject: W86,
        isAsyncFn: E86,
        isThenable: S86,
        setImmediate: MS,
        asap: P86
    };

function Wv(v, z, U, V, N) {
    if (Error.call(this), Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = Error().stack;
    if (this.message = v, this.name = "AxiosError", z && (this.code = z), U && (this.config = U), V && (this.request = V), N) this.response = N, this.status = N.status ? N.status : null
}
f.inherits(Wv, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: f.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
var bS = Wv.prototype,
    RS = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((v) => {
    RS[v] = {
        value: v
    }
});
Object.defineProperties(Wv, RS);
Object.defineProperty(bS, "isAxiosError", {
    value: !0
});
Wv.from = (v, z, U, V, N, K) => {
    let x = Object.create(bS);
    return f.toFlatObject(v, x, function(B) {
        return B !== Error.prototype
    }, (j) => {
        return j !== "isAxiosError"
    }), Wv.call(x, v.message, z, U, V, N), x.cause = v, x.name = v.name, K && Object.assign(x, K), x
};
var B6 = Wv;
var S_ = o(E_(), 1),
    Ox = S_.default;

function RD(v) {
    return f.isPlainObject(v) || f.isArray(v)
}

function __(v) {
    return f.endsWith(v, "[]") ? v.slice(0, -2) : v
}

function P_(v, z, U) {
    if (!v) return z;
    return v.concat(z).map(function(N, K) {
        return N = __(N), !U && K ? "[" + N + "]" : N
    }).join(U ? "." : "")
}

function H56(v) {
    return f.isArray(v) && !v.some(RD)
}
var D56 = f.toFlatObject(f, {}, null, function(z) {
    return /^is[A-Z]/.test(z)
});

function A56(v, z, U) {
    if (!f.isObject(v)) throw TypeError("target must be an object");
    z = z || new(Ox || FormData), U = f.toFlatObject(U, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(w, Z) {
        return !f.isUndefined(Z[w])
    });
    let V = U.metaTokens,
        N = U.visitor || J,
        K = U.dots,
        x = U.indexes,
        B = (U.Blob || typeof Blob < "u" && Blob) && f.isSpecCompliantForm(z);
    if (!f.isFunction(N)) throw TypeError("visitor must be a function");

    function O(A) {
        if (A === null) return "";
        if (f.isDate(A)) return A.toISOString();
        if (!B && f.isBlob(A)) throw new B6("Blob is not supported. Use a Buffer instead.");
        if (f.isArrayBuffer(A) || f.isTypedArray(A)) return B && typeof Blob === "function" ? new Blob([A]) : Buffer.from(A);
        return A
    }

    function J(A, w, Z) {
        let $ = A;
        if (A && !Z && typeof A === "object") {
            if (f.endsWith(w, "{}")) w = V ? w : w.slice(0, -2), A = JSON.stringify(A);
            else if (f.isArray(A) && H56(A) || (f.isFileList(A) || f.endsWith(w, "[]")) && ($ = f.toArray(A))) return w = __(w), $.forEach(function(L, G) {
                !(f.isUndefined(L) || L === null) && z.append(x === !0 ? P_([w], G, K) : x === null ? w : w + "[]", O(L))
            }), !1
        }
        if (RD(A)) return !0;
        return z.append(P_(Z, w, K), O(A)), !1
    }
    let q = [],
        H = Object.assign(D56, {
            defaultVisitor: J,
            convertValue: O,
            isVisitable: RD
        });

    function D(A, w) {
        if (f.isUndefined(A)) return;
        if (q.indexOf(A) !== -1) throw Error("Circular reference detected in " + w.join("."));
        q.push(A), f.forEach(A, function($, F) {
            if ((!(f.isUndefined($) || $ === null) && N.call(z, $, f.isString(F) ? F.trim() : F, w, H)) === !0) D($, w ? w.concat(F) : [F])
        }), q.pop()
    }
    if (!f.isObject(v)) throw TypeError("data must be an object");
    return D(v), z
}
var e9 = A56;

function C_(v) {
    let z = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\x00"
    };
    return encodeURIComponent(v).replace(/[!'()~]|%20|%00/g, function(V) {
        return z[V]
    })
}

function f_(v, z) {
    this._pairs = [], v && e9(v, this, z)
}
var T_ = f_.prototype;
T_.append = function(z, U) {
    this._pairs.push([z, U])
};
T_.toString = function(z) {
    let U = z ? function(V) {
        return z.call(this, V, C_)
    } : C_;
    return this._pairs.map(function(N) {
        return U(N[0]) + "=" + U(N[1])
    }, "").join("&")
};
var Y_ = f_;

function $56(v) {
    return encodeURIComponent(v).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function s5(v, z, U) {
    if (!z) return v;
    let V = U && U.encode || $56;
    if (f.isFunction(U)) U = {
        serialize: U
    };
    let N = U && U.serialize,
        K;
    if (N) K = N(z, U);
    else K = f.isURLSearchParams(z) ? z.toString() : new Y_(z, U).toString(V);
    if (K) {
        let x = v.indexOf("#");
        if (x !== -1) v = v.slice(0, x);
        v += (v.indexOf("?") === -1 ? "?" : "&") + K
    }
    return v
}
class u_ {
    constructor() {
        this.handlers = []
    }
    use(v, z, U) {
        return this.handlers.push({
            fulfilled: v,
            rejected: z,
            synchronous: U ? U.synchronous : !1,
            runWhen: U ? U.runWhen : null
        }), this.handlers.length - 1
    }
    eject(v) {
        if (this.handlers[v]) this.handlers[v] = null
    }
    clear() {
        if (this.handlers) this.handlers = []
    }
    forEach(v) {
        f.forEach(this.handlers, function(U) {
            if (U !== null) v(U)
        })
    }
}
var WD = u_;
var Cv = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
};
var X_ = o(require("crypto"));
var y_ = o(require("url")),
    k_ = y_.default.URLSearchParams;
var ED = "abcdefghijklmnopqrstuvwxyz",
    m_ = "0123456789",
    g_ = {
        DIGIT: m_,
        ALPHA: ED,
        ALPHA_DIGIT: ED + ED.toUpperCase() + m_
    },
    w56 = (v = 16, z = g_.ALPHA_DIGIT) => {
        let U = "",
            {
                length: V
            } = z,
            N = new Uint32Array(v);
        X_.default.randomFillSync(N);
        for (let K = 0; K < v; K++) U += z[N[K] % V];
        return U
    },
    c_ = {
        isNode: !0,
        classes: {
            URLSearchParams: k_,
            FormData: Ox,
            Blob: typeof Blob < "u" && Blob || null
        },
        ALPHABET: g_,
        generateString: w56,
        protocols: ["http", "https", "file", "data"]
    };
var _D = {};
S8(_D, {
    origin: () => F56,
    navigator: () => SD,
    hasStandardBrowserWebWorkerEnv: () => L56,
    hasStandardBrowserEnv: () => Z56,
    hasBrowserEnv: () => PD
});
var PD = typeof window < "u" && typeof document < "u",
    SD = typeof navigator === "object" && navigator || void 0,
    Z56 = PD && (!SD || ["ReactNative", "NativeScript", "NS"].indexOf(SD.product) < 0),
    L56 = (() => {
        return typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function"
    })(),
    F56 = PD && window.location.href || "http://localhost";
var L0 = {
    ..._D,
    ...c_
};

function CD(v, z) {
    return e9(v, new L0.classes.URLSearchParams, Object.assign({
        visitor: function(U, V, N, K) {
            if (L0.isNode && f.isBuffer(U)) return this.append(V, U.toString("base64")), !1;
            return K.defaultVisitor.apply(this, arguments)
        }
    }, z))
}

function G56(v) {
    return f.matchAll(/\w+|\[(\w*)]/g, v).map((z) => {
        return z[0] === "[]" ? "" : z[1] || z[0]
    })
}

function I56(v) {
    let z = {},
        U = Object.keys(v),
        V, N = U.length,
        K;
    for (V = 0; V < N; V++) K = U[V], z[K] = v[K];
    return z
}

function M56(v) {
    function z(U, V, N, K) {
        let x = U[K++];
        if (x === "__proto__") return !0;
        let j = Number.isFinite(+x),
            B = K >= U.length;
        if (x = !x && f.isArray(N) ? N.length : x, B) {
            if (f.hasOwnProp(N, x)) N[x] = [N[x], V];
            else N[x] = V;
            return !j
        }
        if (!N[x] || !f.isObject(N[x])) N[x] = [];
        if (z(U, V, N[x], K) && f.isArray(N[x])) N[x] = I56(N[x]);
        return !j
    }
    if (f.isFormData(v) && f.isFunction(v.entries)) {
        let U = {};
        return f.forEachEntry(v, (V, N) => {
            z(G56(V), N, U, 0)
        }), U
    }
    return null
}
var Jx = M56;

function b56(v, z, U) {
    if (f.isString(v)) try {
        return (z || JSON.parse)(v), f.trim(v)
    } catch (V) {
        if (V.name !== "SyntaxError") throw V
    }
    return (U || JSON.stringify)(v)
}
var fD = {
    transitional: Cv,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(z, U) {
        let V = U.getContentType() || "",
            N = V.indexOf("application/json") > -1,
            K = f.isObject(z);
        if (K && f.isHTMLForm(z)) z = new FormData(z);
        if (f.isFormData(z)) return N ? JSON.stringify(Jx(z)) : z;
        if (f.isArrayBuffer(z) || f.isBuffer(z) || f.isStream(z) || f.isFile(z) || f.isBlob(z) || f.isReadableStream(z)) return z;
        if (f.isArrayBufferView(z)) return z.buffer;
        if (f.isURLSearchParams(z)) return U.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), z.toString();
        let j;
        if (K) {
            if (V.indexOf("application/x-www-form-urlencoded") > -1) return CD(z, this.formSerializer).toString();
            if ((j = f.isFileList(z)) || V.indexOf("multipart/form-data") > -1) {
                let B = this.env && this.env.FormData;
                return e9(j ? {
                    "files[]": z
                } : z, B && new B, this.formSerializer)
            }
        }
        if (K || N) return U.setContentType("application/json", !1), b56(z);
        return z
    }],
    transformResponse: [function(z) {
        let U = this.transitional || fD.transitional,
            V = U && U.forcedJSONParsing,
            N = this.responseType === "json";
        if (f.isResponse(z) || f.isReadableStream(z)) return z;
        if (z && f.isString(z) && (V && !this.responseType || N)) {
            let x = !(U && U.silentJSONParsing) && N;
            try {
                return JSON.parse(z)
            } catch (j) {
                if (x) {
                    if (j.name === "SyntaxError") throw B6.from(j, B6.ERR_BAD_RESPONSE, this, null, this.response);
                    throw j
                }
            }
        }
        return z
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: L0.classes.FormData,
        Blob: L0.classes.Blob
    },
    validateStatus: function(z) {
        return z >= 200 && z < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
f.forEach(["delete", "get", "head", "post", "put", "patch"], (v) => {
    fD.headers[v] = {}
});
var fv = fD;
var R56 = f.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    i_ = (v) => {
        let z = {},
            U, V, N;
        return v && v.split(`
`).forEach(function(x) {
            if (N = x.indexOf(":"), U = x.substring(0, N).trim().toLowerCase(), V = x.substring(N + 1).trim(), !U || z[U] && R56[U]) return;
            if (U === "set-cookie")
                if (z[U]) z[U].push(V);
                else z[U] = [V];
            else z[U] = z[U] ? z[U] + ", " + V : V
        }), z
    };
var l_ = Symbol("internals");

function xU(v) {
    return v && String(v).trim().toLowerCase()
}

function qx(v) {
    if (v === !1 || v == null) return v;
    return f.isArray(v) ? v.map(qx) : String(v)
}

function W56(v) {
    let z = Object.create(null),
        U = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g,
        V;
    while (V = U.exec(v)) z[V[1]] = V[2];
    return z
}
var E56 = (v) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(v.trim());

function TD(v, z, U, V, N) {
    if (f.isFunction(V)) return V.call(this, z, U);
    if (N) z = U;
    if (!f.isString(z)) return;
    if (f.isString(V)) return z.indexOf(V) !== -1;
    if (f.isRegExp(V)) return V.test(z)
}

function S56(v) {
    return v.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (z, U, V) => {
        return U.toUpperCase() + V
    })
}

function P56(v, z) {
    let U = f.toCamelCase(" " + z);
    ["get", "set", "has"].forEach((V) => {
        Object.defineProperty(v, V + U, {
            value: function(N, K, x) {
                return this[V].call(this, z, N, K, x)
            },
            configurable: !0
        })
    })
}
class jU {
    constructor(v) {
        v && this.set(v)
    }
    set(v, z, U) {
        let V = this;

        function N(x, j, B) {
            let O = xU(j);
            if (!O) throw Error("header name must be a non-empty string");
            let J = f.findKey(V, O);
            if (!J || V[J] === void 0 || B === !0 || B === void 0 && V[J] !== !1) V[J || j] = qx(x)
        }
        let K = (x, j) => f.forEach(x, (B, O) => N(B, O, j));
        if (f.isPlainObject(v) || v instanceof this.constructor) K(v, z);
        else if (f.isString(v) && (v = v.trim()) && !E56(v)) K(i_(v), z);
        else if (f.isHeaders(v))
            for (let [x, j] of v.entries()) N(j, x, U);
        else v != null && N(z, v, U);
        return this
    }
    get(v, z) {
        if (v = xU(v), v) {
            let U = f.findKey(this, v);
            if (U) {
                let V = this[U];
                if (!z) return V;
                if (z === !0) return W56(V);
                if (f.isFunction(z)) return z.call(this, V, U);
                if (f.isRegExp(z)) return z.exec(V);
                throw TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(v, z) {
        if (v = xU(v), v) {
            let U = f.findKey(this, v);
            return !!(U && this[U] !== void 0 && (!z || TD(this, this[U], U, z)))
        }
        return !1
    }
    delete(v, z) {
        let U = this,
            V = !1;

        function N(K) {
            if (K = xU(K), K) {
                let x = f.findKey(U, K);
                if (x && (!z || TD(U, U[x], x, z))) delete U[x], V = !0
            }
        }
        if (f.isArray(v)) v.forEach(N);
        else N(v);
        return V
    }
    clear(v) {
        let z = Object.keys(this),
            U = z.length,
            V = !1;
        while (U--) {
            let N = z[U];
            if (!v || TD(this, this[N], N, v, !0)) delete this[N], V = !0
        }
        return V
    }
    normalize(v) {
        let z = this,
            U = {};
        return f.forEach(this, (V, N) => {
            let K = f.findKey(U, N);
            if (K) {
                z[K] = qx(V), delete z[N];
                return
            }
            let x = v ? S56(N) : String(N).trim();
            if (x !== N) delete z[N];
            z[x] = qx(V), U[x] = !0
        }), this
    }
    concat(...v) {
        return this.constructor.concat(this, ...v)
    }
    toJSON(v) {
        let z = Object.create(null);
        return f.forEach(this, (U, V) => {
            U != null && U !== !1 && (z[V] = v && f.isArray(U) ? U.join(", ") : U)
        }), z
    } [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([v, z]) => v + ": " + z).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(v) {
        return v instanceof this ? v : new this(v)
    }
    static concat(v, ...z) {
        let U = new this(v);
        return z.forEach((V) => U.set(V)), U
    }
    static accessor(v) {
        let U = (this[l_] = this[l_] = {
                accessors: {}
            }).accessors,
            V = this.prototype;

        function N(K) {
            let x = xU(K);
            if (!U[x]) P56(V, K), U[x] = !0
        }
        return f.isArray(v) ? v.forEach(N) : N(v), this
    }
}
jU.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
f.reduceDescriptors(jU.prototype, ({
    value: v
}, z) => {
    let U = z[0].toUpperCase() + z.slice(1);
    return {
        get: () => v,
        set(V) {
            this[U] = V
        }
    }
});
f.freezeMethods(jU);
var r0 = jU;

function BU(v, z) {
    let U = this || fv,
        V = z || U,
        N = r0.from(V.headers),
        K = V.data;
    return f.forEach(v, function(j) {
        K = j.call(U, K, N.normalize(), z ? z.status : void 0)
    }), N.normalize(), K
}

function OU(v) {
    return !!(v && v.__CANCEL__)
}

function h_(v, z, U) {
    B6.call(this, v == null ? "canceled" : v, B6.ERR_CANCELED, z, U), this.name = "CanceledError"
}
f.inherits(h_, B6, {
    __CANCEL__: !0
});
var _3 = h_;

function m8(v, z, U) {
    let V = U.config.validateStatus;
    if (!U.status || !V || V(U.status)) v(U);
    else z(new B6("Request failed with status code " + U.status, [B6.ERR_BAD_REQUEST, B6.ERR_BAD_RESPONSE][Math.floor(U.status / 100) - 4], U.config, U.request, U))
}

function YD(v) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(v)
}

function uD(v, z) {
    return z ? v.replace(/\/?\/$/, "") + "/" + z.replace(/^\/+/, "") : v
}

function e5(v, z, U) {
    let V = !YD(z);
    if (v && (V || U == !1)) return uD(v, z);
    return z
}
var _C = o(n_(), 1),
    CC = o(require("http")),
    fC = o(require("https")),
    TC = o(require("util")),
    YC = o(JC(), 1),
    H9 = o(require("zlib"));
var V7 = "1.8.4";

function AU(v) {
    let z = /^([-+\w]{1,25})(:?\/\/|:)/.exec(v);
    return z && z[1] || ""
}
var $76 = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

function aD(v, z, U) {
    let V = U && U.Blob || L0.classes.Blob,
        N = AU(v);
    if (z === void 0 && V) z = !0;
    if (N === "data") {
        v = N.length ? v.slice(N.length + 1) : v;
        let K = $76.exec(v);
        if (!K) throw new B6("Invalid URL", B6.ERR_INVALID_URL);
        let x = K[1],
            j = K[2],
            B = K[3],
            O = Buffer.from(decodeURIComponent(B), j ? "base64" : "utf8");
        if (z) {
            if (!V) throw new B6("Blob is not supported", B6.ERR_NOT_SUPPORT);
            return new V([O], {
                type: x
            })
        }
        return O
    }
    throw new B6("Unsupported protocol " + N, B6.ERR_NOT_SUPPORT)
}
var N7 = o(require("stream"));
var qC = o(require("stream"));
var tD = Symbol("internals");
class HC extends qC.default.Transform {
    constructor(v) {
        v = f.toFlatObject(v, {
            maxRate: 0,
            chunkSize: 65536,
            minChunkSize: 100,
            timeWindow: 500,
            ticksRate: 2,
            samplesCount: 15
        }, null, (U, V) => {
            return !f.isUndefined(V[U])
        });
        super({
            readableHighWaterMark: v.chunkSize
        });
        let z = this[tD] = {
            timeWindow: v.timeWindow,
            chunkSize: v.chunkSize,
            maxRate: v.maxRate,
            minChunkSize: v.minChunkSize,
            bytesSeen: 0,
            isCaptured: !1,
            notifiedBytesLoaded: 0,
            ts: Date.now(),
            bytes: 0,
            onReadCallback: null
        };
        this.on("newListener", (U) => {
            if (U === "progress") {
                if (!z.isCaptured) z.isCaptured = !0
            }
        })
    }
    _read(v) {
        let z = this[tD];
        if (z.onReadCallback) z.onReadCallback();
        return super._read(v)
    }
    _transform(v, z, U) {
        let V = this[tD],
            N = V.maxRate,
            K = this.readableHighWaterMark,
            x = V.timeWindow,
            j = 1000 / x,
            B = N / j,
            O = V.minChunkSize !== !1 ? Math.max(V.minChunkSize, B * 0.01) : 0,
            J = (H, D) => {
                let A = Buffer.byteLength(H);
                if (V.bytesSeen += A, V.bytes += A, V.isCaptured && this.emit("progress", V.bytesSeen), this.push(H)) process.nextTick(D);
                else V.onReadCallback = () => {
                    V.onReadCallback = null, process.nextTick(D)
                }
            },
            q = (H, D) => {
                let A = Buffer.byteLength(H),
                    w = null,
                    Z = K,
                    $, F = 0;
                if (N) {
                    let L = Date.now();
                    if (!V.ts || (F = L - V.ts) >= x) V.ts = L, $ = B - V.bytes, V.bytes = $ < 0 ? -$ : 0, F = 0;
                    $ = B - V.bytes
                }
                if (N) {
                    if ($ <= 0) return setTimeout(() => {
                        D(null, H)
                    }, x - F);
                    if ($ < Z) Z = $
                }
                if (Z && A > Z && A - Z > O) w = H.subarray(Z), H = H.subarray(0, Z);
                J(H, w ? () => {
                    process.nextTick(D, null, w)
                } : D)
            };
        q(v, function H(D, A) {
            if (D) return U(D);
            if (A) q(A, H);
            else U(null)
        })
    }
}
var sD = HC;
var uC = require("events");
var AC = o(require("util")),
    $C = require("stream");
var {
    asyncIterator: DC
} = Symbol, w76 = async function*(v) {
    if (v.stream) yield* v.stream();
    else if (v.arrayBuffer) yield await v.arrayBuffer();
    else if (v[DC]) yield* v[DC]();
    else yield v
}, Zx = w76;
var Z76 = L0.ALPHABET.ALPHA_DIGIT + "-_",
    $U = typeof TextEncoder === "function" ? new TextEncoder : new AC.default.TextEncoder,
    v5 = `\r
`,
    L76 = $U.encode(v5),
    F76 = 2;
class wC {
    constructor(v, z) {
        let {
            escapeName: U
        } = this.constructor, V = f.isString(z), N = `Content-Disposition: form-data; name="${U(v)}"${!V&&z.name?`; filename="${U(z.name)}"`:""}${v5}`;
        if (V) z = $U.encode(String(z).replace(/\r?\n|\r\n?/g, v5));
        else N += `Content-Type: ${z.type||"application/octet-stream"}${v5}`;
        this.headers = $U.encode(N + v5), this.contentLength = V ? z.byteLength : z.size, this.size = this.headers.byteLength + this.contentLength + F76, this.name = v, this.value = z
    }
    async * encode() {
        yield this.headers;
        let {
            value: v
        } = this;
        if (f.isTypedArray(v)) yield v;
        else yield* Zx(v);
        yield L76
    }
    static escapeName(v) {
        return String(v).replace(/[\r\n"]/g, (z) => ({
            "\r": "%0D",
            "\n": "%0A",
            '"': "%22"
        })[z])
    }
}
var G76 = (v, z, U) => {
        let {
            tag: V = "form-data-boundary",
            size: N = 25,
            boundary: K = V + "-" + L0.generateString(N, Z76)
        } = U || {};
        if (!f.isFormData(v)) throw TypeError("FormData instance required");
        if (K.length < 1 || K.length > 70) throw Error("boundary must be 10-70 characters long");
        let x = $U.encode("--" + K + v5),
            j = $U.encode("--" + K + "--" + v5 + v5),
            B = j.byteLength,
            O = Array.from(v.entries()).map(([q, H]) => {
                let D = new wC(q, H);
                return B += D.size, D
            });
        B += x.byteLength * O.length, B = f.toFiniteNumber(B);
        let J = {
            "Content-Type": `multipart/form-data; boundary=${K}`
        };
        if (Number.isFinite(B)) J["Content-Length"] = B;
        return z && z(J), $C.Readable.from(async function*() {
            for (let q of O) yield x, yield* q.encode();
            yield j
        }())
    },
    ZC = G76;
var LC = o(require("stream"));
class FC extends LC.default.Transform {
    __transform(v, z, U) {
        this.push(v), U()
    }
    _transform(v, z, U) {
        if (v.length !== 0) {
            if (this._transform = this.__transform, v[0] !== 120) {
                let V = Buffer.alloc(2);
                V[0] = 120, V[1] = 156, this.push(V, z)
            }
        }
        this.__transform(v, z, U)
    }
}
var GC = FC;
var I76 = (v, z) => {
        return f.isAsyncFn(v) ? function(...U) {
            let V = U.pop();
            v.apply(this, U).then((N) => {
                try {
                    z ? V(null, ...z(N)) : V(null, N)
                } catch (K) {
                    V(K)
                }
            }, V)
        } : v
    },
    IC = I76;

function M76(v, z) {
    v = v || 10;
    let U = Array(v),
        V = Array(v),
        N = 0,
        K = 0,
        x;
    return z = z !== void 0 ? z : 1000,
        function(B) {
            let O = Date.now(),
                J = V[K];
            if (!x) x = O;
            U[N] = B, V[N] = O;
            let q = K,
                H = 0;
            while (q !== N) H += U[q++], q = q % v;
            if (N = (N + 1) % v, N === K) K = (K + 1) % v;
            if (O - x < z) return;
            let D = J && O - J;
            return D ? Math.round(H * 1000 / D) : void 0
        }
}
var MC = M76;

function b76(v, z) {
    let U = 0,
        V = 1000 / z,
        N, K, x = (O, J = Date.now()) => {
            if (U = J, N = null, K) clearTimeout(K), K = null;
            v.apply(null, O)
        };
    return [(...O) => {
        let J = Date.now(),
            q = J - U;
        if (q >= V) x(O, J);
        else if (N = O, !K) K = setTimeout(() => {
            K = null, x(N)
        }, V - q)
    }, () => N && x(N)]
}
var bC = b76;
var q9 = (v, z, U = 3) => {
        let V = 0,
            N = MC(50, 250);
        return bC((K) => {
            let x = K.loaded,
                j = K.lengthComputable ? K.total : void 0,
                B = x - V,
                O = N(B),
                J = x <= j;
            V = x;
            let q = {
                loaded: x,
                total: j,
                progress: j ? x / j : void 0,
                bytes: B,
                rate: O ? O : void 0,
                estimated: O && j && J ? (j - x) / O : void 0,
                event: K,
                lengthComputable: j != null,
                [z ? "download" : "upload"]: !0
            };
            v(q)
        }, U)
    },
    kv = (v, z) => {
        let U = v != null;
        return [(V) => z[0]({
            lengthComputable: U,
            total: v,
            loaded: V
        }), z[1]]
    },
    mv = (v) => (...z) => f.asap(() => v(...z));
var RC = {
        flush: H9.default.constants.Z_SYNC_FLUSH,
        finishFlush: H9.default.constants.Z_SYNC_FLUSH
    },
    R76 = {
        flush: H9.default.constants.BROTLI_OPERATION_FLUSH,
        finishFlush: H9.default.constants.BROTLI_OPERATION_FLUSH
    },
    WC = f.isFunction(H9.default.createBrotliDecompress),
    {
        http: W76,
        https: E76
    } = YC.default,
    S76 = /https:?/,
    EC = L0.protocols.map((v) => {
        return v + ":"
    }),
    SC = (v, [z, U]) => {
        return v.on("end", U).on("error", U), z
    };

function P76(v, z) {
    if (v.beforeRedirects.proxy) v.beforeRedirects.proxy(v);
    if (v.beforeRedirects.config) v.beforeRedirects.config(v, z)
}

function yC(v, z, U) {
    let V = z;
    if (!V && V !== !1) {
        let N = _C.default.getProxyForUrl(U);
        if (N) V = new URL(N)
    }
    if (V) {
        if (V.username) V.auth = (V.username || "") + ":" + (V.password || "");
        if (V.auth) {
            if (V.auth.username || V.auth.password) V.auth = (V.auth.username || "") + ":" + (V.auth.password || "");
            let K = Buffer.from(V.auth, "utf8").toString("base64");
            v.headers["Proxy-Authorization"] = "Basic " + K
        }
        v.headers.host = v.hostname + (v.port ? ":" + v.port : "");
        let N = V.hostname || V.host;
        if (v.hostname = N, v.host = N, v.port = V.port, v.path = U, V.protocol) v.protocol = V.protocol.includes(":") ? V.protocol : `${V.protocol}:`
    }
    v.beforeRedirects.proxy = function(K) {
        yC(K, z, K.href)
    }
}
var _76 = typeof process < "u" && f.kindOf(process) === "process",
    C76 = (v) => {
        return new Promise((z, U) => {
            let V, N, K = (B, O) => {
                    if (N) return;
                    N = !0, V && V(B, O)
                },
                x = (B) => {
                    K(B), z(B)
                },
                j = (B) => {
                    K(B, !0), U(B)
                };
            v(x, j, (B) => V = B).catch(j)
        })
    },
    f76 = ({
        address: v,
        family: z
    }) => {
        if (!f.isString(v)) throw TypeError("address must be a string");
        return {
            address: v,
            family: z || (v.indexOf(".") < 0 ? 6 : 4)
        }
    },
    PC = (v, z) => f76(f.isObject(v) ? v : {
        address: v,
        family: z
    }),
    kC = _76 && function(z) {
        return C76(async function(V, N, K) {
            let {
                data: x,
                lookup: j,
                family: B
            } = z, {
                responseType: O,
                responseEncoding: J
            } = z, q = z.method.toUpperCase(), H, D = !1, A;
            if (j) {
                let q6 = IC(j, (Z6) => f.isArray(Z6) ? Z6 : [Z6]);
                j = (Z6, T6, C) => {
                    q6(Z6, T6, (u, p, R) => {
                        if (u) return C(u);
                        let S = f.isArray(p) ? p.map((k) => PC(k)) : [PC(p, R)];
                        T6.all ? C(u, S) : C(u, S[0].address, S[0].family)
                    })
                }
            }
            let w = new uC.EventEmitter,
                Z = () => {
                    if (z.cancelToken) z.cancelToken.unsubscribe($);
                    if (z.signal) z.signal.removeEventListener("abort", $);
                    w.removeAllListeners()
                };
            K((q6, Z6) => {
                if (H = !0, Z6) D = !0, Z()
            });

            function $(q6) {
                w.emit("abort", !q6 || q6.type ? new _3(null, z, A) : q6)
            }
            if (w.once("abort", N), z.cancelToken || z.signal) {
                if (z.cancelToken && z.cancelToken.subscribe($), z.signal) z.signal.aborted ? $() : z.signal.addEventListener("abort", $)
            }
            let F = e5(z.baseURL, z.url, z.allowAbsoluteUrls),
                L = new URL(F, L0.hasBrowserEnv ? L0.origin : void 0),
                G = L.protocol || EC[0];
            if (G === "data:") {
                let q6;
                if (q !== "GET") return m8(V, N, {
                    status: 405,
                    statusText: "method not allowed",
                    headers: {},
                    config: z
                });
                try {
                    q6 = aD(z.url, O === "blob", {
                        Blob: z.env && z.env.Blob
                    })
                } catch (Z6) {
                    throw B6.from(Z6, B6.ERR_BAD_REQUEST, z)
                }
                if (O === "text") {
                    if (q6 = q6.toString(J), !J || J === "utf8") q6 = f.stripBOM(q6)
                } else if (O === "stream") q6 = N7.default.Readable.from(q6);
                return m8(V, N, {
                    data: q6,
                    status: 200,
                    statusText: "OK",
                    headers: new r0,
                    config: z
                })
            }
            if (EC.indexOf(G) === -1) return N(new B6("Unsupported protocol " + G, B6.ERR_BAD_REQUEST, z));
            let I = r0.from(z.headers).normalize();
            I.set("User-Agent", "axios/" + V7, !1);
            let {
                onUploadProgress: M,
                onDownloadProgress: b
            } = z, W = z.maxRate, E = void 0, y = void 0;
            if (f.isSpecCompliantForm(x)) {
                let q6 = I.getContentType(/boundary=([-_\w\d]{10,70})/i);
                x = ZC(x, (Z6) => {
                    I.set(Z6)
                }, {
                    tag: `axios-${V7}-boundary`,
                    boundary: q6 && q6[1] || void 0
                })
            } else if (f.isFormData(x) && f.isFunction(x.getHeaders)) {
                if (I.set(x.getHeaders()), !I.hasContentLength()) try {
                    let q6 = await TC.default.promisify(x.getLength).call(x);
                    Number.isFinite(q6) && q6 >= 0 && I.setContentLength(q6)
                } catch (q6) {}
            } else if (f.isBlob(x) || f.isFile(x)) x.size && I.setContentType(x.type || "application/octet-stream"), I.setContentLength(x.size || 0), x = N7.default.Readable.from(Zx(x));
            else if (x && !f.isStream(x)) {
                if (Buffer.isBuffer(x));
                else if (f.isArrayBuffer(x)) x = Buffer.from(new Uint8Array(x));
                else if (f.isString(x)) x = Buffer.from(x, "utf-8");
                else return N(new B6("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", B6.ERR_BAD_REQUEST, z));
                if (I.setContentLength(x.length, !1), z.maxBodyLength > -1 && x.length > z.maxBodyLength) return N(new B6("Request body larger than maxBodyLength limit", B6.ERR_BAD_REQUEST, z))
            }
            let T = f.toFiniteNumber(I.getContentLength());
            if (f.isArray(W)) E = W[0], y = W[1];
            else E = y = W;
            if (x && (M || E)) {
                if (!f.isStream(x)) x = N7.default.Readable.from(x, {
                    objectMode: !1
                });
                x = N7.default.pipeline([x, new sD({
                    maxRate: f.toFiniteNumber(E)
                })], f.noop), M && x.on("progress", SC(x, kv(T, q9(mv(M), !1, 3))))
            }
            let X = void 0;
            if (z.auth) {
                let q6 = z.auth.username || "",
                    Z6 = z.auth.password || "";
                X = q6 + ":" + Z6
            }
            if (!X && L.username) {
                let {
                    username: q6,
                    password: Z6
                } = L;
                X = q6 + ":" + Z6
            }
            X && I.delete("authorization");
            let Q;
            try {
                Q = s5(L.pathname + L.search, z.params, z.paramsSerializer).replace(/^\?/, "")
            } catch (q6) {
                let Z6 = Error(q6.message);
                return Z6.config = z, Z6.url = z.url, Z6.exists = !0, N(Z6)
            }
            I.set("Accept-Encoding", "gzip, compress, deflate" + (WC ? ", br" : ""), !1);
            let m = {
                path: Q,
                method: q,
                headers: I.toJSON(),
                agents: {
                    http: z.httpAgent,
                    https: z.httpsAgent
                },
                auth: X,
                protocol: G,
                family: B,
                beforeRedirect: P76,
                beforeRedirects: {}
            };
            if (!f.isUndefined(j) && (m.lookup = j), z.socketPath) m.socketPath = z.socketPath;
            else m.hostname = L.hostname.startsWith("[") ? L.hostname.slice(1, -1) : L.hostname, m.port = L.port, yC(m, z.proxy, G + "//" + L.hostname + (L.port ? ":" + L.port : "") + m.path);
            let P6, F6 = S76.test(m.protocol);
            if (m.agent = F6 ? z.httpsAgent : z.httpAgent, z.transport) P6 = z.transport;
            else if (z.maxRedirects === 0) P6 = F6 ? fC.default : CC.default;
            else {
                if (z.maxRedirects) m.maxRedirects = z.maxRedirects;
                if (z.beforeRedirect) m.beforeRedirects.config = z.beforeRedirect;
                P6 = F6 ? E76 : W76
            }
            if (z.maxBodyLength > -1) m.maxBodyLength = z.maxBodyLength;
            else m.maxBodyLength = 1 / 0;
            if (z.insecureHTTPParser) m.insecureHTTPParser = z.insecureHTTPParser;
            if (A = P6.request(m, function(Z6) {
                    if (A.destroyed) return;
                    let T6 = [Z6],
                        C = +Z6.headers["content-length"];
                    if (b || y) {
                        let k = new sD({
                            maxRate: f.toFiniteNumber(y)
                        });
                        b && k.on("progress", SC(k, kv(C, q9(mv(b), !0, 3)))), T6.push(k)
                    }
                    let u = Z6,
                        p = Z6.req || A;
                    if (z.decompress !== !1 && Z6.headers["content-encoding"]) {
                        if (q === "HEAD" || Z6.statusCode === 204) delete Z6.headers["content-encoding"];
                        switch ((Z6.headers["content-encoding"] || "").toLowerCase()) {
                            case "gzip":
                            case "x-gzip":
                            case "compress":
                            case "x-compress":
                                T6.push(H9.default.createUnzip(RC)), delete Z6.headers["content-encoding"];
                                break;
                            case "deflate":
                                T6.push(new GC), T6.push(H9.default.createUnzip(RC)), delete Z6.headers["content-encoding"];
                                break;
                            case "br":
                                if (WC) T6.push(H9.default.createBrotliDecompress(R76)), delete Z6.headers["content-encoding"]
                        }
                    }
                    u = T6.length > 1 ? N7.default.pipeline(T6, f.noop) : T6[0];
                    let R = N7.default.finished(u, () => {
                            R(), Z()
                        }),
                        S = {
                            status: Z6.statusCode,
                            statusText: Z6.statusMessage,
                            headers: new r0(Z6.headers),
                            config: z,
                            request: p
                        };
                    if (O === "stream") S.data = u, m8(V, N, S);
                    else {
                        let k = [],
                            D6 = 0;
                        u.on("data", function(Y6) {
                            if (k.push(Y6), D6 += Y6.length, z.maxContentLength > -1 && D6 > z.maxContentLength) D = !0, u.destroy(), N(new B6("maxContentLength size of " + z.maxContentLength + " exceeded", B6.ERR_BAD_RESPONSE, z, p))
                        }), u.on("aborted", function() {
                            if (D) return;
                            let Y6 = new B6("stream has been aborted", B6.ERR_BAD_RESPONSE, z, p);
                            u.destroy(Y6), N(Y6)
                        }), u.on("error", function(Y6) {
                            if (A.destroyed) return;
                            N(B6.from(Y6, null, z, p))
                        }), u.on("end", function() {
                            try {
                                let Y6 = k.length === 1 ? k[0] : Buffer.concat(k);
                                if (O !== "arraybuffer") {
                                    if (Y6 = Y6.toString(J), !J || J === "utf8") Y6 = f.stripBOM(Y6)
                                }
                                S.data = Y6
                            } catch (Y6) {
                                return N(B6.from(Y6, null, z, S.request, S))
                            }
                            m8(V, N, S)
                        })
                    }
                    w.once("abort", (k) => {
                        if (!u.destroyed) u.emit("error", k), u.destroy()
                    })
                }), w.once("abort", (q6) => {
                    N(q6), A.destroy(q6)
                }), A.on("error", function(Z6) {
                    N(B6.from(Z6, null, z, A))
                }), A.on("socket", function(Z6) {
                    Z6.setKeepAlive(!0, 60000)
                }), z.timeout) {
                let q6 = parseInt(z.timeout, 10);
                if (Number.isNaN(q6)) {
                    N(new B6("error trying to parse `config.timeout` to int", B6.ERR_BAD_OPTION_VALUE, z, A));
                    return
                }
                A.setTimeout(q6, function() {
                    if (H) return;
                    let T6 = z.timeout ? "timeout of " + z.timeout + "ms exceeded" : "timeout exceeded",
                        C = z.transitional || Cv;
                    if (z.timeoutErrorMessage) T6 = z.timeoutErrorMessage;
                    N(new B6(T6, C.clarifyTimeoutError ? B6.ETIMEDOUT : B6.ECONNABORTED, z, A)), $()
                })
            }
            if (f.isStream(x)) {
                let q6 = !1,
                    Z6 = !1;
                x.on("end", () => {
                    q6 = !0
                }), x.once("error", (T6) => {
                    Z6 = !0, A.destroy(T6)
                }), x.on("close", () => {
                    if (!q6 && !Z6) $(new _3("Request stream has been aborted", z, A))
                }), x.pipe(A)
            } else A.end(x)
        })
    };
var mC = L0.hasStandardBrowserEnv ? ((v, z) => (U) => {
    return U = new URL(U, L0.origin), v.protocol === U.protocol && v.host === U.host && (z || v.port === U.port)
})(new URL(L0.origin), L0.navigator && /(msie|trident)/i.test(L0.navigator.userAgent)) : () => !0;
var XC = L0.hasStandardBrowserEnv ? {
    write(v, z, U, V, N, K) {
        let x = [v + "=" + encodeURIComponent(z)];
        f.isNumber(U) && x.push("expires=" + new Date(U).toGMTString()), f.isString(V) && x.push("path=" + V), f.isString(N) && x.push("domain=" + N), K === !0 && x.push("secure"), document.cookie = x.join("; ")
    },
    read(v) {
        let z = document.cookie.match(new RegExp("(^|;\\s*)(" + v + ")=([^;]*)"));
        return z ? decodeURIComponent(z[3]) : null
    },
    remove(v) {
        this.write(v, "", Date.now() - 86400000)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
var gC = (v) => v instanceof r0 ? {
    ...v
} : v;

function H8(v, z) {
    z = z || {};
    let U = {};

    function V(O, J, q, H) {
        if (f.isPlainObject(O) && f.isPlainObject(J)) return f.merge.call({
            caseless: H
        }, O, J);
        else if (f.isPlainObject(J)) return f.merge({}, J);
        else if (f.isArray(J)) return J.slice();
        return J
    }

    function N(O, J, q, H) {
        if (!f.isUndefined(J)) return V(O, J, q, H);
        else if (!f.isUndefined(O)) return V(void 0, O, q, H)
    }

    function K(O, J) {
        if (!f.isUndefined(J)) return V(void 0, J)
    }

    function x(O, J) {
        if (!f.isUndefined(J)) return V(void 0, J);
        else if (!f.isUndefined(O)) return V(void 0, O)
    }

    function j(O, J, q) {
        if (q in z) return V(O, J);
        else if (q in v) return V(void 0, O)
    }
    let B = {
        url: K,
        method: K,
        data: K,
        baseURL: x,
        transformRequest: x,
        transformResponse: x,
        paramsSerializer: x,
        timeout: x,
        timeoutMessage: x,
        withCredentials: x,
        withXSRFToken: x,
        adapter: x,
        responseType: x,
        xsrfCookieName: x,
        xsrfHeaderName: x,
        onUploadProgress: x,
        onDownloadProgress: x,
        decompress: x,
        maxContentLength: x,
        maxBodyLength: x,
        beforeRedirect: x,
        transport: x,
        httpAgent: x,
        httpsAgent: x,
        cancelToken: x,
        socketPath: x,
        responseEncoding: x,
        validateStatus: j,
        headers: (O, J, q) => N(gC(O), gC(J), q, !0)
    };
    return f.forEach(Object.keys(Object.assign({}, v, z)), function(J) {
        let q = B[J] || N,
            H = q(v[J], z[J], J);
        f.isUndefined(H) && q !== j || (U[J] = H)
    }), U
}
var Lx = (v) => {
    let z = H8({}, v),
        {
            data: U,
            withXSRFToken: V,
            xsrfHeaderName: N,
            xsrfCookieName: K,
            headers: x,
            auth: j
        } = z;
    if (z.headers = x = r0.from(x), z.url = s5(e5(z.baseURL, z.url, z.allowAbsoluteUrls), v.params, v.paramsSerializer), j) x.set("Authorization", "Basic " + btoa((j.username || "") + ":" + (j.password ? unescape(encodeURIComponent(j.password)) : "")));
    let B;
    if (f.isFormData(U)) {
        if (L0.hasStandardBrowserEnv || L0.hasStandardBrowserWebWorkerEnv) x.setContentType(void 0);
        else if ((B = x.getContentType()) !== !1) {
            let [O, ...J] = B ? B.split(";").map((q) => q.trim()).filter(Boolean) : [];
            x.setContentType([O || "multipart/form-data", ...J].join("; "))
        }
    }
    if (L0.hasStandardBrowserEnv) {
        if (V && f.isFunction(V) && (V = V(z)), V || V !== !1 && mC(z.url)) {
            let O = N && K && XC.read(K);
            if (O) x.set(N, O)
        }
    }
    return z
};
var T76 = typeof XMLHttpRequest < "u",
    cC = T76 && function(v) {
        return new Promise(function(U, V) {
            let N = Lx(v),
                K = N.data,
                x = r0.from(N.headers).normalize(),
                {
                    responseType: j,
                    onUploadProgress: B,
                    onDownloadProgress: O
                } = N,
                J, q, H, D, A;

            function w() {
                D && D(), A && A(), N.cancelToken && N.cancelToken.unsubscribe(J), N.signal && N.signal.removeEventListener("abort", J)
            }
            let Z = new XMLHttpRequest;
            Z.open(N.method.toUpperCase(), N.url, !0), Z.timeout = N.timeout;

            function $() {
                if (!Z) return;
                let L = r0.from("getAllResponseHeaders" in Z && Z.getAllResponseHeaders()),
                    I = {
                        data: !j || j === "text" || j === "json" ? Z.responseText : Z.response,
                        status: Z.status,
                        statusText: Z.statusText,
                        headers: L,
                        config: v,
                        request: Z
                    };
                m8(function(b) {
                    U(b), w()
                }, function(b) {
                    V(b), w()
                }, I), Z = null
            }
            if ("onloadend" in Z) Z.onloadend = $;
            else Z.onreadystatechange = function() {
                if (!Z || Z.readyState !== 4) return;
                if (Z.status === 0 && !(Z.responseURL && Z.responseURL.indexOf("file:") === 0)) return;
                setTimeout($)
            };
            if (Z.onabort = function() {
                    if (!Z) return;
                    V(new B6("Request aborted", B6.ECONNABORTED, v, Z)), Z = null
                }, Z.onerror = function() {
                    V(new B6("Network Error", B6.ERR_NETWORK, v, Z)), Z = null
                }, Z.ontimeout = function() {
                    let G = N.timeout ? "timeout of " + N.timeout + "ms exceeded" : "timeout exceeded",
                        I = N.transitional || Cv;
                    if (N.timeoutErrorMessage) G = N.timeoutErrorMessage;
                    V(new B6(G, I.clarifyTimeoutError ? B6.ETIMEDOUT : B6.ECONNABORTED, v, Z)), Z = null
                }, K === void 0 && x.setContentType(null), "setRequestHeader" in Z) f.forEach(x.toJSON(), function(G, I) {
                Z.setRequestHeader(I, G)
            });
            if (!f.isUndefined(N.withCredentials)) Z.withCredentials = !!N.withCredentials;
            if (j && j !== "json") Z.responseType = N.responseType;
            if (O)[H, A] = q9(O, !0), Z.addEventListener("progress", H);
            if (B && Z.upload)[q, D] = q9(B), Z.upload.addEventListener("progress", q), Z.upload.addEventListener("loadend", D);
            if (N.cancelToken || N.signal) {
                if (J = (L) => {
                        if (!Z) return;
                        V(!L || L.type ? new _3(null, v, Z) : L), Z.abort(), Z = null
                    }, N.cancelToken && N.cancelToken.subscribe(J), N.signal) N.signal.aborted ? J() : N.signal.addEventListener("abort", J)
            }
            let F = AU(N.url);
            if (F && L0.protocols.indexOf(F) === -1) {
                V(new B6("Unsupported protocol " + F + ":", B6.ERR_BAD_REQUEST, v));
                return
            }
            Z.send(K || null)
        })
    };
var Y76 = (v, z) => {
        let {
            length: U
        } = v = v ? v.filter(Boolean) : [];
        if (z || U) {
            let V = new AbortController,
                N, K = function(O) {
                    if (!N) {
                        N = !0, j();
                        let J = O instanceof Error ? O : this.reason;
                        V.abort(J instanceof B6 ? J : new _3(J instanceof Error ? J.message : J))
                    }
                },
                x = z && setTimeout(() => {
                    x = null, K(new B6(`timeout ${z} of ms exceeded`, B6.ETIMEDOUT))
                }, z),
                j = () => {
                    if (v) x && clearTimeout(x), x = null, v.forEach((O) => {
                        O.unsubscribe ? O.unsubscribe(K) : O.removeEventListener("abort", K)
                    }), v = null
                };
            v.forEach((O) => O.addEventListener("abort", K));
            let {
                signal: B
            } = V;
            return B.unsubscribe = () => f.asap(j), B
        }
    },
    iC = Y76;
var u76 = function*(v, z) {
        let U = v.byteLength;
        if (!z || U < z) {
            yield v;
            return
        }
        let V = 0,
            N;
        while (V < U) N = V + z, yield v.slice(V, N), V = N
    },
    y76 = async function*(v, z) {
        for await (let U of k76(v)) yield* u76(U, z)
    }, k76 = async function*(v) {
        if (v[Symbol.asyncIterator]) {
            yield* v;
            return
        }
        let z = v.getReader();
        try {
            for (;;) {
                let {
                    done: U,
                    value: V
                } = await z.read();
                if (U) break;
                yield V
            }
        } finally {
            await z.cancel()
        }
    }, eD = (v, z, U, V) => {
        let N = y76(v, z),
            K = 0,
            x, j = (B) => {
                if (!x) x = !0, V && V(B)
            };
        return new ReadableStream({
            async pull(B) {
                try {
                    let {
                        done: O,
                        value: J
                    } = await N.next();
                    if (O) {
                        j(), B.close();
                        return
                    }
                    let q = J.byteLength;
                    if (U) {
                        let H = K += q;
                        U(H)
                    }
                    B.enqueue(new Uint8Array(J))
                } catch (O) {
                    throw j(O), O
                }
            },
            cancel(B) {
                return j(B), N.return()
            }
        }, {
            highWaterMark: 2
        })
    };
var Gx = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function",
    hC = Gx && typeof ReadableStream === "function",
    m76 = Gx && (typeof TextEncoder === "function" ? ((v) => (z) => v.encode(z))(new TextEncoder) : async (v) => new Uint8Array(await new Response(v).arrayBuffer())),
    pC = (v, ...z) => {
        try {
            return !!v(...z)
        } catch (U) {
            return !1
        }
    },
    X76 = hC && pC(() => {
        let v = !1,
            z = new Request(L0.origin, {
                body: new ReadableStream,
                method: "POST",
                get duplex() {
                    return v = !0, "half"
                }
            }).headers.has("Content-Type");
        return v && !z
    }),
    lC = 65536,
    v2 = hC && pC(() => f.isReadableStream(new Response("").body)),
    Fx = {
        stream: v2 && ((v) => v.body)
    };
Gx && ((v) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((z) => {
        !Fx[z] && (Fx[z] = f.isFunction(v[z]) ? (U) => U[z]() : (U, V) => {
            throw new B6(`Response type '${z}' is not supported`, B6.ERR_NOT_SUPPORT, V)
        })
    })
})(new Response);
var g76 = async (v) => {
    if (v == null) return 0;
    if (f.isBlob(v)) return v.size;
    if (f.isSpecCompliantForm(v)) return (await new Request(L0.origin, {
        method: "POST",
        body: v
    }).arrayBuffer()).byteLength;
    if (f.isArrayBufferView(v) || f.isArrayBuffer(v)) return v.byteLength;
    if (f.isURLSearchParams(v)) v = v + "";
    if (f.isString(v)) return (await m76(v)).byteLength
}, c76 = async (v, z) => {
    let U = f.toFiniteNumber(v.getContentLength());
    return U == null ? g76(z) : U
}, nC = Gx && (async (v) => {
    let {
        url: z,
        method: U,
        data: V,
        signal: N,
        cancelToken: K,
        timeout: x,
        onDownloadProgress: j,
        onUploadProgress: B,
        responseType: O,
        headers: J,
        withCredentials: q = "same-origin",
        fetchOptions: H
    } = Lx(v);
    O = O ? (O + "").toLowerCase() : "text";
    let D = iC([N, K && K.toAbortSignal()], x),
        A, w = D && D.unsubscribe && (() => {
            D.unsubscribe()
        }),
        Z;
    try {
        if (B && X76 && U !== "get" && U !== "head" && (Z = await c76(J, V)) !== 0) {
            let I = new Request(z, {
                    method: "POST",
                    body: V,
                    duplex: "half"
                }),
                M;
            if (f.isFormData(V) && (M = I.headers.get("content-type"))) J.setContentType(M);
            if (I.body) {
                let [b, W] = kv(Z, q9(mv(B)));
                V = eD(I.body, lC, b, W)
            }
        }
        if (!f.isString(q)) q = q ? "include" : "omit";
        let $ = "credentials" in Request.prototype;
        A = new Request(z, {
            ...H,
            signal: D,
            method: U.toUpperCase(),
            headers: J.normalize().toJSON(),
            body: V,
            duplex: "half",
            credentials: $ ? q : void 0
        });
        let F = await fetch(A),
            L = v2 && (O === "stream" || O === "response");
        if (v2 && (j || L && w)) {
            let I = {};
            ["status", "statusText", "headers"].forEach((E) => {
                I[E] = F[E]
            });
            let M = f.toFiniteNumber(F.headers.get("content-length")),
                [b, W] = j && kv(M, q9(mv(j), !0)) || [];
            F = new Response(eD(F.body, lC, b, () => {
                W && W(), w && w()
            }), I)
        }
        O = O || "text";
        let G = await Fx[f.findKey(Fx, O) || "text"](F, v);
        return !L && w && w(), await new Promise((I, M) => {
            m8(I, M, {
                data: G,
                headers: r0.from(F.headers),
                status: F.status,
                statusText: F.statusText,
                config: v,
                request: A
            })
        })
    } catch ($) {
        if (w && w(), $ && $.name === "TypeError" && /fetch/i.test($.message)) throw Object.assign(new B6("Network Error", B6.ERR_NETWORK, v, A), {
            cause: $.cause || $
        });
        throw B6.from($, $ && $.code, v, A)
    }
});
var z2 = {
    http: kC,
    xhr: cC,
    fetch: nC
};
f.forEach(z2, (v, z) => {
    if (v) {
        try {
            Object.defineProperty(v, "name", {
                value: z
            })
        } catch (U) {}
        Object.defineProperty(v, "adapterName", {
            value: z
        })
    }
});
var QC = (v) => `- ${v}`,
    i76 = (v) => f.isFunction(v) || v === null || v === !1,
    Ix = {
        getAdapter: (v) => {
            v = f.isArray(v) ? v : [v];
            let {
                length: z
            } = v, U, V, N = {};
            for (let K = 0; K < z; K++) {
                U = v[K];
                let x;
                if (V = U, !i76(U)) {
                    if (V = z2[(x = String(U)).toLowerCase()], V === void 0) throw new B6(`Unknown adapter '${x}'`)
                }
                if (V) break;
                N[x || "#" + K] = V
            }
            if (!V) {
                let K = Object.entries(N).map(([j, B]) => `adapter ${j} ` + (B === !1 ? "is not supported by the environment" : "is not available in the build")),
                    x = z ? K.length > 1 ? `since :
` + K.map(QC).join(`
`) : " " + QC(K[0]) : "as no adapter specified";
                throw new B6("There is no suitable adapter to dispatch the request " + x, "ERR_NOT_SUPPORT")
            }
            return V
        },
        adapters: z2
    };

function U2(v) {
    if (v.cancelToken) v.cancelToken.throwIfRequested();
    if (v.signal && v.signal.aborted) throw new _3(null, v)
}

function Mx(v) {
    if (U2(v), v.headers = r0.from(v.headers), v.data = BU.call(v, v.transformRequest), ["post", "put", "patch"].indexOf(v.method) !== -1) v.headers.setContentType("application/x-www-form-urlencoded", !1);
    return Ix.getAdapter(v.adapter || fv.adapter)(v).then(function(V) {
        return U2(v), V.data = BU.call(v, v.transformResponse, V), V.headers = r0.from(V.headers), V
    }, function(V) {
        if (!OU(V)) {
            if (U2(v), V && V.response) V.response.data = BU.call(v, v.transformResponse, V.response), V.response.headers = r0.from(V.response.headers)
        }
        return Promise.reject(V)
    })
}
var bx = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((v, z) => {
    bx[v] = function(V) {
        return typeof V === v || "a" + (z < 1 ? "n " : " ") + v
    }
});
var dC = {};
bx.transitional = function(z, U, V) {
    function N(K, x) {
        return "[Axios v" + V7 + "] Transitional option '" + K + "'" + x + (V ? ". " + V : "")
    }
    return (K, x, j) => {
        if (z === !1) throw new B6(N(x, " has been removed" + (U ? " in " + U : "")), B6.ERR_DEPRECATED);
        if (U && !dC[x]) dC[x] = !0, console.warn(N(x, " has been deprecated since v" + U + " and will be removed in the near future"));
        return z ? z(K, x, j) : !0
    }
};
bx.spelling = function(z) {
    return (U, V) => {
        return console.warn(`${V} is likely a misspelling of ${z}`), !0
    }
};

function l76(v, z, U) {
    if (typeof v !== "object") throw new B6("options must be an object", B6.ERR_BAD_OPTION_VALUE);
    let V = Object.keys(v),
        N = V.length;
    while (N-- > 0) {
        let K = V[N],
            x = z[K];
        if (x) {
            let j = v[K],
                B = j === void 0 || x(j, K, v);
            if (B !== !0) throw new B6("option " + K + " must be " + B, B6.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (U !== !0) throw new B6("Unknown option " + K, B6.ERR_BAD_OPTION)
    }
}
var wU = {
    assertOptions: l76,
    validators: bx
};
var X8 = wU.validators;
class ZU {
    constructor(v) {
        this.defaults = v, this.interceptors = {
            request: new WD,
            response: new WD
        }
    }
    async request(v, z) {
        try {
            return await this._request(v, z)
        } catch (U) {
            if (U instanceof Error) {
                let V = {};
                Error.captureStackTrace ? Error.captureStackTrace(V) : V = Error();
                let N = V.stack ? V.stack.replace(/^.+\n/, "") : "";
                try {
                    if (!U.stack) U.stack = N;
                    else if (N && !String(U.stack).endsWith(N.replace(/^.+\n.+\n/, ""))) U.stack += `
` + N
                } catch (K) {}
            }
            throw U
        }
    }
    _request(v, z) {
        if (typeof v === "string") z = z || {}, z.url = v;
        else z = v || {};
        z = H8(this.defaults, z);
        let {
            transitional: U,
            paramsSerializer: V,
            headers: N
        } = z;
        if (U !== void 0) wU.assertOptions(U, {
            silentJSONParsing: X8.transitional(X8.boolean),
            forcedJSONParsing: X8.transitional(X8.boolean),
            clarifyTimeoutError: X8.transitional(X8.boolean)
        }, !1);
        if (V != null)
            if (f.isFunction(V)) z.paramsSerializer = {
                serialize: V
            };
            else wU.assertOptions(V, {
                encode: X8.function,
                serialize: X8.function
            }, !0);
        if (z.allowAbsoluteUrls !== void 0);
        else if (this.defaults.allowAbsoluteUrls !== void 0) z.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        else z.allowAbsoluteUrls = !0;
        wU.assertOptions(z, {
            baseUrl: X8.spelling("baseURL"),
            withXsrfToken: X8.spelling("withXSRFToken")
        }, !0), z.method = (z.method || this.defaults.method || "get").toLowerCase();
        let K = N && f.merge(N.common, N[z.method]);
        N && f.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (D) => {
            delete N[D]
        }), z.headers = r0.concat(K, N);
        let x = [],
            j = !0;
        this.interceptors.request.forEach(function(A) {
            if (typeof A.runWhen === "function" && A.runWhen(z) === !1) return;
            j = j && A.synchronous, x.unshift(A.fulfilled, A.rejected)
        });
        let B = [];
        this.interceptors.response.forEach(function(A) {
            B.push(A.fulfilled, A.rejected)
        });
        let O, J = 0,
            q;
        if (!j) {
            let D = [Mx.bind(this), void 0];
            D.unshift.apply(D, x), D.push.apply(D, B), q = D.length, O = Promise.resolve(z);
            while (J < q) O = O.then(D[J++], D[J++]);
            return O
        }
        q = x.length;
        let H = z;
        J = 0;
        while (J < q) {
            let D = x[J++],
                A = x[J++];
            try {
                H = D(H)
            } catch (w) {
                A.call(this, w);
                break
            }
        }
        try {
            O = Mx.call(this, H)
        } catch (D) {
            return Promise.reject(D)
        }
        J = 0, q = B.length;
        while (J < q) O = O.then(B[J++], B[J++]);
        return O
    }
    getUri(v) {
        v = H8(this.defaults, v);
        let z = e5(v.baseURL, v.url, v.allowAbsoluteUrls);
        return s5(z, v.params, v.paramsSerializer)
    }
}
f.forEach(["delete", "get", "head", "options"], function(z) {
    ZU.prototype[z] = function(U, V) {
        return this.request(H8(V || {}, {
            method: z,
            url: U,
            data: (V || {}).data
        }))
    }
});
f.forEach(["post", "put", "patch"], function(z) {
    function U(V) {
        return function(K, x, j) {
            return this.request(H8(j || {}, {
                method: z,
                headers: V ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: K,
                data: x
            }))
        }
    }
    ZU.prototype[z] = U(), ZU.prototype[z + "Form"] = U(!0)
});
var LU = ZU;
class V2 {
    constructor(v) {
        if (typeof v !== "function") throw TypeError("executor must be a function.");
        let z;
        this.promise = new Promise(function(N) {
            z = N
        });
        let U = this;
        this.promise.then((V) => {
            if (!U._listeners) return;
            let N = U._listeners.length;
            while (N-- > 0) U._listeners[N](V);
            U._listeners = null
        }), this.promise.then = (V) => {
            let N, K = new Promise((x) => {
                U.subscribe(x), N = x
            }).then(V);
            return K.cancel = function() {
                U.unsubscribe(N)
            }, K
        }, v(function(N, K, x) {
            if (U.reason) return;
            U.reason = new _3(N, K, x), z(U.reason)
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(v) {
        if (this.reason) {
            v(this.reason);
            return
        }
        if (this._listeners) this._listeners.push(v);
        else this._listeners = [v]
    }
    unsubscribe(v) {
        if (!this._listeners) return;
        let z = this._listeners.indexOf(v);
        if (z !== -1) this._listeners.splice(z, 1)
    }
    toAbortSignal() {
        let v = new AbortController,
            z = (U) => {
                v.abort(U)
            };
        return this.subscribe(z), v.signal.unsubscribe = () => this.unsubscribe(z), v.signal
    }
    static source() {
        let v;
        return {
            token: new V2(function(V) {
                v = V
            }),
            cancel: v
        }
    }
}
var oC = V2;

function N2(v) {
    return function(U) {
        return v.apply(null, U)
    }
}

function K2(v) {
    return f.isObject(v) && v.isAxiosError === !0
}
var x2 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(x2).forEach(([v, z]) => {
    x2[z] = v
});
var rC = x2;

function aC(v) {
    let z = new LU(v),
        U = ez(LU.prototype.request, z);
    return f.extend(U, LU.prototype, z, {
        allOwnKeys: !0
    }), f.extend(U, z, null, {
        allOwnKeys: !0
    }), U.create = function(N) {
        return aC(H8(v, N))
    }, U
}
var B4 = aC(fv);
B4.Axios = LU;
B4.CanceledError = _3;
B4.CancelToken = oC;
B4.isCancel = OU;
B4.VERSION = V7;
B4.toFormData = e9;
B4.AxiosError = B6;
B4.Cancel = B4.CanceledError;
B4.all = function(z) {
    return Promise.all(z)
};
B4.spread = N2;
B4.isAxiosError = K2;
B4.mergeConfig = H8;
B4.AxiosHeaders = r0;
B4.formToJSON = (v) => Jx(f.isHTMLForm(v) ? new FormData(v) : v);
B4.getAdapter = Ix.getAdapter;
B4.HttpStatusCode = rC;
B4.default = B4;
var w3 = B4;
var tC = require("path"),
    sC = require("os");

function Xv() {
    return (process.env.CLAUDE_CONFIG_DIR ?? tC.join(sC.homedir(), ".claude")).normalize("NFC")
}

function K7(v) {
    if (!v) return !1;
    if (typeof v === "boolean") return v;
    let z = v.toLowerCase().trim();
    return ["1", "true", "yes", "on"].includes(z)
}

function h76() {
    return "prod"
}
var p76 = "user:inference",
    n76 = "org:create_api_key",
    Rx = "oauth-2025-04-20",
    j2 = [n76, "user:profile"],
    gv = ["user:profile", p76, "user:sessions:claude_code", "user:mcp_servers"],
    Vb6 = Array.from(new Set([...j2, ...gv])),
    eC = {
        BASE_API_URL: "https://api.anthropic.com",
        CONSOLE_AUTHORIZE_URL: "https://platform.claude.com/oauth/authorize",
        CLAUDE_AI_AUTHORIZE_URL: "https://claude.ai/oauth/authorize",
        TOKEN_URL: "https://platform.claude.com/v1/oauth/token",
        API_KEY_URL: "https://api.anthropic.com/api/oauth/claude_cli/create_api_key",
        ROLES_URL: "https://api.anthropic.com/api/oauth/claude_cli/roles",
        CONSOLE_SUCCESS_URL: "https://platform.claude.com/buy_credits?returnUrl=/oauth/code/success%3Fapp%3Dclaude-code",
        CLAUDEAI_SUCCESS_URL: "https://platform.claude.com/oauth/code/success?app=claude-code",
        MANUAL_REDIRECT_URL: "https://platform.claude.com/oauth/code/callback",
        CLIENT_ID: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
        OAUTH_FILE_SUFFIX: "",
        MCP_PROXY_URL: "https://mcp-proxy.anthropic.com",
        MCP_PROXY_PATH: "/v1/mcp/{server_id}"
    },
    Q76 = void 0,
    d76 = {
        BASE_API_URL: "http://localhost:3000",
        CONSOLE_AUTHORIZE_URL: "http://localhost:3000/oauth/authorize",
        CLAUDE_AI_AUTHORIZE_URL: "http://localhost:4000/oauth/authorize",
        TOKEN_URL: "http://localhost:3000/v1/oauth/token",
        API_KEY_URL: "http://localhost:3000/api/oauth/claude_cli/create_api_key",
        ROLES_URL: "http://localhost:3000/api/oauth/claude_cli/roles",
        CONSOLE_SUCCESS_URL: "http://localhost:3000/buy_credits?returnUrl=/oauth/code/success%3Fapp%3Dclaude-code",
        CLAUDEAI_SUCCESS_URL: "http://localhost:3000/oauth/code/success?app=claude-code",
        MANUAL_REDIRECT_URL: "https://console.staging.ant.dev/oauth/code/callback",
        CLIENT_ID: "22422756-60c9-4084-8eb7-27705fd5cf9a",
        OAUTH_FILE_SUFFIX: "-local-oauth",
        MCP_PROXY_URL: "http://localhost:8205",
        MCP_PROXY_PATH: "/v1/toolbox/shttp/mcp/{server_id}"
    },
    o76 = ["https://beacon.claude-ai.staging.ant.dev", "https://claude.fedstart.com", "https://claude-staging.fedstart.com"];

function b4() {
    let v = (() => {
            switch (h76()) {
                case "local":
                    return d76;
                case "staging":
                    return Q76 ?? eC;
                case "prod":
                    return eC
            }
        })(),
        z = process.env.CLAUDE_CODE_CUSTOM_OAUTH_URL;
    if (z) {
        let V = z.replace(/\/$/, "");
        if (!o76.includes(V)) throw Error("CLAUDE_CODE_CUSTOM_OAUTH_URL is not an approved endpoint.");
        v = {
            ...v,
            BASE_API_URL: V,
            CONSOLE_AUTHORIZE_URL: `${V}/oauth/authorize`,
            CLAUDE_AI_AUTHORIZE_URL: `${V}/oauth/authorize`,
            TOKEN_URL: `${V}/v1/oauth/token`,
            API_KEY_URL: `${V}/api/oauth/claude_cli/create_api_key`,
            ROLES_URL: `${V}/api/oauth/claude_cli/roles`,
            CONSOLE_SUCCESS_URL: `${V}/oauth/code/success?app=claude-code`,
            CLAUDEAI_SUCCESS_URL: `${V}/oauth/code/success?app=claude-code`,
            MANUAL_REDIRECT_URL: `${V}/oauth/code/callback`,
            OAUTH_FILE_SUFFIX: "-custom-oauth"
        }
    }
    let U = process.env.CLAUDE_CODE_OAUTH_CLIENT_ID;
    if (U) v = {
        ...v,
        CLIENT_ID: U
    };
    return v
}

function B2(v) {
    if (!v || v.utilization === null) return;
    return {
        utilization: v.utilization,
        resetsAt: v.resets_at ?? void 0
    }
}

function r76(v) {
    let z = {},
        U = B2(v.five_hour);
    if (U) z.fiveHour = U;
    let V = B2(v.seven_day);
    if (V) z.sevenDay = V;
    let N = B2(v.seven_day_sonnet);
    if (N) z.sevenDaySonnet = N;
    if (v.extra_usage) z.extraUsage = {
        isEnabled: v.extra_usage.is_enabled,
        monthlyLimit: v.extra_usage.monthly_limit ?? void 0,
        usedCredits: v.extra_usage.used_credits ?? void 0,
        utilization: v.extra_usage.utilization ?? void 0
    };
    return z
}
async function vf(v, z) {
    if (v.getAuthStatus()?.authMethod !== "claudeai") {
        if (v.isAuthLoginDisabled()) return {
            unavailableReason: 'Usage tracking requires Claude AI authentication. Enable "claude-code.enableAuthLogin" in settings.'
        };
        return {
            unavailableReason: "Usage tracking is only available for Claude AI subscribers."
        }
    }
    let V = await v.getAuthHeaders();
    if (!V) return;
    let N = `${b4().BASE_API_URL}/api/oauth/usage`;
    try {
        let K = await w3.get(N, {
            headers: {
                "Content-Type": "application/json",
                ...V
            },
            timeout: 5000
        });
        return r76(K.data)
    } catch (K) {
        throw z.error(`Failed to fetch utilization: ${K}`), K
    }
}
var xT = require("child_process");
var MU = require("fs"),
    g8 = require("path");
var a76 = typeof global == "object" && global && global.Object === Object && global,
    zf = a76;
var t76 = typeof self == "object" && self && self.Object === Object && self,
    s76 = zf || t76 || Function("return this")(),
    cv = s76;
var e76 = cv.Symbol,
    iv = e76;
var Uf = Object.prototype,
    vv6 = Uf.hasOwnProperty,
    zv6 = Uf.toString,
    FU = iv ? iv.toStringTag : void 0;

function Uv6(v) {
    var z = vv6.call(v, FU),
        U = v[FU];
    try {
        v[FU] = void 0;
        var V = !0
    } catch (K) {}
    var N = zv6.call(v);
    if (V)
        if (z) v[FU] = U;
        else delete v[FU];
    return N
}
var Vf = Uv6;
var Vv6 = Object.prototype,
    Nv6 = Vv6.toString;

function Kv6(v) {
    return Nv6.call(v)
}
var Nf = Kv6;
var xv6 = "[object Null]",
    jv6 = "[object Undefined]",
    Kf = iv ? iv.toStringTag : void 0;

function Bv6(v) {
    if (v == null) return v === void 0 ? jv6 : xv6;
    return Kf && Kf in Object(v) ? Vf(v) : Nf(v)
}
var xf = Bv6;

function Ov6(v) {
    var z = typeof v;
    return v != null && (z == "object" || z == "function")
}
var Wx = Ov6;
var Jv6 = "[object AsyncFunction]",
    qv6 = "[object Function]",
    Hv6 = "[object GeneratorFunction]",
    Dv6 = "[object Proxy]";

function Av6(v) {
    if (!Wx(v)) return !1;
    var z = xf(v);
    return z == qv6 || z == Hv6 || z == Jv6 || z == Dv6
}
var jf = Av6;
var $v6 = cv["__core-js_shared__"],
    Ex = $v6;
var Bf = function() {
    var v = /[^.]+$/.exec(Ex && Ex.keys && Ex.keys.IE_PROTO || "");
    return v ? "Symbol(src)_1." + v : ""
}();

function wv6(v) {
    return !!Bf && Bf in v
}
var Of = wv6;
var Zv6 = Function.prototype,
    Lv6 = Zv6.toString;

function Fv6(v) {
    if (v != null) {
        try {
            return Lv6.call(v)
        } catch (z) {}
        try {
            return v + ""
        } catch (z) {}
    }
    return ""
}
var Jf = Fv6;
var Gv6 = /[\\^$.*+?()[\]{}|]/g,
    Iv6 = /^\[object .+?Constructor\]$/,
    Mv6 = Function.prototype,
    bv6 = Object.prototype,
    Rv6 = Mv6.toString,
    Wv6 = bv6.hasOwnProperty,
    Ev6 = RegExp("^" + Rv6.call(Wv6).replace(Gv6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function Sv6(v) {
    if (!Wx(v) || Of(v)) return !1;
    var z = jf(v) ? Ev6 : Iv6;
    return z.test(Jf(v))
}
var qf = Sv6;

function Pv6(v, z) {
    return v == null ? void 0 : v[z]
}
var Hf = Pv6;

function _v6(v, z) {
    var U = Hf(v, z);
    return qf(U) ? U : void 0
}
var Sx = _v6;
var Cv6 = Sx(Object, "create"),
    D9 = Cv6;

function fv6() {
    this.__data__ = D9 ? D9(null) : {}, this.size = 0
}
var Df = fv6;

function Tv6(v) {
    var z = this.has(v) && delete this.__data__[v];
    return this.size -= z ? 1 : 0, z
}
var Af = Tv6;
var Yv6 = "__lodash_hash_undefined__",
    uv6 = Object.prototype,
    yv6 = uv6.hasOwnProperty;

function kv6(v) {
    var z = this.__data__;
    if (D9) {
        var U = z[v];
        return U === Yv6 ? void 0 : U
    }
    return yv6.call(z, v) ? z[v] : void 0
}
var $f = kv6;
var mv6 = Object.prototype,
    Xv6 = mv6.hasOwnProperty;

function gv6(v) {
    var z = this.__data__;
    return D9 ? z[v] !== void 0 : Xv6.call(z, v)
}
var wf = gv6;
var cv6 = "__lodash_hash_undefined__";

function iv6(v, z) {
    var U = this.__data__;
    return this.size += this.has(v) ? 0 : 1, U[v] = D9 && z === void 0 ? cv6 : z, this
}
var Zf = iv6;

function lv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
lv.prototype.clear = Df;
lv.prototype.delete = Af;
lv.prototype.get = $f;
lv.prototype.has = wf;
lv.prototype.set = Zf;
var O2 = lv;

function lv6() {
    this.__data__ = [], this.size = 0
}
var Lf = lv6;

function hv6(v, z) {
    return v === z || v !== v && z !== z
}
var Ff = hv6;

function pv6(v, z) {
    var U = v.length;
    while (U--)
        if (Ff(v[U][0], z)) return U;
    return -1
}
var z5 = pv6;
var nv6 = Array.prototype,
    Qv6 = nv6.splice;

function dv6(v) {
    var z = this.__data__,
        U = z5(z, v);
    if (U < 0) return !1;
    var V = z.length - 1;
    if (U == V) z.pop();
    else Qv6.call(z, U, 1);
    return --this.size, !0
}
var Gf = dv6;

function ov6(v) {
    var z = this.__data__,
        U = z5(z, v);
    return U < 0 ? void 0 : z[U][1]
}
var If = ov6;

function rv6(v) {
    return z5(this.__data__, v) > -1
}
var Mf = rv6;

function av6(v, z) {
    var U = this.__data__,
        V = z5(U, v);
    if (V < 0) ++this.size, U.push([v, z]);
    else U[V][1] = z;
    return this
}
var bf = av6;

function hv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
hv.prototype.clear = Lf;
hv.prototype.delete = Gf;
hv.prototype.get = If;
hv.prototype.has = Mf;
hv.prototype.set = bf;
var Rf = hv;
var tv6 = Sx(cv, "Map"),
    Wf = tv6;

function sv6() {
    this.size = 0, this.__data__ = {
        hash: new O2,
        map: new(Wf || Rf),
        string: new O2
    }
}
var Ef = sv6;

function ev6(v) {
    var z = typeof v;
    return z == "string" || z == "number" || z == "symbol" || z == "boolean" ? v !== "__proto__" : v === null
}
var Sf = ev6;

function v16(v, z) {
    var U = v.__data__;
    return Sf(z) ? U[typeof z == "string" ? "string" : "hash"] : U.map
}
var U5 = v16;

function z16(v) {
    var z = U5(this, v).delete(v);
    return this.size -= z ? 1 : 0, z
}
var Pf = z16;

function U16(v) {
    return U5(this, v).get(v)
}
var _f = U16;

function V16(v) {
    return U5(this, v).has(v)
}
var Cf = V16;

function N16(v, z) {
    var U = U5(this, v),
        V = U.size;
    return U.set(v, z), this.size += U.size == V ? 0 : 1, this
}
var ff = N16;

function pv(v) {
    var z = -1,
        U = v == null ? 0 : v.length;
    this.clear();
    while (++z < U) {
        var V = v[z];
        this.set(V[0], V[1])
    }
}
pv.prototype.clear = Ef;
pv.prototype.delete = Pf;
pv.prototype.get = _f;
pv.prototype.has = Cf;
pv.prototype.set = ff;
var J2 = pv;
var K16 = "Expected a function";

function q2(v, z) {
    if (typeof v != "function" || z != null && typeof z != "function") throw TypeError(K16);
    var U = function() {
        var V = arguments,
            N = z ? z.apply(this, V) : V[0],
            K = U.cache;
        if (K.has(N)) return K.get(N);
        var x = v.apply(this, V);
        return U.cache = K.set(N, x) || K, x
    };
    return U.cache = new(q2.Cache || J2), U
}
q2.Cache = J2;
var O4 = q2;
var Tf = require("process"),
    H2 = require("fs"),
    Yf = require("crypto");

function x16() {
    let v = "";
    if (typeof process < "u" && typeof process.cwd === "function" && typeof H2.realpathSync === "function") v = H2.realpathSync(Tf.cwd()).normalize("NFC");
    return {
        originalCwd: v,
        projectRoot: v,
        totalCostUSD: 0,
        totalAPIDuration: 0,
        totalAPIDurationWithoutRetries: 0,
        totalToolDuration: 0,
        startTime: Date.now(),
        lastInteractionTime: Date.now(),
        totalLinesAdded: 0,
        totalLinesRemoved: 0,
        hasUnknownModelCost: !1,
        cwd: v,
        modelUsage: {},
        mainLoopModelOverride: void 0,
        initialMainLoopModel: null,
        modelStrings: null,
        isInteractive: !1,
        clientType: "cli",
        sessionIngressToken: void 0,
        oauthTokenFromFd: void 0,
        apiKeyFromFd: void 0,
        flagSettingsPath: void 0,
        allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"],
        meter: null,
        sessionCounter: null,
        locCounter: null,
        prCounter: null,
        commitCounter: null,
        costCounter: null,
        tokenCounter: null,
        codeEditToolDecisionCounter: null,
        activeTimeCounter: null,
        sessionId: Yf.randomUUID(),
        parentSessionId: void 0,
        loggerProvider: null,
        eventLogger: null,
        meterProvider: null,
        tracerProvider: null,
        agentColorMap: new Map,
        agentColorIndex: 0,
        lastAPIRequest: null,
        inMemoryErrorLog: [],
        inlinePlugins: [],
        useCoworkPlugins: !1,
        sessionBypassPermissionsMode: !1,
        sessionTrustAccepted: !1,
        sessionPersistenceDisabled: !1,
        hasExitedPlanMode: !1,
        needsPlanModeExitAttachment: !1,
        hasExitedDelegateMode: !1,
        needsDelegateModeExitAttachment: !1,
        lspRecommendationShownThisSession: !1,
        initJsonSchema: null,
        registeredHooks: null,
        planSlugCache: new Map,
        teleportedSessionInfo: null,
        invokedSkills: new Map,
        slowOperations: [],
        promptCacheBreaks: [],
        sdkBetas: void 0,
        mainThreadAgentType: void 0,
        isRemoteMode: !1,
        directConnectServerUrl: void 0,
        systemPromptSectionCache: new Map,
        lastEmittedDate: null,
        additionalDirectoriesForClaudeMd: [],
        resumedTranscriptPath: null,
        promptCache1hAllowlist: null
    }
}
var D2 = x16();

function uf() {
    return D2.sessionId
}

function yf() {
    return D2.originalCwd
}

function kf() {
    return D2.cwd
}

function j16() {
    return kf()
}

function A9() {
    try {
        return j16()
    } catch {
        return yf()
    }
}
var l0 = o(require("node:path")),
    A2 = o(require("node:os")),
    Px = o(require("node:process")),
    V5 = A2.default.homedir(),
    $2 = A2.default.tmpdir(),
    {
        env: nv
    } = Px.default,
    B16 = (v) => {
        let z = l0.default.join(V5, "Library");
        return {
            data: l0.default.join(z, "Application Support", v),
            config: l0.default.join(z, "Preferences", v),
            cache: l0.default.join(z, "Caches", v),
            log: l0.default.join(z, "Logs", v),
            temp: l0.default.join($2, v)
        }
    },
    O16 = (v) => {
        let z = nv.APPDATA || l0.default.join(V5, "AppData", "Roaming"),
            U = nv.LOCALAPPDATA || l0.default.join(V5, "AppData", "Local");
        return {
            data: l0.default.join(U, v, "Data"),
            config: l0.default.join(z, v, "Config"),
            cache: l0.default.join(U, v, "Cache"),
            log: l0.default.join(U, v, "Log"),
            temp: l0.default.join($2, v)
        }
    },
    J16 = (v) => {
        let z = l0.default.basename(V5);
        return {
            data: l0.default.join(nv.XDG_DATA_HOME || l0.default.join(V5, ".local", "share"), v),
            config: l0.default.join(nv.XDG_CONFIG_HOME || l0.default.join(V5, ".config"), v),
            cache: l0.default.join(nv.XDG_CACHE_HOME || l0.default.join(V5, ".cache"), v),
            log: l0.default.join(nv.XDG_STATE_HOME || l0.default.join(V5, ".local", "state"), v),
            temp: l0.default.join($2, z, v)
        }
    };

function w2(v, {
    suffix: z = "nodejs"
} = {}) {
    if (typeof v !== "string") throw TypeError(`Expected a string, got ${typeof v}`);
    if (z) v += `-${z}`;
    if (Px.default.platform === "darwin") return B16(v);
    if (Px.default.platform === "win32") return O16(v);
    return J16(v)
}
var p6 = o(require("fs"));
var Z4 = require("fs/promises");

function q16(v, z) {
    if (v.destroyed) return;
    v.write(z)
}

function mf(v) {
    q16(process.stderr, v)
}
var Xf = O4((v) => {
    if (!v || v.trim() === "") return null;
    let z = v.split(",").map((K) => K.trim()).filter(Boolean);
    if (z.length === 0) return null;
    let U = z.some((K) => K.startsWith("!")),
        V = z.some((K) => !K.startsWith("!"));
    if (U && V) return null;
    let N = z.map((K) => K.replace(/^!/, "").toLowerCase());
    return {
        include: U ? [] : N,
        exclude: U ? N : [],
        isExclusive: U
    }
});

function H16(v) {
    let z = [],
        U = v.match(/^MCP server ["']([^"']+)["']/);
    if (U && U[1]) z.push("mcp"), z.push(U[1].toLowerCase());
    else {
        let K = v.match(/^([^:[]+):/);
        if (K && K[1]) z.push(K[1].trim().toLowerCase())
    }
    let V = v.match(/^\[([^\]]+)]/);
    if (V && V[1]) z.push(V[1].trim().toLowerCase());
    if (v.toLowerCase().includes("1p event:")) z.push("1p");
    let N = v.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
    if (N && N[1]) {
        let K = N[1].trim().toLowerCase();
        if (K.length < 30 && !K.includes(" ")) z.push(K)
    }
    return Array.from(new Set(z))
}

function D16(v, z) {
    if (!z) return !0;
    if (v.length === 0) return !1;
    if (z.isExclusive) return !v.some((U) => z.exclude.includes(U));
    else return v.some((U) => z.include.includes(U))
}

function gf(v, z) {
    if (!z) return !0;
    let U = H16(v);
    return D16(U, z)
}
var dv = require("path");

function cf({
    writeFn: v,
    flushIntervalMs: z = 1000,
    maxBufferSize: U = 100,
    immediateMode: V = !1
}) {
    let N = [],
        K = null;

    function x() {
        if (K) clearTimeout(K), K = null
    }

    function j() {
        if (N.length === 0) return;
        v(N.join("")), N = [], x()
    }

    function B() {
        if (!K) K = setTimeout(j, z)
    }
    return {
        write(O) {
            if (V) {
                v(O);
                return
            }
            if (N.push(O), B(), N.length >= U) j()
        },
        flush: j,
        dispose() {
            j()
        }
    }
}
var lf = new Set;

function _x(v) {
    return lf.add(v), () => lf.delete(v)
}
var $9 = require("fs"),
    w9 = (() => {
        let v = process.env.CLAUDE_CODE_SLOW_OPERATION_THRESHOLD_MS;
        if (v !== void 0) {
            let z = Number(v);
            if (!Number.isNaN(z) && z >= 0) return z
        }
        return 20
    })();

function A16(v) {
    if (v === null) return "null";
    if (v === void 0) return "undefined";
    if (Array.isArray(v)) return `Array[${v.length}]`;
    if (typeof v === "object") return `Object{${Object.keys(v).length} keys}`;
    if (typeof v === "string") return `string(${v.length} chars)`;
    return typeof v
}

function hf(v, z) {
    let U = performance.now();
    try {
        return z()
    } finally {
        performance.now() - U > w9
    }
}

function N5(v, z, U) {
    let V = A16(v);
    return hf(`JSON.stringify(${V})`, () => JSON.stringify(v, z, U))
}
var Qv = (v, z) => {
    let U = typeof v === "string" ? v.length : 0;
    return hf(`JSON.parse(${U} chars)`, () => JSON.parse(v, z))
};

function pf(v, z, U) {
    let V = performance.now();
    try {
        if (U !== null && typeof U === "object" && "flush" in U && U.flush === !0) {
            let K = typeof U === "object" && "encoding" in U ? U.encoding : void 0,
                x = typeof U === "object" && "mode" in U ? U.mode : void 0,
                j;
            try {
                j = $9.openSync(v, "w", x), $9.writeFileSync(j, z, {
                    encoding: K ?? void 0
                }), $9.fsyncSync(j)
            } finally {
                if (j !== void 0) $9.closeSync(j)
            }
        } else $9.writeFileSync(v, z, U)
    } finally {
        performance.now() - V > w9
    }
}
var $16 = O4(() => {
        return K7(process.env.DEBUG) || K7(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || nf() || process.argv.some((v) => v.startsWith("--debug=")) || Qf() !== null
    }),
    w16 = O4(() => {
        let v = process.argv.find((U) => U.startsWith("--debug="));
        if (!v) return null;
        let z = v.substring(8);
        return Xf(z)
    }),
    nf = O4(() => {
        return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e")
    }),
    Qf = O4(() => {
        for (let v = 0; v < process.argv.length; v++) {
            let z = process.argv[v];
            if (z.startsWith("--debug-file=")) return z.substring(13);
            if (z === "--debug-file" && v + 1 < process.argv.length) return process.argv[v + 1]
        }
        return null
    });

function Z16(v) {
    if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return !1;
    let z = w16();
    return gf(v, z)
}
var L16 = !1;
var Cx = null;

function F16() {
    if (!Cx) {
        let v = null;
        Cx = cf({
            writeFn: (z) => {
                let U = df(),
                    V = dv.dirname(U);
                if (v !== V) {
                    try {
                        w4().mkdirSync(V)
                    } catch {}
                    v = V
                }
                w4().appendFileSync(U, z), G16()
            },
            flushIntervalMs: 1000,
            maxBufferSize: 100,
            immediateMode: $16()
        }), _x(async () => Cx?.dispose())
    }
    return Cx
}

function fx(v, {
    level: z
} = {
    level: "debug"
}) {
    if (!Z16(v)) return;
    if (L16 && v.includes(`
`)) v = N5(v);
    let V = `${new Date().toISOString()} [${z.toUpperCase()}] ${v.trim()}
`;
    if (nf()) {
        mf(V);
        return
    }
    F16().write(V)
}

function df() {
    return Qf() ?? process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? dv.join(Xv(), "debug", `${uf()}.txt`)
}
var G16 = O4(() => {
    if (process.argv[2] === "--ripgrep") return;
    try {
        let v = df(),
            z = dv.dirname(v),
            U = dv.join(z, "latest");
        if (!w4().existsSync(z)) w4().mkdirSync(z);
        if (w4().existsSync(U)) try {
            w4().unlinkSync(U)
        } catch {}
        w4().symlinkSync(v, U)
    } catch {}
});
var I16 = !1;

function J4(v, z) {
    let U = performance.now();
    try {
        return z()
    } finally {
        performance.now() - U > w9
    }
}
var M16 = {
        cwd() {
            return process.cwd()
        },
        existsSync(v) {
            return J4(`existsSync(${v})`, () => p6.existsSync(v))
        },
        async stat(v) {
            return Z4.stat(v)
        },
        async readdir(v) {
            return Z4.readdir(v, {
                withFileTypes: !0
            })
        },
        async unlink(v) {
            return Z4.unlink(v)
        },
        async rmdir(v) {
            return Z4.rmdir(v)
        },
        async rm(v, z) {
            return Z4.rm(v, z)
        },
        async mkdir(v, z) {
            await Z4.mkdir(v, {
                recursive: !0,
                ...z
            })
        },
        async readFile(v, z) {
            return Z4.readFile(v, {
                encoding: z.encoding
            })
        },
        async rename(v, z) {
            return Z4.rename(v, z)
        },
        statSync(v) {
            return J4(`statSync(${v})`, () => p6.statSync(v))
        },
        lstatSync(v) {
            return J4(`lstatSync(${v})`, () => p6.lstatSync(v))
        },
        readFileSync(v, z) {
            return J4(`readFileSync(${v})`, () => p6.readFileSync(v, {
                encoding: z.encoding
            }))
        },
        readFileBytesSync(v) {
            return J4(`readFileBytesSync(${v})`, () => p6.readFileSync(v))
        },
        readSync(v, z) {
            return J4(`readSync(${v}, ${z.length} bytes)`, () => {
                let U = void 0;
                try {
                    U = p6.openSync(v, "r");
                    let V = Buffer.alloc(z.length),
                        N = p6.readSync(U, V, 0, z.length, 0);
                    return {
                        buffer: V,
                        bytesRead: N
                    }
                } finally {
                    if (U) p6.closeSync(U)
                }
            })
        },
        appendFileSync(v, z, U) {
            return J4(`appendFileSync(${v}, ${z.length} chars)`, () => {
                if (!p6.existsSync(v) && U?.mode !== void 0) {
                    let V = p6.openSync(v, "a", U.mode);
                    try {
                        p6.appendFileSync(V, z)
                    } finally {
                        p6.closeSync(V)
                    }
                } else p6.appendFileSync(v, z)
            })
        },
        copyFileSync(v, z) {
            return J4(`copyFileSync(${v}  ${z})`, () => p6.copyFileSync(v, z))
        },
        unlinkSync(v) {
            return J4(`unlinkSync(${v})`, () => p6.unlinkSync(v))
        },
        renameSync(v, z) {
            return J4(`renameSync(${v}  ${z})`, () => p6.renameSync(v, z))
        },
        linkSync(v, z) {
            return J4(`linkSync(${v}  ${z})`, () => p6.linkSync(v, z))
        },
        symlinkSync(v, z, U) {
            return J4(`symlinkSync(${v}  ${z})`, () => p6.symlinkSync(v, z, U))
        },
        readlinkSync(v) {
            return J4(`readlinkSync(${v})`, () => p6.readlinkSync(v))
        },
        realpathSync(v) {
            return J4(`realpathSync(${v})`, () => p6.realpathSync(v).normalize("NFC"))
        },
        mkdirSync(v, z) {
            return J4(`mkdirSync(${v})`, () => {
                if (!p6.existsSync(v)) {
                    let U = {
                        recursive: !0
                    };
                    if (z?.mode !== void 0) U.mode = z.mode;
                    p6.mkdirSync(v, U)
                }
            })
        },
        readdirSync(v) {
            return J4(`readdirSync(${v})`, () => p6.readdirSync(v, {
                withFileTypes: !0
            }))
        },
        readdirStringSync(v) {
            return J4(`readdirStringSync(${v})`, () => p6.readdirSync(v))
        },
        isDirEmptySync(v) {
            return J4(`isDirEmptySync(${v})`, () => {
                return this.readdirSync(v).length === 0
            })
        },
        rmdirSync(v) {
            return J4(`rmdirSync(${v})`, () => p6.rmdirSync(v))
        },
        rmSync(v, z) {
            return J4(`rmSync(${v})`, () => p6.rmSync(v, z))
        },
        createWriteStream(v) {
            return p6.createWriteStream(v)
        },
        async readFileBytes(v, z) {
            if (z === void 0) return Z4.readFile(v);
            let U = await Z4.open(v, "r");
            try {
                let {
                    size: V
                } = await U.stat(), N = Math.min(V, z), K = Buffer.allocUnsafe(N), x = 0;
                while (x < N) {
                    let {
                        bytesRead: j
                    } = await U.read(K, x, N - x, x);
                    if (j === 0) break;
                    x += j
                }
                return x < N ? K.subarray(0, x) : K
            } finally {
                await U.close()
            }
        }
    },
    b16 = M16;

function w4() {
    return b16
}
var uW6 = w2("claude-cli");
var R16 = ["ide_opened_file", "ide_selection", "command-name", "command-message", "command-args"],
    mW6 = new RegExp(R16.map((v) => `<${v}(?:\\s[^>]*)?>([\\s\\S]*?)<\\/${v}>\\n?`).join("|"), "g");
var W16 = 100,
    Z2 = [];

function E16(v) {
    if (Z2.length >= W16) Z2.shift();
    Z2.push(v)
}
var S16 = [],
    of = null;
var zE6 = O4(() => {
    return process.argv.includes("--hard-fail")
});

function L2(v) {
    try {
        if (K7(process.env.CLAUDE_CODE_USE_BEDROCK) || K7(process.env.CLAUDE_CODE_USE_VERTEX) || K7(process.env.CLAUDE_CODE_USE_FOUNDRY) || process.env.DISABLE_ERROR_REPORTING || process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
        let U = {
            error: v.stack || v.message,
            timestamp: new Date().toISOString()
        };
        if (E16(U), of === null) {
            S16.push({
                type: "error",
                error: v
            });
            return
        }
        of.logError(v)
    } catch {}
}
var rf = 1000,
    af = 60;

function Tx(v, z, U = 10 * af * rf) {
    let V;
    if (z === void 0) V = {};
    else if (z instanceof AbortSignal) V = {
        abortSignal: z,
        timeout: U
    };
    else V = z;
    let {
        abortSignal: N,
        timeout: K = 10 * af * rf,
        input: x,
        stdio: j = ["ignore", "pipe", "pipe"]
    } = V;
    N?.throwIfAborted();
    let B = performance.now();
    try {
        let O = E3(v, {
            env: process.env,
            maxBuffer: 1e6,
            timeout: K,
            cwd: A9(),
            stdio: j,
            shell: !0,
            reject: !1,
            input: x
        });
        if (performance.now() - B > w9, !O.stdout) return null;
        return O.stdout.trim() || null
    } catch {
        return performance.now() - B > w9, null
    }
}
var F2 = 1000,
    G2 = 60;

function I2(v, z, U = {
    timeout: 10 * G2 * F2,
    preserveOutputOnError: !0,
    useCwd: !0
}) {
    return _16(v, z, {
        abortSignal: U.abortSignal,
        timeout: U.timeout,
        preserveOutputOnError: U.preserveOutputOnError,
        cwd: U.useCwd ? A9() : void 0,
        env: U.env,
        stdin: U.stdin
    })
}

function P16(v, z) {
    if (v.shortMessage) return v.shortMessage;
    if (typeof v.signal === "string") return v.signal;
    return String(z)
}

function _16(v, z, {
    abortSignal: U,
    timeout: V = 10 * G2 * F2,
    preserveOutputOnError: N = !0,
    cwd: K,
    env: x,
    maxBuffer: j,
    shell: B,
    stdin: O
} = {
    timeout: 10 * G2 * F2,
    preserveOutputOnError: !0,
    maxBuffer: 1e6
}) {
    return new Promise((J) => {
        g7(v, z, {
            maxBuffer: j,
            signal: U,
            timeout: V,
            cwd: K,
            env: x,
            shell: B,
            stdin: O,
            reject: !1
        }).then((q) => {
            if (q.failed)
                if (N) {
                    let H = q.exitCode ?? 1;
                    J({
                        stdout: q.stdout || "",
                        stderr: q.stderr || "",
                        code: H,
                        error: P16(q, H)
                    })
                } else J({
                    stdout: "",
                    stderr: "",
                    code: q.exitCode ?? 1
                });
            else J({
                stdout: q.stdout,
                stderr: q.stderr,
                code: 0
            })
        }).catch((q) => {
            L2(q), J({
                stdout: "",
                stderr: "",
                code: 1
            })
        })
    })
}
var M2 = require("path");

function x7(v, z, U = {}) {
    let V = C16();
    if (!V) return;
    let N = {
            timestamp: new Date().toISOString(),
            level: v,
            event: z,
            data: U
        },
        K = w4();
    if (!K.existsSync(M2.dirname(V))) K.mkdirSync(M2.dirname(V));
    K.appendFileSync(V, N5(N) + `
`)
}

function C16() {
    return process.env.CLAUDE_CODE_DIAGNOSTICS_FILE
}
var tf = require("child_process");

function f16(v, z) {
    performance.now() - z > w9
}

function b2(v, z) {
    let U = `execSync: ${v.slice(0,100)}`,
        V = performance.now();
    try {
        return tf.execSync(v, z)
    } finally {
        f16(U, V)
    }
}

function T16(v) {
    if (process.platform === "win32") try {
        return b2(`where.exe ${v}`, {
            encoding: "utf-8",
            stdio: ["ignore", "pipe", "ignore"]
        }).toString().trim().split(/\r?\n/)[0] || null
    } catch {
        return null
    }
    try {
        return b2(`which ${v}`, {
            encoding: "utf-8",
            stdio: ["ignore", "pipe", "ignore"]
        }).toString().trim() || null
    } catch {
        return null
    }
}

function sf(v) {
    if (typeof Bun < "u") return Bun.which(v);
    return T16(v)
}
var IU = require("fs"),
    Z9 = require("fs/promises"),
    f3 = require("path");
var GU = new Map;
async function vT(v) {
    let z = f3.resolve(v ?? A9()),
        U = GU.get(z);
    if (U !== void 0) return U;
    let V = R2(z);
    if (!V) return GU.set(z, null), null;
    let N = f3.join(V, ".git");
    try {
        if ((await Z9.stat(N)).isFile()) {
            let x = (await Z9.readFile(N, "utf-8")).trim();
            if (x.startsWith("gitdir:")) {
                let j = x.slice(7).trim(),
                    B = f3.resolve(V, j);
                return GU.set(z, B), B
            }
        }
        return GU.set(z, N), N
    } catch {
        return GU.set(z, null), null
    }
}
async function Y16(v) {
    try {
        let z = (await Z9.readFile(f3.join(v, "HEAD"), "utf-8")).trim();
        if (z.startsWith("ref:")) {
            let U = z.slice(4).trim();
            if (U.startsWith("refs/heads/")) return {
                type: "branch",
                name: U.slice(11)
            };
            let V = await zT(v, U);
            return V ? {
                type: "detached",
                sha: V
            } : {
                type: "detached",
                sha: ""
            }
        }
        return {
            type: "detached",
            sha: z
        }
    } catch {
        return null
    }
}
async function zT(v, z) {
    let U = await ef(v, z);
    if (U) return U;
    let V = await u16(v);
    if (V && V !== v) return ef(V, z);
    return null
}
async function ef(v, z) {
    try {
        let U = (await Z9.readFile(f3.join(v, z), "utf-8")).trim();
        if (U.startsWith("ref:")) return zT(v, U.slice(4).trim());
        return U
    } catch {}
    try {
        let U = await Z9.readFile(f3.join(v, "packed-refs"), "utf-8");
        for (let V of U.split(`
`)) {
            if (V.startsWith("#") || V.startsWith("^")) continue;
            let N = V.indexOf(" ");
            if (N === -1) continue;
            if (V.slice(N + 1) === z) return V.slice(0, N)
        }
    } catch {}
    return null
}
async function u16(v) {
    try {
        let z = (await Z9.readFile(f3.join(v, "commondir"), "utf-8")).trim();
        return f3.resolve(v, z)
    } catch {
        return null
    }
}
var y16 = 1000;
class UT {
    gitDir = null;
    initialized = !1;
    initPromise = null;
    watchedPaths = [];
    branchRefPath = null;
    cache = new Map;
    async ensureStarted() {
        if (this.initialized) return;
        if (this.initPromise) return this.initPromise;
        return this.initPromise = this.start(), this.initPromise
    }
    async start() {
        if (this.initialized = !0, this.gitDir = await vT(), !this.gitDir) return;
        this.watchPath(f3.join(this.gitDir, "HEAD"), () => {
            this.onHeadChanged()
        }), this.watchPath(f3.join(this.gitDir, "config"), () => {
            this.invalidate()
        }), await this.watchCurrentBranchRef(), _x(async () => {
            this.stopWatching()
        })
    }
    watchPath(v, z) {
        this.watchedPaths.push(v), IU.watchFile(v, {
            interval: y16
        }, z)
    }
    async watchCurrentBranchRef() {
        if (!this.gitDir) return;
        let v = await Y16(this.gitDir);
        if (!v || v.type !== "branch") return;
        let z = f3.join(this.gitDir, "refs", "heads", v.name);
        if (z === this.branchRefPath) return;
        if (this.branchRefPath) IU.unwatchFile(this.branchRefPath), this.watchedPaths = this.watchedPaths.filter((U) => U !== this.branchRefPath);
        this.branchRefPath = z, this.watchPath(z, () => {
            this.invalidate()
        })
    }
    async onHeadChanged() {
        await this.watchCurrentBranchRef(), this.invalidate()
    }
    invalidate() {
        for (let v of this.cache.values()) v.dirty = !0
    }
    stopWatching() {
        for (let v of this.watchedPaths) IU.unwatchFile(v);
        this.watchedPaths = [], this.branchRefPath = null
    }
    async get(v, z) {
        await this.ensureStarted();
        let U = this.cache.get(v);
        if (U && !U.dirty) return U.value;
        if (U) U.dirty = !1;
        let V = await z(),
            N = this.cache.get(v);
        if (N && !N.dirty) N.value = V;
        if (!N) this.cache.set(v, {
            value: V,
            dirty: !1,
            compute: z
        });
        return V
    }
    reset() {
        this.stopWatching(), this.cache.clear(), this.initialized = !1, this.initPromise = null, this.gitDir = null
    }
}
var yE6 = new UT;
var R2 = O4((v) => {
        let z = Date.now();
        x7("info", "find_git_root_started");
        let U = g8.resolve(v),
            V = U.substring(0, U.indexOf(g8.sep) + 1) || g8.sep,
            N = 0;
        while (U !== V) {
            try {
                let x = g8.join(U, ".git");
                N++;
                let j = MU.statSync(x);
                if (j.isDirectory() || j.isFile()) return x7("info", "find_git_root_completed", {
                    duration_ms: Date.now() - z,
                    stat_count: N,
                    found: !0
                }), U.normalize("NFC")
            } catch {}
            let K = g8.dirname(U);
            if (K === U) break;
            U = K
        }
        try {
            let K = g8.join(V, ".git");
            N++;
            let x = MU.statSync(K);
            if (x.isDirectory() || x.isFile()) return x7("info", "find_git_root_completed", {
                duration_ms: Date.now() - z,
                stat_count: N,
                found: !0
            }), V.normalize("NFC")
        } catch {}
        return x7("info", "find_git_root_completed", {
            duration_ms: Date.now() - z,
            stat_count: N,
            found: !1
        }), null
    }),
    tE6 = O4(() => {
        return sf("git") || "git"
    }),
    sE6 = O4(async () => {
        let v = Date.now();
        x7("info", "is_git_check_started");
        let z = R2(A9()) !== null;
        return x7("info", "is_git_check_completed", {
            duration_ms: Date.now() - v,
            is_git: z
        }), z
    });

function Yx(v) {
    let z = v.trim(),
        U = /github\.com[:/]([^/]+)\/([^/]+)$/,
        V = z.match(U);
    if (V && V[1] && V[2]) {
        let N = V[1],
            K = V[2].replace(/\.git$/, ""),
            x = `${N}/${K}`;
        return fx(`Parsed repository: ${x} from ${z}`), x
    }
    if (!z.includes("://") && !z.includes("@") && z.includes("/")) {
        let N = z.split("/");
        if (N.length === 2 && N[0] && N[1]) {
            let K = N[1].replace(/\.git$/, "");
            return `${N[0]}/${K}`
        }
    }
    return fx(`Could not parse repository from: ${z}`), null
}
var jT = [2000, 4000, 8000, 16000],
    VT = jT.length;

function k16(v) {
    if (!w3.isAxiosError(v)) return !1;
    if (!v.response) return !0;
    if (v.response.status >= 500) return !0;
    return !1
}
async function W2(v, z) {
    let U;
    for (let V = 0; V <= VT; V++) try {
        return await w3.get(v, z)
    } catch (N) {
        if (U = N, !k16(N)) throw N;
        if (V >= VT) throw N;
        let K = jT[V] ?? 2000;
        await new Promise((x) => setTimeout(x, K))
    }
    throw U
}

function NT(v) {
    return {
        Authorization: `Bearer ${v}`,
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
    }
}

function KT(v) {
    return v.session_context.outcomes?.find((U) => U.type === "git_repository")?.git_info?.branches[0]
}
class E2 {
    authManager;
    logger;
    cwd;
    currentRepoCache = void 0;
    constructor(v, z, U) {
        this.authManager = v;
        this.logger = z;
        this.cwd = U
    }
    async detectCurrentRepository() {
        if (this.currentRepoCache !== void 0) return this.currentRepoCache;
        try {
            let v = await new Promise((U, V) => {
                    xT.execFile("git", ["remote", "get-url", "origin"], {
                        cwd: this.cwd
                    }, (N, K) => {
                        if (N) V(N);
                        else U(K.trim())
                    })
                }),
                z = Yx(v);
            return this.currentRepoCache = z, z
        } catch {
            return this.currentRepoCache = null, null
        }
    }
    async prepareApiRequest() {
        let v = await this.authManager.getAuthHeaders();
        if (!v?.Authorization) return this.logger.warn("No OAuth token available for teleport"), null;
        let z = v.Authorization.replace("Bearer ", ""),
            U = this.authManager.getOrganizationUUID();
        if (!U) U = await this.authManager.fetchOrganizationUUID();
        if (!U) return this.logger.error("No organization UUID available"), null;
        return {
            accessToken: z,
            orgUUID: U
        }
    }
    async fetchRemoteSessions() {
        let v = await this.prepareApiRequest();
        if (!v) throw Error("Failed to connect to remote server");
        let {
            accessToken: z,
            orgUUID: U
        } = v, V = `${b4().BASE_API_URL}/v1/sessions`;
        try {
            let N = {
                    ...NT(z),
                    "x-organization-uuid": U
                },
                K = await W2(V, {
                    headers: N,
                    timeout: 15000,
                    proxy: !1
                });
            if (K.status !== 200) return this.logger.error(`Failed to fetch remote sessions: ${K.statusText}`), [];
            let x = await this.detectCurrentRepository(),
                j;
            if (x) j = K.data.data.filter((O) => {
                let J = O.session_context.sources.find((H) => H.type === "git_repository");
                if (!J?.url) return !1;
                return Yx(J.url) === x
            });
            else j = K.data.data;
            let B = j.map((O) => {
                let J = O.session_context.sources.find((H) => H.type === "git_repository"),
                    q = void 0;
                if (J?.url) {
                    let H = Yx(J.url);
                    if (H) {
                        let [D, A] = H.split("/");
                        if (D && A) {
                            let w = KT(O);
                            q = {
                                owner: D,
                                name: A,
                                branch: w || void 0
                            }
                        }
                    }
                }
                return {
                    id: O.id,
                    lastModified: new Date(O.updated_at).getTime(),
                    messageCount: 0,
                    summary: O.title || "Untitled",
                    isRemote: !0,
                    remoteRepo: q,
                    status: O.session_status === "running" ? "running" : "idle"
                }
            });
            return this.logger.log(`Fetched ${B.length} remote sessions`), B
        } catch (N) {
            return this.logger.error(`Error fetching remote sessions: ${N}`), []
        }
    }
    async teleportSession(v) {
        let z = await this.prepareApiRequest();
        if (!z) return null;
        let {
            accessToken: U,
            orgUUID: V
        } = z;
        try {
            let N = `${b4().BASE_API_URL}/v1/sessions/${v}`,
                K = {
                    ...NT(U),
                    "x-organization-uuid": V
                },
                x = await W2(N, {
                    headers: K,
                    timeout: 15000,
                    validateStatus: (q) => q < 500,
                    proxy: !1
                });
            if (x.status !== 200) {
                if (x.status === 404) return this.logger.error(`Session not found: ${v}`), null;
                if (x.status === 401) return this.logger.error("Session expired, please login again"), null;
                return this.logger.error(`Failed to fetch session: ${x.status}`), null
            }
            let j = x.data,
                B = KT(j),
                O = `${b4().BASE_API_URL}/v1/session_ingress/session/${v}`,
                J = await W2(O, {
                    headers: K,
                    timeout: 20000,
                    validateStatus: (q) => q < 500,
                    proxy: !1
                });
            if (J.status === 200) {
                let q = J.data.loglines || [];
                return this.logger.log(`Fetched ${q.length} log entries for session ${v}`), {
                    messages: q,
                    branch: B,
                    title: j.title || void 0
                }
            }
            if (J.status === 404) return this.logger.log(`No logs found for session ${v}`), {
                messages: [],
                branch: B,
                title: j.title || void 0
            };
            return this.logger.error(`Failed to fetch session logs: ${J.status}`), null
        } catch (N) {
            return this.logger.error(`Error teleporting session ${v}: ${N}`), null
        }
    }
}
class S2 {
    cwd;
    logger;
    settings;
    openNewInTab;
    showTerminalBanner;
    experimentGates;
    authManager;
    channels = new Map;
    fromClientStream = new l7;
    abortControllers = new Map;
    config;
    showReviewUpsellBanner;
    outstandingRequests = new Map;
    pluginManager;
    teleportService;
    cachedCurrentRepo;
    constructor(v, z, U, V, N, K, x) {
        this.cwd = v;
        this.logger = z;
        this.settings = U;
        this.openNewInTab = V;
        this.showTerminalBanner = N;
        this.experimentGates = K;
        this.authManager = x;
        this.pluginManager = new gq(z, () => this.getClaudeBinary()), this.teleportService = new E2(x, z, this.cwd), this.readFromClient();
        try {
            B3.load(this.cwd, this.logger)
        } catch (j) {
            this.logger.error(`Failed to load sessions at startup: ${j}`)
        }
    }
    async fromClient(v) {
        this.fromClientStream.enqueue(v)
    }
    async readFromClient() {
        for await (let v of this.fromClientStream) switch (v.type) {
            case "launch_claude":
                await this.launchClaude(v.channelId, v.resume, v.cwd, v.model, v.permissionMode, v.thinkingLevel);
                break;
            case "close_channel":
                this.closeChannel(v.channelId, !1);
                break;
            case "interrupt_claude":
                this.interruptClaude(v.channelId);
                break;
            case "start_speech_to_text":
                await this.handleStartSpeechToText(v.channelId);
                break;
            case "stop_speech_to_text":
                this.handleStopSpeechToText(v.channelId);
                break;
            case "io_message":
                this.transportMessage(v.channelId, v.message, v.done);
                break;
            case "request":
                this.handleRequest(v);
                break;
            case "response": {
                let z = v.requestId,
                    U = this.outstandingRequests.get(z);
                if (U)
                    if (v.response.type === "error") U.reject(Error(v.response.error));
                    else U.resolve(v.response);
                else this.logger.warn(`No handler for response with requestId: ${z}`)
            }
            break;
            case "cancel_request":
                this.handleCancellation(v.targetRequestId);
                break;
            default:
                this.logger.error(`Unknown message: ${v}`)
        }
    }
    async launchClaude(v, z, U, V, N, K) {
        if (this.logger.log(`Launching Claude on channel: ${v}`), this.channels.has(v)) throw Error(`Channel already exists: ${v}`);
        this.generateAndPushProactiveSuggestions(v);
        try {
            let x = new l7,
                j = AS((D) => {
                    this.onExperimentGatesUpdated(D)
                }, (D, A, w) => {
                    if (Dz(D)) return;
                    this.send({
                        type: "file_updated",
                        channelId: v,
                        filePath: D,
                        oldContent: A,
                        newContent: w
                    })
                });
            // --- forceLocal: register remote file proxy tools on in-process MCP server ---
            if (isForceLocalMode()) {
                try {
                    var _remoteTools2 = require("./src/remote-tools");
                    var _fileUpdatedCb = (D, A, w) => {
                        if (Dz(D)) return;
                        this.send({
                            type: "file_updated",
                            channelId: v,
                            filePath: D,
                            oldContent: A,
                            newContent: w
                        });
                    };
                    // --- forceLocal: _reviewEdit callback for review mode ---
                    // Sends tool_permission_request to webview, which triggers dialog + open_diff.
                    // RY() handles the diff tab natively (blocks until Accept/Reject).
                    // User modifications stored via setEditOverride() in RY(), consumed here.
                    var _selfIJ = this;
                    var _forceLocalAcceptAll = false;
                    // Track runtime permission mode (N = initial mode from launch_claude)
                    var _forceLocalPermMode = N || _selfIJ.settings.getInitialPermissionMode() || "default";
                    var _origSetPermissionMode = _selfIJ.setPermissionMode.bind(_selfIJ);
                    _selfIJ.setPermissionMode = async function(_v, _z) {
                        if (_v === v) _forceLocalPermMode = _z;
                        return _origSetPermissionMode(_v, _z);
                    };
                    var _reviewEdit = async function(mcpToolName, toolInput, oldContent, newContent) {
                        var vsc = require("vscode");
                        var config = vsc.workspace.getConfiguration("claudeCode");
                        var diffMode = config.get("forceLocalDiffMode", "auto");
                        if (diffMode !== "review") return { accepted: true, finalContent: newContent };

                        // Bypass review if permission mode is "bypassPermissions" or "acceptEdits"
                        if (_forceLocalPermMode === "bypassPermissions" || _forceLocalPermMode === "acceptEdits") return { accepted: true, finalContent: newContent };
                        // Bypass review if user chose "allow all edits this session" (button 2)
                        if (_forceLocalAcceptAll) return { accepted: true, finalContent: newContent };

                        var _rt = require("./src/remote-tools");
                        var remotePath = _rt.toRemotePath(toolInput.file_path);

                        // Send tool_permission_request  triggers webview dialog AND open_diff  RY().
                        // RY() handles the diff tab natively (blocks until Accept/Reject).
                        var webviewToolName = mcpToolName === "edit_file" ? "Edit" : "Write";
                        var webviewInputs = Object.assign({}, toolInput, { file_path: remotePath });

                        try {
                            var response = await _selfIJ.sendRequest(v, {
                                type: "tool_permission_request",
                                toolName: webviewToolName,
                                inputs: webviewInputs,
                                suggestions: [{ type: "setMode", mode: "acceptEdits", destination: "session" }]
                            }, null);

                            var accepted = response.result.behavior === "allow";

                            if (accepted) {
                                // Check if user chose "allow all edits this session"
                                var perms = response.result.updatedPermissions;
                                if (perms && perms.length > 0) {
                                    for (var _p = 0; _p < perms.length; _p++) {
                                        if (perms[_p].type === "setMode" && perms[_p].mode === "acceptEdits") {
                                            _forceLocalAcceptAll = true;
                                            break;
                                        }
                                    }
                                }
                                // RY() stores user-modified content via setEditOverride() on Accept.
                                // Consume it here; falls back to original newContent if no override.
                                var override = _rt.consumeEditOverride(remotePath);
                                var finalContent = override !== null ? override : newContent;
                                return { accepted: true, finalContent: finalContent };
                            } else {
                                return { accepted: false };
                            }
                        } catch (e) {
                            (_selfIJ.output || _selfIJ.logger).warn("forceLocal: reviewEdit error", e.message || e);
                            return { accepted: false };
                        }
                    };
                    _remoteTools2.registerTools(j.instance, s, this.output || this.logger, _fileUpdatedCb, _reviewEdit);
                    (this.output || this.logger).info("forceLocal: registered remote tools on in-process MCP server. Tools: " + Object.keys(j.instance._registeredTools).length);
                } catch (_rtErr2) {
                    (this.output || this.logger).error("forceLocal: FAILED to register remote tools on in-process MCP server: " + (_rtErr2.message || _rtErr2));
                }
            }
            let B = this.getAdditionalMcpServers(),
                O = {
                    "claude-vscode": j,
                    ...B
                },
                J = await this.spawnClaude(x, z, async (D, A, w) => {
                    return this.requestToolPermission(v, D, A, w.suggestions || [], w.signal)
                }, V || null, U, N, this.settings.getAllowDangerouslySkipPermissions(), this.getMaxThinkingTokensForModel(K), O),
                q, H = new Promise((D) => {
                    q = D
                });
            this.channels.set(v, {
                in: x,
                query: J,
                pid: H,
                resolvePid: q,
                vscodeMcpServer: j,
                mcpServers: {},
                chromeMcpState: {
                    status: "disconnected"
                },
                debuggerMcpState: this.getInitialDebuggerState(),
                jupyterMcpState: this.getInitialJupyterState()
            }), this.claudeLaunched(v), J.initializationResult().then((D) => {
                q(D.pid ?? 0)
            }).catch(() => {
                q(0)
            }), (async () => {
                // --- forceLocal: transform MCP tool names to built-in names for webview rendering ---
                var _mcpToBuiltinName = {
                    "mcp__claude-vscode__read_file": "Read",
                    "mcp__claude-vscode__write_file": "Write",
                    "mcp__claude-vscode__edit_file": "Edit",
                    "mcp__claude-vscode__glob": "Glob",
                    "mcp__claude-vscode__grep": "Grep",
                    "mcp__claude-vscode__bash": "Bash"
                };
                var _transformForWebview = function(D) {
                    if (!isForceLocalMode()) return D;
                    // Primary path: transform assistant messages with tool_use content blocks
                    if (D.type === "assistant" && D.message && Array.isArray(D.message.content)) {
                        var _changed = false;
                        var _newContent = D.message.content.map(function(c) {
                            if (c.type === "tool_use" && c.name && _mcpToBuiltinName[c.name]) {
                                _changed = true;
                                var _transformed = Object.assign({}, c, { name: _mcpToBuiltinName[c.name] });
                                if (_transformed.input && _transformed.input.file_path) {
                                    try {
                                        var _rt_xf = require("./src/remote-tools");
                                        _transformed.input = Object.assign({}, _transformed.input, {
                                            file_path: _rt_xf.toRemotePath(_transformed.input.file_path)
                                        });
                                    } catch (_) {}
                                }
                                return _transformed;
                            }
                            return c;
                        });
                        if (_changed) return Object.assign({}, D, { message: Object.assign({}, D.message, { content: _newContent }) });
                    }
                    return D;
                };
                try {
                    for await (let D of J) {
                        var _D = _transformForWebview(D);
                        this.send({
                            type: "io_message",
                            channelId: v,
                            message: _D,
                            done: !1
                        });
                        sb(_D);
                    }
                    this.closeChannel(v, !0)
                } catch (D) {
                    this.closeChannel(v, !0, String(D)), this.logger.error(`Error from Claude (on channel ${v}): ${D}`)
                }
            })()
        } catch (x) {
            this.closeChannel(v, !0, String(x)), this.logger.error(`Error spawning Claude (on channel ${v}): ${x}`)
        }
    }
    claudeLaunched(v) {}
    async requestToolPermission(v, z, U, V, N) {
        if (this.channels.get(v)?.chromeMcpState.status === "connected" && z.startsWith("mcp__claude-in-chrome__")) return {
            behavior: "allow",
            updatedInput: U
        };
        let x = await this.sendRequest(v, {
            type: "tool_permission_request",
            toolName: z,
            inputs: U,
            suggestions: V
        }, N);
        return tb(z, x), x.result
    }
    sendRequest(v, z, U) {
        let V = e8();
        return new Promise((N, K) => {
            if (this.outstandingRequests.set(V, {
                    resolve: (x) => {
                        N(x)
                    },
                    reject: K
                }), U) {
                let x = () => {
                    this.outstandingRequests.delete(V), this.send({
                        type: "cancel_request",
                        targetRequestId: V
                    }), K(Error(U.reason || "aborted"))
                };
                if (U.aborted) {
                    x();
                    return
                }
                U.addEventListener("abort", x, {
                    once: !0
                })
            }
            this.send({
                type: "request",
                channelId: v,
                requestId: V,
                request: z
            })
        }).finally(() => {
            this.outstandingRequests.delete(V)
        })
    }
    async interruptClaude(v) {
        let z = this.channels.get(v);
        if (!z) {
            this.logger.warn(`Channel not found: ${v}`);
            return
        }
        try {
            await z.query.interrupt(), this.logger.log(`Interrupted Claude for requestId: ${v}`)
        } catch (U) {
            this.logger.error(`Failed to interrupt Claude: ${U}`)
        }
    }
    logEvent(v, z, U = {}) {
        let V = this.channels.get(v);
        if (!V) {
            this.logger.warn(`Channel not found for logEvent: ${v}`);
            return
        }
        $S(V.vscodeMcpServer, z, U)
    }
    async handleStartSpeechToText(v) {
        throw Error("Speech-to-text is not supported in this environment")
    }
    async handleStopSpeechToText(v) {
        throw Error("Speech-to-text is not supported in this environment")
    }
    async closeChannel(v, z, U) {
        if (this.logger.log(`Closing Claude on channel: ${v}`), z) this.send({
            type: "close_channel",
            channelId: v,
            error: U
        });
        let V = this.channels.get(v);
        if (V) {
            V.in.done();
            try {
                await V.query.return()
            } catch (N) {
                this.logger.warn(`Error cleaning up channel ${v}: ${N}`)
            }
            this.channels.delete(v)
        }
    }
    transportMessage(v, z, U) {
        let V = this.channels.get(v);
        if (!V) throw Error(`Channel not found: ${v}`);
        if (z.type === "user") V.in.enqueue(z);
        if (U) V.in.done()
    }
    async shutdown() {
        await this.closeAllChannels(), this.fromClientStream.done()
    }
    async closeAllChannels() {
        let v = Array.from(this.channels.keys()).map((z) => this.closeChannel(z, !1));
        await Promise.all(v), this.channels.clear()
    }
    async closeAllChannelsWithCredentialChange() {
        this.invalidateConfigCache();
        let v = Array.from(this.channels.keys()).map((z) => this.closeChannel(z, !0));
        await Promise.all(v), this.channels.clear()
    }
    invalidateConfigCache() {
        this.config = void 0
    }
    loadConfig() {
        if (this.config) return this.config;
        this.logger.log("Loading config cache by launching Claude...");
        let v = (async () => {
            let z = new l7,
                U = await this.spawnClaude(z, void 0, async () => ({
                    behavior: "deny",
                    message: "Config loading only"
                }), "default", this.cwd, "default", !1, 0, void 0);
            z.done();
            let V = await U.initializationResult();
            return U.return(), V
        })().catch((z) => {
            throw this.logger.error(`Failed to load config cache: ${z}`), this.config = void 0, z
        });
        return this.config = v, v
    }
    async getMcpServers(v) {
        let z = v ? this.channels.get(v) : void 0;
        if (!z) throw Error(`Channel not found: ${v}`);
        try {
            return {
                type: "get_mcp_servers_response",
                mcpServers: (await z.query.mcpServerStatus()).filter((V) => V.name !== "claude-vscode")
            }
        } catch (U) {
            return this.logger.error(`Error fetching MCP servers: ${U}`), {
                type: "get_mcp_servers_response",
                mcpServers: []
            }
        }
    }
    async setMcpServerEnabled(v, z, U) {
        let V = this.channels.get(v);
        if (!V) return {
            type: "set_mcp_server_enabled_response",
            success: !1,
            error: `Channel not found: ${v}`
        };
        try {
            return this.logger.log(`[MCP Management] ${U?"Enabling":"Disabling"} server: ${z}`), await V.query.toggleMcpServer(z, U), {
                type: "set_mcp_server_enabled_response",
                success: !0
            }
        } catch (N) {
            return this.logger.error(`Error setting MCP server enabled state: ${N}`), {
                type: "set_mcp_server_enabled_response",
                success: !1,
                error: N instanceof Error ? N.message : String(N)
            }
        }
    }
    async reconnectMcpServer(v, z) {
        let U = this.channels.get(v);
        if (!U) return {
            type: "reconnect_mcp_server_response",
            success: !1,
            error: `Channel not found: ${v}`
        };
        try {
            return this.logger.log(`[MCP Management] Reconnecting server: ${z}`), await U.query.reconnectMcpServer(z), {
                type: "reconnect_mcp_server_response",
                success: !0
            }
        } catch (V) {
            return this.logger.error(`Error reconnecting MCP server: ${V}`), {
                type: "reconnect_mcp_server_response",
                success: !1,
                error: V instanceof Error ? V.message : String(V)
            }
        }
    }
    async ensureChromeMcpEnabled(v) {
        let z = this.channels.get(v);
        if (!z) throw Error(`Channel not found: ${v}`);
        let U = z.chromeMcpState.status === "disconnected";
        this.logEvent(v, "chrome_mcp_ensure_enabled"), z.chromeMcpState = {
            status: "connecting"
        }, await this.pushChannelStateUpdate(v);
        try {
            let V = this.getChromeMcpServerConfig(),
                N = {
                    ...z.mcpServers,
                    "claude-in-chrome": V
                },
                K = await z.query.setMcpServers(N);
            if (K.errors && Object.keys(K.errors).length > 0) {
                let x = Object.entries(K.errors).map(([j, B]) => `${j}: ${B}`).join(", ");
                throw Error(x)
            }
            return z.mcpServers = N, z.chromeMcpState = {
                status: "connected"
            }, await this.pushChannelStateUpdate(v), {
                type: "ensure_chrome_mcp_enabled_response",
                wasDisabled: U
            }
        } catch (V) {
            let N = V instanceof Error ? V.message : "Unknown error";
            throw z.chromeMcpState = {
                status: "error",
                error: N
            }, await this.pushChannelStateUpdate(v), V
        }
    }
    async disableChromeMcp(v) {
        let z = this.channels.get(v);
        if (!z) throw Error(`Channel not found: ${v}`);
        let U = z.chromeMcpState.status === "connected",
            {
                "claude-in-chrome": V,
                ...N
            } = z.mcpServers;
        if (await z.query.setMcpServers(N), z.mcpServers = N, z.chromeMcpState = {
                status: "disconnected"
            }, await this.pushChannelStateUpdate(v), U) {
            let K = {
                type: "user",
                session_id: "",
                parent_tool_use_id: null,
                isSynthetic: !0,
                message: {
                    role: "user",
                    content: "[Browser disconnected: The browser connection has been closed. Browser tools are no longer available.]"
                }
            };
            z.in.enqueue(K)
        }
        return {
            type: "disable_chrome_mcp_response",
            wasEnabled: U
        }
    }
    async createNewBrowserTab() {
        throw Error("createNewBrowserTab must be implemented by subclass")
    }
    getChromeMcpServerConfig() {
        throw Error("getChromeMcpServerConfig must be implemented by subclass")
    }
    async askDebuggerHelp(v) {
        throw Error("askDebuggerHelp must be implemented by subclass")
    }
    getAdditionalMcpServers() {
        return {}
    }
    getInitialDebuggerState() {
        return {
            status: "inactive"
        }
    }
    getInitialJupyterState() {
        return {
            status: "inactive"
        }
    }
    async enableJupyterMcp(v) {
        throw Error("enableJupyterMcp must be implemented by subclass")
    }
    async disableJupyterMcp(v) {
        throw Error("disableJupyterMcp must be implemented by subclass")
    }
    async handleRequest(v) {
        let z = new AbortController;
        try {
            this.abortControllers.set(v.requestId, z);
            let U = await this.processRequest(v, z.signal);
            this.send({
                type: "response",
                requestId: v.requestId,
                response: U
            })
        } catch (U) {
            this.logger.error(`Error processing client request: ${U}`), this.send({
                type: "response",
                requestId: v.requestId,
                response: {
                    type: "error",
                    error: U instanceof Error ? U.message : String(U)
                }
            })
        } finally {
            this.abortControllers.delete(v.requestId)
        }
    }
    async processRequest(v, z) {
        switch (v.request.type) {
            case "init": {
                let U = this.authManager?.getAuthStatus(),
                    V = v.channelId ? this.channels.get(v.channelId) : void 0;
                if (this.cachedCurrentRepo === void 0) {
                    let K = await this.teleportService.detectCurrentRepository();
                    if (K) {
                        let [x, j] = K.split("/");
                        if (x && j) this.cachedCurrentRepo = {
                            owner: x,
                            name: j
                        }
                    }
                }
                let N = this.cachedCurrentRepo;
                return {
                    type: "init_response",
                    state: {
                        defaultCwd: this.cwd,
                        openNewInTab: this.openNewInTab,
                        showTerminalBanner: this.showTerminalBanner,
                        showReviewUpsellBanner: this.showReviewUpsellBanner || !1,
                        isOnboardingEnabled: this.experimentGates.tengu_vscode_onboarding || !1,
                        isOnboardingDismissed: this.getIsOnboardingDismissed(),
                        authStatus: U,
                        modelSetting: this.settings.getModel(),
                        thinkingLevel: this.settings.getThinkingLevel(),
                        initialPermissionMode: this.settings.getInitialPermissionMode(),
                        allowDangerouslySkipPermissions: this.settings.getAllowDangerouslySkipPermissions(),
                        platform: this.getPlatform(),
                        speechToTextEnabled: this.isSpeechToTextEnabled(),
                        marketplaceType: this.getMarketplaceType(),
                        useCtrlEnterToSend: this.settings.getUseCtrlEnterToSend(),
                        chromeMcpState: V?.chromeMcpState ?? {
                            status: "disconnected"
                        },
                        browserIntegrationSupported: this.isBrowserIntegrationSupported(),
                        debuggerMcpState: V?.debuggerMcpState ?? this.getInitialDebuggerState(),
                        jupyterMcpState: V?.jupyterMcpState ?? this.getInitialJupyterState(),
                        spinnerVerbsConfig: this.settings.getSpinnerVerbsConfig(),
                        currentRepo: N
                    }
                }
            }
            case "get_claude_state":
                return {
                    type: "get_claude_state_response", config: await this.loadConfig()
                };
            case "get_mcp_servers":
                return await this.getMcpServers(v.channelId);
            case "set_mcp_server_enabled": {
                if (!v.channelId) throw Error("channelId is required for set_mcp_server_enabled");
                return await this.setMcpServerEnabled(v.channelId, v.request.serverName, v.request.enabled)
            }
            case "reconnect_mcp_server": {
                if (!v.channelId) throw Error("channelId is required for reconnect_mcp_server");
                return await this.reconnectMcpServer(v.channelId, v.request.serverName)
            }
            case "ensure_chrome_mcp_enabled": {
                if (!v.channelId) throw Error("channelId is required for ensure_chrome_mcp_enabled");
                return await this.ensureChromeMcpEnabled(v.channelId)
            }
            case "disable_chrome_mcp": {
                if (!v.channelId) throw Error("channelId is required for disable_chrome_mcp");
                return await this.disableChromeMcp(v.channelId)
            }
            case "ask_debugger_help": {
                if (!v.channelId) throw Error("channelId is required for ask_debugger_help");
                return await this.askDebuggerHelp(v.channelId)
            }
            case "enable_jupyter_mcp": {
                if (!v.channelId) throw Error("channelId is required for enable_jupyter_mcp");
                return await this.enableJupyterMcp(v.channelId)
            }
            case "disable_jupyter_mcp": {
                if (!v.channelId) throw Error("channelId is required for disable_jupyter_mcp");
                return await this.disableJupyterMcp(v.channelId)
            }
            case "create_new_browser_tab":
                return await this.createNewBrowserTab();
            case "list_sessions_request":
                return this.listSessions();
            case "list_remote_sessions":
                return this.listRemoteSessions();
            case "teleport_session":
                return this.teleportSession(v.request.sessionId);
            case "checkout_branch":
                return this.checkoutBranch(v.request.branch);
            case "check_git_status":
                return this.checkGitStatus();
            case "update_skipped_branch":
                return this.updateSkippedBranch(v.request.sessionId, v.request.branch, v.request.failed);
            case "open_file":
                return this.openFile(v.request.filePath, v.request.location), {
                    type: "open_file_response"
                };
            case "get_session_request":
                return this.getSession(v.request.sessionId);
            case "exec":
                return this.execCommand(v.request.command, v.request.params);
            case "list_files_request":
                return {
                    type: "list_files_response", files: await this.findFiles(v.request.pattern)
                };
            case "get_terminal_contents":
                return this.logEvent(v.channelId || "", "get_terminal_contents"), {
                    type: "get_terminal_contents_response",
                    content: await this.getTerminalContents(v.request.terminalName)
                };
            case "open_diff":
                return this.openDiff(v.request.originalFilePath, v.request.newFilePath, v.request.edits, v.request.supportMultiEdits || !1, z);
            case "open_content":
                return this.openContent(v.request.content, v.request.fileName, v.request.editable, z);
            case "open_markdown_preview":
                return this.openMarkdownPreview(v.request.channelId, v.request.content, v.request.title);
            case "get_plan_comments":
                return this.getPlanComments(v.request.channelId);
            case "remove_plan_comment":
                return this.removePlanComment(v.request.channelId, v.request.commentId);
            case "close_plan_preview":
                return this.closePlanPreview(v.request.channelId);
            case "get_asset_uris":
                return {
                    type: "asset_uris_response", assetUris: this.getAssetUris()
                };
            case "open_url":
                return await this.openURL(v.request.url), {
                    type: "open_url_response"
                };
            case "set_permission_mode":
                return this.setPermissionMode(v.channelId, v.request.mode);
            case "set_model":
                return this.setModel(v.channelId, v.request.model);
            case "set_thinking_level":
                return this.setThinkingLevel(v.channelId, v.request.thinkingLevel);
            case "get_auth_status":
                return {
                    type: "get_auth_status_response", status: this.authManager?.getAuthStatus()
                };
            case "login": {
                if (!this.authManager) throw Error("Authentication is not supported in this environment");
                let {
                    method: U
                } = v.request, V = await this.authManager.login(U, async (N) => {
                    this.send({
                        type: "request",
                        channelId: "",
                        requestId: e8(),
                        request: {
                            type: "auth_url",
                            url: N.manualRedirectUrl,
                            method: U
                        }
                    });
                    try {
                        await this.openURL(N.automaticRedirectUrl)
                    } catch (K) {
                        this.logger.warn(`Failed to open browser: ${K}`)
                    }
                });
                return await this.closeAllChannelsWithCredentialChange(), {
                    type: "login_response",
                    auth: V
                }
            }
            case "submit_oauth_code": {
                if (!this.authManager) throw Error("Authentication is not supported in this environment");
                let {
                    code: U
                } = v.request;
                return this.authManager.handleManualAuthCode(U), {
                    type: "submit_oauth_code_response"
                }
            }
            case "open_config_file":
                return this.openConfigFile(v.request.configType), {
                    type: "open_config_file_response"
                };
            case "open_claude_in_terminal":
                return await this.openClaudeInTerminal(v.request.prompt, v.request.args, v.request.location), {
                    type: "open_claude_in_terminal_response"
                };
            case "open_terminal":
                return await this.openTerminal(v.request.executable, v.request.args, v.request.cwd, v.request.location, v.channelId), {
                    type: "open_terminal_response"
                };
            case "show_claude_terminal_setting":
                return await this.showClaudeTerminalSetting(), {
                    type: "show_claude_terminal_setting_response"
                };
            case "dismiss_terminal_banner":
                return await this.dismissTerminalBanner(), {
                    type: "dismiss_terminal_banner_response"
                };
            case "dismiss_review_upsell_banner":
                return await this.dismissReviewUpsellBanner(v.request.metadata), {
                    type: "dismiss_review_upsell_banner_response"
                };
            case "dismiss_onboarding":
                return await this.dismissOnboarding(v.request.dismissType), {
                    type: "dismiss_onboarding_response"
                };
            case "log_event": {
                let U = v.channelId || "";
                return this.logEvent(U, v.request.eventName, v.request.eventData), {
                    type: "log_event_response"
                }
            }
            case "open_folder":
                return {
                    type: "open_folder_response", opened: await this.openFolderPicker()
                };
            case "open_config":
                return await this.openConfig(v.request.searchString), {
                    type: "open_config_response"
                };
            case "open_help":
                return await this.openHelp(), {
                    type: "open_help_response"
                };
            case "open_output_panel":
                return await this.openOutputPanel(), {
                    type: "open_output_panel_response"
                };
            case "fork_conversation":
                return {
                    type: "fork_conversation_response", sessionId: await (await B3.load(this.cwd, this.logger)).forkSession(v.request.forkedFromSession, v.request.resumeSessionAt)
                };
            case "rewind_code": {
                let U = v.channelId ? this.channels.get(v.channelId) : void 0;
                if (!U) throw Error(`Channel not found: ${v.channelId}`);
                return {
                    type: "rewind_code_response",
                    ...await U.query.rewindFiles(v.request.userMessageId, {
                        dryRun: v.request.dryRun
                    })
                }
            }
            case "open_file_diffs":
                return await this.openFileDiffs(v.request.fileDiffs), {
                    type: "open_file_diffs_response"
                };
            case "request_usage_update":
                return await this.handleUsageUpdateRequest(), {
                    type: "request_usage_update_response"
                };
            case "list_plugins":
                return await this.pluginManager.listPlugins(this.cwd, {
                    includeAvailable: v.request.includeAvailable
                });
            case "list_marketplaces":
                return await this.pluginManager.listMarketplaces(this.cwd);
            case "install_plugin":
                return await this.pluginManager.installPlugin(v.request.pluginId, v.request.scope, this.cwd);
            case "uninstall_plugin":
                return await this.pluginManager.uninstallPlugin(v.request.pluginId, this.cwd);
            case "set_plugin_enabled":
                return await this.pluginManager.setPluginEnabled(v.request.pluginId, v.request.enabled, this.cwd);
            case "add_marketplace":
                return await this.pluginManager.addMarketplace(v.request.source, this.cwd);
            case "remove_marketplace":
                return await this.pluginManager.removeMarketplace(v.request.marketplaceId, this.cwd);
            case "refresh_marketplace":
                return await this.pluginManager.refreshMarketplace(v.request.marketplaceId, this.cwd);
            default:
        }
        throw Error("Unknown request type.")
    }
    async loadSessionsFromPath(v, z, U) {
        try {
            let N = (await (await B3.load(v, this.logger)).fetchSessions()).filter((x) => {
                    return !x.isSidechain
                }),
                K = new Map;
            for (let x of N) {
                let j = K.get(x.id);
                if (!j) K.set(x.id, {
                    id: x.id,
                    lastModified: x.lastModified,
                    messageCount: x.messageCount,
                    summary: x.summary,
                    gitBranch: x.gitBranch,
                    worktree: z,
                    isCurrentWorkspace: U,
                    teleportedFromSessionId: x.teleportedFromSessionId,
                    teleportBranch: x.teleportBranch,
                    teleportedMessageCount: x.teleportedMessageCount,
                    skippedBranch: x.skippedBranch,
                    branchCheckoutFailed: x.branchCheckoutFailed
                });
                else {
                    let B = x.lastModified > j.lastModified,
                        O = j.summary !== "No prompt",
                        q = x.summary !== "No prompt" && !O ? x.summary : j.summary,
                        H = B ? x : j;
                    K.set(x.id, {
                        id: x.id,
                        lastModified: H.lastModified,
                        messageCount: H.messageCount,
                        summary: q,
                        gitBranch: H.gitBranch,
                        worktree: z,
                        isCurrentWorkspace: U,
                        teleportedFromSessionId: H.teleportedFromSessionId,
                        teleportBranch: H.teleportBranch,
                        teleportedMessageCount: H.teleportedMessageCount,
                        skippedBranch: H.skippedBranch,
                        branchCheckoutFailed: H.branchCheckoutFailed
                    })
                }
            }
            return [...K.values()]
        } catch (V) {
            return this.logger.warn(`Failed to load sessions from ${v}: ${V}`), []
        }
    }
    async listSessions() {
        let v = [],
            z = await this.loadSessionsFromPath(this.cwd, void 0, !0);
        return v.push(...z), ab(v), {
            type: "list_sessions_response",
            sessions: v
        }
    }
    async getSession(v) {
        let z = await B3.load(this.cwd, this.logger),
            U = z.getSessionMessages(v),
            V = await z.getSessionDiffs(v, this.cwd, U);
        return {
            type: "get_session_response",
            messages: U,
            sessionDiffs: V
        }
    }
    async listRemoteSessions() {
        try {
            return {
                type: "list_remote_sessions_response",
                sessions: await this.teleportService.fetchRemoteSessions()
            }
        } catch (v) {
            return this.logger.error(`Failed to list remote sessions: ${v}`), {
                type: "list_remote_sessions_response",
                sessions: [],
                error: v instanceof Error ? v.message : String(v)
            }
        }
    }
    async teleportSession(v) {
        this.logger.log(`Teleport started for session ${v}`);
        let z = Date.now();
        try {
            let V = function(O) {
                    let J = O.uuid;
                    if (O.type === "user") return {
                        type: "user",
                        message: O.message,
                        uuid: J,
                        session_id: O.sessionId,
                        parent_tool_use_id: null
                    };
                    if (O.type === "assistant") return {
                        type: "assistant",
                        message: O.message,
                        uuid: J,
                        session_id: O.sessionId,
                        parent_tool_use_id: null
                    };
                    return null
                },
                U = await this.teleportService.teleportSession(v);
            if (!U) return this.logger.error(`Teleport failed for session ${v} after ${Date.now()-z}ms: failed to fetch session`), {
                type: "teleport_session_response",
                success: !1,
                error: "Failed to fetch session"
            };
            let N = U.messages.map(V).filter((O) => O !== null),
                {
                    randomUUID: K
                } = await import("crypto"),
                x = K();
            await (await B3.load(this.cwd, this.logger)).saveSession(x, N, U.title, v, U.branch), this.logger.log(`Teleport succeeded for session ${v} in ${Date.now()-z}ms (${N.length} messages)`);
            let B = U.branch;
            if (B) {
                if ((await this.execCommand("git", ["rev-parse", "--verify", `refs/heads/${B}`])).exitCode !== 0) {
                    let J = await this.execCommand("git", ["ls-remote", "--heads", "origin", B]);
                    if (J.exitCode !== 0 || !J.stdout.trim()) this.logger.log(`Branch ${B} does not exist locally or remotely, skipping checkout prompt`), B = void 0
                }
            }
            return {
                type: "teleport_session_response",
                success: !0,
                messages: N,
                branch: B,
                localSessionId: x,
                summary: U.title || void 0
            }
        } catch (U) {
            return this.logger.error(`Teleport failed for session ${v} after ${Date.now()-z}ms: ${U}`), {
                type: "teleport_session_response",
                success: !1,
                error: U instanceof Error ? U.message : String(U)
            }
        }
    }
    async checkoutBranch(v) {
        try {
            if ((await this.execCommand("git", ["fetch", "origin", `${v}:${v}`])).exitCode !== 0) {
                let V = await this.execCommand("git", ["fetch", "origin", v]);
                if (V.exitCode !== 0) return this.logger.error(`Failed to fetch branch ${v}: ${V.stderr}`), {
                    type: "checkout_branch_response",
                    success: !1,
                    error: `Failed to fetch branch: ${V.stderr.trim()}`
                }
            }
            let U = await this.execCommand("git", ["checkout", v]);
            if (U.exitCode !== 0) this.logger.log("Local checkout failed, trying to create tracking branch from origin"), U = await this.execCommand("git", ["checkout", "-b", v, "--track", `origin/${v}`]);
            if (U.exitCode !== 0) U = await this.execCommand("git", ["checkout", "--track", `origin/${v}`]);
            if (U.exitCode !== 0) return this.logger.error(`Failed to checkout branch ${v}: ${U.stderr}`), {
                type: "checkout_branch_response",
                success: !1,
                error: `Failed to check out branch: ${U.stderr.trim()}`
            };
            return await this.execCommand("git", ["branch", "--set-upstream-to", `origin/${v}`, v]), this.logger.log(`Successfully checked out branch ${v}`), {
                type: "checkout_branch_response",
                success: !0
            }
        } catch (z) {
            return this.logger.error(`Error checking out branch ${v}: ${z}`), {
                type: "checkout_branch_response",
                success: !1,
                error: z instanceof Error ? z.message : String(z)
            }
        }
    }
    async checkGitStatus() {
        try {
            let z = (await this.execCommand("git", ["status", "--porcelain", "-uno"])).stdout.trim(),
                U = z.length === 0,
                V = U ? [] : z.split(`
`).filter(Boolean);
            return this.logger.log(`Git status check: ${U?"clean":`dirty (${V.length} changed files)`}`), {
                type: "check_git_status_response",
                isClean: U,
                changedFiles: V
            }
        } catch (v) {
            return this.logger.error(`Error checking git status: ${v}`), {
                type: "check_git_status_response",
                isClean: !1
            }
        }
    }
    async updateSkippedBranch(v, z, U) {
        try {
            return await (await B3.load(this.cwd, this.logger)).appendSkippedBranch(v, z, U), {
                type: "update_skipped_branch_response",
                success: !0
            }
        } catch (V) {
            return this.logger.error(`Error updating skipped branch: ${V}`), {
                type: "update_skipped_branch_response",
                success: !1
            }
        }
    }
    handleCancellation(v) {
        let z = this.abortControllers.get(v);
        if (z) z.abort()
    }
    async execCommand(v, z) {
        let U = "",
            V = "",
            N = BT.spawn(v, z, {
                cwd: this.cwd,
                shell: !1
            });
        N.stdout.on("data", (x) => {
            U += x.toString()
        }), N.stderr.on("data", (x) => {
            V += x.toString()
        });
        let K = await new Promise((x) => {
            N.on("close", (j) => {
                x(j ?? 0)
            }), N.on("error", (j) => {
                V += j.message, x(1)
            })
        });
        return {
            type: "exec_response",
            stdout: U,
            stderr: V,
            exitCode: K
        }
    }
    async createSpeechToTextStream() {
        throw Error("Speech-to-text is not supported in this environment")
    }
    isSpeechToTextEnabled() {
        return !1
    }
    getAssetUris() {
        return pb()
    }
    async setPermissionMode(v, z) {
        let U = v ? this.channels.get(v) : void 0;
        if (!U) throw Error(`Channel not found: ${v}`);
        try {
            return await U.query.setPermissionMode(z), {
                type: "set_permission_mode_response",
                success: !0
            }
        } catch (V) {
            return this.logger.error(`Failed to set permission mode: ${V}`), {
                type: "set_permission_mode_response",
                success: !1
            }
        }
    }
    async setModel(v, z) {
        let U = v ? this.channels.get(v) : void 0;
        if (!U) throw Error(`Channel not found: ${v}`);
        let V = this.settings.getModel();
        try {
            return await this.settings.setModel(z.value), await U.query.setModel(z.value), {
                type: "set_model_response",
                success: !0
            }
        } catch (N) {
            this.logger.error(`Failed to set model: ${N}`);
            try {
                await this.settings.setModel(V)
            } catch {}
            return {
                type: "set_model_response",
                success: !1,
                error: N instanceof Error ? N.message : String(N)
            }
        }
    }
    async setThinkingLevel(v, z) {
        let U = v ? this.channels.get(v) : void 0;
        if (!U) throw Error(`Channel not found: ${v}`);
        let V = this.getMaxThinkingTokensForModel(z);
        return await U.query.setMaxThinkingTokens(V), await this.settings.setThinkingLevel(z), {
            type: "set_thinking_level_response"
        }
    }
    getPlatform() {
        switch (process.platform) {
            case "win32":
                return "windows";
            case "darwin":
                return "macos";
            default:
                return "linux"
        }
    }
    isBrowserIntegrationSupported() {
        return !1
    }
    async pushStateUpdate() {
        let v = await this.loadConfig(),
            z = {
                type: "request",
                channelId: "",
                requestId: e8(),
                request: {
                    type: "update_state",
                    state: this.getCurrentState(),
                    config: v
                }
            };
        this.send(z)
    }
    getCurrentState() {
        let v = this.authManager?.getAuthStatus();
        return {
            defaultCwd: this.cwd,
            openNewInTab: this.openNewInTab,
            showTerminalBanner: this.showTerminalBanner,
            showReviewUpsellBanner: this.showReviewUpsellBanner ?? !1,
            isOnboardingEnabled: this.experimentGates.tengu_vscode_onboarding ?? !1,
            isOnboardingDismissed: this.getIsOnboardingDismissed(),
            authStatus: v,
            modelSetting: this.settings.getModel(),
            thinkingLevel: this.settings.getThinkingLevel(),
            allowDangerouslySkipPermissions: this.settings.getAllowDangerouslySkipPermissions(),
            initialPermissionMode: this.settings.getInitialPermissionMode(),
            platform: this.getPlatform(),
            speechToTextEnabled: this.isSpeechToTextEnabled(),
            marketplaceType: this.getMarketplaceType(),
            useCtrlEnterToSend: this.settings.getUseCtrlEnterToSend(),
            chromeMcpState: {
                status: "disconnected"
            },
            browserIntegrationSupported: this.isBrowserIntegrationSupported(),
            debuggerMcpState: {
                status: "inactive"
            },
            jupyterMcpState: {
                status: "inactive"
            },
            spinnerVerbsConfig: this.settings.getSpinnerVerbsConfig(),
            currentRepo: this.cachedCurrentRepo
        }
    }
    async pushChannelStateUpdate(v) {
        let z = this.channels.get(v);
        if (!z) return;
        let U = await this.loadConfig(),
            V = this.getCurrentState();
        V.chromeMcpState = z.chromeMcpState, V.debuggerMcpState = z.debuggerMcpState, V.jupyterMcpState = z.jupyterMcpState;
        let N = {
            type: "request",
            channelId: v,
            requestId: e8(),
            request: {
                type: "update_state",
                state: V,
                config: U
            }
        };
        this.send(N)
    }
    async handleUsageUpdateRequest() {
        await this.onUsageUpdateRequested()
    }
    async onUsageUpdateRequested() {
        let {
            utilization: v,
            error: z
        } = await this.fetchUsageData();
        this.sendUsageUpdate(v, z)
    }
    async fetchUsageData() {
        try {
            return {
                utilization: await vf(this.authManager, this.logger)
            }
        } catch (v) {
            return {
                error: v instanceof Error ? v.message : String(v)
            }
        }
    }
    sendUsageUpdate(v, z) {
        let U = {
            type: "request",
            channelId: "",
            requestId: e8(),
            request: {
                type: "usage_update",
                utilization: v,
                error: z
            }
        };
        this.send(U)
    }
    async generateAndPushProactiveSuggestions(v) {
        if (process.env.CLAUDE_PROACTIVE_SUGGESTIONS !== "true") return;
        try {
            let {
                pathToClaudeCodeExecutable: z,
                executableArgs: U,
                env: V
            } = this.getClaudeBinary(), N = await US({
                cwd: this.cwd,
                logger: this.logger,
                pathToClaudeCodeExecutable: z,
                executableArgs: U,
                env: V
            });
            if (N.suggestions.length > 0) {
                let K = {
                    type: "request",
                    channelId: v,
                    requestId: e8(),
                    request: {
                        type: "proactive_suggestions_update",
                        suggestions: N.suggestions
                    }
                };
                this.send(K)
            }
        } catch (z) {
            this.logger.warn(`Failed to generate proactive suggestions: ${z}`)
        }
    }
    getMaxThinkingTokensForModel(v) {
        if (v === "off") return 0;
        return 31999
    }
}
var z6 = o(require("vscode"));
var e4 = o(require("vscode")),
    ov = require("fs"),
    _2 = require("os"),
    ux = require("path"),
    yx = require("child_process");
var T3 = o(require("vscode"));
class P2 {
    context;
    constructor(v) {
        this.context = v
    }
    getModel() {
        let v = R4("selectedModel");
        return v ? v : "default"
    }
    async setModel(v) {
        await T3.workspace.getConfiguration("claudeCode").update("selectedModel", v, T3.ConfigurationTarget.Global)
    }
    getThinkingLevel() {
        let v = this.context.globalState.get("thinkingLevel");
        return v ? v : "default_on"
    }
    async setThinkingLevel(v) {
        this.context.globalState.update("thinkingLevel", v)
    }
    getInitialPermissionMode() {
        let z = R4("initialPermissionMode") || "default";
        if (z === "bypassPermissions" && !this.getAllowDangerouslySkipPermissions()) return "default";
        return z
    }
    getAllowDangerouslySkipPermissions() {
        return R4("allowDangerouslySkipPermissions") || !1
    }
    getUseCtrlEnterToSend() {
        return R4("useCtrlEnterToSend") || !1
    }
    getHideOnboarding() {
        return R4("hideOnboarding") || !1
    }
    async setHideOnboarding(v) {
        await T3.workspace.getConfiguration("claudeCode").update("hideOnboarding", v, T3.ConfigurationTarget.Global)
    }
    getSpinnerVerbsConfig() {
        return R4("spinnerVerbs")
    }
    getPreferredLocation() {
        if (R4("preferredLocation") === "sidebar") return "sidebar";
        return "panel"
    }
    async setPreferredLocation(v) {
        await T3.workspace.getConfiguration("claudeCode").update("preferredLocation", v, T3.ConfigurationTarget.Global)
    }
    migrateAllSettings() {
        this.migrateOldConfigSettings(), this.migrateLastClaudeLocation()
    }
    migrateOldConfigSettings() {
        if (this.context.globalState.get("settingsMigrated20251024")) return;
        let v = T3.workspace.getConfiguration("claude-code"),
            z = T3.workspace.getConfiguration("claudeCode"),
            U = ["selectedModel", "environmentVariables", "useTerminal", "allowDangerouslySkipPermissions", "claudeProcessWrapper", "respectGitIgnore"];
        for (let V of U) {
            let N = v.get(V);
            if (N !== void 0) z.update(V, N, T3.ConfigurationTarget.Global), v.update(V, void 0, T3.ConfigurationTarget.Global)
        }
        this.context.globalState.update("settingsMigrated20251024", !0)
    }
    migrateLastClaudeLocation() {
        if (this.context.globalState.get("lastClaudeLocationMigrated")) return;
        let v = this.context.globalState.get("lastClaudeLocation");
        if (v !== void 0) {
            let z = v === 0 ? "sidebar" : "panel";
            this.setPreferredLocation(z)
        }
        this.context.globalState.update("lastClaudeLocationMigrated", !0)
    }
}

function R4(v) {
    return T3.workspace.getConfiguration("claudeCode").get(v)
}

function X16(v) {
    let z = v.trim();
    if (!z) return "**/*";
    if (/[*?{}[\]]/.test(z)) return z;
    return `**/*${z.split("").map((V)=>{if(/[a-zA-Z]/.test(V)){let N=V.toLowerCase(),K=V.toUpperCase();return`[${N}${K}]`}return V}).join("")}*`
}
var JT = `{${["**/node_modules/**","**/.git/**","**/dist/**","**/build/**","**/.next/**","**/.nuxt/**","**/.DS_Store","**/Thumbs.db","**/*.log","**/.env","**/.env.*","**/yarn-error.log","**/npm-debug.log*"].join(",")}}`;
async function C2(v) {
    let z = v ? X16(v) : "**/*",
        U = await qT(),
        V = 100,
        N;
    try {
        N = await e4.workspace.findFiles(z, U, 100)
    } catch {
        N = await e4.workspace.findFiles(z, JT, 100)
    }
    let K = [];
    try {
        let x = [];
        for (let O of N) {
            let J = e4.workspace.asRelativePath(O).replaceAll("\\", "/"),
                q = O.path.split("/").pop() || "";
            K.push({
                path: J,
                name: q,
                type: "file"
            }), x.push(J)
        }
        let j = new Set;
        for (let O of x) {
            let J = O.indexOf("/");
            while (J !== -1) j.add(O.substring(0, J)), J = O.indexOf("/", J + 1)
        }
        let B = v?.toLowerCase();
        for (let O of j)
            if (!B || O.toLowerCase().includes(B)) K.push({
                path: O + "/",
                name: O.split("/").pop() || "",
                type: "directory"
            });
        K.sort((O, J) => O.path.localeCompare(J.path))
    } catch {}
    return K
}
async function qT() {
    let v = [];
    try {
        let V = e4.workspace.getConfiguration("search"),
            N = e4.workspace.getConfiguration("files"),
            K = V.get("exclude") || {},
            x = N.get("exclude") || {};
        for (let [O, J] of Object.entries(K))
            if (J && typeof O === "string") v.push(O);
        for (let [O, J] of Object.entries(x))
            if (J && typeof O === "string") v.push(O);
        let j = V.get("useIgnoreFiles", !0),
            B = R4("respectGitIgnore") ?? !0;
        if (j && B) {
            let O = e4.workspace.workspaceFolders;
            if (O)
                for (let J of O) {
                    let q = c16(J.uri.fsPath);
                    v.push(...q)
                }
        }
    } catch (V) {}
    let z = v.filter((V) => typeof V === "string" && V.length > 0);
    if (z.length === 0) return JT;
    return z.length === 1 ? z[0] : `{${z.join(",")}}`
}
var g16 = O4(() => {
    try {
        let v = yx.execFileSync("git", ["config", "--global", "core.excludesFile"], {
            encoding: "utf8",
            timeout: 2000
        }).trim();
        if (v) {
            if (v.startsWith("~/")) return ux.join(_2.homedir(), v.slice(2));
            return v
        }
    } catch {}
    return ux.join(_2.homedir(), ".config", "git", "ignore")
});

function c16(v) {
    let z = [];
    try {
        let U = ux.join(v, ".gitignore");
        if (ov.existsSync(U)) {
            let N = ov.readFileSync(U, "utf8");
            z.push(...OT(N))
        }
        let V = g16();
        if (V && ov.existsSync(V)) {
            let N = ov.readFileSync(V, "utf8");
            z.push(...OT(N))
        }
    } catch (U) {}
    return z
}

function OT(v) {
    let z = [];
    for (let U of v.split(`
`)) {
        let V = U.trim();
        if (!V || V.startsWith("#")) continue;
        if (V.startsWith("!")) continue;
        let N = V;
        if (N.endsWith("/")) N = N.slice(0, -1) + "/**";
        if (!N.startsWith("/")) N = "**/" + N;
        else N = N.slice(1);
        if (!z.includes(N)) z.push(N)
    }
    return z
}
async function i16(v) {
    if (v.scheme === "comment" || v.scheme === "output") return !0;
    try {
        let z = e4.workspace.getWorkspaceFolder(v);
        if (!z) return !1;
        let U = e4.workspace.asRelativePath(v, !1),
            V = await qT();
        if ((await e4.workspace.findFiles(new e4.RelativePattern(z, U), V, 1)).length === 0) return !0;
        let K = R4("respectGitIgnore") ?? !0;
        if (e4.workspace.getConfiguration("search").get("useIgnoreFiles", !0) && K) {
            if (await new Promise((O) => {
                    yx.execFile("git", ["check-ignore", v.fsPath], {
                        cwd: z.uri.fsPath
                    }, (J, q) => {
                        O(!J && !!q)
                    })
                })) return !0
        }
        return !1
    } catch (z) {
        return !1
    }
}
var kx = O4(i16, (v) => v.fsPath);
var l2 = o(require("vscode")),
    x5 = o(require("path"));

function L9(v) {
    return !Array.isArray ? FT(v) === "[object Array]" : Array.isArray(v)
}
var l16 = 1 / 0;

function h16(v) {
    if (typeof v == "string") return v;
    let z = v + "";
    return z == "0" && 1 / v == -l16 ? "-0" : z
}

function p16(v) {
    return v == null ? "" : h16(v)
}

function c8(v) {
    return typeof v === "string"
}

function ZT(v) {
    return typeof v === "number"
}

function n16(v) {
    return v === !0 || v === !1 || Q16(v) && FT(v) == "[object Boolean]"
}

function LT(v) {
    return typeof v === "object"
}

function Q16(v) {
    return LT(v) && v !== null
}

function Y3(v) {
    return v !== void 0 && v !== null
}

function f2(v) {
    return !v.trim().length
}

function FT(v) {
    return v == null ? v === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(v)
}
var d16 = "Incorrect 'index' type",
    o16 = (v) => `Invalid value for key ${v}`,
    r16 = (v) => `Pattern length exceeds max of ${v}.`,
    a16 = (v) => `Missing ${v} property in key`,
    t16 = (v) => `Property 'weight' in key '${v}' must be a positive integer`,
    HT = Object.prototype.hasOwnProperty;
class GT {
    constructor(v) {
        this._keys = [], this._keyMap = {};
        let z = 0;
        v.forEach((U) => {
            let V = IT(U);
            this._keys.push(V), this._keyMap[V.id] = V, z += V.weight
        }), this._keys.forEach((U) => {
            U.weight /= z
        })
    }
    get(v) {
        return this._keyMap[v]
    }
    keys() {
        return this._keys
    }
    toJSON() {
        return JSON.stringify(this._keys)
    }
}

function IT(v) {
    let z = null,
        U = null,
        V = null,
        N = 1,
        K = null;
    if (c8(v) || L9(v)) V = v, z = DT(v), U = T2(v);
    else {
        if (!HT.call(v, "name")) throw Error(a16("name"));
        let x = v.name;
        if (V = x, HT.call(v, "weight")) {
            if (N = v.weight, N <= 0) throw Error(t16(x))
        }
        z = DT(x), U = T2(x), K = v.getFn
    }
    return {
        path: z,
        id: U,
        weight: N,
        src: V,
        getFn: K
    }
}

function DT(v) {
    return L9(v) ? v : v.split(".")
}

function T2(v) {
    return L9(v) ? v.join(".") : v
}

function s16(v, z) {
    let U = [],
        V = !1,
        N = (K, x, j) => {
            if (!Y3(K)) return;
            if (!x[j]) U.push(K);
            else {
                let B = x[j],
                    O = K[B];
                if (!Y3(O)) return;
                if (j === x.length - 1 && (c8(O) || ZT(O) || n16(O))) U.push(p16(O));
                else if (L9(O)) {
                    V = !0;
                    for (let J = 0, q = O.length; J < q; J += 1) N(O[J], x, j + 1)
                } else if (x.length) N(O, x, j + 1)
            }
        };
    return N(v, c8(z) ? z.split(".") : z, 0), V ? U : U[0]
}
var e16 = {
        includeMatches: !1,
        findAllMatches: !1,
        minMatchCharLength: 1
    },
    vz6 = {
        isCaseSensitive: !1,
        includeScore: !1,
        keys: [],
        shouldSort: !0,
        sortFn: (v, z) => v.score === z.score ? v.idx < z.idx ? -1 : 1 : v.score < z.score ? -1 : 1
    },
    zz6 = {
        location: 0,
        threshold: 0.6,
        distance: 100
    },
    Uz6 = {
        useExtendedSearch: !1,
        getFn: s16,
        ignoreLocation: !1,
        ignoreFieldNorm: !1,
        fieldNormWeight: 1
    },
    Q6 = {
        ...vz6,
        ...e16,
        ...zz6,
        ...Uz6
    },
    Vz6 = /[^ ]+/g;

function Nz6(v = 1, z = 3) {
    let U = new Map,
        V = Math.pow(10, z);
    return {
        get(N) {
            let K = N.match(Vz6).length;
            if (U.has(K)) return U.get(K);
            let x = 1 / Math.pow(K, 0.5 * v),
                j = parseFloat(Math.round(x * V) / V);
            return U.set(K, j), j
        },
        clear() {
            U.clear()
        }
    }
}
class gx {
    constructor({
        getFn: v = Q6.getFn,
        fieldNormWeight: z = Q6.fieldNormWeight
    } = {}) {
        this.norm = Nz6(z, 3), this.getFn = v, this.isCreated = !1, this.setIndexRecords()
    }
    setSources(v = []) {
        this.docs = v
    }
    setIndexRecords(v = []) {
        this.records = v
    }
    setKeys(v = []) {
        this.keys = v, this._keysMap = {}, v.forEach((z, U) => {
            this._keysMap[z.id] = U
        })
    }
    create() {
        if (this.isCreated || !this.docs.length) return;
        if (this.isCreated = !0, c8(this.docs[0])) this.docs.forEach((v, z) => {
            this._addString(v, z)
        });
        else this.docs.forEach((v, z) => {
            this._addObject(v, z)
        });
        this.norm.clear()
    }
    add(v) {
        let z = this.size();
        if (c8(v)) this._addString(v, z);
        else this._addObject(v, z)
    }
    removeAt(v) {
        this.records.splice(v, 1);
        for (let z = v, U = this.size(); z < U; z += 1) this.records[z].i -= 1
    }
    getValueForItemAtKeyId(v, z) {
        return v[this._keysMap[z]]
    }
    size() {
        return this.records.length
    }
    _addString(v, z) {
        if (!Y3(v) || f2(v)) return;
        let U = {
            v,
            i: z,
            n: this.norm.get(v)
        };
        this.records.push(U)
    }
    _addObject(v, z) {
        let U = {
            i: z,
            $: {}
        };
        this.keys.forEach((V, N) => {
            let K = V.getFn ? V.getFn(v) : this.getFn(v, V.path);
            if (!Y3(K)) return;
            if (L9(K)) {
                let x = [],
                    j = [{
                        nestedArrIndex: -1,
                        value: K
                    }];
                while (j.length) {
                    let {
                        nestedArrIndex: B,
                        value: O
                    } = j.pop();
                    if (!Y3(O)) continue;
                    if (c8(O) && !f2(O)) {
                        let J = {
                            v: O,
                            i: B,
                            n: this.norm.get(O)
                        };
                        x.push(J)
                    } else if (L9(O)) O.forEach((J, q) => {
                        j.push({
                            nestedArrIndex: q,
                            value: J
                        })
                    })
                }
                U.$[N] = x
            } else if (c8(K) && !f2(K)) {
                let x = {
                    v: K,
                    n: this.norm.get(K)
                };
                U.$[N] = x
            }
        }), this.records.push(U)
    }
    toJSON() {
        return {
            keys: this.keys,
            records: this.records
        }
    }
}

function MT(v, z, {
    getFn: U = Q6.getFn,
    fieldNormWeight: V = Q6.fieldNormWeight
} = {}) {
    let N = new gx({
        getFn: U,
        fieldNormWeight: V
    });
    return N.setKeys(v.map(IT)), N.setSources(z), N.create(), N
}

function Kz6(v, {
    getFn: z = Q6.getFn,
    fieldNormWeight: U = Q6.fieldNormWeight
} = {}) {
    let {
        keys: V,
        records: N
    } = v, K = new gx({
        getFn: z,
        fieldNormWeight: U
    });
    return K.setKeys(V), K.setIndexRecords(N), K
}

function mx(v, {
    errors: z = 0,
    currentLocation: U = 0,
    expectedLocation: V = 0,
    distance: N = Q6.distance,
    ignoreLocation: K = Q6.ignoreLocation
} = {}) {
    let x = z / v.length;
    if (K) return x;
    let j = Math.abs(V - U);
    if (!N) return j ? 1 : x;
    return x + j / N
}

function xz6(v = [], z = Q6.minMatchCharLength) {
    let U = [],
        V = -1,
        N = -1,
        K = 0;
    for (let x = v.length; K < x; K += 1) {
        let j = v[K];
        if (j && V === -1) V = K;
        else if (!j && V !== -1) {
            if (N = K - 1, N - V + 1 >= z) U.push([V, N]);
            V = -1
        }
    }
    if (v[K - 1] && K - V >= z) U.push([V, K - 1]);
    return U
}
var j7 = 32;

function jz6(v, z, U, {
    location: V = Q6.location,
    distance: N = Q6.distance,
    threshold: K = Q6.threshold,
    findAllMatches: x = Q6.findAllMatches,
    minMatchCharLength: j = Q6.minMatchCharLength,
    includeMatches: B = Q6.includeMatches,
    ignoreLocation: O = Q6.ignoreLocation
} = {}) {
    if (z.length > j7) throw Error(r16(j7));
    let J = z.length,
        q = v.length,
        H = Math.max(0, Math.min(V, q)),
        D = K,
        A = H,
        w = j > 1 || B,
        Z = w ? Array(q) : [],
        $;
    while (($ = v.indexOf(z, A)) > -1) {
        let b = mx(z, {
            currentLocation: $,
            expectedLocation: H,
            distance: N,
            ignoreLocation: O
        });
        if (D = Math.min(b, D), A = $ + J, w) {
            let W = 0;
            while (W < J) Z[$ + W] = 1, W += 1
        }
    }
    A = -1;
    let F = [],
        L = 1,
        G = J + q,
        I = 1 << J - 1;
    for (let b = 0; b < J; b += 1) {
        let W = 0,
            E = G;
        while (W < E) {
            if (mx(z, {
                    errors: b,
                    currentLocation: H + E,
                    expectedLocation: H,
                    distance: N,
                    ignoreLocation: O
                }) <= D) W = E;
            else G = E;
            E = Math.floor((G - W) / 2 + W)
        }
        G = E;
        let y = Math.max(1, H - E + 1),
            T = x ? q : Math.min(H + E, q) + J,
            X = Array(T + 2);
        X[T + 1] = (1 << b) - 1;
        for (let m = T; m >= y; m -= 1) {
            let P6 = m - 1,
                F6 = U[v.charAt(P6)];
            if (w) Z[P6] = +!!F6;
            if (X[m] = (X[m + 1] << 1 | 1) & F6, b) X[m] |= (F[m + 1] | F[m]) << 1 | 1 | F[m + 1];
            if (X[m] & I) {
                if (L = mx(z, {
                        errors: b,
                        currentLocation: P6,
                        expectedLocation: H,
                        distance: N,
                        ignoreLocation: O
                    }), L <= D) {
                    if (D = L, A = P6, A <= H) break;
                    y = Math.max(1, 2 * H - A)
                }
            }
        }
        if (mx(z, {
                errors: b + 1,
                currentLocation: H,
                expectedLocation: H,
                distance: N,
                ignoreLocation: O
            }) > D) break;
        F = X
    }
    let M = {
        isMatch: A >= 0,
        score: Math.max(0.001, L)
    };
    if (w) {
        let b = xz6(Z, j);
        if (!b.length) M.isMatch = !1;
        else if (B) M.indices = b
    }
    return M
}

function Bz6(v) {
    let z = {};
    for (let U = 0, V = v.length; U < V; U += 1) {
        let N = v.charAt(U);
        z[N] = (z[N] || 0) | 1 << V - U - 1
    }
    return z
}
class X2 {
    constructor(v, {
        location: z = Q6.location,
        threshold: U = Q6.threshold,
        distance: V = Q6.distance,
        includeMatches: N = Q6.includeMatches,
        findAllMatches: K = Q6.findAllMatches,
        minMatchCharLength: x = Q6.minMatchCharLength,
        isCaseSensitive: j = Q6.isCaseSensitive,
        ignoreLocation: B = Q6.ignoreLocation
    } = {}) {
        if (this.options = {
                location: z,
                threshold: U,
                distance: V,
                includeMatches: N,
                findAllMatches: K,
                minMatchCharLength: x,
                isCaseSensitive: j,
                ignoreLocation: B
            }, this.pattern = j ? v : v.toLowerCase(), this.chunks = [], !this.pattern.length) return;
        let O = (q, H) => {
                this.chunks.push({
                    pattern: q,
                    alphabet: Bz6(q),
                    startIndex: H
                })
            },
            J = this.pattern.length;
        if (J > j7) {
            let q = 0,
                H = J % j7,
                D = J - H;
            while (q < D) O(this.pattern.substr(q, j7), q), q += j7;
            if (H) {
                let A = J - j7;
                O(this.pattern.substr(A), A)
            }
        } else O(this.pattern, 0)
    }
    searchIn(v) {
        let {
            isCaseSensitive: z,
            includeMatches: U
        } = this.options;
        if (!z) v = v.toLowerCase();
        if (this.pattern === v) {
            let D = {
                isMatch: !0,
                score: 0
            };
            if (U) D.indices = [
                [0, v.length - 1]
            ];
            return D
        }
        let {
            location: V,
            distance: N,
            threshold: K,
            findAllMatches: x,
            minMatchCharLength: j,
            ignoreLocation: B
        } = this.options, O = [], J = 0, q = !1;
        this.chunks.forEach(({
            pattern: D,
            alphabet: A,
            startIndex: w
        }) => {
            let {
                isMatch: Z,
                score: $,
                indices: F
            } = jz6(v, D, A, {
                location: V + w,
                distance: N,
                threshold: K,
                findAllMatches: x,
                minMatchCharLength: j,
                includeMatches: U,
                ignoreLocation: B
            });
            if (Z) q = !0;
            if (J += $, Z && F) O = [...O, ...F]
        });
        let H = {
            isMatch: q,
            score: q ? J / this.chunks.length : 1
        };
        if (q && U) H.indices = O;
        return H
    }
}
class F9 {
    constructor(v) {
        this.pattern = v
    }
    static isMultiMatch(v) {
        return AT(v, this.multiRegex)
    }
    static isSingleMatch(v) {
        return AT(v, this.singleRegex)
    }
    search() {}
}

function AT(v, z) {
    let U = v.match(z);
    return U ? U[1] : null
}
class bT extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "exact"
    }
    static get multiRegex() {
        return /^="(.*)"$/
    }
    static get singleRegex() {
        return /^=(.*)$/
    }
    search(v) {
        let z = v === this.pattern;
        return {
            isMatch: z,
            score: z ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class RT extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "inverse-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"$/
    }
    static get singleRegex() {
        return /^!(.*)$/
    }
    search(v) {
        let U = v.indexOf(this.pattern) === -1;
        return {
            isMatch: U,
            score: U ? 0 : 1,
            indices: [0, v.length - 1]
        }
    }
}
class WT extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "prefix-exact"
    }
    static get multiRegex() {
        return /^\^"(.*)"$/
    }
    static get singleRegex() {
        return /^\^(.*)$/
    }
    search(v) {
        let z = v.startsWith(this.pattern);
        return {
            isMatch: z,
            score: z ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class ET extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "inverse-prefix-exact"
    }
    static get multiRegex() {
        return /^!\^"(.*)"$/
    }
    static get singleRegex() {
        return /^!\^(.*)$/
    }
    search(v) {
        let z = !v.startsWith(this.pattern);
        return {
            isMatch: z,
            score: z ? 0 : 1,
            indices: [0, v.length - 1]
        }
    }
}
class ST extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "suffix-exact"
    }
    static get multiRegex() {
        return /^"(.*)"\$$/
    }
    static get singleRegex() {
        return /^(.*)\$$/
    }
    search(v) {
        let z = v.endsWith(this.pattern);
        return {
            isMatch: z,
            score: z ? 0 : 1,
            indices: [v.length - this.pattern.length, v.length - 1]
        }
    }
}
class PT extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "inverse-suffix-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"\$$/
    }
    static get singleRegex() {
        return /^!(.*)\$$/
    }
    search(v) {
        let z = !v.endsWith(this.pattern);
        return {
            isMatch: z,
            score: z ? 0 : 1,
            indices: [0, v.length - 1]
        }
    }
}
class g2 extends F9 {
    constructor(v, {
        location: z = Q6.location,
        threshold: U = Q6.threshold,
        distance: V = Q6.distance,
        includeMatches: N = Q6.includeMatches,
        findAllMatches: K = Q6.findAllMatches,
        minMatchCharLength: x = Q6.minMatchCharLength,
        isCaseSensitive: j = Q6.isCaseSensitive,
        ignoreLocation: B = Q6.ignoreLocation
    } = {}) {
        super(v);
        this._bitapSearch = new X2(v, {
            location: z,
            threshold: U,
            distance: V,
            includeMatches: N,
            findAllMatches: K,
            minMatchCharLength: x,
            isCaseSensitive: j,
            ignoreLocation: B
        })
    }
    static get type() {
        return "fuzzy"
    }
    static get multiRegex() {
        return /^"(.*)"$/
    }
    static get singleRegex() {
        return /^(.*)$/
    }
    search(v) {
        return this._bitapSearch.searchIn(v)
    }
}
class c2 extends F9 {
    constructor(v) {
        super(v)
    }
    static get type() {
        return "include"
    }
    static get multiRegex() {
        return /^'"(.*)"$/
    }
    static get singleRegex() {
        return /^'(.*)$/
    }
    search(v) {
        let z = 0,
            U, V = [],
            N = this.pattern.length;
        while ((U = v.indexOf(this.pattern, z)) > -1) z = U + N, V.push([U, z - 1]);
        let K = !!V.length;
        return {
            isMatch: K,
            score: K ? 0 : 1,
            indices: V
        }
    }
}
var Y2 = [bT, c2, WT, ET, PT, ST, RT, g2],
    $T = Y2.length,
    Oz6 = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
    Jz6 = "|";

function qz6(v, z = {}) {
    return v.split(Jz6).map((U) => {
        let V = U.trim().split(Oz6).filter((K) => K && !!K.trim()),
            N = [];
        for (let K = 0, x = V.length; K < x; K += 1) {
            let j = V[K],
                B = !1,
                O = -1;
            while (!B && ++O < $T) {
                let J = Y2[O],
                    q = J.isMultiMatch(j);
                if (q) N.push(new J(q, z)), B = !0
            }
            if (B) continue;
            O = -1;
            while (++O < $T) {
                let J = Y2[O],
                    q = J.isSingleMatch(j);
                if (q) {
                    N.push(new J(q, z));
                    break
                }
            }
        }
        return N
    })
}
var Hz6 = new Set([g2.type, c2.type]);
class _T {
    constructor(v, {
        isCaseSensitive: z = Q6.isCaseSensitive,
        includeMatches: U = Q6.includeMatches,
        minMatchCharLength: V = Q6.minMatchCharLength,
        ignoreLocation: N = Q6.ignoreLocation,
        findAllMatches: K = Q6.findAllMatches,
        location: x = Q6.location,
        threshold: j = Q6.threshold,
        distance: B = Q6.distance
    } = {}) {
        this.query = null, this.options = {
            isCaseSensitive: z,
            includeMatches: U,
            minMatchCharLength: V,
            findAllMatches: K,
            ignoreLocation: N,
            location: x,
            threshold: j,
            distance: B
        }, this.pattern = z ? v : v.toLowerCase(), this.query = qz6(this.pattern, this.options)
    }
    static condition(v, z) {
        return z.useExtendedSearch
    }
    searchIn(v) {
        let z = this.query;
        if (!z) return {
            isMatch: !1,
            score: 1
        };
        let {
            includeMatches: U,
            isCaseSensitive: V
        } = this.options;
        v = V ? v : v.toLowerCase();
        let N = 0,
            K = [],
            x = 0;
        for (let j = 0, B = z.length; j < B; j += 1) {
            let O = z[j];
            K.length = 0, N = 0;
            for (let J = 0, q = O.length; J < q; J += 1) {
                let H = O[J],
                    {
                        isMatch: D,
                        indices: A,
                        score: w
                    } = H.search(v);
                if (D) {
                    if (N += 1, x += w, U) {
                        let Z = H.constructor.type;
                        if (Hz6.has(Z)) K = [...K, ...A];
                        else K.push(A)
                    }
                } else {
                    x = 0, N = 0, K.length = 0;
                    break
                }
            }
            if (N) {
                let J = {
                    isMatch: !0,
                    score: x / N
                };
                if (U) J.indices = K;
                return J
            }
        }
        return {
            isMatch: !1,
            score: 1
        }
    }
}
var u2 = [];

function Dz6(...v) {
    u2.push(...v)
}

function y2(v, z) {
    for (let U = 0, V = u2.length; U < V; U += 1) {
        let N = u2[U];
        if (N.condition(v, z)) return new N(v, z)
    }
    return new X2(v, z)
}
var Xx = {
        AND: "$and",
        OR: "$or"
    },
    k2 = {
        PATH: "$path",
        PATTERN: "$val"
    },
    m2 = (v) => !!(v[Xx.AND] || v[Xx.OR]),
    Az6 = (v) => !!v[k2.PATH],
    $z6 = (v) => !L9(v) && LT(v) && !m2(v),
    wT = (v) => ({
        [Xx.AND]: Object.keys(v).map((z) => ({
            [z]: v[z]
        }))
    });

function CT(v, z, {
    auto: U = !0
} = {}) {
    let V = (N) => {
        let K = Object.keys(N),
            x = Az6(N);
        if (!x && K.length > 1 && !m2(N)) return V(wT(N));
        if ($z6(N)) {
            let B = x ? N[k2.PATH] : K[0],
                O = x ? N[k2.PATTERN] : N[B];
            if (!c8(O)) throw Error(o16(B));
            let J = {
                keyId: T2(B),
                pattern: O
            };
            if (U) J.searcher = y2(O, z);
            return J
        }
        let j = {
            children: [],
            operator: K[0]
        };
        return K.forEach((B) => {
            let O = N[B];
            if (L9(O)) O.forEach((J) => {
                j.children.push(V(J))
            })
        }), j
    };
    if (!m2(v)) v = wT(v);
    return V(v)
}

function wz6(v, {
    ignoreFieldNorm: z = Q6.ignoreFieldNorm
}) {
    v.forEach((U) => {
        let V = 1;
        U.matches.forEach(({
            key: N,
            norm: K,
            score: x
        }) => {
            let j = N ? N.weight : null;
            V *= Math.pow(x === 0 && j ? Number.EPSILON : x, (j || 1) * (z ? 1 : K))
        }), U.score = V
    })
}

function Zz6(v, z) {
    let U = v.matches;
    if (z.matches = [], !Y3(U)) return;
    U.forEach((V) => {
        if (!Y3(V.indices) || !V.indices.length) return;
        let {
            indices: N,
            value: K
        } = V, x = {
            indices: N,
            value: K
        };
        if (V.key) x.key = V.key.src;
        if (V.idx > -1) x.refIndex = V.idx;
        z.matches.push(x)
    })
}

function Lz6(v, z) {
    z.score = v.score
}

function Fz6(v, z, {
    includeMatches: U = Q6.includeMatches,
    includeScore: V = Q6.includeScore
} = {}) {
    let N = [];
    if (U) N.push(Zz6);
    if (V) N.push(Lz6);
    return v.map((K) => {
        let {
            idx: x
        } = K, j = {
            item: z[x],
            refIndex: x
        };
        if (N.length) N.forEach((B) => {
            B(K, j)
        });
        return j
    })
}
class K5 {
    constructor(v, z = {}, U) {
        this.options = {
            ...Q6,
            ...z
        }, this.options.useExtendedSearch, this._keyStore = new GT(this.options.keys), this.setCollection(v, U)
    }
    setCollection(v, z) {
        if (this._docs = v, z && !(z instanceof gx)) throw Error(d16);
        this._myIndex = z || MT(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
        })
    }
    add(v) {
        if (!Y3(v)) return;
        this._docs.push(v), this._myIndex.add(v)
    }
    remove(v = () => !1) {
        let z = [];
        for (let U = 0, V = this._docs.length; U < V; U += 1) {
            let N = this._docs[U];
            if (v(N, U)) this.removeAt(U), U -= 1, V -= 1, z.push(N)
        }
        return z
    }
    removeAt(v) {
        this._docs.splice(v, 1), this._myIndex.removeAt(v)
    }
    getIndex() {
        return this._myIndex
    }
    search(v, {
        limit: z = -1
    } = {}) {
        let {
            includeMatches: U,
            includeScore: V,
            shouldSort: N,
            sortFn: K,
            ignoreFieldNorm: x
        } = this.options, j = c8(v) ? c8(this._docs[0]) ? this._searchStringList(v) : this._searchObjectList(v) : this._searchLogical(v);
        if (wz6(j, {
                ignoreFieldNorm: x
            }), N) j.sort(K);
        if (ZT(z) && z > -1) j = j.slice(0, z);
        return Fz6(j, this._docs, {
            includeMatches: U,
            includeScore: V
        })
    }
    _searchStringList(v) {
        let z = y2(v, this.options),
            {
                records: U
            } = this._myIndex,
            V = [];
        return U.forEach(({
            v: N,
            i: K,
            n: x
        }) => {
            if (!Y3(N)) return;
            let {
                isMatch: j,
                score: B,
                indices: O
            } = z.searchIn(N);
            if (j) V.push({
                item: N,
                idx: K,
                matches: [{
                    score: B,
                    value: N,
                    norm: x,
                    indices: O
                }]
            })
        }), V
    }
    _searchLogical(v) {
        let z = CT(v, this.options),
            U = (x, j, B) => {
                if (!x.children) {
                    let {
                        keyId: J,
                        searcher: q
                    } = x, H = this._findMatches({
                        key: this._keyStore.get(J),
                        value: this._myIndex.getValueForItemAtKeyId(j, J),
                        searcher: q
                    });
                    if (H && H.length) return [{
                        idx: B,
                        item: j,
                        matches: H
                    }];
                    return []
                }
                let O = [];
                for (let J = 0, q = x.children.length; J < q; J += 1) {
                    let H = x.children[J],
                        D = U(H, j, B);
                    if (D.length) O.push(...D);
                    else if (x.operator === Xx.AND) return []
                }
                return O
            },
            V = this._myIndex.records,
            N = {},
            K = [];
        return V.forEach(({
            $: x,
            i: j
        }) => {
            if (Y3(x)) {
                let B = U(z, x, j);
                if (B.length) {
                    if (!N[j]) N[j] = {
                        idx: j,
                        item: x,
                        matches: []
                    }, K.push(N[j]);
                    B.forEach(({
                        matches: O
                    }) => {
                        N[j].matches.push(...O)
                    })
                }
            }
        }), K
    }
    _searchObjectList(v) {
        let z = y2(v, this.options),
            {
                keys: U,
                records: V
            } = this._myIndex,
            N = [];
        return V.forEach(({
            $: K,
            i: x
        }) => {
            if (!Y3(K)) return;
            let j = [];
            if (U.forEach((B, O) => {
                    j.push(...this._findMatches({
                        key: B,
                        value: K[O],
                        searcher: z
                    }))
                }), j.length) N.push({
                idx: x,
                item: K,
                matches: j
            })
        }), N
    }
    _findMatches({
        key: v,
        value: z,
        searcher: U
    }) {
        if (!Y3(z)) return [];
        let V = [];
        if (L9(z)) z.forEach(({
            v: N,
            i: K,
            n: x
        }) => {
            if (!Y3(N)) return;
            let {
                isMatch: j,
                score: B,
                indices: O
            } = U.searchIn(N);
            if (j) V.push({
                score: B,
                key: v,
                value: N,
                idx: K,
                norm: x,
                indices: O
            })
        });
        else {
            let {
                v: N,
                n: K
            } = z, {
                isMatch: x,
                score: j,
                indices: B
            } = U.searchIn(N);
            if (x) V.push({
                score: j,
                key: v,
                value: N,
                norm: K,
                indices: B
            })
        }
        return V
    }
}
K5.version = "7.0.0";
K5.createIndex = MT;
K5.parseIndex = Kz6;
K5.config = Q6;
K5.parseQuery = CT;
Dz6(_T);
var cx = require("child_process");
var __dirname = "/home/runner/work/claude-cli-internal/claude-cli-internal/packages/claude-vscode/src/extension",
    i2 = 100,
    Gz6 = 20000000,
    Iz6 = 1e4,
    Mz6 = O4(() => {
        if (!process.env.USE_BUILTIN_RIPGREP || process.env.USE_BUILTIN_RIPGREP === "0" || process.env.USE_BUILTIN_RIPGREP === "false") {
            let N = process.platform === "win32" ? "rg.exe" : "rg";
            try {
                return cx.execFileSync(N, ["--version"], {
                    stdio: "ignore"
                }), {
                    mode: "system",
                    command: N,
                    args: []
                }
            } catch {}
        }
        let z = x5.resolve(__dirname, "..", "..", "..", ".."),
            U = x5.resolve(z, "vendor", "ripgrep");
        return {
            mode: "builtin",
            command: process.platform === "win32" ? x5.resolve(U, `${process.arch}-win32`, "rg.exe") : x5.resolve(U, `${process.arch}-${process.platform}`, "rg"),
            args: []
        }
    });

function bz6() {
    let v = Mz6();
    return {
        rgPath: v.command,
        rgArgs: v.args
    }
}
async function Rz6(v, z) {
    return new Promise((U, V) => {
        let {
            rgPath: N,
            rgArgs: K
        } = bz6();
        cx.execFile(N, [...K, ...v], {
            cwd: z,
            maxBuffer: Gz6,
            timeout: Iz6
        }, (x, j) => {
            if (!x) {
                U(j.trim().split(`
`).filter(Boolean));
                return
            }
            if ("code" in x && x.code === 1) {
                U([]);
                return
            }
            let B = j && j.trim().length > 0,
                O = "signal" in x && x.signal === "SIGTERM" || "code" in x && x.code === "ABORT_ERR",
                J = "code" in x && x.code === "ERR_CHILD_PROCESS_STDIO_MAXBUFFER";
            if ((O || J) && B) {
                let q = j.trim().split(`
`).filter(Boolean);
                U(q.length > 0 ? q.slice(0, -1) : []);
                return
            }
            V(x)
        })
    })
}

function fT(v) {
    return v.replaceAll("\\", "/")
}

function Wz6(v, z) {
    if (!z) {
        let j = new Set;
        for (let B of v) {
            let O = B.split("/")[0];
            if (O) {
                if (j.add(O), j.size >= i2) break
            }
        }
        return [...j].sort().map((B) => {
            let O = v.some((J) => J.startsWith(B + "/"));
            return {
                path: O ? B + "/" : B,
                filename: x5.basename(B),
                isDirectory: O
            }
        })
    }
    let U = fT(z),
        V = v.map((j) => ({
            path: j,
            filename: x5.basename(j),
            testPenalty: j.includes("test") ? 1 : 0
        })),
        N = U.lastIndexOf("/");
    if (N > 2) V = V.filter((j) => {
        return j.path.substring(0, N).startsWith(U.substring(0, N))
    });
    let x = new K5(V, {
        includeScore: !0,
        threshold: 0.5,
        keys: [{
            name: "path",
            weight: 1
        }, {
            name: "filename",
            weight: 2
        }]
    }).search(U, {
        limit: i2
    });
    return x = x.sort((j, B) => {
        if (j.score === void 0 || B.score === void 0) return 0;
        if (Math.abs(j.score - B.score) > 0.05) return j.score - B.score;
        return j.item.testPenalty - B.item.testPenalty
    }), x.map((j) => ({
        path: j.item.path,
        filename: j.item.filename,
        isDirectory: j.item.path.endsWith("/")
    })).slice(0, i2)
}
async function TT(v, z, U) {
    try {
        let V = ["--files", "--follow", "--hidden"];
        if (!(R4("respectGitIgnore") ?? !0)) V.push("--no-ignore-vcs");
        try {
            let J = l2.workspace.getConfiguration("search"),
                q = l2.workspace.getConfiguration("files"),
                H = J.get("exclude") || {},
                D = q.get("exclude") || {};
            for (let [A, w] of Object.entries(H))
                if (w) V.push("--glob", `!${A}`);
            for (let [A, w] of Object.entries(D))
                if (w && !H[A]) V.push("--glob", `!${A}`)
        } catch (J) {
            U.warn("Failed to get VSCode exclude patterns", J)
        }
        let K = await Rz6(V, z),
            x = process.platform === "win32" ? K.map(fT) : K,
            B = [...Ez6(x), ...x];
        return Wz6(B, v).map((J) => ({
            path: J.path,
            name: J.filename,
            type: J.isDirectory ? "directory" : "file"
        }))
    } catch (V) {
        throw U.error("Ripgrep search failed", V), V
    }
}

function Ez6(v) {
    let z = new Set;
    for (let U of v) {
        let V = U.indexOf("/");
        while (V !== -1) z.add(U.substring(0, V)), V = U.indexOf("/", V + 1)
    }
    return [...z].map((U) => U + "/")
}
var S4 = require("path"),
    MF = o(n2(), 1),
    kg = require("os");
var B5 = o(require("vscode"));
var j5 = o(require("vscode"));

function rv() {
    return j5.window.tabGroups.all.flatMap((v) => v.tabs)
}

function av(v, z) {
    return new Promise((U, V) => {
        let N, K = setInterval(() => {
            let x = v();
            if (x) {
                if (clearInterval(K), N) clearTimeout(N);
                U(x)
            }
        }, 100);
        if (z) N = setTimeout(() => {
            clearInterval(K), V(Error(`Timeout waiting after ${z}ms`))
        }, z)
    })
}
async function O7(v, z) {
    if (!v) return;
    let U = v.input;
    if (U instanceof j5.TabInputTextDiff) try {
        let V = await j5.workspace.openTextDocument(U.modified);
        if (V.isDirty) {
            let N = new Promise((K) => {
                let x = j5.workspace.onDidSaveTextDocument((j) => {
                    if (j.uri.toString() === V.uri.toString()) x.dispose(), K()
                });
                setTimeout(() => {
                    x.dispose(), K()
                }, 2000)
            });
            await V.save(), await N
        }
    } catch (V) {
        z.error("Error saving modified file:", V)
    }
    try {
        await j5.window.tabGroups.close(v)
    } catch {}
}
async function lT(v, z, U, V, N, K, x) {
    let j = [],
        O = `${N||"Claude Code"} (${Math.random().toString(36).substring(2,8)})`,
        J = [],
        q;
    if (!K) {
        let A = `/temp/readonly/${O}`,
            w = z.createFile(A, V);
        q = await B5.workspace.openTextDocument(w), await B5.window.showTextDocument(q, {
            preview: !0
        })
    } else {
        let A = `/temp/${O}`,
            Z = U.createFile(A, V).uri;
        q = await B5.workspace.openTextDocument(Z), v.info("Editable uri: ", Z.toString());
        let $ = new Promise((L) => {
            j.push(B5.workspace.onWillSaveTextDocument((G) => {
                if (G.document.uri.toString() === Z.toString()) {
                    let I = G.document.getText();
                    L(I)
                }
            }))
        });
        if (B5.workspace.getConfiguration("files").get("autoSave") === "off") v.info("files.autoSave is off, waiting for file save"), J.push($);
        else v.info("files.autoSave is on, cannot save to exit");
        let F = {
            preview: !1,
            preserveFocus: !0
        };
        await B5.window.showTextDocument(q, F)
    }
    let H = await av(() => {
        return rv().find((A) => A.label === O)
    }, 1000);
    x?.addEventListener("abort", () => {
        O7(H, v)
    });
    let D = av(() => {
        return !rv().some((A) => A.label === O)
    }).then(() => {
        if (v.info("Tab closed", O), !K) return;
        else return q.getText()
    });
    return J.push(D), await Promise.race(J).finally(() => {
        j.forEach((A) => A.dispose())
    }).then((A) => {
        return v.info("File save operation completed", A), A
    }).finally(() => {
        O7(H, v)
    })
}
var dx = o(require("vscode"));

function d2() {
    return {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null
    }
}
var q7 = d2();

function oT(v) {
    q7 = v
}
var WU = {
    exec: () => null
};

function R0(v, z = "") {
    let U = typeof v === "string" ? v : v.source,
        V = {
            replace: (N, K) => {
                let x = typeof K === "string" ? K : K.source;
                return x = x.replace(v3.caret, "$1"), U = U.replace(N, x), V
            },
            getRegex: () => {
                return new RegExp(U, z)
            }
        };
    return V
}
var v3 = {
        codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
        outputLinkReplace: /\\([\[\]])/g,
        indentCodeCompensation: /^(\s+)(?:```)/,
        beginningSpace: /^\s+/,
        endingHash: /#$/,
        startingSpaceChar: /^ /,
        endingSpaceChar: / $/,
        nonSpaceChar: /[^ ]/,
        newLineCharGlobal: /\n/g,
        tabCharGlobal: /\t/g,
        multipleSpaceGlobal: /\s+/g,
        blankLine: /^[ \t]*$/,
        doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
        blockquoteStart: /^ {0,3}>/,
        blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
        blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
        listReplaceTabs: /^\t+/,
        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
        listIsTask: /^\[[ xX]\] /,
        listReplaceTask: /^\[[ xX]\] +/,
        anyLine: /\n.*\n/,
        hrefBrackets: /^<(.*)>$/,
        tableDelimiter: /[:|]/,
        tableAlignChars: /^\||\| *$/g,
        tableRowBlankLine: /\n[ \t]*$/,
        tableAlignRight: /^ *-+: *$/,
        tableAlignCenter: /^ *:-+: *$/,
        tableAlignLeft: /^ *:-+ *$/,
        startATag: /^<a /i,
        endATag: /^<\/a>/i,
        startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
        endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
        startAngleBracket: /^</,
        endAngleBracket: />$/,
        pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
        unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
        escapeTest: /[&<>"']/,
        escapeReplace: /[&<>"']/g,
        escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
        escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
        unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
        caret: /(^|[^\[])\^/g,
        percentDecode: /%25/g,
        findPipe: /\|/g,
        splitPipe: / \|/,
        slashPipe: /\\\|/g,
        carriageReturn: /\r\n|\r/g,
        spaceLine: /^ +$/gm,
        notSpaceStart: /^\S*/,
        endingNewline: /\n$/,
        listItemRegex: (v) => new RegExp(`^( {0,3}${v})((?:[	 ][^\\n]*)?(?:\\n|$))`),
        nextBulletRegex: (v) => new RegExp(`^ {0,${Math.min(3,v-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
        hrRegex: (v) => new RegExp(`^ {0,${Math.min(3,v-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
        fencesBeginRegex: (v) => new RegExp(`^ {0,${Math.min(3,v-1)}}(?:\`\`\`|~~~)`),
        headingBeginRegex: (v) => new RegExp(`^ {0,${Math.min(3,v-1)}}#`),
        htmlBeginRegex: (v) => new RegExp(`^ {0,${Math.min(3,v-1)}}<(?:[a-z].*>|!--)`, "i")
    },
    yz6 = /^(?:[ \t]*(?:\n|$))+/,
    kz6 = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,
    mz6 = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    _U = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    Xz6 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    rT = /(?:[*+-]|\d{1,9}[.)])/,
    aT = R0(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, rT).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(),
    o2 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    gz6 = /^[^\n]+/,
    r2 = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
    cz6 = R0(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", r2).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),
    iz6 = R0(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, rT).getRegex(),
    px = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
    a2 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
    lz6 = R0("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$))", "i").replace("comment", a2).replace("tag", px).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),
    tT = R0(o2).replace("hr", _U).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", px).getRegex(),
    hz6 = R0(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", tT).getRegex(),
    t2 = {
        blockquote: hz6,
        code: kz6,
        def: cz6,
        fences: mz6,
        heading: Xz6,
        hr: _U,
        html: lz6,
        lheading: aT,
        list: iz6,
        newline: yz6,
        paragraph: tT,
        table: WU,
        text: gz6
    },
    hT = R0("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", _U).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}\t)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", px).getRegex(),
    pz6 = {
        ...t2,
        table: hT,
        paragraph: R0(o2).replace("hr", _U).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", hT).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", px).getRegex()
    },
    nz6 = {
        ...t2,
        html: R0(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", a2).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: WU,
        lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
        paragraph: R0(o2).replace("hr", _U).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", aT).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
    },
    Qz6 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    dz6 = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    sT = /^( {2,}|\\)\n(?!\s*$)/,
    oz6 = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    nx = /[\p{P}\p{S}]/u,
    s2 = /[\s\p{P}\p{S}]/u,
    eT = /[^\s\p{P}\p{S}]/u,
    rz6 = R0(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, s2).getRegex(),
    vY = /(?!~)[\p{P}\p{S}]/u,
    az6 = /(?!~)[\s\p{P}\p{S}]/u,
    tz6 = /(?:[^\s\p{P}\p{S}]|~)/u,
    sz6 = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g,
    zY = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,
    ez6 = R0(zY, "u").replace(/punct/g, nx).getRegex(),
    vU6 = R0(zY, "u").replace(/punct/g, vY).getRegex(),
    UY = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",
    zU6 = R0(UY, "gu").replace(/notPunctSpace/g, eT).replace(/punctSpace/g, s2).replace(/punct/g, nx).getRegex(),
    UU6 = R0(UY, "gu").replace(/notPunctSpace/g, tz6).replace(/punctSpace/g, az6).replace(/punct/g, vY).getRegex(),
    VU6 = R0("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, eT).replace(/punctSpace/g, s2).replace(/punct/g, nx).getRegex(),
    NU6 = R0(/\\(punct)/, "gu").replace(/punct/g, nx).getRegex(),
    KU6 = R0(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),
    xU6 = R0(a2).replace("(?:-->|$)", "-->").getRegex(),
    jU6 = R0("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", xU6).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),
    hx = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
    BU6 = R0(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", hx).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),
    VY = R0(/^!?\[(label)\]\[(ref)\]/).replace("label", hx).replace("ref", r2).getRegex(),
    NY = R0(/^!?\[(ref)\](?:\[\])?/).replace("ref", r2).getRegex(),
    OU6 = R0("reflink|nolink(?!\\()", "g").replace("reflink", VY).replace("nolink", NY).getRegex(),
    e2 = {
        _backpedal: WU,
        anyPunctuation: NU6,
        autolink: KU6,
        blockSkip: sz6,
        br: sT,
        code: dz6,
        del: WU,
        emStrongLDelim: ez6,
        emStrongRDelimAst: zU6,
        emStrongRDelimUnd: VU6,
        escape: Qz6,
        link: BU6,
        nolink: NY,
        punctuation: rz6,
        reflink: VY,
        reflinkSearch: OU6,
        tag: jU6,
        text: oz6,
        url: WU
    },
    JU6 = {
        ...e2,
        link: R0(/^!?\[(label)\]\((.*?)\)/).replace("label", hx).getRegex(),
        reflink: R0(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", hx).getRegex()
    },
    Q2 = {
        ...e2,
        emStrongRDelimAst: UU6,
        emStrongLDelim: vU6,
        url: R0(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
        _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    },
    qU6 = {
        ...Q2,
        br: R0(sT).replace("{2,}", "*").getRegex(),
        text: R0(Q2.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    },
    lx = {
        normal: t2,
        gfm: pz6,
        pedantic: nz6
    },
    bU = {
        normal: e2,
        gfm: Q2,
        breaks: qU6,
        pedantic: JU6
    },
    HU6 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    },
    pT = (v) => HU6[v];

function i8(v, z) {
    if (z) {
        if (v3.escapeTest.test(v)) return v.replace(v3.escapeReplace, pT)
    } else if (v3.escapeTestNoEncode.test(v)) return v.replace(v3.escapeReplaceNoEncode, pT);
    return v
}

function nT(v) {
    try {
        v = encodeURI(v).replace(v3.percentDecode, "%")
    } catch {
        return null
    }
    return v
}

function QT(v, z) {
    let U = v.replace(v3.findPipe, (K, x, j) => {
            let B = !1,
                O = x;
            while (--O >= 0 && j[O] === "\\") B = !B;
            if (B) return "|";
            else return " |"
        }),
        V = U.split(v3.splitPipe),
        N = 0;
    if (!V[0].trim()) V.shift();
    if (V.length > 0 && !V.at(-1)?.trim()) V.pop();
    if (z)
        if (V.length > z) V.splice(z);
        else
            while (V.length < z) V.push("");
    for (; N < V.length; N++) V[N] = V[N].trim().replace(v3.slashPipe, "|");
    return V
}

function RU(v, z, U) {
    let V = v.length;
    if (V === 0) return "";
    let N = 0;
    while (N < V)
        if (v.charAt(V - N - 1) === z) N++;
        else break;
    return v.slice(0, V - N)
}

function DU6(v, z) {
    if (v.indexOf(z[1]) === -1) return -1;
    let U = 0;
    for (let V = 0; V < v.length; V++)
        if (v[V] === "\\") V++;
        else if (v[V] === z[0]) U++;
    else if (v[V] === z[1]) {
        if (U--, U < 0) return V
    }
    return -1
}

function dT(v, z, U, V, N) {
    let K = z.href,
        x = z.title || null,
        j = v[1].replace(N.other.outputLinkReplace, "$1");
    if (v[0].charAt(0) !== "!") {
        V.state.inLink = !0;
        let B = {
            type: "link",
            raw: U,
            href: K,
            title: x,
            text: j,
            tokens: V.inlineTokens(j)
        };
        return V.state.inLink = !1, B
    }
    return {
        type: "image",
        raw: U,
        href: K,
        title: x,
        text: j
    }
}

function AU6(v, z, U) {
    let V = v.match(U.other.indentCodeCompensation);
    if (V === null) return z;
    let N = V[1];
    return z.split(`
`).map((K) => {
        let x = K.match(U.other.beginningSpace);
        if (x === null) return K;
        let [j] = x;
        if (j.length >= N.length) return K.slice(N.length);
        return K
    }).join(`
`)
}
class SU {
    options;
    rules;
    lexer;
    constructor(v) {
        this.options = v || q7
    }
    space(v) {
        let z = this.rules.block.newline.exec(v);
        if (z && z[0].length > 0) return {
            type: "space",
            raw: z[0]
        }
    }
    code(v) {
        let z = this.rules.block.code.exec(v);
        if (z) {
            let U = z[0].replace(this.rules.other.codeRemoveIndent, "");
            return {
                type: "code",
                raw: z[0],
                codeBlockStyle: "indented",
                text: !this.options.pedantic ? RU(U, `
`) : U
            }
        }
    }
    fences(v) {
        let z = this.rules.block.fences.exec(v);
        if (z) {
            let U = z[0],
                V = AU6(U, z[3] || "", this.rules);
            return {
                type: "code",
                raw: U,
                lang: z[2] ? z[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : z[2],
                text: V
            }
        }
    }
    heading(v) {
        let z = this.rules.block.heading.exec(v);
        if (z) {
            let U = z[2].trim();
            if (this.rules.other.endingHash.test(U)) {
                let V = RU(U, "#");
                if (this.options.pedantic) U = V.trim();
                else if (!V || this.rules.other.endingSpaceChar.test(V)) U = V.trim()
            }
            return {
                type: "heading",
                raw: z[0],
                depth: z[1].length,
                text: U,
                tokens: this.lexer.inline(U)
            }
        }
    }
    hr(v) {
        let z = this.rules.block.hr.exec(v);
        if (z) return {
            type: "hr",
            raw: RU(z[0], `
`)
        }
    }
    blockquote(v) {
        let z = this.rules.block.blockquote.exec(v);
        if (z) {
            let U = RU(z[0], `
`).split(`
`),
                V = "",
                N = "",
                K = [];
            while (U.length > 0) {
                let x = !1,
                    j = [],
                    B;
                for (B = 0; B < U.length; B++)
                    if (this.rules.other.blockquoteStart.test(U[B])) j.push(U[B]), x = !0;
                    else if (!x) j.push(U[B]);
                else break;
                U = U.slice(B);
                let O = j.join(`
`),
                    J = O.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
                V = V ? `${V}
${O}` : O, N = N ? `${N}
${J}` : J;
                let q = this.lexer.state.top;
                if (this.lexer.state.top = !0, this.lexer.blockTokens(J, K, !0), this.lexer.state.top = q, U.length === 0) break;
                let H = K.at(-1);
                if (H?.type === "code") break;
                else if (H?.type === "blockquote") {
                    let D = H,
                        A = D.raw + `
` + U.join(`
`),
                        w = this.blockquote(A);
                    K[K.length - 1] = w, V = V.substring(0, V.length - D.raw.length) + w.raw, N = N.substring(0, N.length - D.text.length) + w.text;
                    break
                } else if (H?.type === "list") {
                    let D = H,
                        A = D.raw + `
` + U.join(`
`),
                        w = this.list(A);
                    K[K.length - 1] = w, V = V.substring(0, V.length - H.raw.length) + w.raw, N = N.substring(0, N.length - D.raw.length) + w.raw, U = A.substring(K.at(-1).raw.length).split(`
`);
                    continue
                }
            }
            return {
                type: "blockquote",
                raw: V,
                tokens: K,
                text: N
            }
        }
    }
    list(v) {
        let z = this.rules.block.list.exec(v);
        if (z) {
            let U = z[1].trim(),
                V = U.length > 1,
                N = {
                    type: "list",
                    raw: "",
                    ordered: V,
                    start: V ? +U.slice(0, -1) : "",
                    loose: !1,
                    items: []
                };
            if (U = V ? `\\d{1,9}\\${U.slice(-1)}` : `\\${U}`, this.options.pedantic) U = V ? U : "[*+-]";
            let K = this.rules.other.listItemRegex(U),
                x = !1;
            while (v) {
                let B = !1,
                    O = "",
                    J = "";
                if (!(z = K.exec(v))) break;
                if (this.rules.block.hr.test(v)) break;
                O = z[0], v = v.substring(O.length);
                let q = z[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, ($) => " ".repeat(3 * $.length)),
                    H = v.split(`
`, 1)[0],
                    D = !q.trim(),
                    A = 0;
                if (this.options.pedantic) A = 2, J = q.trimStart();
                else if (D) A = z[1].length + 1;
                else A = z[2].search(this.rules.other.nonSpaceChar), A = A > 4 ? 1 : A, J = q.slice(A), A += z[1].length;
                if (D && this.rules.other.blankLine.test(H)) O += H + `
`, v = v.substring(H.length + 1), B = !0;
                if (!B) {
                    let $ = this.rules.other.nextBulletRegex(A),
                        F = this.rules.other.hrRegex(A),
                        L = this.rules.other.fencesBeginRegex(A),
                        G = this.rules.other.headingBeginRegex(A),
                        I = this.rules.other.htmlBeginRegex(A);
                    while (v) {
                        let M = v.split(`
`, 1)[0],
                            b;
                        if (H = M, this.options.pedantic) H = H.replace(this.rules.other.listReplaceNesting, "  "), b = H;
                        else b = H.replace(this.rules.other.tabCharGlobal, "    ");
                        if (L.test(H)) break;
                        if (G.test(H)) break;
                        if (I.test(H)) break;
                        if ($.test(H)) break;
                        if (F.test(H)) break;
                        if (b.search(this.rules.other.nonSpaceChar) >= A || !H.trim()) J += `
` + b.slice(A);
                        else {
                            if (D) break;
                            if (q.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) break;
                            if (L.test(q)) break;
                            if (G.test(q)) break;
                            if (F.test(q)) break;
                            J += `
` + H
                        }
                        if (!D && !H.trim()) D = !0;
                        O += M + `
`, v = v.substring(M.length + 1), q = b.slice(A)
                    }
                }
                if (!N.loose) {
                    if (x) N.loose = !0;
                    else if (this.rules.other.doubleBlankLine.test(O)) x = !0
                }
                let w = null,
                    Z;
                if (this.options.gfm) {
                    if (w = this.rules.other.listIsTask.exec(J), w) Z = w[0] !== "[ ] ", J = J.replace(this.rules.other.listReplaceTask, "")
                }
                N.items.push({
                    type: "list_item",
                    raw: O,
                    task: !!w,
                    checked: Z,
                    loose: !1,
                    text: J,
                    tokens: []
                }), N.raw += O
            }
            let j = N.items.at(-1);
            if (j) j.raw = j.raw.trimEnd(), j.text = j.text.trimEnd();
            else return;
            N.raw = N.raw.trimEnd();
            for (let B = 0; B < N.items.length; B++)
                if (this.lexer.state.top = !1, N.items[B].tokens = this.lexer.blockTokens(N.items[B].text, []), !N.loose) {
                    let O = N.items[B].tokens.filter((q) => q.type === "space"),
                        J = O.length > 0 && O.some((q) => this.rules.other.anyLine.test(q.raw));
                    N.loose = J
                } if (N.loose)
                for (let B = 0; B < N.items.length; B++) N.items[B].loose = !0;
            return N
        }
    }
    html(v) {
        let z = this.rules.block.html.exec(v);
        if (z) return {
            type: "html",
            block: !0,
            raw: z[0],
            pre: z[1] === "pre" || z[1] === "script" || z[1] === "style",
            text: z[0]
        }
    }
    def(v) {
        let z = this.rules.block.def.exec(v);
        if (z) {
            let U = z[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "),
                V = z[2] ? z[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "",
                N = z[3] ? z[3].substring(1, z[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : z[3];
            return {
                type: "def",
                tag: U,
                raw: z[0],
                href: V,
                title: N
            }
        }
    }
    table(v) {
        let z = this.rules.block.table.exec(v);
        if (!z) return;
        if (!this.rules.other.tableDelimiter.test(z[2])) return;
        let U = QT(z[1]),
            V = z[2].replace(this.rules.other.tableAlignChars, "").split("|"),
            N = z[3]?.trim() ? z[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [],
            K = {
                type: "table",
                raw: z[0],
                header: [],
                align: [],
                rows: []
            };
        if (U.length !== V.length) return;
        for (let x of V)
            if (this.rules.other.tableAlignRight.test(x)) K.align.push("right");
            else if (this.rules.other.tableAlignCenter.test(x)) K.align.push("center");
        else if (this.rules.other.tableAlignLeft.test(x)) K.align.push("left");
        else K.align.push(null);
        for (let x = 0; x < U.length; x++) K.header.push({
            text: U[x],
            tokens: this.lexer.inline(U[x]),
            header: !0,
            align: K.align[x]
        });
        for (let x of N) K.rows.push(QT(x, K.header.length).map((j, B) => {
            return {
                text: j,
                tokens: this.lexer.inline(j),
                header: !1,
                align: K.align[B]
            }
        }));
        return K
    }
    lheading(v) {
        let z = this.rules.block.lheading.exec(v);
        if (z) return {
            type: "heading",
            raw: z[0],
            depth: z[2].charAt(0) === "=" ? 1 : 2,
            text: z[1],
            tokens: this.lexer.inline(z[1])
        }
    }
    paragraph(v) {
        let z = this.rules.block.paragraph.exec(v);
        if (z) {
            let U = z[1].charAt(z[1].length - 1) === `
` ? z[1].slice(0, -1) : z[1];
            return {
                type: "paragraph",
                raw: z[0],
                text: U,
                tokens: this.lexer.inline(U)
            }
        }
    }
    text(v) {
        let z = this.rules.block.text.exec(v);
        if (z) return {
            type: "text",
            raw: z[0],
            text: z[0],
            tokens: this.lexer.inline(z[0])
        }
    }
    escape(v) {
        let z = this.rules.inline.escape.exec(v);
        if (z) return {
            type: "escape",
            raw: z[0],
            text: z[1]
        }
    }
    tag(v) {
        let z = this.rules.inline.tag.exec(v);
        if (z) {
            if (!this.lexer.state.inLink && this.rules.other.startATag.test(z[0])) this.lexer.state.inLink = !0;
            else if (this.lexer.state.inLink && this.rules.other.endATag.test(z[0])) this.lexer.state.inLink = !1;
            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(z[0])) this.lexer.state.inRawBlock = !0;
            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(z[0])) this.lexer.state.inRawBlock = !1;
            return {
                type: "html",
                raw: z[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: !1,
                text: z[0]
            }
        }
    }
    link(v) {
        let z = this.rules.inline.link.exec(v);
        if (z) {
            let U = z[2].trim();
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(U)) {
                if (!this.rules.other.endAngleBracket.test(U)) return;
                let K = RU(U.slice(0, -1), "\\");
                if ((U.length - K.length) % 2 === 0) return
            } else {
                let K = DU6(z[2], "()");
                if (K > -1) {
                    let j = (z[0].indexOf("!") === 0 ? 5 : 4) + z[1].length + K;
                    z[2] = z[2].substring(0, K), z[0] = z[0].substring(0, j).trim(), z[3] = ""
                }
            }
            let V = z[2],
                N = "";
            if (this.options.pedantic) {
                let K = this.rules.other.pedanticHrefTitle.exec(V);
                if (K) V = K[1], N = K[3]
            } else N = z[3] ? z[3].slice(1, -1) : "";
            if (V = V.trim(), this.rules.other.startAngleBracket.test(V))
                if (this.options.pedantic && !this.rules.other.endAngleBracket.test(U)) V = V.slice(1);
                else V = V.slice(1, -1);
            return dT(z, {
                href: V ? V.replace(this.rules.inline.anyPunctuation, "$1") : V,
                title: N ? N.replace(this.rules.inline.anyPunctuation, "$1") : N
            }, z[0], this.lexer, this.rules)
        }
    }
    reflink(v, z) {
        let U;
        if ((U = this.rules.inline.reflink.exec(v)) || (U = this.rules.inline.nolink.exec(v))) {
            let V = (U[2] || U[1]).replace(this.rules.other.multipleSpaceGlobal, " "),
                N = z[V.toLowerCase()];
            if (!N) {
                let K = U[0].charAt(0);
                return {
                    type: "text",
                    raw: K,
                    text: K
                }
            }
            return dT(U, N, U[0], this.lexer, this.rules)
        }
    }
    emStrong(v, z, U = "") {
        let V = this.rules.inline.emStrongLDelim.exec(v);
        if (!V) return;
        if (V[3] && U.match(this.rules.other.unicodeAlphaNumeric)) return;
        if (!(V[1] || V[2]) || !U || this.rules.inline.punctuation.exec(U)) {
            let K = [...V[0]].length - 1,
                x, j, B = K,
                O = 0,
                J = V[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            J.lastIndex = 0, z = z.slice(-1 * v.length + K);
            while ((V = J.exec(z)) != null) {
                if (x = V[1] || V[2] || V[3] || V[4] || V[5] || V[6], !x) continue;
                if (j = [...x].length, V[3] || V[4]) {
                    B += j;
                    continue
                } else if (V[5] || V[6]) {
                    if (K % 3 && !((K + j) % 3)) {
                        O += j;
                        continue
                    }
                }
                if (B -= j, B > 0) continue;
                j = Math.min(j, j + B + O);
                let q = [...V[0]][0].length,
                    H = v.slice(0, K + V.index + q + j);
                if (Math.min(K, j) % 2) {
                    let A = H.slice(1, -1);
                    return {
                        type: "em",
                        raw: H,
                        text: A,
                        tokens: this.lexer.inlineTokens(A)
                    }
                }
                let D = H.slice(2, -2);
                return {
                    type: "strong",
                    raw: H,
                    text: D,
                    tokens: this.lexer.inlineTokens(D)
                }
            }
        }
    }
    codespan(v) {
        let z = this.rules.inline.code.exec(v);
        if (z) {
            let U = z[2].replace(this.rules.other.newLineCharGlobal, " "),
                V = this.rules.other.nonSpaceChar.test(U),
                N = this.rules.other.startingSpaceChar.test(U) && this.rules.other.endingSpaceChar.test(U);
            if (V && N) U = U.substring(1, U.length - 1);
            return {
                type: "codespan",
                raw: z[0],
                text: U
            }
        }
    }
    br(v) {
        let z = this.rules.inline.br.exec(v);
        if (z) return {
            type: "br",
            raw: z[0]
        }
    }
    del(v) {
        let z = this.rules.inline.del.exec(v);
        if (z) return {
            type: "del",
            raw: z[0],
            text: z[2],
            tokens: this.lexer.inlineTokens(z[2])
        }
    }
    autolink(v) {
        let z = this.rules.inline.autolink.exec(v);
        if (z) {
            let U, V;
            if (z[2] === "@") U = z[1], V = "mailto:" + U;
            else U = z[1], V = U;
            return {
                type: "link",
                raw: z[0],
                text: U,
                href: V,
                tokens: [{
                    type: "text",
                    raw: U,
                    text: U
                }]
            }
        }
    }
    url(v) {
        let z;
        if (z = this.rules.inline.url.exec(v)) {
            let U, V;
            if (z[2] === "@") U = z[0], V = "mailto:" + U;
            else {
                let N;
                do N = z[0], z[0] = this.rules.inline._backpedal.exec(z[0])?.[0] ?? ""; while (N !== z[0]);
                if (U = z[0], z[1] === "www.") V = "http://" + z[0];
                else V = z[0]
            }
            return {
                type: "link",
                raw: z[0],
                text: U,
                href: V,
                tokens: [{
                    type: "text",
                    raw: U,
                    text: U
                }]
            }
        }
    }
    inlineText(v) {
        let z = this.rules.inline.text.exec(v);
        if (z) {
            let U = this.lexer.state.inRawBlock;
            return {
                type: "text",
                raw: z[0],
                text: z[0],
                escaped: U
            }
        }
    }
}
class h3 {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(v) {
        this.tokens = [], this.tokens.links = Object.create(null), this.options = v || q7, this.options.tokenizer = this.options.tokenizer || new SU, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
            inLink: !1,
            inRawBlock: !1,
            top: !0
        };
        let z = {
            other: v3,
            block: lx.normal,
            inline: bU.normal
        };
        if (this.options.pedantic) z.block = lx.pedantic, z.inline = bU.pedantic;
        else if (this.options.gfm)
            if (z.block = lx.gfm, this.options.breaks) z.inline = bU.breaks;
            else z.inline = bU.gfm;
        this.tokenizer.rules = z
    }
    static get rules() {
        return {
            block: lx,
            inline: bU
        }
    }
    static lex(v, z) {
        return new h3(z).lex(v)
    }
    static lexInline(v, z) {
        return new h3(z).inlineTokens(v)
    }
    lex(v) {
        v = v.replace(v3.carriageReturn, `
`), this.blockTokens(v, this.tokens);
        for (let z = 0; z < this.inlineQueue.length; z++) {
            let U = this.inlineQueue[z];
            this.inlineTokens(U.src, U.tokens)
        }
        return this.inlineQueue = [], this.tokens
    }
    blockTokens(v, z = [], U = !1) {
        if (this.options.pedantic) v = v.replace(v3.tabCharGlobal, "    ").replace(v3.spaceLine, "");
        while (v) {
            let V;
            if (this.options.extensions?.block?.some((K) => {
                    if (V = K.call({
                            lexer: this
                        }, v, z)) return v = v.substring(V.raw.length), z.push(V), !0;
                    return !1
                })) continue;
            if (V = this.tokenizer.space(v)) {
                v = v.substring(V.raw.length);
                let K = z.at(-1);
                if (V.raw.length === 1 && K !== void 0) K.raw += `
`;
                else z.push(V);
                continue
            }
            if (V = this.tokenizer.code(v)) {
                v = v.substring(V.raw.length);
                let K = z.at(-1);
                if (K?.type === "paragraph" || K?.type === "text") K.raw += `
` + V.raw, K.text += `
` + V.text, this.inlineQueue.at(-1).src = K.text;
                else z.push(V);
                continue
            }
            if (V = this.tokenizer.fences(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.heading(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.hr(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.blockquote(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.list(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.html(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.def(v)) {
                v = v.substring(V.raw.length);
                let K = z.at(-1);
                if (K?.type === "paragraph" || K?.type === "text") K.raw += `
` + V.raw, K.text += `
` + V.raw, this.inlineQueue.at(-1).src = K.text;
                else if (!this.tokens.links[V.tag]) this.tokens.links[V.tag] = {
                    href: V.href,
                    title: V.title
                };
                continue
            }
            if (V = this.tokenizer.table(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            if (V = this.tokenizer.lheading(v)) {
                v = v.substring(V.raw.length), z.push(V);
                continue
            }
            let N = v;
            if (this.options.extensions?.startBlock) {
                let K = 1 / 0,
                    x = v.slice(1),
                    j;
                if (this.options.extensions.startBlock.forEach((B) => {
                        if (j = B.call({
                                lexer: this
                            }, x), typeof j === "number" && j >= 0) K = Math.min(K, j)
                    }), K < 1 / 0 && K >= 0) N = v.substring(0, K + 1)
            }
            if (this.state.top && (V = this.tokenizer.paragraph(N))) {
                let K = z.at(-1);
                if (U && K?.type === "paragraph") K.raw += `
` + V.raw, K.text += `
` + V.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = K.text;
                else z.push(V);
                U = N.length !== v.length, v = v.substring(V.raw.length);
                continue
            }
            if (V = this.tokenizer.text(v)) {
                v = v.substring(V.raw.length);
                let K = z.at(-1);
                if (K?.type === "text") K.raw += `
` + V.raw, K.text += `
` + V.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = K.text;
                else z.push(V);
                continue
            }
            if (v) {
                let K = "Infinite loop on byte: " + v.charCodeAt(0);
                if (this.options.silent) {
                    console.error(K);
                    break
                } else throw Error(K)
            }
        }
        return this.state.top = !0, z
    }
    inline(v, z = []) {
        return this.inlineQueue.push({
            src: v,
            tokens: z
        }), z
    }
    inlineTokens(v, z = []) {
        let U = v,
            V = null;
        if (this.tokens.links) {
            let x = Object.keys(this.tokens.links);
            if (x.length > 0) {
                while ((V = this.tokenizer.rules.inline.reflinkSearch.exec(U)) != null)
                    if (x.includes(V[0].slice(V[0].lastIndexOf("[") + 1, -1))) U = U.slice(0, V.index) + "[" + "a".repeat(V[0].length - 2) + "]" + U.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)
            }
        }
        while ((V = this.tokenizer.rules.inline.blockSkip.exec(U)) != null) U = U.slice(0, V.index) + "[" + "a".repeat(V[0].length - 2) + "]" + U.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        while ((V = this.tokenizer.rules.inline.anyPunctuation.exec(U)) != null) U = U.slice(0, V.index) + "++" + U.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        let N = !1,
            K = "";
        while (v) {
            if (!N) K = "";
            N = !1;
            let x;
            if (this.options.extensions?.inline?.some((B) => {
                    if (x = B.call({
                            lexer: this
                        }, v, z)) return v = v.substring(x.raw.length), z.push(x), !0;
                    return !1
                })) continue;
            if (x = this.tokenizer.escape(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.tag(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.link(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.reflink(v, this.tokens.links)) {
                v = v.substring(x.raw.length);
                let B = z.at(-1);
                if (x.type === "text" && B?.type === "text") B.raw += x.raw, B.text += x.text;
                else z.push(x);
                continue
            }
            if (x = this.tokenizer.emStrong(v, U, K)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.codespan(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.br(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.del(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (x = this.tokenizer.autolink(v)) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            if (!this.state.inLink && (x = this.tokenizer.url(v))) {
                v = v.substring(x.raw.length), z.push(x);
                continue
            }
            let j = v;
            if (this.options.extensions?.startInline) {
                let B = 1 / 0,
                    O = v.slice(1),
                    J;
                if (this.options.extensions.startInline.forEach((q) => {
                        if (J = q.call({
                                lexer: this
                            }, O), typeof J === "number" && J >= 0) B = Math.min(B, J)
                    }), B < 1 / 0 && B >= 0) j = v.substring(0, B + 1)
            }
            if (x = this.tokenizer.inlineText(j)) {
                if (v = v.substring(x.raw.length), x.raw.slice(-1) !== "_") K = x.raw.slice(-1);
                N = !0;
                let B = z.at(-1);
                if (B?.type === "text") B.raw += x.raw, B.text += x.text;
                else z.push(x);
                continue
            }
            if (v) {
                let B = "Infinite loop on byte: " + v.charCodeAt(0);
                if (this.options.silent) {
                    console.error(B);
                    break
                } else throw Error(B)
            }
        }
        return z
    }
}
class PU {
    options;
    parser;
    constructor(v) {
        this.options = v || q7
    }
    space(v) {
        return ""
    }
    code({
        text: v,
        lang: z,
        escaped: U
    }) {
        let V = (z || "").match(v3.notSpaceStart)?.[0],
            N = v.replace(v3.endingNewline, "") + `
`;
        if (!V) return "<pre><code>" + (U ? N : i8(N, !0)) + `</code></pre>
`;
        return '<pre><code class="language-' + i8(V) + '">' + (U ? N : i8(N, !0)) + `</code></pre>
`
    }
    blockquote({
        tokens: v
    }) {
        return `<blockquote>
${this.parser.parse(v)}</blockquote>
`
    }
    html({
        text: v
    }) {
        return v
    }
    heading({
        tokens: v,
        depth: z
    }) {
        return `<h${z}>${this.parser.parseInline(v)}</h${z}>
`
    }
    hr(v) {
        return `<hr>
`
    }
    list(v) {
        let {
            ordered: z,
            start: U
        } = v, V = "";
        for (let x = 0; x < v.items.length; x++) {
            let j = v.items[x];
            V += this.listitem(j)
        }
        let N = z ? "ol" : "ul",
            K = z && U !== 1 ? ' start="' + U + '"' : "";
        return "<" + N + K + `>
` + V + "</" + N + `>
`
    }
    listitem(v) {
        let z = "";
        if (v.task) {
            let U = this.checkbox({
                checked: !!v.checked
            });
            if (v.loose)
                if (v.tokens[0]?.type === "paragraph") {
                    if (v.tokens[0].text = U + " " + v.tokens[0].text, v.tokens[0].tokens && v.tokens[0].tokens.length > 0 && v.tokens[0].tokens[0].type === "text") v.tokens[0].tokens[0].text = U + " " + i8(v.tokens[0].tokens[0].text), v.tokens[0].tokens[0].escaped = !0
                } else v.tokens.unshift({
                    type: "text",
                    raw: U + " ",
                    text: U + " ",
                    escaped: !0
                });
            else z += U + " "
        }
        return z += this.parser.parse(v.tokens, !!v.loose), `<li>${z}</li>
`
    }
    checkbox({
        checked: v
    }) {
        return "<input " + (v ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
    }
    paragraph({
        tokens: v
    }) {
        return `<p>${this.parser.parseInline(v)}</p>
`
    }
    table(v) {
        let z = "",
            U = "";
        for (let N = 0; N < v.header.length; N++) U += this.tablecell(v.header[N]);
        z += this.tablerow({
            text: U
        });
        let V = "";
        for (let N = 0; N < v.rows.length; N++) {
            let K = v.rows[N];
            U = "";
            for (let x = 0; x < K.length; x++) U += this.tablecell(K[x]);
            V += this.tablerow({
                text: U
            })
        }
        if (V) V = `<tbody>${V}</tbody>`;
        return `<table>
<thead>
` + z + `</thead>
` + V + `</table>
`
    }
    tablerow({
        text: v
    }) {
        return `<tr>
${v}</tr>
`
    }
    tablecell(v) {
        let z = this.parser.parseInline(v.tokens),
            U = v.header ? "th" : "td";
        return (v.align ? `<${U} align="${v.align}">` : `<${U}>`) + z + `</${U}>
`
    }
    strong({
        tokens: v
    }) {
        return `<strong>${this.parser.parseInline(v)}</strong>`
    }
    em({
        tokens: v
    }) {
        return `<em>${this.parser.parseInline(v)}</em>`
    }
    codespan({
        text: v
    }) {
        return `<code>${i8(v,!0)}</code>`
    }
    br(v) {
        return "<br>"
    }
    del({
        tokens: v
    }) {
        return `<del>${this.parser.parseInline(v)}</del>`
    }
    link({
        href: v,
        title: z,
        tokens: U
    }) {
        let V = this.parser.parseInline(U),
            N = nT(v);
        if (N === null) return V;
        v = N;
        let K = '<a href="' + v + '"';
        if (z) K += ' title="' + i8(z) + '"';
        return K += ">" + V + "</a>", K
    }
    image({
        href: v,
        title: z,
        text: U
    }) {
        let V = nT(v);
        if (V === null) return i8(U);
        v = V;
        let N = `<img src="${v}" alt="${U}"`;
        if (z) N += ` title="${i8(z)}"`;
        return N += ">", N
    }
    text(v) {
        return "tokens" in v && v.tokens ? this.parser.parseInline(v.tokens) : ("escaped" in v) && v.escaped ? v.text : i8(v.text)
    }
}
class Qx {
    strong({
        text: v
    }) {
        return v
    }
    em({
        text: v
    }) {
        return v
    }
    codespan({
        text: v
    }) {
        return v
    }
    del({
        text: v
    }) {
        return v
    }
    html({
        text: v
    }) {
        return v
    }
    text({
        text: v
    }) {
        return v
    }
    link({
        text: v
    }) {
        return "" + v
    }
    image({
        text: v
    }) {
        return "" + v
    }
    br() {
        return ""
    }
}
class p3 {
    options;
    renderer;
    textRenderer;
    constructor(v) {
        this.options = v || q7, this.options.renderer = this.options.renderer || new PU, this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Qx
    }
    static parse(v, z) {
        return new p3(z).parse(v)
    }
    static parseInline(v, z) {
        return new p3(z).parseInline(v)
    }
    parse(v, z = !0) {
        let U = "";
        for (let V = 0; V < v.length; V++) {
            let N = v[V];
            if (this.options.extensions?.renderers?.[N.type]) {
                let x = N,
                    j = this.options.extensions.renderers[x.type].call({
                        parser: this
                    }, x);
                if (j !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(x.type)) {
                    U += j || "";
                    continue
                }
            }
            let K = N;
            switch (K.type) {
                case "space": {
                    U += this.renderer.space(K);
                    continue
                }
                case "hr": {
                    U += this.renderer.hr(K);
                    continue
                }
                case "heading": {
                    U += this.renderer.heading(K);
                    continue
                }
                case "code": {
                    U += this.renderer.code(K);
                    continue
                }
                case "table": {
                    U += this.renderer.table(K);
                    continue
                }
                case "blockquote": {
                    U += this.renderer.blockquote(K);
                    continue
                }
                case "list": {
                    U += this.renderer.list(K);
                    continue
                }
                case "html": {
                    U += this.renderer.html(K);
                    continue
                }
                case "paragraph": {
                    U += this.renderer.paragraph(K);
                    continue
                }
                case "text": {
                    let x = K,
                        j = this.renderer.text(x);
                    while (V + 1 < v.length && v[V + 1].type === "text") x = v[++V], j += `
` + this.renderer.text(x);
                    if (z) U += this.renderer.paragraph({
                        type: "paragraph",
                        raw: j,
                        text: j,
                        tokens: [{
                            type: "text",
                            raw: j,
                            text: j,
                            escaped: !0
                        }]
                    });
                    else U += j;
                    continue
                }
                default: {
                    let x = 'Token with "' + K.type + '" type was not found.';
                    if (this.options.silent) return console.error(x), "";
                    else throw Error(x)
                }
            }
        }
        return U
    }
    parseInline(v, z = this.renderer) {
        let U = "";
        for (let V = 0; V < v.length; V++) {
            let N = v[V];
            if (this.options.extensions?.renderers?.[N.type]) {
                let x = this.options.extensions.renderers[N.type].call({
                    parser: this
                }, N);
                if (x !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(N.type)) {
                    U += x || "";
                    continue
                }
            }
            let K = N;
            switch (K.type) {
                case "escape": {
                    U += z.text(K);
                    break
                }
                case "html": {
                    U += z.html(K);
                    break
                }
                case "link": {
                    U += z.link(K);
                    break
                }
                case "image": {
                    U += z.image(K);
                    break
                }
                case "strong": {
                    U += z.strong(K);
                    break
                }
                case "em": {
                    U += z.em(K);
                    break
                }
                case "codespan": {
                    U += z.codespan(K);
                    break
                }
                case "br": {
                    U += z.br(K);
                    break
                }
                case "del": {
                    U += z.del(K);
                    break
                }
                case "text": {
                    U += z.text(K);
                    break
                }
                default: {
                    let x = 'Token with "' + K.type + '" type was not found.';
                    if (this.options.silent) return console.error(x), "";
                    else throw Error(x)
                }
            }
        }
        return U
    }
}
class EU {
    options;
    block;
    constructor(v) {
        this.options = v || q7
    }
    static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens"]);
    preprocess(v) {
        return v
    }
    postprocess(v) {
        return v
    }
    processAllTokens(v) {
        return v
    }
    provideLexer() {
        return this.block ? h3.lex : h3.lexInline
    }
    provideParser() {
        return this.block ? p3.parse : p3.parseInline
    }
}
class KY {
    defaults = d2();
    options = this.setOptions;
    parse = this.parseMarkdown(!0);
    parseInline = this.parseMarkdown(!1);
    Parser = p3;
    Renderer = PU;
    TextRenderer = Qx;
    Lexer = h3;
    Tokenizer = SU;
    Hooks = EU;
    constructor(...v) {
        this.use(...v)
    }
    walkTokens(v, z) {
        let U = [];
        for (let V of v) switch (U = U.concat(z.call(this, V)), V.type) {
            case "table": {
                let N = V;
                for (let K of N.header) U = U.concat(this.walkTokens(K.tokens, z));
                for (let K of N.rows)
                    for (let x of K) U = U.concat(this.walkTokens(x.tokens, z));
                break
            }
            case "list": {
                let N = V;
                U = U.concat(this.walkTokens(N.items, z));
                break
            }
            default: {
                let N = V;
                if (this.defaults.extensions?.childTokens?.[N.type]) this.defaults.extensions.childTokens[N.type].forEach((K) => {
                    let x = N[K].flat(1 / 0);
                    U = U.concat(this.walkTokens(x, z))
                });
                else if (N.tokens) U = U.concat(this.walkTokens(N.tokens, z))
            }
        }
        return U
    }
    use(...v) {
        let z = this.defaults.extensions || {
            renderers: {},
            childTokens: {}
        };
        return v.forEach((U) => {
            let V = {
                ...U
            };
            if (V.async = this.defaults.async || V.async || !1, U.extensions) U.extensions.forEach((N) => {
                if (!N.name) throw Error("extension name required");
                if ("renderer" in N) {
                    let K = z.renderers[N.name];
                    if (K) z.renderers[N.name] = function(...x) {
                        let j = N.renderer.apply(this, x);
                        if (j === !1) j = K.apply(this, x);
                        return j
                    };
                    else z.renderers[N.name] = N.renderer
                }
                if ("tokenizer" in N) {
                    if (!N.level || N.level !== "block" && N.level !== "inline") throw Error("extension level must be 'block' or 'inline'");
                    let K = z[N.level];
                    if (K) K.unshift(N.tokenizer);
                    else z[N.level] = [N.tokenizer];
                    if (N.start) {
                        if (N.level === "block")
                            if (z.startBlock) z.startBlock.push(N.start);
                            else z.startBlock = [N.start];
                        else if (N.level === "inline")
                            if (z.startInline) z.startInline.push(N.start);
                            else z.startInline = [N.start]
                    }
                }
                if ("childTokens" in N && N.childTokens) z.childTokens[N.name] = N.childTokens
            }), V.extensions = z;
            if (U.renderer) {
                let N = this.defaults.renderer || new PU(this.defaults);
                for (let K in U.renderer) {
                    if (!(K in N)) throw Error(`renderer '${K}' does not exist`);
                    if (["options", "parser"].includes(K)) continue;
                    let x = K,
                        j = U.renderer[x],
                        B = N[x];
                    N[x] = (...O) => {
                        let J = j.apply(N, O);
                        if (J === !1) J = B.apply(N, O);
                        return J || ""
                    }
                }
                V.renderer = N
            }
            if (U.tokenizer) {
                let N = this.defaults.tokenizer || new SU(this.defaults);
                for (let K in U.tokenizer) {
                    if (!(K in N)) throw Error(`tokenizer '${K}' does not exist`);
                    if (["options", "rules", "lexer"].includes(K)) continue;
                    let x = K,
                        j = U.tokenizer[x],
                        B = N[x];
                    N[x] = (...O) => {
                        let J = j.apply(N, O);
                        if (J === !1) J = B.apply(N, O);
                        return J
                    }
                }
                V.tokenizer = N
            }
            if (U.hooks) {
                let N = this.defaults.hooks || new EU;
                for (let K in U.hooks) {
                    if (!(K in N)) throw Error(`hook '${K}' does not exist`);
                    if (["options", "block"].includes(K)) continue;
                    let x = K,
                        j = U.hooks[x],
                        B = N[x];
                    if (EU.passThroughHooks.has(K)) N[x] = (O) => {
                        if (this.defaults.async) return Promise.resolve(j.call(N, O)).then((q) => {
                            return B.call(N, q)
                        });
                        let J = j.call(N, O);
                        return B.call(N, J)
                    };
                    else N[x] = (...O) => {
                        let J = j.apply(N, O);
                        if (J === !1) J = B.apply(N, O);
                        return J
                    }
                }
                V.hooks = N
            }
            if (U.walkTokens) {
                let N = this.defaults.walkTokens,
                    K = U.walkTokens;
                V.walkTokens = function(x) {
                    let j = [];
                    if (j.push(K.call(this, x)), N) j = j.concat(N.call(this, x));
                    return j
                }
            }
            this.defaults = {
                ...this.defaults,
                ...V
            }
        }), this
    }
    setOptions(v) {
        return this.defaults = {
            ...this.defaults,
            ...v
        }, this
    }
    lexer(v, z) {
        return h3.lex(v, z ?? this.defaults)
    }
    parser(v, z) {
        return p3.parse(v, z ?? this.defaults)
    }
    parseMarkdown(v) {
        return (U, V) => {
            let N = {
                    ...V
                },
                K = {
                    ...this.defaults,
                    ...N
                },
                x = this.onError(!!K.silent, !!K.async);
            if (this.defaults.async === !0 && N.async === !1) return x(Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
            if (typeof U > "u" || U === null) return x(Error("marked(): input parameter is undefined or null"));
            if (typeof U !== "string") return x(Error("marked(): input parameter is of type " + Object.prototype.toString.call(U) + ", string expected"));
            if (K.hooks) K.hooks.options = K, K.hooks.block = v;
            let j = K.hooks ? K.hooks.provideLexer() : v ? h3.lex : h3.lexInline,
                B = K.hooks ? K.hooks.provideParser() : v ? p3.parse : p3.parseInline;
            if (K.async) return Promise.resolve(K.hooks ? K.hooks.preprocess(U) : U).then((O) => j(O, K)).then((O) => K.hooks ? K.hooks.processAllTokens(O) : O).then((O) => K.walkTokens ? Promise.all(this.walkTokens(O, K.walkTokens)).then(() => O) : O).then((O) => B(O, K)).then((O) => K.hooks ? K.hooks.postprocess(O) : O).catch(x);
            try {
                if (K.hooks) U = K.hooks.preprocess(U);
                let O = j(U, K);
                if (K.hooks) O = K.hooks.processAllTokens(O);
                if (K.walkTokens) this.walkTokens(O, K.walkTokens);
                let J = B(O, K);
                if (K.hooks) J = K.hooks.postprocess(J);
                return J
            } catch (O) {
                return x(O)
            }
        }
    }
    onError(v, z) {
        return (U) => {
            if (U.message += `
Please report this to https://github.com/markedjs/marked.`, v) {
                let V = "<p>An error occurred:</p><pre>" + i8(U.message + "", !0) + "</pre>";
                if (z) return Promise.resolve(V);
                return V
            }
            if (z) return Promise.reject(U);
            throw U
        }
    }
}
var J7 = new KY;

function I0(v, z) {
    return J7.parse(v, z)
}
I0.options = I0.setOptions = function(v) {
    return J7.setOptions(v), I0.defaults = J7.defaults, oT(I0.defaults), I0
};
I0.getDefaults = d2;
I0.defaults = q7;
I0.use = function(...v) {
    return J7.use(...v), I0.defaults = J7.defaults, oT(I0.defaults), I0
};
I0.walkTokens = function(v, z) {
    return J7.walkTokens(v, z)
};
I0.parseInline = J7.parseInline;
I0.Parser = p3;
I0.parser = p3.parse;
I0.Renderer = PU;
I0.TextRenderer = Qx;
I0.Lexer = h3;
I0.lexer = h3.lex;
I0.Tokenizer = SU;
I0.Hooks = EU;
I0.parse = I0;
var {
    options: cS6,
    setOptions: iS6,
    use: lS6,
    walkTokens: hS6,
    parseInline: pS6
} = I0;
var nS6 = p3.parse,
    QS6 = h3.lex;
var xY = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{TITLE}}</title>
<style>
  body {
    font-family: var(--vscode-markdown-font-family, var(--vscode-font-family));
    font-size: var(--vscode-markdown-font-size, 14px);
    line-height: 1.6;
    color: var(--vscode-editor-foreground);
    background: var(--vscode-editor-background);
    padding: 16px 24px;
    margin: 0;
  }
  h1, h2, h3, h4, h5, h6 {
    color: var(--vscode-editor-foreground);
    margin-top: 24px;
    margin-bottom: 8px;
    font-weight: 600;
  }
  h1 { font-size: 1.6em; border-bottom: 1px solid var(--vscode-panel-border); padding-bottom: 8px; }
  h2 { font-size: 1.3em; border-bottom: 1px solid var(--vscode-panel-border); padding-bottom: 6px; }
  h3 { font-size: 1.1em; }
  code {
    font-family: var(--vscode-editor-font-family);
    font-size: var(--vscode-editor-font-size, 13px);
    background: var(--vscode-textCodeBlock-background);
    padding: 2px 4px;
    border-radius: 3px;
  }
  pre {
    background: var(--vscode-textCodeBlock-background);
    padding: 12px;
    border-radius: 4px;
    overflow-x: auto;
  }
  pre code { background: none; padding: 0; }
  blockquote {
    border-left: 3px solid var(--vscode-textBlockQuote-border);
    margin: 8px 0;
    padding: 4px 12px;
    color: var(--vscode-textBlockQuote-foreground);
  }
  a { color: var(--vscode-textLink-foreground); }
  a:hover { color: var(--vscode-textLink-activeForeground); }
  ul, ol { padding-left: 24px; }
  li { margin: 4px 0; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid var(--vscode-panel-border); padding: 6px 12px; text-align: left; }
  th { background: var(--vscode-textCodeBlock-background); }
  hr { border: none; border-top: 1px solid var(--vscode-panel-border); margin: 16px 0; }
  mark {
    background: color-mix(in srgb, var(--vscode-editor-findMatchHighlightBackground, #ea5c0055) 60%, transparent);
    border-radius: 2px;
    padding: 1px 0;
    position: relative;
  }
  mark .comment-indicator {
    display: inline-block;
    width: 14px;
    height: 14px;
    background: var(--vscode-textLink-foreground);
    color: var(--vscode-editor-background);
    border-radius: 50%;
    font-size: 10px;
    line-height: 14px;
    text-align: center;
    margin-left: 2px;
    cursor: pointer;
    vertical-align: middle;
  }

  #comment-btn {
    position: fixed;
    background: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    z-index: 100;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    display: none;
  }
  #comment-btn:hover { background: var(--vscode-button-hoverBackground); }

  #comment-input {
    position: fixed;
    background: var(--vscode-editorWidget-background);
    border: 1px solid var(--vscode-editorWidget-border, var(--vscode-panel-border));
    border-radius: 6px;
    padding: 12px;
    z-index: 101;
    width: 320px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    display: none;
  }
  #comment-input .selected-text-preview {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
    border-left: 2px solid var(--vscode-textBlockQuote-border);
    padding: 4px 8px;
    margin-bottom: 8px;
    max-height: 60px;
    overflow: hidden;
    white-space: pre-wrap;
    word-break: break-word;
  }
  #comment-input textarea {
    width: 100%;
    min-height: 60px;
    background: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border, var(--vscode-panel-border));
    border-radius: 3px;
    padding: 6px 8px;
    font-family: var(--vscode-font-family);
    font-size: 13px;
    resize: vertical;
    box-sizing: border-box;
  }
  #comment-input textarea:focus { outline: 1px solid var(--vscode-focusBorder); }
  .comment-actions {
    display: flex;
    gap: 6px;
    margin-top: 8px;
    justify-content: flex-end;
  }
  .comment-actions button {
    padding: 4px 12px;
    border-radius: 3px;
    font-size: 12px;
    cursor: pointer;
    border: none;
  }
  .comment-actions .submit-btn {
    background: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
  }
  .comment-actions .submit-btn:hover { background: var(--vscode-button-hoverBackground); }
  .comment-actions .cancel-btn {
    background: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
  }
  .comment-actions .cancel-btn:hover { background: var(--vscode-button-secondaryHoverBackground); }
</style>
</head>
<body>
  <div id="content">{{CONTENT}}</div>

  <div id="comment-btn">Add Comment</div>

  <div id="comment-input">
    <div class="selected-text-preview" id="selected-text-preview"></div>
    <textarea id="comment-textarea" placeholder="Add your feedback\\u2026"></textarea>
    <div class="comment-actions">
      <button class="cancel-btn" id="cancel-btn">Cancel</button>
      <button class="submit-btn" id="submit-btn">Add Comment</button>
    </div>
  </div>

  <script>
    (function() {
      const vscode = acquireVsCodeApi();
      const commentBtn = document.getElementById('comment-btn');
      const commentInput = document.getElementById('comment-input');
      const selectedTextPreview = document.getElementById('selected-text-preview');
      const textarea = document.getElementById('comment-textarea');
      const submitBtn = document.getElementById('submit-btn');
      const cancelBtn = document.getElementById('cancel-btn');

      let currentRange = null;
      let currentSelectedText = '';
      let commentCount = 0;

      function findSectionHeading(node) {
        let current = node;
        while (current) {
          // Check previous siblings
          let sibling = current.previousElementSibling || current.previousSibling;
          while (sibling) {
            if (sibling.tagName && /^H[1-6]$/.test(sibling.tagName)) {
              return sibling.textContent || '';
            }
            sibling = sibling.previousElementSibling || sibling.previousSibling;
          }
          current = current.parentElement;
        }
        return '';
      }

      function hideCommentUI() {
        commentBtn.style.display = 'none';
        commentInput.style.display = 'none';
        textarea.value = '';
        currentRange = null;
        currentSelectedText = '';
      }

      document.addEventListener('mouseup', function(e) {
        // Ignore clicks inside comment UI
        if (commentInput.contains(e.target) || commentBtn.contains(e.target)) {
          return;
        }

        const sel = window.getSelection();
        if (sel && sel.toString().trim() && sel.rangeCount > 0) {
          currentSelectedText = sel.toString().trim();
          currentRange = sel.getRangeAt(0).cloneRange();

          const rect = sel.getRangeAt(0).getBoundingClientRect();
          commentBtn.style.left = rect.left + 'px';
          commentBtn.style.top = (rect.bottom + 6) + 'px';
          commentBtn.style.display = 'block';
          commentInput.style.display = 'none';
        } else {
          // Small delay to allow button click to register
          setTimeout(function() {
            if (!commentInput.contains(document.activeElement)) {
              hideCommentUI();
            }
          }, 150);
        }
      });

      commentBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();

        if (!currentRange || !currentSelectedText) return;

        const rect = currentRange.getBoundingClientRect();

        // Truncate preview if too long
        const preview = currentSelectedText.length > 120
          ? currentSelectedText.slice(0, 120) + '\\u2026'
          : currentSelectedText;
        selectedTextPreview.textContent = preview;

        // Position input below the selection
        const inputLeft = Math.min(rect.left, window.innerWidth - 350);
        commentInput.style.left = Math.max(8, inputLeft) + 'px';
        commentInput.style.top = (rect.bottom + 8) + 'px';
        commentInput.style.display = 'block';
        commentBtn.style.display = 'none';

        textarea.focus();
      });

      submitBtn.addEventListener('click', function() {
        const commentText = textarea.value.trim();
        if (!commentText || !currentRange) return;

        const heading = findSectionHeading(currentRange.startContainer);

        const commentId = 'comment-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);

        // Highlight the commented text
        try {
          const mark = document.createElement('mark');
          mark.dataset.commentId = commentId;
          commentCount++;
          const indicator = document.createElement('span');
          indicator.className = 'comment-indicator';
          indicator.textContent = String(commentCount);
          indicator.title = commentText;

          currentRange.surroundContents(mark);
          mark.appendChild(indicator);
        } catch (e) {
          // surroundContents can fail if selection crosses element boundaries
          // In that case, just skip the highlight
        }

        vscode.postMessage({
          type: 'comment',
          id: commentId,
          selectedText: currentSelectedText,
          sectionHeading: heading,
          comment: commentText,
        });

        hideCommentUI();
        window.getSelection().removeAllRanges();
      });

      cancelBtn.addEventListener('click', function() {
        hideCommentUI();
      });

      // Handle messages from extension host (e.g. remove comment)
      window.addEventListener('message', function(event) {
        const msg = event.data;
        if (msg.type === 'removeComment' && msg.commentId) {
          const mark = document.querySelector('mark[data-comment-id="' + msg.commentId + '"]');
          if (mark) {
            // Unwrap the mark: move its text content back into the DOM
            const parent = mark.parentNode;
            while (mark.firstChild) {
              // Skip the comment indicator span
              if (mark.firstChild.className === 'comment-indicator') {
                mark.removeChild(mark.firstChild);
              } else {
                parent.insertBefore(mark.firstChild, mark);
              }
            }
            parent.removeChild(mark);
          }
        }
      });

      // Enter submits, Shift+Enter inserts newline
      textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          submitBtn.click();
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          hideCommentUI();
        }
      });
    })();
  </script>
</body>
</html>
`;
var wU6 = xY;

function jY(v, z, U) {
    let V = dx.window.createWebviewPanel("claudePlanPreview", z, {
            viewColumn: dx.ViewColumn.One,
            preserveFocus: !0
        }, {
            enableScripts: !0,
            retainContextWhenHidden: !0
        }),
        N = I0.parse(v);
    return V.webview.html = ZU6(typeof N === "string" ? N : "", z), V.webview.onDidReceiveMessage((K) => {
        if (K.type === "comment") U({
            id: K.id,
            selectedText: K.selectedText,
            sectionHeading: K.sectionHeading,
            comment: K.comment
        })
    }), V
}

function ZU6(v, z) {
    return wU6.replace("{{TITLE}}", LU6(z)).replace("{{CONTENT}}", v)
}

function LU6(v) {
    return v.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
}
var ox = o(require("vscode")),
    J5 = o(require("path")),
    O5 = void 0;
async function FU6() {
    if (O5 === null) return;
    if (O5) return O5;
    let v = ox.extensions.getExtension("ms-python.python");
    if (!v) {
        O5 = null;
        return
    }
    try {
        if (!v.isActive) await v.activate();
        if (!v.exports?.environments) {
            console.warn("Python extension environments API not available"), O5 = null;
            return
        }
        return O5 = v.exports, O5
    } catch (z) {
        console.warn("Failed to get Python extension API:", z), O5 = null;
        return
    }
}
async function BY(v) {
    let z = await FU6();
    if (!z) return v;
    let U = ox.workspace.workspaceFolders?.[0];
    if (!U) return v;
    try {
        let V = z.environments.getActiveEnvironmentPath(U.uri);
        if (!V?.path) return v;
        let N = await z.environments.resolveEnvironment(V);
        if (!N) return v;
        let K = N.executable?.sysPrefix || (N.executable?.uri ? J5.dirname(J5.dirname(N.executable.uri.fsPath)) : void 0);
        if (!K) return v;
        let x = {
            ...v
        };
        x.VIRTUAL_ENV = K;
        let j = process.platform === "win32" ? J5.join(K, "Scripts") : J5.join(K, "bin"),
            B = x.PATH || process.env.PATH || "";
        return x.PATH = `${j}${J5.delimiter}${B}`, console.log(`Python environment activated: VIRTUAL_ENV=${K}`), x
    } catch (V) {
        return console.warn("Failed to get Python environment variables:", V), v
    }
}
var a0 = o(require("vscode")),
    bY = o(require("fs"));
class W4 {
    diff(v, z, U = {}) {
        let V;
        if (typeof U === "function") V = U, U = {};
        else if ("callback" in U) V = U.callback;
        let N = this.castInput(v, U),
            K = this.castInput(z, U),
            x = this.removeEmpty(this.tokenize(N, U)),
            j = this.removeEmpty(this.tokenize(K, U));
        return this.diffWithOptionsObj(x, j, U, V)
    }
    diffWithOptionsObj(v, z, U, V) {
        var N;
        let K = ($) => {
                if ($ = this.postProcess($, U), V) {
                    setTimeout(function() {
                        V($)
                    }, 0);
                    return
                } else return $
            },
            x = z.length,
            j = v.length,
            B = 1,
            O = x + j;
        if (U.maxEditLength != null) O = Math.min(O, U.maxEditLength);
        let J = (N = U.timeout) !== null && N !== void 0 ? N : 1 / 0,
            q = Date.now() + J,
            H = [{
                oldPos: -1,
                lastComponent: void 0
            }],
            D = this.extractCommon(H[0], z, v, 0, U);
        if (H[0].oldPos + 1 >= j && D + 1 >= x) return K(this.buildValues(H[0].lastComponent, z, v));
        let A = -1 / 0,
            w = 1 / 0,
            Z = () => {
                for (let $ = Math.max(A, -B); $ <= Math.min(w, B); $ += 2) {
                    let F, L = H[$ - 1],
                        G = H[$ + 1];
                    if (L) H[$ - 1] = void 0;
                    let I = !1;
                    if (G) {
                        let b = G.oldPos - $;
                        I = G && 0 <= b && b < x
                    }
                    let M = L && L.oldPos + 1 < j;
                    if (!I && !M) {
                        H[$] = void 0;
                        continue
                    }
                    if (!M || I && L.oldPos < G.oldPos) F = this.addToPath(G, !0, !1, 0, U);
                    else F = this.addToPath(L, !1, !0, 1, U);
                    if (D = this.extractCommon(F, z, v, $, U), F.oldPos + 1 >= j && D + 1 >= x) return K(this.buildValues(F.lastComponent, z, v)) || !0;
                    else {
                        if (H[$] = F, F.oldPos + 1 >= j) w = Math.min(w, $ - 1);
                        if (D + 1 >= x) A = Math.max(A, $ + 1)
                    }
                }
                B++
            };
        if (V)(function $() {
            setTimeout(function() {
                if (B > O || Date.now() > q) return V(void 0);
                if (!Z()) $()
            }, 0)
        })();
        else
            while (B <= O && Date.now() <= q) {
                let $ = Z();
                if ($) return $
            }
    }
    addToPath(v, z, U, V, N) {
        let K = v.lastComponent;
        if (K && !N.oneChangePerToken && K.added === z && K.removed === U) return {
            oldPos: v.oldPos + V,
            lastComponent: {
                count: K.count + 1,
                added: z,
                removed: U,
                previousComponent: K.previousComponent
            }
        };
        else return {
            oldPos: v.oldPos + V,
            lastComponent: {
                count: 1,
                added: z,
                removed: U,
                previousComponent: K
            }
        }
    }
    extractCommon(v, z, U, V, N) {
        let K = z.length,
            x = U.length,
            j = v.oldPos,
            B = j - V,
            O = 0;
        while (B + 1 < K && j + 1 < x && this.equals(U[j + 1], z[B + 1], N))
            if (B++, j++, O++, N.oneChangePerToken) v.lastComponent = {
                count: 1,
                previousComponent: v.lastComponent,
                added: !1,
                removed: !1
            };
        if (O && !N.oneChangePerToken) v.lastComponent = {
            count: O,
            previousComponent: v.lastComponent,
            added: !1,
            removed: !1
        };
        return v.oldPos = j, B
    }
    equals(v, z, U) {
        if (U.comparator) return U.comparator(v, z);
        else return v === z || !!U.ignoreCase && v.toLowerCase() === z.toLowerCase()
    }
    removeEmpty(v) {
        let z = [];
        for (let U = 0; U < v.length; U++)
            if (v[U]) z.push(v[U]);
        return z
    }
    castInput(v, z) {
        return v
    }
    tokenize(v, z) {
        return Array.from(v)
    }
    join(v) {
        return v.join("")
    }
    postProcess(v, z) {
        return v
    }
    get useLongestToken() {
        return !1
    }
    buildValues(v, z, U) {
        let V = [],
            N;
        while (v) V.push(v), N = v.previousComponent, delete v.previousComponent, v = N;
        V.reverse();
        let K = V.length,
            x = 0,
            j = 0,
            B = 0;
        for (; x < K; x++) {
            let O = V[x];
            if (!O.removed) {
                if (!O.added && this.useLongestToken) {
                    let J = z.slice(j, j + O.count);
                    J = J.map(function(q, H) {
                        let D = U[B + H];
                        return D.length > q.length ? D : q
                    }), O.value = this.join(J)
                } else O.value = this.join(z.slice(j, j + O.count));
                if (j += O.count, !O.added) B += O.count
            } else O.value = this.join(U.slice(B, B + O.count)), B += O.count
        }
        return V
    }
}
class OY extends W4 {}
var GU6 = new OY;

function vA(v, z) {
    let U;
    for (U = 0; U < v.length && U < z.length; U++)
        if (v[U] != z[U]) return v.slice(0, U);
    return v.slice(0, U)
}

function zA(v, z) {
    let U;
    if (!v || !z || v[v.length - 1] != z[z.length - 1]) return "";
    for (U = 0; U < v.length && U < z.length; U++)
        if (v[v.length - (U + 1)] != z[z.length - (U + 1)]) return v.slice(-U);
    return v.slice(-U)
}

function rx(v, z, U) {
    if (v.slice(0, z.length) != z) throw Error(`string ${JSON.stringify(v)} doesn't start with prefix ${JSON.stringify(z)}; this is a bug`);
    return U + v.slice(z.length)
}

function ax(v, z, U) {
    if (!z) return v + U;
    if (v.slice(-z.length) != z) throw Error(`string ${JSON.stringify(v)} doesn't end with suffix ${JSON.stringify(z)}; this is a bug`);
    return v.slice(0, -z.length) + U
}

function tv(v, z) {
    return rx(v, z, "")
}

function CU(v, z) {
    return ax(v, z, "")
}

function UA(v, z) {
    return z.slice(0, IU6(v, z))
}

function IU6(v, z) {
    let U = 0;
    if (v.length > z.length) U = v.length - z.length;
    let V = z.length;
    if (v.length < z.length) V = v.length;
    let N = Array(V),
        K = 0;
    N[0] = 0;
    for (let x = 1; x < V; x++) {
        if (z[x] == z[K]) N[x] = N[K];
        else N[x] = K;
        while (K > 0 && z[x] != z[K]) K = N[K];
        if (z[x] == z[K]) K++
    }
    K = 0;
    for (let x = U; x < v.length; x++) {
        while (K > 0 && v[x] != z[K]) K = N[K];
        if (v[x] == z[K]) K++
    }
    return K
}

function sv(v) {
    let z;
    for (z = v.length - 1; z >= 0; z--)
        if (!v[z].match(/\s/)) break;
    return v.substring(z + 1)
}

function G9(v) {
    let z = v.match(/^\s*/);
    return z ? z[0] : ""
}
var tx = "a-zA-Z0-9_\\u{AD}\\u{C0}-\\u{D6}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",
    MU6 = new RegExp(`[${tx}]+|\\s+|[^${tx}]`, "ug");
class qY extends W4 {
    equals(v, z, U) {
        if (U.ignoreCase) v = v.toLowerCase(), z = z.toLowerCase();
        return v.trim() === z.trim()
    }
    tokenize(v, z = {}) {
        let U;
        if (z.intlSegmenter) {
            let K = z.intlSegmenter;
            if (K.resolvedOptions().granularity != "word") throw Error('The segmenter passed must have a granularity of "word"');
            U = [];
            for (let x of Array.from(K.segment(v))) {
                let j = x.segment;
                if (U.length && /\s/.test(U[U.length - 1]) && /\s/.test(j)) U[U.length - 1] += j;
                else U.push(j)
            }
        } else U = v.match(MU6) || [];
        let V = [],
            N = null;
        return U.forEach((K) => {
            if (/\s/.test(K))
                if (N == null) V.push(K);
                else V.push(V.pop() + K);
            else if (N != null && /\s/.test(N))
                if (V[V.length - 1] == N) V.push(V.pop() + K);
                else V.push(N + K);
            else V.push(K);
            N = K
        }), V
    }
    join(v) {
        return v.map((z, U) => {
            if (U == 0) return z;
            else return z.replace(/^\s+/, "")
        }).join("")
    }
    postProcess(v, z) {
        if (!v || z.oneChangePerToken) return v;
        let U = null,
            V = null,
            N = null;
        if (v.forEach((K) => {
                if (K.added) V = K;
                else if (K.removed) N = K;
                else {
                    if (V || N) JY(U, N, V, K);
                    U = K, V = null, N = null
                }
            }), V || N) JY(U, N, V, null);
        return v
    }
}
var bU6 = new qY;

function JY(v, z, U, V) {
    if (z && U) {
        let N = G9(z.value),
            K = sv(z.value),
            x = G9(U.value),
            j = sv(U.value);
        if (v) {
            let B = vA(N, x);
            v.value = ax(v.value, x, B), z.value = tv(z.value, B), U.value = tv(U.value, B)
        }
        if (V) {
            let B = zA(K, j);
            V.value = rx(V.value, j, B), z.value = CU(z.value, B), U.value = CU(U.value, B)
        }
    } else if (U) {
        if (v) {
            let N = G9(U.value);
            U.value = U.value.substring(N.length)
        }
        if (V) {
            let N = G9(V.value);
            V.value = V.value.substring(N.length)
        }
    } else if (v && V) {
        let N = G9(V.value),
            K = G9(z.value),
            x = sv(z.value),
            j = vA(N, K);
        z.value = tv(z.value, j);
        let B = zA(tv(N, j), x);
        z.value = CU(z.value, B), V.value = rx(V.value, N, B), v.value = ax(v.value, N, N.slice(0, N.length - B.length))
    } else if (V) {
        let N = G9(V.value),
            K = sv(z.value),
            x = UA(K, N);
        z.value = CU(z.value, x)
    } else if (v) {
        let N = sv(v.value),
            K = G9(z.value),
            x = UA(N, K);
        z.value = tv(z.value, x)
    }
}
class HY extends W4 {
    tokenize(v) {
        let z = new RegExp(`(\\r?\\n)|[${tx}]+|[^\\S\\n\\r]+|[^${tx}]`, "ug");
        return v.match(z) || []
    }
}
var RU6 = new HY;
class DY extends W4 {
    constructor() {
        super(...arguments);
        this.tokenize = VA
    }
    equals(v, z, U) {
        if (U.ignoreWhitespace) {
            if (!U.newlineIsToken || !v.includes(`
`)) v = v.trim();
            if (!U.newlineIsToken || !z.includes(`
`)) z = z.trim()
        } else if (U.ignoreNewlineAtEof && !U.newlineIsToken) {
            if (v.endsWith(`
`)) v = v.slice(0, -1);
            if (z.endsWith(`
`)) z = z.slice(0, -1)
        }
        return super.equals(v, z, U)
    }
}
var AY = new DY;

function sx(v, z, U) {
    return AY.diff(v, z, U)
}

function VA(v, z) {
    if (z.stripTrailingCr) v = v.replace(/\r\n/g, `
`);
    let U = [],
        V = v.split(/(\n|\r\n)/);
    if (!V[V.length - 1]) V.pop();
    for (let N = 0; N < V.length; N++) {
        let K = V[N];
        if (N % 2 && !z.newlineIsToken) U[U.length - 1] += K;
        else U.push(K)
    }
    return U
}

function WU6(v) {
    return v == "." || v == "!" || v == "?"
}
class $Y extends W4 {
    tokenize(v) {
        var z;
        let U = [],
            V = 0;
        for (let N = 0; N < v.length; N++) {
            if (N == v.length - 1) {
                U.push(v.slice(V));
                break
            }
            if (WU6(v[N]) && v[N + 1].match(/\s/)) {
                U.push(v.slice(V, N + 1)), N = V = N + 1;
                while ((z = v[N + 1]) === null || z === void 0 ? void 0 : z.match(/\s/)) N++;
                U.push(v.slice(V, N + 1)), V = N + 1
            }
        }
        return U
    }
}
var EU6 = new $Y;
class wY extends W4 {
    tokenize(v) {
        return v.split(/([{}:;,]|\s+)/)
    }
}
var SU6 = new wY;
class ZY extends W4 {
    constructor() {
        super(...arguments);
        this.tokenize = VA
    }
    get useLongestToken() {
        return !0
    }
    castInput(v, z) {
        let {
            undefinedReplacement: U,
            stringifyReplacer: V = (N, K) => typeof K > "u" ? U : K
        } = z;
        return typeof v === "string" ? v : JSON.stringify(ex(v, null, null, V), null, "  ")
    }
    equals(v, z, U) {
        return super.equals(v.replace(/,([\r\n])/g, "$1"), z.replace(/,([\r\n])/g, "$1"), U)
    }
}
var PU6 = new ZY;

function ex(v, z, U, V, N) {
    if (z = z || [], U = U || [], V) v = V(N === void 0 ? "" : N, v);
    let K;
    for (K = 0; K < z.length; K += 1)
        if (z[K] === v) return U[K];
    let x;
    if (Object.prototype.toString.call(v) === "[object Array]") {
        z.push(v), x = Array(v.length), U.push(x);
        for (K = 0; K < v.length; K += 1) x[K] = ex(v[K], z, U, V, String(K));
        return z.pop(), U.pop(), x
    }
    if (v && v.toJSON) v = v.toJSON();
    if (typeof v === "object" && v !== null) {
        z.push(v), x = {}, U.push(x);
        let j = [],
            B;
        for (B in v)
            if (Object.prototype.hasOwnProperty.call(v, B)) j.push(B);
        j.sort();
        for (K = 0; K < j.length; K += 1) B = j[K], x[B] = ex(v[B], z, U, V, B);
        z.pop(), U.pop()
    } else x = v;
    return x
}
class LY extends W4 {
    tokenize(v) {
        return v.slice()
    }
    join(v) {
        return v
    }
    removeEmpty(v) {
        return v
    }
}
var _U6 = new LY;

function NA(v, z, U, V, N, K, x) {
    let j;
    if (!x) j = {};
    else if (typeof x === "function") j = {
        callback: x
    };
    else j = x;
    if (typeof j.context > "u") j.context = 4;
    let B = j.context;
    if (j.newlineIsToken) throw Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
    if (!j.callback) return O(sx(U, V, j));
    else {
        let {
            callback: J
        } = j;
        sx(U, V, Object.assign(Object.assign({}, j), {
            callback: (q) => {
                let H = O(q);
                J(H)
            }
        }))
    }

    function O(J) {
        if (!J) return;
        J.push({
            value: "",
            lines: []
        });

        function q(F) {
            return F.map(function(L) {
                return " " + L
            })
        }
        let H = [],
            D = 0,
            A = 0,
            w = [],
            Z = 1,
            $ = 1;
        for (let F = 0; F < J.length; F++) {
            let L = J[F],
                G = L.lines || fU6(L.value);
            if (L.lines = G, L.added || L.removed) {
                if (!D) {
                    let I = J[F - 1];
                    if (D = Z, A = $, I) w = B > 0 ? q(I.lines.slice(-B)) : [], D -= w.length, A -= w.length
                }
                for (let I of G) w.push((L.added ? "+" : "-") + I);
                if (L.added) $ += G.length;
                else Z += G.length
            } else {
                if (D)
                    if (G.length <= B * 2 && F < J.length - 2)
                        for (let I of q(G)) w.push(I);
                    else {
                        let I = Math.min(G.length, B);
                        for (let b of q(G.slice(0, I))) w.push(b);
                        let M = {
                            oldStart: D,
                            oldLines: Z - D + I,
                            newStart: A,
                            newLines: $ - A + I,
                            lines: w
                        };
                        H.push(M), D = 0, A = 0, w = []
                    } Z += G.length, $ += G.length
            }
        }
        for (let F of H)
            for (let L = 0; L < F.lines.length; L++)
                if (F.lines[L].endsWith(`
`)) F.lines[L] = F.lines[L].slice(0, -1);
                else F.lines.splice(L + 1, 0, "\\ No newline at end of file"), L++;
        return {
            oldFileName: v,
            newFileName: z,
            oldHeader: N,
            newHeader: K,
            hunks: H
        }
    }
}

function fU6(v) {
    let z = v.endsWith(`
`),
        U = v.split(`
`).map((V) => V + `
`);
    if (z) U.pop();
    else U.push(U.pop().slice(0, -1));
    return U
}

function GY(v, z) {
    let U = v,
        V = [];
    if (!v && z.length === 1 && z[0] && z[0].oldString === "" && z[0].newString === "") return "";
    for (let N of z) {
        let K = N.oldString.replace(/\n+$/, "");
        for (let j of V)
            if (K !== "" && j.includes(K)) throw Error("Cannot edit file: old_string is a substring of a new_string from a previous edit.");
        let x = U;
        if (N.oldString === "") U = N.newString;
        else U = TU6(U, N.oldString, N.newString, N.replaceAll);
        if (U === x) throw Error("String not found in file. Failed to apply edit.");
        V.push(N.newString)
    }
    if (U === v) throw Error("Original and edited file match exactly. Failed to apply edit.");
    return U
}

function TU6(v, z, U, V = !1) {
    let N = V ? (x, j, B) => x.replaceAll(j, () => B) : (x, j, B) => x.replace(j, () => B);
    if (U !== "") return N(v, z, U);
    return !z.endsWith(`
`) && v.includes(z + `
`) ? N(v, z + `
`, U) : N(v, z, U)
}

function KA(v, z, U, V) {
    let K = kU6({
        filePath: v,
        oldContent: z,
        newContent: U,
        singleHunk: V === "single"
    });
    if (K.length === 0) return [];
    return YU6(K)
}

function YU6(v) {
    return v.map((z) => {
        let U = [],
            V = [],
            N = [];
        for (let K of z.lines)
            if (K.startsWith(" ")) U.push(K.slice(1)), V.push(K.slice(1)), N.push(K.slice(1));
            else if (K.startsWith("-")) V.push(K.slice(1));
        else if (K.startsWith("+")) N.push(K.slice(1));
        return {
            oldString: V.join(`
`),
            newString: N.join(`
`),
            replaceAll: !1
        }
    })
}
var IY = "<<:AMPERSAND_TOKEN:>>",
    MY = "<<:DOLLAR_TOKEN:>>";

function FY(v) {
    return v.replaceAll("&", IY).replaceAll("$", MY)
}

function uU6(v) {
    return v.replaceAll(IY, "&").replaceAll(MY, "$")
}
var yU6 = 3;

function kU6({
    filePath: v,
    oldContent: z,
    newContent: U,
    ignoreWhitespace: V = !1,
    singleHunk: N = !1
}) {
    return NA(v, v, FY(z), FY(U), void 0, void 0, {
        ignoreWhitespace: V,
        context: N ? 1e5 : yU6
    }).hunks.map((K) => ({
        ...K,
        lines: K.lines.map(uU6)
    }))
}
async function RY(v, z, U, V, N, K, x, j, B) {
    // --- original code ---
    let O = V.split("/").pop() || V,
        J = N.split("/").pop() || N,
        H = ` [Claude Code] ${O===J?O:`${O}  ${J}`}`;
    v.info("diff from", V, "to", N, "as", H);
    let D, A = "";
    if (isForceLocalMode()) {
        try {
            var _rt_ry = require("./src/remote-tools");
            var _remUri_ry = _rt_ry.getRemoteUri(V);
            var _remData_ry = await a0.workspace.fs.readFile(_remUri_ry);
            A = Buffer.from(_remData_ry).toString("utf8");
            D = z.createFile(V, A).uri;
        } catch (_e_ry) {
            v.info("forceLocal: RY remote read failed", V, _e_ry.message || _e_ry);
            A = "";
            D = z.createFile(V, "").uri;
        }
    } else {
        D = a0.Uri.file(V);
        try {
            let F6 = await a0.workspace.openTextDocument(D);
            if (F6.isDirty) A = bY.readFileSync(V, "utf8"), D = z.createFile(V, A).uri;
            else A = F6.getText()
        } catch (F6) {
            v.info("leftTempFileProvider.createFile", V), D = z.createFile(V, "").uri
        }
    }
    let w = GY(A, K),
        $ = U.createFile(N, w).uri,
        F = await a0.workspace.openTextDocument($);
    if (await mU6(v, D, $) > 0) await new Promise((F6) => setTimeout(F6, 200));
    let G = [],
        I = w,
        M = w,
        b = void 0;
    G.push(a0.workspace.onDidChangeTextDocument((F6) => {
        if (F6.document.uri.toString() === $.toString()) {
            if (I = M, M = F6.document.getText(), F6.contentChanges.length > 3 && F6.reason !== a0.TextDocumentChangeReason.Undo && F6.reason !== a0.TextDocumentChangeReason.Redo) b = {
                time: Date.now(),
                contents: I
            }
        }
    }));
    let W = new Promise((F6) => {
            G.push(a0.workspace.onWillSaveTextDocument((q6) => {
                if (q6.document.uri.toString() === $.toString()) {
                    let Z6 = q6.document.getText();
                    if (b && Date.now() - b.time < 500) Z6 = b.contents;
                    F6(Z6)
                }
            }))
        }),
        E = new Promise((F6) => {
            G.push(j((q6) => {
                if (q6.activeTab && q6.activeTab.label === H) F6(q6)
            }))
        }).then((F6) => {
            if (F6.accepted) {
                var _userText = F.getText();
                if (isForceLocalMode() && _userText !== w) {
                    try {
                        var _rt_acc = require("./src/remote-tools");
                        _rt_acc.setEditOverride(_rt_acc.toRemotePath(N), _userText);
                        v.info("forceLocal: user modified diff, stored override for", N);
                    } catch (_e_acc) {}
                }
                return v.info("diff_accepted", H), KA(N, A, _userText, x ? "multiple" : "single");
            }
            return
        }),
        y = {
            preview: !1,
            preserveFocus: !0
        },
        T = await a0.commands.executeCommand("vscode.diff", D, $, H, y);
    v.info("diff result", T, H, D, $, y);
    let X = await av(() => {
        return rv().find((F6) => F6.label === H)
    }, 1000);
    B?.addEventListener("abort", () => {
        O7(X, v)
    });
    let Q = av(() => {
            return !rv().some((F6) => F6.label === H)
        }).then(() => {
            v.info("tab_closed", H);
            return
        }),
        m = W.then(async (F6) => {
            return KA(N, A, F6, x ? "multiple" : "single")
        }),
        P6 = [Q, E];
    if (a0.workspace.getConfiguration("files").get("autoSave") === "off") v.info("files.autoSave is off, waiting for file save"), P6.push(m);
    else v.info("files.autoSave is on, need explicit accept");
    return await Promise.race(P6).finally(() => {
        G.forEach((F6) => F6.dispose())
    }).then((F6) => {
        return v.info("diff operation completed", F6), F6
    }).finally(() => {
        O7(X, v)
    })
}
async function mU6(v, z, U) {
    let V = 0,
        N = z.toString(),
        K = U.toString();
    for (let x of a0.window.tabGroups.all)
        for (let j of x.tabs)
            if (j.input instanceof a0.TabInputTextDiff && j.input.original.toString() === N && j.input.modified.toString() === K) await O7(j, v), V++;
    if (V > 0) v.info(`Closed ${V} existing diff tab(s) with matching URIs`);
    return V
}

function WY(v) {
    let z = new a0.EventEmitter;
    return v.push(a0.commands.registerCommand("claude-vscode.acceptProposedDiff", async () => {
        let U = a0.window.tabGroups.activeTabGroup.activeTab;
        z.fire({
            accepted: !0,
            activeTab: U
        })
    })), v.push(a0.commands.registerCommand("claude-vscode.rejectProposedDiff", async () => {
        let U = a0.window.tabGroups.activeTabGroup.activeTab;
        z.fire({
            accepted: !1,
            activeTab: U
        })
    })), z.event
}
var q5 = o(require("vscode"));
var vj = o(require("vscode"));
var EY = require("node:child_process");

function SY(v) {
    let z = v;
    if (v.startsWith("file://")) z = v.substring(7);
    if (!z.startsWith("/") || /^\/[a-zA-Z]:/.test(z)) return v;
    try {
        return EY.execFileSync("wsl.exe", ["-e", "wslpath", "-w", z], {
            encoding: "utf8",
            stdio: ["pipe", "pipe", "ignore"]
        }).trim()
    } catch {
        return v
    }
}

function zj(v) {
    if (process.platform === "win32") {
        let z = SY(v);
        return z.startsWith("file://") ? vj.Uri.parse(z) : vj.Uri.file(z)
    } else return vj.Uri.parse(v)
}

function XU6(v) {
    return v.map((z) => ({
        message: z.message,
        severity: q5.DiagnosticSeverity[z.severity],
        range: {
            start: {
                line: z.range.start.line,
                character: z.range.start.character
            },
            end: {
                line: z.range.end.line,
                character: z.range.end.character
            }
        },
        source: z.source,
        code: z.code?.toString()
    }))
}

function fU(v) {
    return (v ? (() => {
        let U = zj(v);
        return [
            [U, q5.languages.getDiagnostics(U)]
        ]
    })() : q5.languages.getDiagnostics()).map(([U, V]) => ({
        uri: U.toString(!0),
        linesInFile: gU6(U),
        diagnostics: XU6(V)
    }))
}

function gU6(v) {
    try {
        return q5.workspace.textDocuments.find((U) => U.uri.toString() === v.toString())?.lineCount
    } catch {
        return
    }
}
class H7 {
    static instance;
    listener;
    clients;
    clientCounter;
    output;
    constructor(v) {
        this.clients = new Map, this.clientCounter = 0, this.output = v
    }
    static getInstance(v) {
        if (!H7.instance) H7.instance = new H7(v);
        return H7.instance
    }
    registerClient(v) {
        let z = `client_${this.clientCounter++}`;
        return this.clients.set(z, v), this.startStreaming(), z
    }
    unregisterClient(v) {
        if (this.clients.delete(v)) {
            if (this.output.info(`[DiagnosticStreamManager] Unregistered client ${v}. Total clients: ${this.clients.size}`), this.clients.size === 0) this.stopStreaming()
        }
    }
    startStreaming() {
        if (!this.listener) this.listener = q5.languages.onDidChangeDiagnostics((v) => {
            this.notifyDiagnosticsChanged(v.uris)
        }), this.output.info("[DiagnosticStreamManager] Started streaming diagnostics")
    }
    stopStreaming() {
        if (this.listener) this.listener.dispose(), this.listener = void 0, this.output.info("[DiagnosticStreamManager] Stopped streaming diagnostics")
    }
    notifyDiagnosticsChanged(v) {
        if (this.clients.size === 0) return;
        let z = v.map((U) => U.toString());
        this.output.info(`[DiagnosticStreamManager] Notifying ${this.clients.size} clients about diagnostics change for ${v.length} files`), this.clients.forEach((U, V) => {
            try {
                U(z)
            } catch (N) {
                this.output.error(`[DiagnosticStreamManager] Error notifying client ${V}: ${N}`)
            }
        })
    }
    dispose() {
        this.clients.clear(), this.stopStreaming()
    }
}
var Uj = o(require("vscode"));
class xA {
    logger;
    baselineDiagnostics = new Map;
    constructor(v) {
        this.logger = v
    }
    async captureBaseline(v) {
        try {
            if (v.hook_event_name !== "PreToolUse") return {
                continue: !0
            };
            let z = this.extractFilePath(v);
            if (z && typeof z === "string") {
                let U = fU(z);
                this.baselineDiagnostics.set(z, U), this.logger.log(`[DiagnosticTracking] Captured baseline diagnostics for ${z}: ${U.length} files`)
            }
        } catch (z) {
            this.logger.error(`[DiagnosticTracking] Error capturing baseline diagnostics: ${z}`)
        }
        return {
            continue: !0
        }
    }
    async findDiagnosticsProblems(v) {
        try {
            if (v.hook_event_name !== "PostToolUse") return {
                continue: !0
            };
            let z = this.extractFilePath(v);
            if (z && typeof z === "string") {
                let U = Uj.Uri.file(z),
                    V = Uj.window.visibleTextEditors.some((x) => x.document.uri.toString() === U.toString()),
                    N = this.baselineDiagnostics.get(z) || [],
                    K = V ? [750, 750] : [1000];
                for (let x = 0; x < K.length; x++) {
                    await new Promise((O) => setTimeout(O, K[x]));
                    let j = fU(z),
                        B = this.findNewDiagnostics(N, j);
                    if (B.length > 0) {
                        this.logger.log(`[DiagnosticTracking] Found ${B.length} new diagnostics for ${z} at ${x+1}s`);
                        let O = this.formatDiagnosticsSummary(B);
                        return this.baselineDiagnostics.delete(z), {
                            continue: !0,
                            hookSpecificOutput: {
                                hookEventName: "PostToolUse",
                                additionalContext: `<ide_diagnostics>${O}</ide_diagnostics>`
                            }
                        }
                    }
                }
                this.logger.log(`[DiagnosticTracking] No new diagnostics found for ${z}`), this.baselineDiagnostics.delete(z)
            }
        } catch (z) {
            this.logger.error(`[DiagnosticTracking] Error tracking post-tool diagnostics: ${z}`)
        }
        return {
            continue: !0
        }
    }
    extractFilePath(v) {
        if (v.hook_event_name === "PreToolUse" || v.hook_event_name === "PostToolUse") {
            if (v.tool_name === "Edit" || v.tool_name === "MultiEdit" || v.tool_name === "Write") return v.tool_input?.file_path
        }
        return
    }
    findNewDiagnostics(v, z) {
        let U = [];
        for (let V of z) {
            let N = v.find((K) => K.uri === V.uri);
            if (!N) U.push(V);
            else {
                let K = N.linesInFile !== void 0 && V.linesInFile !== void 0 ? Math.abs(N.linesInFile - V.linesInFile) : 0,
                    x = V.diagnostics.filter((j) => {
                        return !N.diagnostics.some((B) => this.areDiagnosticsEqual(j, B, K))
                    });
                if (x.length > 0) U.push({
                    uri: V.uri,
                    linesInFile: V.linesInFile,
                    diagnostics: x
                })
            }
        }
        return U
    }
    areDiagnosticsEqual(v, z, U) {
        let V = Math.abs((v.range?.start?.line ?? 0) - (z.range?.start?.line ?? 0)),
            N = Math.abs((v.range?.end?.line ?? 0) - (z.range?.end?.line ?? 0));
        return v.message === z.message && v.severity === z.severity && v.source === z.source && v.code === z.code && V <= U && N <= U && v.range?.start?.character === z.range?.start?.character && v.range?.end?.character === z.range?.end?.character
    }
    formatDiagnosticsSummary(v) {
        let z = v.flatMap((U) => U.diagnostics.map((V) => ({
            filePath: this.normalizeFileUri(U.uri),
            line: V.range?.start?.line !== void 0 ? V.range.start.line + 1 : 0,
            column: V.range?.start?.character !== void 0 ? V.range.start.character + 1 : 0,
            message: V.message,
            code: V.code || "",
            severity: V.severity || ""
        })));
        return JSON.stringify(z, null, 2)
    }
    normalizeFileUri(v) {
        let z = ["file://", "_claude_fs_right:", "_claude_fs_left:"];
        for (let U of z)
            if (v.startsWith(U)) return v.slice(U.length);
        return v
    }
}
var Nj = o(require("path")),
    Z3 = o(require("fs"));
var TU = o(require("crypto")),
    PY = o(require("http"));
class jA {
    logger;
    codeVerifier;
    server = null;
    manualAuthCodeResolver = null;
    constructor(v) {
        this.logger = v;
        this.codeVerifier = this.generateCodeVerifier()
    }
    async startOAuthFlow(v, z) {
        let U = await this.startCallbackServer(),
            V = this.generateCodeChallenge(this.codeVerifier),
            N = this.generateState(),
            K = this.buildAuthUrls({
                codeChallenge: V,
                state: N,
                port: U,
                loginWithClaudeAi: v
            });
        await z(K);
        let {
            code: x,
            isManualFlow: j
        } = await this.waitForAuthorizationCode(N, U, v);
        return await this.exchangeCodeForTokens(x, N, this.codeVerifier, j ? void 0 : U)
    }
    buildAuthUrls(v) {
        let z = b4(),
            U = v.loginWithClaudeAi ? z.CLAUDE_AI_AUTHORIZE_URL : z.CONSOLE_AUTHORIZE_URL,
            V = new URL(U);
        V.searchParams.set("code", "true"), V.searchParams.set("client_id", z.CLIENT_ID), V.searchParams.set("response_type", "code");
        let N = v.loginWithClaudeAi ? gv : j2;
        V.searchParams.set("scope", N.join(" ")), V.searchParams.set("code_challenge", v.codeChallenge), V.searchParams.set("code_challenge_method", "S256"), V.searchParams.set("state", v.state), V.searchParams.set("redirect_uri", `http://localhost:${v.port}/callback`);
        let K = V.toString();
        V.searchParams.set("redirect_uri", z.MANUAL_REDIRECT_URL);
        let x = V.toString();
        return {
            automaticRedirectUrl: K,
            manualRedirectUrl: x
        }
    }
    async startCallbackServer() {
        return new Promise((v, z) => {
            this.server = PY.createServer(), this.server.listen(0, "127.0.0.1", () => {
                let U = this.server.address();
                if (!U || typeof U === "string") {
                    z(Error("Failed to get server address"));
                    return
                }
                v(U.port)
            }), this.server.on("error", z)
        })
    }
    async waitForAuthorizationCode(v, z, U) {
        return new Promise((V, N) => {
            if (!this.server) {
                N(Error("Server not started"));
                return
            }
            this.manualAuthCodeResolver = (K) => {
                let x = K.trim().split("#");
                if (x[1] !== v) throw Error("Invalid state parameter");
                V({
                    code: x[0],
                    isManualFlow: !0
                })
            }, this.server.on("request", (K, x) => {
                let j = new URL(K.url, `http://localhost:${z}`);
                if (j.pathname === "/callback") {
                    let B = j.searchParams.get("code");
                    if (j.searchParams.get("state") !== v) {
                        x.writeHead(400), x.end("Invalid state parameter"), N(Error("Invalid state parameter"));
                        return
                    }
                    if (!B) {
                        x.writeHead(400), x.end("Missing authorization code"), N(Error("Missing authorization code"));
                        return
                    }
                    let J = U ? b4().CLAUDEAI_SUCCESS_URL : b4().CONSOLE_SUCCESS_URL;
                    x.writeHead(302, {
                        Location: J
                    }), x.end(), this.manualAuthCodeResolver = null, V({
                        code: B,
                        isManualFlow: !1
                    })
                }
            })
        })
    }
    async exchangeCodeForTokens(v, z, U, V) {
        let N = b4(),
            K = {
                grant_type: "authorization_code",
                code: v,
                redirect_uri: V ? `http://localhost:${V}/callback` : N.MANUAL_REDIRECT_URL,
                client_id: N.CLIENT_ID,
                code_verifier: U,
                state: z
            };
        try {
            let x = await w3.post(N.TOKEN_URL, K, {
                headers: {
                    "Content-Type": "application/json"
                }
            });
            if (x.status !== 200) throw Error(`Token exchange failed: ${x.statusText}`);
            let j = x.data,
                B = {
                    accessToken: j.access_token,
                    refreshToken: j.refresh_token || null,
                    expiresAt: j.expires_in ? Date.now() + j.expires_in * 1000 : null,
                    scopes: j.scope ? j.scope.split(" ") : [],
                    subscriptionType: null,
                    rateLimitTier: null
                };
            if (B.scopes.includes("user:profile")) {
                let O = await this.fetchProfileInfo(B.accessToken);
                B.subscriptionType = O.subscriptionType, B.rateLimitTier = O.rateLimitTier
            }
            return B
        } catch (x) {
            let j = x;
            throw Error(`Token exchange failed: ${j.response?.data?.error||j.response?.data?.message||j.message||"Unknown error"}`)
        }
    }
    handleManualAuthCodeInput(v) {
        if (this.manualAuthCodeResolver && v) this.manualAuthCodeResolver(v), this.manualAuthCodeResolver = null, this.cleanup()
    }
    async createApiKey(v) {
        let z = b4();
        try {
            return (await w3.post(z.API_KEY_URL, null, {
                headers: {
                    Authorization: `Bearer ${v}`
                }
            })).data?.raw_key || null
        } catch {
            return null
        }
    }
    cleanup() {
        if (this.server) this.server.close(), this.server = null
    }
    generateCodeVerifier() {
        return TU.randomBytes(32).toString("base64url")
    }
    generateCodeChallenge(v) {
        return TU.createHash("sha256").update(v).digest("base64url")
    }
    generateState() {
        return TU.randomBytes(32).toString("base64url")
    }
    async fetchProfileInfo(v) {
        try {
            let z = `${b4().BASE_API_URL}/api/claude_cli_profile`,
                U = await w3.get(z, {
                    headers: {
                        Authorization: `Bearer ${v}`,
                        "Content-Type": "application/json"
                    }
                }),
                V = U.data?.organization?.organization_type,
                N = null;
            switch (V) {
                case "claude_max":
                    N = "max";
                    break;
                case "claude_pro":
                    N = "pro";
                    break;
                case "claude_enterprise":
                    N = "enterprise";
                    break;
                case "claude_team":
                    N = "team";
                    break;
                default:
                    N = null;
                    break
            }
            return {
                subscriptionType: N,
                rateLimitTier: U.data?.organization?.rate_limit_tier ?? null
            }
        } catch (z) {
            return this.logger.error(`Failed to fetch subscription: ${z}`), {
                subscriptionType: null,
                rateLimitTier: null
            }
        }
    }
}
var mY = require("fs");
var CY = require("crypto");
var fY = require("os");

function I9(v = "") {
    let z = Xv(),
        V = !process.env.CLAUDE_CONFIG_DIR ? "" : `-${CY.createHash("sha256").update(z).digest("hex").substring(0,8)}`;
    return `Claude Code${b4().OAUTH_FILE_SUFFIX}${v}${V}`
}

function H5() {
    try {
        return process.env.USER || fY.userInfo().username
    } catch {
        return "claude-code-user"
    }
}
var D8 = {
    data: null,
    valid: !1
};

function _Y() {
    D8 = {
        data: null,
        valid: !1
    }
}
var TY = {
    name: "keychain",
    read() {
        if (D8.valid) return D8.data;
        try {
            let v = I9("-credentials"),
                z = H5(),
                U = Tx(`security find-generic-password -a "${z}" -w -s "${v}"`);
            if (U) {
                let V = Qv(U);
                return D8 = {
                    data: V,
                    valid: !0
                }, V
            }
        } catch (v) {
            return D8 = {
                data: null,
                valid: !0
            }, null
        }
        return D8 = {
            data: null,
            valid: !0
        }, null
    },
    async readAsync() {
        if (D8.valid) return D8.data;
        try {
            let v = I9("-credentials"),
                z = H5(),
                {
                    stdout: U,
                    code: V
                } = await I2("security", ["find-generic-password", "-a", z, "-w", "-s", v], {
                    useCwd: !1,
                    preserveOutputOnError: !1
                });
            if (V === 0 && U) {
                let N = Qv(U.trim());
                return D8 = {
                    data: N,
                    valid: !0
                }, N
            }
        } catch (v) {}
        return D8 = {
            data: null,
            valid: !0
        }, null
    },
    update(v) {
        _Y();
        try {
            let z = I9("-credentials"),
                U = H5(),
                V = N5(v),
                N = Buffer.from(V, "utf-8").toString("hex"),
                K = `add-generic-password -U -a "${U}" -s "${z}" -X "${N}"
`;
            if (E3("security", ["-i"], {
                    input: K,
                    stdio: ["pipe", "pipe", "pipe"],
                    reject: !1
                }).exitCode !== 0) return {
                success: !1
            };
            return D8 = {
                data: v,
                valid: !0
            }, {
                success: !0
            }
        } catch (z) {
            return {
                success: !1
            }
        }
    },
    delete() {
        _Y();
        try {
            let v = I9("-credentials"),
                z = H5();
            return Tx(`security delete-generic-password -a "${z}" -s "${v}"`), !0
        } catch (v) {
            return !1
        }
    }
};

function YY(v, z) {
    return {
        name: `${v.name}-with-${z.name}-fallback`,
        read() {
            let U = v.read();
            if (U !== null && U !== void 0) return U;
            return z.read() || {}
        },
        async readAsync() {
            let U = await v.readAsync();
            if (U !== null && U !== void 0) return U;
            return await z.readAsync() || {}
        },
        update(U) {
            let V = v.read(),
                N = v.update(U);
            if (N.success) {
                if (V === null) z.delete();
                return N
            }
            let K = z.update(U);
            if (K.success) return {
                success: !0,
                warning: K.warning
            };
            return {
                success: !1
            }
        },
        delete() {
            let U = v.delete(),
                V = z.delete();
            return U || V
        }
    }
}
var uY = require("path");
var yY = require("fs");

function BA() {
    let v = Xv(),
        z = ".credentials.json";
    return {
        storageDir: v,
        storagePath: uY.join(v, ".credentials.json")
    }
}
var OA = {
    name: "plaintext",
    read() {
        let {
            storagePath: v
        } = BA();
        if (w4().existsSync(v)) try {
            let z = w4().readFileSync(v, {
                encoding: "utf8"
            });
            return Qv(z)
        } catch (z) {
            return null
        }
        return null
    },
    async readAsync() {
        return this.read()
    },
    update(v) {
        try {
            let {
                storageDir: z,
                storagePath: U
            } = BA();
            if (!w4().existsSync(z)) w4().mkdirSync(z);
            return pf(U, N5(v), {
                encoding: "utf8",
                flush: !1
            }), yY.chmodSync(U, 384), {
                success: !0,
                warning: "Warning: Storing credentials in plaintext."
            }
        } catch (z) {
            return {
                success: !1
            }
        }
    },
    delete() {
        let {
            storagePath: v
        } = BA();
        if (w4().existsSync(v)) try {
            return w4().unlinkSync(v), !0
        } catch (z) {
            return !1
        }
        return !0
    }
};

function ev() {
    if (process.platform === "darwin") return YY(TY, OA);
    return OA
}

function kY(v) {
    return v.slice(-20)
}
var cU6 = 300000;
class YU {
    logger;
    env;
    disableAuthLogin;
    currentOAuthService = null;
    cachedOrgUUID = null;
    pendingRefresh = null;
    constructor(v, z, U = !1) {
        this.logger = v;
        this.env = z;
        this.disableAuthLogin = U;
        this.logger.log("AuthManager initialized")
    }
    getOrganizationUUID() {
        if (this.cachedOrgUUID) return this.cachedOrgUUID;
        let z = ev().read() || {};
        if (z.organizationUuid) return this.cachedOrgUUID = z.organizationUuid, this.cachedOrgUUID;
        return null
    }
    async fetchOrganizationUUID() {
        if (this.cachedOrgUUID) return this.cachedOrgUUID;
        let v = this.getOAuthTokens();
        if (!v?.accessToken) return null;
        try {
            let z = `${b4().BASE_API_URL}/api/oauth/profile`,
                V = (await w3.get(z, {
                    headers: {
                        Authorization: `Bearer ${v.accessToken}`,
                        "anthropic-beta": Rx
                    },
                    timeout: 1e4,
                    proxy: !1
                })).data?.organization?.uuid;
            if (V) {
                this.cachedOrgUUID = V;
                let N = ev(),
                    K = N.read() || {};
                return K.organizationUuid = V, N.update(K), V
            }
        } catch (z) {
            this.logger.error(`Failed to fetch organization UUID: ${z}`)
        }
        return null
    }
    isAuthLoginDisabled() {
        return this.disableAuthLogin
    }
    getAuthStatus() {
        if (this.logger.log("Getting authentication status"), this.disableAuthLogin) return {
            authMethod: "not-specified",
            email: null,
            subscriptionType: null
        };
        if (Vj(this.env.CLAUDE_CODE_USE_BEDROCK) || Vj(this.env.CLAUDE_CODE_USE_VERTEX) || Vj(this.env.CLAUDE_CODE_USE_FOUNDRY) || Vj(this.env.CLAUDE_CODE_SKIP_AUTH_LOGIN)) return {
            authMethod: "3p",
            email: null,
            subscriptionType: null
        };
        let v = this.getOAuthTokens(),
            z = !!this.env.ANTHROPIC_API_KEY || !!this.env.ANTHROPIC_AUTH_TOKEN;
        if (v) return {
            authMethod: v.scopes.includes("user:inference") ? "claudeai" : "console",
            email: null,
            subscriptionType: v.subscriptionType || null
        };
        if (z) return {
            authMethod: "3p",
            email: null,
            subscriptionType: null
        };
        if (!this.getApiKey()) {
            this.logger.log("No authentication found");
            return
        }
        return {
            authMethod: "api-key",
            email: null,
            subscriptionType: null
        }
    }
    async getAuthHeaders() {
        let v = this.getOAuthTokens();
        if (v?.accessToken) {
            if (iU6(v.expiresAt)) {
                this.logger.log("OAuth token expired or expiring soon, refreshing");
                let U = await this.refreshOAuthToken(v);
                if (U) return {
                    Authorization: `Bearer ${U.accessToken}`,
                    "anthropic-beta": Rx
                };
                this.logger.warn("OAuth token refresh failed, using potentially expired token")
            }
            return {
                Authorization: `Bearer ${v.accessToken}`,
                "anthropic-beta": Rx
            }
        }
        let z = this.getApiKey();
        if (z) return {
            "x-api-key": z
        };
        return
    }
    async refreshOAuthToken(v) {
        if (!v.refreshToken) return this.logger.warn("No refresh token available"), null;
        if (this.pendingRefresh) return this.pendingRefresh;
        this.pendingRefresh = this.doRefreshOAuthToken(v.refreshToken);
        try {
            return await this.pendingRefresh
        } finally {
            this.pendingRefresh = null
        }
    }
    async doRefreshOAuthToken(v) {
        try {
            let z = b4(),
                U = await w3.post(z.TOKEN_URL, {
                    grant_type: "refresh_token",
                    refresh_token: v,
                    client_id: z.CLIENT_ID,
                    scope: gv.join(" ")
                }, {
                    headers: {
                        "Content-Type": "application/json"
                    },
                    timeout: 1e4,
                    proxy: !1
                });
            if (U.status !== 200) return this.logger.error(`Token refresh failed: ${U.statusText}`), null;
            let V = U.data,
                N = {
                    accessToken: V.access_token,
                    refreshToken: V.refresh_token || v,
                    expiresAt: Date.now() + V.expires_in * 1000,
                    scopes: V.scope ? V.scope.split(" ") : gv.slice(),
                    subscriptionType: null,
                    rateLimitTier: null
                };
            return this.saveOAuthTokens(N), this.logger.log("OAuth token refreshed successfully"), N
        } catch (z) {
            return this.logger.error(`Failed to refresh OAuth token: ${z}`), null
        }
    }
    getOAuthTokens() {
        let U = (ev().read() || {})?.claudeAiOauth;
        if (!U) return null;
        return this.logger.log("OAuth tokens found in secure storage"), {
            accessToken: U.accessToken,
            refreshToken: U.refreshToken || null,
            expiresAt: U.expiresAt || null,
            scopes: U.scopes,
            subscriptionType: U.subscriptionType,
            rateLimitTier: U.rateLimitTier
        }
    }
    getApiKey() {
        if (process.platform === "darwin") try {
            let U = E3("security", ["find-generic-password", "-a", H5(), "-w", "-s", I9()]);
            if (U.stdout) return this.logger.log("API key found in macOS keychain"), U.stdout.trim()
        } catch {
            this.logger.log("Keychain read failed, trying file fallback")
        }
        let v = this.getConfigPath(),
            z = Nj.join(v, "config.json");
        if (Z3.existsSync(z)) try {
            let U = JSON.parse(Z3.readFileSync(z, "utf8"));
            if (U.primaryApiKey) return this.logger.log("API key found in config file"), U.primaryApiKey
        } catch {
            this.logger.warn("Failed to read config file")
        }
        return null
    }
    saveOAuthTokens(v) {
        this.logger.log("Saving OAuth tokens to secure storage");
        let z = ev(),
            U = z.read() || {};
        U.claudeAiOauth = {
            accessToken: v.accessToken,
            refreshToken: v.refreshToken || "",
            expiresAt: v.expiresAt || Date.now() + 3600000,
            scopes: v.scopes,
            subscriptionType: v.subscriptionType,
            rateLimitTier: v.rateLimitTier
        }, z.update(U)
    }
    async saveApiKey(v) {
        this.logger.log("Saving API key");
        let z = this.getConfigPath();
        if (!Z3.existsSync(z)) Z3.mkdirSync(z, {
            recursive: !0
        });
        let U = Nj.join(z, "config.json"),
            V = {};
        if (Z3.existsSync(U)) try {
            V = JSON.parse(Z3.readFileSync(U, "utf8"))
        } catch {}
        if (process.platform === "darwin") try {
            let K = I9(),
                x = H5(),
                j = Buffer.from(v, "utf-8").toString("hex"),
                B = `add-generic-password -U -a "${x}" -s "${K}" -X "${j}"
`,
                O = E3("security", ["-i"], {
                    input: B,
                    stdio: ["pipe", "pipe", "pipe"],
                    reject: !1
                });
            if (O.exitCode !== 0) throw Error(`security command failed with exit code ${O.exitCode}`);
            this.logger.log("API key saved to macOS keychain named ")
        } catch (K) {
            throw this.logger.error(`Failed to save API key to keychain: ${K}`), Error("Unable to save API key to macOS Keychain. Please ensure VS Code has keychain access permissions.")
        } else V.primaryApiKey = v;
        if (!V.customApiKeyResponses) V.customApiKeyResponses = {};
        if (!V.customApiKeyResponses.approved) V.customApiKeyResponses.approved = [];
        let N = kY(v);
        if (!V.customApiKeyResponses.approved.includes(N)) V.customApiKeyResponses.approved.push(N);
        try {
            Z3.writeFileSync(U, JSON.stringify(V, null, 2), "utf8"), mY.chmodSync(U, 384), this.logger.log("API key saved to config file")
        } catch (K) {
            throw this.logger.error(`Failed to save API key: ${K}`), Error(`Failed to save API key ${K}`)
        }
    }
    async logout() {
        this.logger.log("Logging out - clearing stored credentials");
        let v = !0;
        if (this.cachedOrgUUID = null, process.platform === "darwin") this.maybeRemoveApiKeyFromMacOSKeychain();
        ev().delete();
        let U = this.getConfigPath(),
            V = Nj.join(U, "config.json");
        if (Z3.existsSync(V)) try {
            let N = JSON.parse(Z3.readFileSync(V, "utf8"));
            delete N.primaryApiKey, Z3.writeFileSync(V, JSON.stringify(N, null, 2), "utf8")
        } catch {
            v = !1
        }
        return this.logger.log(`Logout ${v?"successful":"failed"}`), v
    }
    getConfigPath() {
        return h7()
    }
    handleManualAuthCode(v) {
        if (this.currentOAuthService) this.logger.log("Handling manual auth code input"), this.currentOAuthService.handleManualAuthCodeInput(v);
        else this.logger.warn("No active OAuth service to handle manual auth code")
    }
    async login(v, z) {
        this.logger.log(`Starting OAuth login flow: method=${v}`), this.currentOAuthService = new jA(this.logger);
        try {
            let U = await this.currentOAuthService.startOAuthFlow(v === "claudeai", z);
            if (v === "claudeai") this.saveOAuthTokens(U);
            else if (v === "console") {
                this.logger.log("Creating API key for Console user");
                let N = await this.currentOAuthService.createApiKey(U.accessToken);
                if (!N) throw this.logger.error("Failed to create API key"), Error("Failed to create API key");
                await this.saveApiKey(N)
            }
            this.logger.log("Login successful");
            let V = this.getAuthStatus();
            if (!V) throw Error("Failed to retrieve auth status after login");
            return V
        } finally {
            if (this.currentOAuthService) this.currentOAuthService.cleanup(), this.currentOAuthService = null
        }
    }
    maybeRemoveApiKeyFromMacOSKeychain() {
        if (process.platform === "darwin") try {
            let v = I9();
            E3("security", ["delete-generic-password", "-a", H5(), "-s", v])
        } catch (v) {
            this.logger.error(`Failed to remove API key from keychain: ${v}`)
        }
    }
}

function Vj(v) {
    if (!v) return !1;
    if (typeof v === "boolean") return v;
    let z = v.toLowerCase().trim();
    return ["1", "true", "yes", "on"].includes(z)
}

function iU6(v) {
    if (v === null) return !1;
    return Date.now() + cU6 >= v
}

function XY(v) {
    if (v !== void 0) {
        if (Date.now() - v < 86400000) return !0
    }
    return !1
}

function gY() {
    let v = rb();
    if (v.totalSessions <= 12) return !1;
    if (v.recentSessions <= 4) return !1;
    if (v.editsAccepted < 4 && v.editsAutoAccepted < 10) return !1;
    if (v.editsDeclined > 1) return !1;
    return !0
}
var $8 = {};
S8($8, {
    version: () => D$,
    util: () => v6,
    treeifyError: () => Bj,
    toJSONSchema: () => $1,
    toDotPath: () => lY,
    safeParseAsync: () => $5,
    safeParse: () => A5,
    registry: () => rU,
    regexes: () => w5,
    prettifyError: () => Oj,
    parseAsync: () => w7,
    parse: () => $7,
    locales: () => J1,
    isValidJWT: () => xu,
    isValidBase64URL: () => Ku,
    isValidBase64: () => F$,
    globalRegistry: () => A8,
    globalConfig: () => uU,
    function: () => hB,
    formatError: () => N1,
    flattenError: () => V1,
    config: () => V4,
    clone: () => p4,
    _xid: () => jV,
    _void: () => yB,
    _uuidv7: () => vV,
    _uuidv6: () => eU,
    _uuidv4: () => sU,
    _uuid: () => tU,
    _url: () => zV,
    _uppercase: () => GV,
    _unknown: () => F7,
    _union: () => KN6,
    _undefined: () => fB,
    _ulid: () => xV,
    _uint64: () => _B,
    _uint32: () => WB,
    _tuple: () => Lw,
    _trim: () => EV,
    _transform: () => AN6,
    _toUpperCase: () => PV,
    _toLowerCase: () => SV,
    _templateLiteral: () => bN6,
    _symbol: () => CB,
    _success: () => FN6,
    _stringbool: () => iB,
    _stringFormat: () => lB,
    _string: () => LB,
    _startsWith: () => MV,
    _size: () => ZV,
    _set: () => JN6,
    _safeParseAsync: () => Dj,
    _safeParse: () => Hj,
    _regex: () => LV,
    _refine: () => cB,
    _record: () => BN6,
    _readonly: () => MN6,
    _property: () => Zw,
    _promise: () => WN6,
    _positive: () => Dw,
    _pipe: () => IN6,
    _parseAsync: () => qj,
    _parse: () => Jj,
    _overwrite: () => E9,
    _optional: () => $N6,
    _number: () => GB,
    _nullable: () => wN6,
    _null: () => TB,
    _normalize: () => WV,
    _nonpositive: () => $w,
    _nonoptional: () => LN6,
    _nonnegative: () => ww,
    _never: () => uB,
    _negative: () => Aw,
    _nativeEnum: () => HN6,
    _nanoid: () => VV,
    _nan: () => mB,
    _multipleOf: () => G7,
    _minSize: () => I7,
    _minLength: () => F5,
    _min: () => F3,
    _mime: () => RV,
    _maxSize: () => H1,
    _maxLength: () => D1,
    _max: () => n3,
    _map: () => ON6,
    _lte: () => n3,
    _lt: () => R9,
    _lowercase: () => FV,
    _literal: () => DN6,
    _length: () => A1,
    _lazy: () => RN6,
    _ksuid: () => BV,
    _jwt: () => wV,
    _isoTime: () => jw,
    _isoDuration: () => Bw,
    _isoDateTime: () => Kw,
    _isoDate: () => xw,
    _ipv6: () => JV,
    _ipv4: () => OV,
    _intersection: () => jN6,
    _int64: () => PB,
    _int32: () => RB,
    _int: () => IB,
    _includes: () => IV,
    _guid: () => q1,
    _gte: () => F3,
    _gt: () => W9,
    _float64: () => bB,
    _float32: () => MB,
    _file: () => XB,
    _enum: () => qN6,
    _endsWith: () => bV,
    _emoji: () => UV,
    _email: () => aU,
    _e164: () => $V,
    _discriminatedUnion: () => xN6,
    _default: () => ZN6,
    _date: () => kB,
    _custom: () => gB,
    _cuid2: () => KV,
    _cuid: () => NV,
    _coercedString: () => Nw,
    _coercedNumber: () => Ow,
    _coercedDate: () => Hw,
    _coercedBoolean: () => Jw,
    _coercedBigint: () => qw,
    _cidrv6: () => HV,
    _cidrv4: () => qV,
    _catch: () => GN6,
    _boolean: () => EB,
    _bigint: () => SB,
    _base64url: () => AV,
    _base64: () => DV,
    _array: () => _V,
    _any: () => YB,
    TimePrecision: () => FB,
    NEVER: () => Kj,
    JSONSchemaGenerator: () => pB,
    JSONSchema: () => Ju,
    Doc: () => Zj,
    $output: () => wB,
    $input: () => ZB,
    $constructor: () => Y,
    $brand: () => xj,
    $ZodXID: () => _j,
    $ZodVoid: () => dj,
    $ZodUnknown: () => L7,
    $ZodUnion: () => QU,
    $ZodUndefined: () => hj,
    $ZodUUID: () => Ij,
    $ZodURL: () => bj,
    $ZodULID: () => Pj,
    $ZodType: () => i6,
    $ZodTuple: () => L5,
    $ZodTransform: () => B1,
    $ZodTemplateLiteral: () => HB,
    $ZodSymbol: () => lj,
    $ZodSuccess: () => BB,
    $ZodStringFormat: () => S0,
    $ZodString: () => Z5,
    $ZodSet: () => ej,
    $ZodRegistry: () => oU,
    $ZodRecord: () => tj,
    $ZodRealError: () => U1,
    $ZodReadonly: () => qB,
    $ZodPromise: () => DB,
    $ZodPrefault: () => xB,
    $ZodPipe: () => O1,
    $ZodOptional: () => VB,
    $ZodObject: () => nU,
    $ZodNumberFormat: () => cj,
    $ZodNumber: () => hU,
    $ZodNullable: () => NB,
    $ZodNull: () => pj,
    $ZodNonOptional: () => jB,
    $ZodNever: () => Qj,
    $ZodNanoID: () => Wj,
    $ZodNaN: () => JB,
    $ZodMap: () => sj,
    $ZodLiteral: () => zB,
    $ZodLazy: () => AB,
    $ZodKSUID: () => Cj,
    $ZodJWT: () => Xj,
    $ZodIntersection: () => aj,
    $ZodISOTime: () => Z$,
    $ZodISODuration: () => L$,
    $ZodISODateTime: () => $$,
    $ZodISODate: () => w$,
    $ZodIPv6: () => Tj,
    $ZodIPv4: () => fj,
    $ZodGUID: () => Gj,
    $ZodFunction: () => Fw,
    $ZodFile: () => UB,
    $ZodError: () => lU,
    $ZodEnum: () => vB,
    $ZodEmoji: () => Rj,
    $ZodEmail: () => Mj,
    $ZodE164: () => mj,
    $ZodDiscriminatedUnion: () => rj,
    $ZodDefault: () => KB,
    $ZodDate: () => oj,
    $ZodCustomStringFormat: () => gj,
    $ZodCustom: () => $B,
    $ZodCheckUpperCase: () => x$,
    $ZodCheckStringFormat: () => K1,
    $ZodCheckStartsWith: () => B$,
    $ZodCheckSizeEquals: () => v$,
    $ZodCheckRegex: () => N$,
    $ZodCheckProperty: () => J$,
    $ZodCheckOverwrite: () => H$,
    $ZodCheckNumberFormat: () => aA,
    $ZodCheckMultipleOf: () => rA,
    $ZodCheckMinSize: () => eA,
    $ZodCheckMinLength: () => U$,
    $ZodCheckMimeType: () => q$,
    $ZodCheckMaxSize: () => sA,
    $ZodCheckMaxLength: () => z$,
    $ZodCheckLowerCase: () => K$,
    $ZodCheckLessThan: () => $j,
    $ZodCheckLengthEquals: () => V$,
    $ZodCheckIncludes: () => j$,
    $ZodCheckGreaterThan: () => wj,
    $ZodCheckEndsWith: () => O$,
    $ZodCheckBigIntFormat: () => tA,
    $ZodCheck: () => h0,
    $ZodCatch: () => OB,
    $ZodCUID2: () => Sj,
    $ZodCUID: () => Ej,
    $ZodCIDRv6: () => uj,
    $ZodCIDRv4: () => Yj,
    $ZodBoolean: () => x1,
    $ZodBigIntFormat: () => ij,
    $ZodBigInt: () => pU,
    $ZodBase64URL: () => kj,
    $ZodBase64: () => yj,
    $ZodAsyncError: () => M9,
    $ZodArray: () => j1,
    $ZodAny: () => nj
});
var Kj = Object.freeze({
    status: "aborted"
});

function Y(v, z, U) {
    function V(j, B) {
        var O;
        Object.defineProperty(j, "_zod", {
            value: j._zod ?? {},
            enumerable: !1
        }), (O = j._zod).traits ?? (O.traits = new Set), j._zod.traits.add(v), z(j, B);
        for (let J in x.prototype)
            if (!(J in j)) Object.defineProperty(j, J, {
                value: x.prototype[J].bind(j)
            });
        j._zod.constr = x, j._zod.def = B
    }
    let N = U?.Parent ?? Object;
    class K extends N {}
    Object.defineProperty(K, "name", {
        value: v
    });

    function x(j) {
        var B;
        let O = U?.Parent ? new K : this;
        V(O, j), (B = O._zod).deferred ?? (B.deferred = []);
        for (let J of O._zod.deferred) J();
        return O
    }
    return Object.defineProperty(x, "init", {
        value: V
    }), Object.defineProperty(x, Symbol.hasInstance, {
        value: (j) => {
            if (U?.Parent && j instanceof U.Parent) return !0;
            return j?._zod?.traits?.has(v)
        }
    }), Object.defineProperty(x, "name", {
        value: v
    }), x
}
var xj = Symbol("zod_brand");
class M9 extends Error {
    constructor() {
        super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")
    }
}
var uU = {};

function V4(v) {
    if (v) Object.assign(uU, v);
    return uU
}
var v6 = {};
S8(v6, {
    unwrapMessage: () => yU,
    stringifyPrimitive: () => K6,
    required: () => NV6,
    randomString: () => rU6,
    propertyKeyTypes: () => gU,
    promiseAllObject: () => oU6,
    primitiveTypes: () => $A,
    prefixIssues: () => L3,
    pick: () => eU6,
    partial: () => VV6,
    optionalKeys: () => wA,
    omit: () => vV6,
    numKeys: () => aU6,
    nullish: () => D5,
    normalizeParams: () => e,
    merge: () => UV6,
    jsonStringifyReplacer: () => qA,
    joinValues: () => h,
    issue: () => FA,
    isPlainObject: () => z1,
    isObject: () => v1,
    getSizableOrigin: () => cU,
    getParsedType: () => tU6,
    getLengthableOrigin: () => iU,
    getEnumValues: () => kU,
    getElementAtPath: () => dU6,
    floatSafeRemainder: () => HA,
    finalizeIssue: () => u3,
    extend: () => zV6,
    escapeRegex: () => b9,
    esc: () => D7,
    defineLazy: () => G0,
    createTransparentProxy: () => sU6,
    clone: () => p4,
    cleanRegex: () => XU,
    cleanEnum: () => KV6,
    captureStackTrace: () => jj,
    cached: () => mU,
    assignProp: () => DA,
    assertNotEqual: () => hU6,
    assertNever: () => nU6,
    assertIs: () => pU6,
    assertEqual: () => lU6,
    assert: () => QU6,
    allowsEval: () => AA,
    aborted: () => A7,
    NUMBER_FORMAT_RANGES: () => ZA,
    Class: () => cY,
    BIGINT_FORMAT_RANGES: () => LA
});

function lU6(v) {
    return v
}

function hU6(v) {
    return v
}

function pU6(v) {}

function nU6(v) {
    throw Error()
}

function QU6(v) {}

function kU(v) {
    let z = Object.values(v).filter((V) => typeof V === "number");
    return Object.entries(v).filter(([V, N]) => z.indexOf(+V) === -1).map(([V, N]) => N)
}

function h(v, z = "|") {
    return v.map((U) => K6(U)).join(z)
}

function qA(v, z) {
    if (typeof z === "bigint") return z.toString();
    return z
}

function mU(v) {
    return {
        get value() {
            {
                let U = v();
                return Object.defineProperty(this, "value", {
                    value: U
                }), U
            }
            throw Error("cached value already set")
        }
    }
}

function D5(v) {
    return v === null || v === void 0
}

function XU(v) {
    let z = v.startsWith("^") ? 1 : 0,
        U = v.endsWith("$") ? v.length - 1 : v.length;
    return v.slice(z, U)
}

function HA(v, z) {
    let U = (v.toString().split(".")[1] || "").length,
        V = (z.toString().split(".")[1] || "").length,
        N = U > V ? U : V,
        K = Number.parseInt(v.toFixed(N).replace(".", "")),
        x = Number.parseInt(z.toFixed(N).replace(".", ""));
    return K % x / 10 ** N
}

function G0(v, z, U) {
    Object.defineProperty(v, z, {
        get() {
            {
                let N = U();
                return v[z] = N, N
            }
            throw Error("cached value already set")
        },
        set(N) {
            Object.defineProperty(v, z, {
                value: N
            })
        },
        configurable: !0
    })
}

function DA(v, z, U) {
    Object.defineProperty(v, z, {
        value: U,
        writable: !0,
        enumerable: !0,
        configurable: !0
    })
}

function dU6(v, z) {
    if (!z) return v;
    return z.reduce((U, V) => U?.[V], v)
}

function oU6(v) {
    let z = Object.keys(v),
        U = z.map((V) => v[V]);
    return Promise.all(U).then((V) => {
        let N = {};
        for (let K = 0; K < z.length; K++) N[z[K]] = V[K];
        return N
    })
}

function rU6(v = 10) {
    let U = "";
    for (let V = 0; V < v; V++) U += "abcdefghijklmnopqrstuvwxyz" [Math.floor(Math.random() * 26)];
    return U
}

function D7(v) {
    return JSON.stringify(v)
}
var jj = Error.captureStackTrace ? Error.captureStackTrace : (...v) => {};

function v1(v) {
    return typeof v === "object" && v !== null && !Array.isArray(v)
}
var AA = mU(() => {
    if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1;
    try {
        return new Function(""), !0
    } catch (v) {
        return !1
    }
});

function z1(v) {
    if (v1(v) === !1) return !1;
    let z = v.constructor;
    if (z === void 0) return !0;
    let U = z.prototype;
    if (v1(U) === !1) return !1;
    if (Object.prototype.hasOwnProperty.call(U, "isPrototypeOf") === !1) return !1;
    return !0
}

function aU6(v) {
    let z = 0;
    for (let U in v)
        if (Object.prototype.hasOwnProperty.call(v, U)) z++;
    return z
}
var tU6 = (v) => {
        let z = typeof v;
        switch (z) {
            case "undefined":
                return "undefined";
            case "string":
                return "string";
            case "number":
                return Number.isNaN(v) ? "nan" : "number";
            case "boolean":
                return "boolean";
            case "function":
                return "function";
            case "bigint":
                return "bigint";
            case "symbol":
                return "symbol";
            case "object":
                if (Array.isArray(v)) return "array";
                if (v === null) return "null";
                if (v.then && typeof v.then === "function" && v.catch && typeof v.catch === "function") return "promise";
                if (typeof Map < "u" && v instanceof Map) return "map";
                if (typeof Set < "u" && v instanceof Set) return "set";
                if (typeof Date < "u" && v instanceof Date) return "date";
                if (typeof File < "u" && v instanceof File) return "file";
                return "object";
            default:
                throw Error(`Unknown data type: ${z}`)
        }
    },
    gU = new Set(["string", "number", "symbol"]),
    $A = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);

function b9(v) {
    return v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function p4(v, z, U) {
    let V = new v._zod.constr(z ?? v._zod.def);
    if (!z || U?.parent) V._zod.parent = v;
    return V
}

function e(v) {
    let z = v;
    if (!z) return {};
    if (typeof z === "string") return {
        error: () => z
    };
    if (z?.message !== void 0) {
        if (z?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
        z.error = z.message
    }
    if (delete z.message, typeof z.error === "string") return {
        ...z,
        error: () => z.error
    };
    return z
}

function sU6(v) {
    let z;
    return new Proxy({}, {
        get(U, V, N) {
            return z ?? (z = v()), Reflect.get(z, V, N)
        },
        set(U, V, N, K) {
            return z ?? (z = v()), Reflect.set(z, V, N, K)
        },
        has(U, V) {
            return z ?? (z = v()), Reflect.has(z, V)
        },
        deleteProperty(U, V) {
            return z ?? (z = v()), Reflect.deleteProperty(z, V)
        },
        ownKeys(U) {
            return z ?? (z = v()), Reflect.ownKeys(z)
        },
        getOwnPropertyDescriptor(U, V) {
            return z ?? (z = v()), Reflect.getOwnPropertyDescriptor(z, V)
        },
        defineProperty(U, V, N) {
            return z ?? (z = v()), Reflect.defineProperty(z, V, N)
        }
    })
}

function K6(v) {
    if (typeof v === "bigint") return v.toString() + "n";
    if (typeof v === "string") return `"${v}"`;
    return `${v}`
}

function wA(v) {
    return Object.keys(v).filter((z) => {
        return v[z]._zod.optin === "optional" && v[z]._zod.optout === "optional"
    })
}
var ZA = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-2147483648, 2147483647],
        uint32: [0, 4294967295],
        float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    },
    LA = {
        int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
        uint64: [BigInt(0), BigInt("18446744073709551615")]
    };

function eU6(v, z) {
    let U = {},
        V = v._zod.def;
    for (let N in z) {
        if (!(N in V.shape)) throw Error(`Unrecognized key: "${N}"`);
        if (!z[N]) continue;
        U[N] = V.shape[N]
    }
    return p4(v, {
        ...v._zod.def,
        shape: U,
        checks: []
    })
}

function vV6(v, z) {
    let U = {
            ...v._zod.def.shape
        },
        V = v._zod.def;
    for (let N in z) {
        if (!(N in V.shape)) throw Error(`Unrecognized key: "${N}"`);
        if (!z[N]) continue;
        delete U[N]
    }
    return p4(v, {
        ...v._zod.def,
        shape: U,
        checks: []
    })
}

function zV6(v, z) {
    if (!z1(z)) throw Error("Invalid input to extend: expected a plain object");
    let U = {
        ...v._zod.def,
        get shape() {
            let V = {
                ...v._zod.def.shape,
                ...z
            };
            return DA(this, "shape", V), V
        },
        checks: []
    };
    return p4(v, U)
}

function UV6(v, z) {
    return p4(v, {
        ...v._zod.def,
        get shape() {
            let U = {
                ...v._zod.def.shape,
                ...z._zod.def.shape
            };
            return DA(this, "shape", U), U
        },
        catchall: z._zod.def.catchall,
        checks: []
    })
}

function VV6(v, z, U) {
    let V = z._zod.def.shape,
        N = {
            ...V
        };
    if (U)
        for (let K in U) {
            if (!(K in V)) throw Error(`Unrecognized key: "${K}"`);
            if (!U[K]) continue;
            N[K] = v ? new v({
                type: "optional",
                innerType: V[K]
            }) : V[K]
        } else
            for (let K in V) N[K] = v ? new v({
                type: "optional",
                innerType: V[K]
            }) : V[K];
    return p4(z, {
        ...z._zod.def,
        shape: N,
        checks: []
    })
}

function NV6(v, z, U) {
    let V = z._zod.def.shape,
        N = {
            ...V
        };
    if (U)
        for (let K in U) {
            if (!(K in N)) throw Error(`Unrecognized key: "${K}"`);
            if (!U[K]) continue;
            N[K] = new v({
                type: "nonoptional",
                innerType: V[K]
            })
        } else
            for (let K in V) N[K] = new v({
                type: "nonoptional",
                innerType: V[K]
            });
    return p4(z, {
        ...z._zod.def,
        shape: N,
        checks: []
    })
}

function A7(v, z = 0) {
    for (let U = z; U < v.issues.length; U++)
        if (v.issues[U]?.continue !== !0) return !0;
    return !1
}

function L3(v, z) {
    return z.map((U) => {
        var V;
        return (V = U).path ?? (V.path = []), U.path.unshift(v), U
    })
}

function yU(v) {
    return typeof v === "string" ? v : v?.message
}

function u3(v, z, U) {
    let V = {
        ...v,
        path: v.path ?? []
    };
    if (!v.message) {
        let N = yU(v.inst?._zod.def?.error?.(v)) ?? yU(z?.error?.(v)) ?? yU(U.customError?.(v)) ?? yU(U.localeError?.(v)) ?? "Invalid input";
        V.message = N
    }
    if (delete V.inst, delete V.continue, !z?.reportInput) delete V.input;
    return V
}

function cU(v) {
    if (v instanceof Set) return "set";
    if (v instanceof Map) return "map";
    if (v instanceof File) return "file";
    return "unknown"
}

function iU(v) {
    if (Array.isArray(v)) return "array";
    if (typeof v === "string") return "string";
    return "unknown"
}

function FA(...v) {
    let [z, U, V] = v;
    if (typeof z === "string") return {
        message: z,
        code: "custom",
        input: U,
        inst: V
    };
    return {
        ...z
    }
}

function KV6(v) {
    return Object.entries(v).filter(([z, U]) => {
        return Number.isNaN(Number.parseInt(z, 10))
    }).map((z) => z[1])
}
class cY {
    constructor(...v) {}
}
var iY = (v, z) => {
        v.name = "$ZodError", Object.defineProperty(v, "_zod", {
            value: v._zod,
            enumerable: !1
        }), Object.defineProperty(v, "issues", {
            value: z,
            enumerable: !1
        }), Object.defineProperty(v, "message", {
            get() {
                return JSON.stringify(z, qA, 2)
            },
            enumerable: !0
        })
    },
    lU = Y("$ZodError", iY),
    U1 = Y("$ZodError", iY, {
        Parent: Error
    });

function V1(v, z = (U) => U.message) {
    let U = {},
        V = [];
    for (let N of v.issues)
        if (N.path.length > 0) U[N.path[0]] = U[N.path[0]] || [], U[N.path[0]].push(z(N));
        else V.push(z(N));
    return {
        formErrors: V,
        fieldErrors: U
    }
}

function N1(v, z) {
    let U = z || function(K) {
            return K.message
        },
        V = {
            _errors: []
        },
        N = (K) => {
            for (let x of K.issues)
                if (x.code === "invalid_union" && x.errors.length) x.errors.map((j) => N({
                    issues: j
                }));
                else if (x.code === "invalid_key") N({
                issues: x.issues
            });
            else if (x.code === "invalid_element") N({
                issues: x.issues
            });
            else if (x.path.length === 0) V._errors.push(U(x));
            else {
                let j = V,
                    B = 0;
                while (B < x.path.length) {
                    let O = x.path[B];
                    if (B !== x.path.length - 1) j[O] = j[O] || {
                        _errors: []
                    };
                    else j[O] = j[O] || {
                        _errors: []
                    }, j[O]._errors.push(U(x));
                    j = j[O], B++
                }
            }
        };
    return N(v), V
}

function Bj(v, z) {
    let U = z || function(K) {
            return K.message
        },
        V = {
            errors: []
        },
        N = (K, x = []) => {
            var j, B;
            for (let O of K.issues)
                if (O.code === "invalid_union" && O.errors.length) O.errors.map((J) => N({
                    issues: J
                }, O.path));
                else if (O.code === "invalid_key") N({
                issues: O.issues
            }, O.path);
            else if (O.code === "invalid_element") N({
                issues: O.issues
            }, O.path);
            else {
                let J = [...x, ...O.path];
                if (J.length === 0) {
                    V.errors.push(U(O));
                    continue
                }
                let q = V,
                    H = 0;
                while (H < J.length) {
                    let D = J[H],
                        A = H === J.length - 1;
                    if (typeof D === "string") q.properties ?? (q.properties = {}), (j = q.properties)[D] ?? (j[D] = {
                        errors: []
                    }), q = q.properties[D];
                    else q.items ?? (q.items = []), (B = q.items)[D] ?? (B[D] = {
                        errors: []
                    }), q = q.items[D];
                    if (A) q.errors.push(U(O));
                    H++
                }
            }
        };
    return N(v), V
}

function lY(v) {
    let z = [];
    for (let U of v)
        if (typeof U === "number") z.push(`[${U}]`);
        else if (typeof U === "symbol") z.push(`[${JSON.stringify(String(U))}]`);
    else if (/[^\w$]/.test(U)) z.push(`[${JSON.stringify(U)}]`);
    else {
        if (z.length) z.push(".");
        z.push(U)
    }
    return z.join("")
}

function Oj(v) {
    let z = [],
        U = [...v.issues].sort((V, N) => V.path.length - N.path.length);
    for (let V of U)
        if (z.push(` ${V.message}`), V.path?.length) z.push(`   at ${lY(V.path)}`);
    return z.join(`
`)
}
var Jj = (v) => (z, U, V, N) => {
        let K = V ? Object.assign(V, {
                async: !1
            }) : {
                async: !1
            },
            x = z._zod.run({
                value: U,
                issues: []
            }, K);
        if (x instanceof Promise) throw new M9;
        if (x.issues.length) {
            let j = new(N?.Err ?? v)(x.issues.map((B) => u3(B, K, V4())));
            throw jj(j, N?.callee), j
        }
        return x.value
    },
    $7 = Jj(U1),
    qj = (v) => async (z, U, V, N) => {
        let K = V ? Object.assign(V, {
                async: !0
            }) : {
                async: !0
            },
            x = z._zod.run({
                value: U,
                issues: []
            }, K);
        if (x instanceof Promise) x = await x;
        if (x.issues.length) {
            let j = new(N?.Err ?? v)(x.issues.map((B) => u3(B, K, V4())));
            throw jj(j, N?.callee), j
        }
        return x.value
    }, w7 = qj(U1), Hj = (v) => (z, U, V) => {
        let N = V ? {
                ...V,
                async: !1
            } : {
                async: !1
            },
            K = z._zod.run({
                value: U,
                issues: []
            }, N);
        if (K instanceof Promise) throw new M9;
        return K.issues.length ? {
            success: !1,
            error: new(v ?? lU)(K.issues.map((x) => u3(x, N, V4())))
        } : {
            success: !0,
            data: K.value
        }
    }, A5 = Hj(U1), Dj = (v) => async (z, U, V) => {
        let N = V ? Object.assign(V, {
                async: !0
            }) : {
                async: !0
            },
            K = z._zod.run({
                value: U,
                issues: []
            }, N);
        if (K instanceof Promise) K = await K;
        return K.issues.length ? {
            success: !1,
            error: new v(K.issues.map((x) => u3(x, N, V4())))
        } : {
            success: !0,
            data: K.value
        }
    }, $5 = Dj(U1);
var w5 = {};
S8(w5, {
    xid: () => bA,
    uuid7: () => JV6,
    uuid6: () => OV6,
    uuid4: () => BV6,
    uuid: () => Z7,
    uppercase: () => oA,
    unicodeEmail: () => DV6,
    undefined: () => QA,
    ulid: () => MA,
    time: () => XA,
    string: () => cA,
    rfc5322Email: () => HV6,
    number: () => hA,
    null: () => nA,
    nanoid: () => WA,
    lowercase: () => dA,
    ksuid: () => RA,
    ipv6: () => fA,
    ipv4: () => CA,
    integer: () => lA,
    html5Email: () => qV6,
    hostname: () => yA,
    guid: () => SA,
    extendedDuration: () => jV6,
    emoji: () => _A,
    email: () => PA,
    e164: () => kA,
    duration: () => EA,
    domain: () => wV6,
    datetime: () => gA,
    date: () => mA,
    cuid2: () => IA,
    cuid: () => GA,
    cidrv6: () => YA,
    cidrv4: () => TA,
    browserEmail: () => AV6,
    boolean: () => pA,
    bigint: () => iA,
    base64url: () => Aj,
    base64: () => uA,
    _emoji: () => $V6
});
var GA = /^[cC][^\s-]{8,}$/,
    IA = /^[0-9a-z]+$/,
    MA = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
    bA = /^[0-9a-vA-V]{20}$/,
    RA = /^[A-Za-z0-9]{27}$/,
    WA = /^[a-zA-Z0-9_-]{21}$/,
    EA = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
    jV6 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
    SA = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
    Z7 = (v) => {
        if (!v) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
        return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${v}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`)
    },
    BV6 = Z7(4),
    OV6 = Z7(6),
    JV6 = Z7(7),
    PA = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
    qV6 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    HV6 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    DV6 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
    AV6 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    $V6 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";

function _A() {
    return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")
}
var CA = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    fA = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
    TA = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
    YA = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    uA = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
    Aj = /^[A-Za-z0-9_-]*$/,
    yA = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
    wV6 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
    kA = /^\+(?:[0-9]){6,14}[0-9]$/,
    hY = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
    mA = new RegExp(`^${hY}$`);

function pY(v) {
    return typeof v.precision === "number" ? v.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : v.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${v.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?"
}

function XA(v) {
    return new RegExp(`^${pY(v)}$`)
}

function gA(v) {
    let z = pY({
            precision: v.precision
        }),
        U = ["Z"];
    if (v.local) U.push("");
    if (v.offset) U.push("([+-]\\d{2}:\\d{2})");
    let V = `${z}(?:${U.join("|")})`;
    return new RegExp(`^${hY}T(?:${V})$`)
}
var cA = (v) => {
        let z = v ? `[\\s\\S]{${v?.minimum??0},${v?.maximum??""}}` : "[\\s\\S]*";
        return new RegExp(`^${z}$`)
    },
    iA = /^\d+n?$/,
    lA = /^\d+$/,
    hA = /^-?\d+(?:\.\d+)?/i,
    pA = /true|false/i,
    nA = /null/i;
var QA = /undefined/i;
var dA = /^[^A-Z]*$/,
    oA = /^[^a-z]*$/;
var h0 = Y("$ZodCheck", (v, z) => {
        var U;
        v._zod ?? (v._zod = {}), v._zod.def = z, (U = v._zod).onattach ?? (U.onattach = [])
    }),
    QY = {
        number: "number",
        bigint: "bigint",
        object: "date"
    },
    $j = Y("$ZodCheckLessThan", (v, z) => {
        h0.init(v, z);
        let U = QY[typeof z.value];
        v._zod.onattach.push((V) => {
            let N = V._zod.bag,
                K = (z.inclusive ? N.maximum : N.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
            if (z.value < K)
                if (z.inclusive) N.maximum = z.value;
                else N.exclusiveMaximum = z.value
        }), v._zod.check = (V) => {
            if (z.inclusive ? V.value <= z.value : V.value < z.value) return;
            V.issues.push({
                origin: U,
                code: "too_big",
                maximum: z.value,
                input: V.value,
                inclusive: z.inclusive,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    wj = Y("$ZodCheckGreaterThan", (v, z) => {
        h0.init(v, z);
        let U = QY[typeof z.value];
        v._zod.onattach.push((V) => {
            let N = V._zod.bag,
                K = (z.inclusive ? N.minimum : N.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
            if (z.value > K)
                if (z.inclusive) N.minimum = z.value;
                else N.exclusiveMinimum = z.value
        }), v._zod.check = (V) => {
            if (z.inclusive ? V.value >= z.value : V.value > z.value) return;
            V.issues.push({
                origin: U,
                code: "too_small",
                minimum: z.value,
                input: V.value,
                inclusive: z.inclusive,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    rA = Y("$ZodCheckMultipleOf", (v, z) => {
        h0.init(v, z), v._zod.onattach.push((U) => {
            var V;
            (V = U._zod.bag).multipleOf ?? (V.multipleOf = z.value)
        }), v._zod.check = (U) => {
            if (typeof U.value !== typeof z.value) throw Error("Cannot mix number and bigint in multiple_of check.");
            if (typeof U.value === "bigint" ? U.value % z.value === BigInt(0) : HA(U.value, z.value) === 0) return;
            U.issues.push({
                origin: typeof U.value,
                code: "not_multiple_of",
                divisor: z.value,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    aA = Y("$ZodCheckNumberFormat", (v, z) => {
        h0.init(v, z), z.format = z.format || "float64";
        let U = z.format?.includes("int"),
            V = U ? "int" : "number",
            [N, K] = ZA[z.format];
        v._zod.onattach.push((x) => {
            let j = x._zod.bag;
            if (j.format = z.format, j.minimum = N, j.maximum = K, U) j.pattern = lA
        }), v._zod.check = (x) => {
            let j = x.value;
            if (U) {
                if (!Number.isInteger(j)) {
                    x.issues.push({
                        expected: V,
                        format: z.format,
                        code: "invalid_type",
                        input: j,
                        inst: v
                    });
                    return
                }
                if (!Number.isSafeInteger(j)) {
                    if (j > 0) x.issues.push({
                        input: j,
                        code: "too_big",
                        maximum: Number.MAX_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst: v,
                        origin: V,
                        continue: !z.abort
                    });
                    else x.issues.push({
                        input: j,
                        code: "too_small",
                        minimum: Number.MIN_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst: v,
                        origin: V,
                        continue: !z.abort
                    });
                    return
                }
            }
            if (j < N) x.issues.push({
                origin: "number",
                input: j,
                code: "too_small",
                minimum: N,
                inclusive: !0,
                inst: v,
                continue: !z.abort
            });
            if (j > K) x.issues.push({
                origin: "number",
                input: j,
                code: "too_big",
                maximum: K,
                inst: v
            })
        }
    }),
    tA = Y("$ZodCheckBigIntFormat", (v, z) => {
        h0.init(v, z);
        let [U, V] = LA[z.format];
        v._zod.onattach.push((N) => {
            let K = N._zod.bag;
            K.format = z.format, K.minimum = U, K.maximum = V
        }), v._zod.check = (N) => {
            let K = N.value;
            if (K < U) N.issues.push({
                origin: "bigint",
                input: K,
                code: "too_small",
                minimum: U,
                inclusive: !0,
                inst: v,
                continue: !z.abort
            });
            if (K > V) N.issues.push({
                origin: "bigint",
                input: K,
                code: "too_big",
                maximum: V,
                inst: v
            })
        }
    }),
    sA = Y("$ZodCheckMaxSize", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.size !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
            if (z.maximum < V) U._zod.bag.maximum = z.maximum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.size <= z.maximum) return;
            U.issues.push({
                origin: cU(V),
                code: "too_big",
                maximum: z.maximum,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    eA = Y("$ZodCheckMinSize", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.size !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
            if (z.minimum > V) U._zod.bag.minimum = z.minimum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.size >= z.minimum) return;
            U.issues.push({
                origin: cU(V),
                code: "too_small",
                minimum: z.minimum,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    v$ = Y("$ZodCheckSizeEquals", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.size !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.minimum = z.size, V.maximum = z.size, V.size = z.size
        }), v._zod.check = (U) => {
            let V = U.value,
                N = V.size;
            if (N === z.size) return;
            let K = N > z.size;
            U.issues.push({
                origin: cU(V),
                ...K ? {
                    code: "too_big",
                    maximum: z.size
                } : {
                    code: "too_small",
                    minimum: z.size
                },
                inclusive: !0,
                exact: !0,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    z$ = Y("$ZodCheckMaxLength", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
            if (z.maximum < V) U._zod.bag.maximum = z.maximum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.length <= z.maximum) return;
            let K = iU(V);
            U.issues.push({
                origin: K,
                code: "too_big",
                maximum: z.maximum,
                inclusive: !0,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    U$ = Y("$ZodCheckMinLength", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
            if (z.minimum > V) U._zod.bag.minimum = z.minimum
        }), v._zod.check = (U) => {
            let V = U.value;
            if (V.length >= z.minimum) return;
            let K = iU(V);
            U.issues.push({
                origin: K,
                code: "too_small",
                minimum: z.minimum,
                inclusive: !0,
                input: V,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    V$ = Y("$ZodCheckLengthEquals", (v, z) => {
        h0.init(v, z), v._zod.when = (U) => {
            let V = U.value;
            return !D5(V) && V.length !== void 0
        }, v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.minimum = z.length, V.maximum = z.length, V.length = z.length
        }), v._zod.check = (U) => {
            let V = U.value,
                N = V.length;
            if (N === z.length) return;
            let K = iU(V),
                x = N > z.length;
            U.issues.push({
                origin: K,
                ...x ? {
                    code: "too_big",
                    maximum: z.length
                } : {
                    code: "too_small",
                    minimum: z.length
                },
                inclusive: !0,
                exact: !0,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    K1 = Y("$ZodCheckStringFormat", (v, z) => {
        var U, V;
        if (h0.init(v, z), v._zod.onattach.push((N) => {
                let K = N._zod.bag;
                if (K.format = z.format, z.pattern) K.patterns ?? (K.patterns = new Set), K.patterns.add(z.pattern)
            }), z.pattern)(U = v._zod).check ?? (U.check = (N) => {
            if (z.pattern.lastIndex = 0, z.pattern.test(N.value)) return;
            N.issues.push({
                origin: "string",
                code: "invalid_format",
                format: z.format,
                input: N.value,
                ...z.pattern ? {
                    pattern: z.pattern.toString()
                } : {},
                inst: v,
                continue: !z.abort
            })
        });
        else(V = v._zod).check ?? (V.check = () => {})
    }),
    N$ = Y("$ZodCheckRegex", (v, z) => {
        K1.init(v, z), v._zod.check = (U) => {
            if (z.pattern.lastIndex = 0, z.pattern.test(U.value)) return;
            U.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "regex",
                input: U.value,
                pattern: z.pattern.toString(),
                inst: v,
                continue: !z.abort
            })
        }
    }),
    K$ = Y("$ZodCheckLowerCase", (v, z) => {
        z.pattern ?? (z.pattern = dA), K1.init(v, z)
    }),
    x$ = Y("$ZodCheckUpperCase", (v, z) => {
        z.pattern ?? (z.pattern = oA), K1.init(v, z)
    }),
    j$ = Y("$ZodCheckIncludes", (v, z) => {
        h0.init(v, z);
        let U = b9(z.includes),
            V = new RegExp(typeof z.position === "number" ? `^.{${z.position}}${U}` : U);
        z.pattern = V, v._zod.onattach.push((N) => {
            let K = N._zod.bag;
            K.patterns ?? (K.patterns = new Set), K.patterns.add(V)
        }), v._zod.check = (N) => {
            if (N.value.includes(z.includes, z.position)) return;
            N.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "includes",
                includes: z.includes,
                input: N.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    B$ = Y("$ZodCheckStartsWith", (v, z) => {
        h0.init(v, z);
        let U = new RegExp(`^${b9(z.prefix)}.*`);
        z.pattern ?? (z.pattern = U), v._zod.onattach.push((V) => {
            let N = V._zod.bag;
            N.patterns ?? (N.patterns = new Set), N.patterns.add(U)
        }), v._zod.check = (V) => {
            if (V.value.startsWith(z.prefix)) return;
            V.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "starts_with",
                prefix: z.prefix,
                input: V.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    O$ = Y("$ZodCheckEndsWith", (v, z) => {
        h0.init(v, z);
        let U = new RegExp(`.*${b9(z.suffix)}$`);
        z.pattern ?? (z.pattern = U), v._zod.onattach.push((V) => {
            let N = V._zod.bag;
            N.patterns ?? (N.patterns = new Set), N.patterns.add(U)
        }), v._zod.check = (V) => {
            if (V.value.endsWith(z.suffix)) return;
            V.issues.push({
                origin: "string",
                code: "invalid_format",
                format: "ends_with",
                suffix: z.suffix,
                input: V.value,
                inst: v,
                continue: !z.abort
            })
        }
    });

function nY(v, z, U) {
    if (v.issues.length) z.issues.push(...L3(U, v.issues))
}
var J$ = Y("$ZodCheckProperty", (v, z) => {
        h0.init(v, z), v._zod.check = (U) => {
            let V = z.schema._zod.run({
                value: U.value[z.property],
                issues: []
            }, {});
            if (V instanceof Promise) return V.then((N) => nY(N, U, z.property));
            nY(V, U, z.property);
            return
        }
    }),
    q$ = Y("$ZodCheckMimeType", (v, z) => {
        h0.init(v, z);
        let U = new Set(z.mime);
        v._zod.onattach.push((V) => {
            V._zod.bag.mime = z.mime
        }), v._zod.check = (V) => {
            if (U.has(V.value.type)) return;
            V.issues.push({
                code: "invalid_value",
                values: z.mime,
                input: V.value.type,
                inst: v
            })
        }
    }),
    H$ = Y("$ZodCheckOverwrite", (v, z) => {
        h0.init(v, z), v._zod.check = (U) => {
            U.value = z.tx(U.value)
        }
    });
class Zj {
    constructor(v = []) {
        if (this.content = [], this.indent = 0, this) this.args = v
    }
    indented(v) {
        this.indent += 1, v(this), this.indent -= 1
    }
    write(v) {
        if (typeof v === "function") {
            v(this, {
                execution: "sync"
            }), v(this, {
                execution: "async"
            });
            return
        }
        let U = v.split(`
`).filter((K) => K),
            V = Math.min(...U.map((K) => K.length - K.trimStart().length)),
            N = U.map((K) => K.slice(V)).map((K) => " ".repeat(this.indent * 2) + K);
        for (let K of N) this.content.push(K)
    }
    compile() {
        let v = Function,
            z = this?.args,
            V = [...(this?.content ?? [""]).map((N) => `  ${N}`)];
        return new v(...z, V.join(`
`))
    }
}
var D$ = {
    major: 4,
    minor: 0,
    patch: 0
};
var i6 = Y("$ZodType", (v, z) => {
        var U;
        v ?? (v = {}), v._zod.def = z, v._zod.bag = v._zod.bag || {}, v._zod.version = D$;
        let V = [...v._zod.def.checks ?? []];
        if (v._zod.traits.has("$ZodCheck")) V.unshift(v);
        for (let N of V)
            for (let K of N._zod.onattach) K(v);
        if (V.length === 0)(U = v._zod).deferred ?? (U.deferred = []), v._zod.deferred?.push(() => {
            v._zod.run = v._zod.parse
        });
        else {
            let N = (K, x, j) => {
                let B = A7(K),
                    O;
                for (let J of x) {
                    if (J._zod.when) {
                        if (!J._zod.when(K)) continue
                    } else if (B) continue;
                    let q = K.issues.length,
                        H = J._zod.check(K);
                    if (H instanceof Promise && j?.async === !1) throw new M9;
                    if (O || H instanceof Promise) O = (O ?? Promise.resolve()).then(async () => {
                        if (await H, K.issues.length === q) return;
                        if (!B) B = A7(K, q)
                    });
                    else {
                        if (K.issues.length === q) continue;
                        if (!B) B = A7(K, q)
                    }
                }
                if (O) return O.then(() => {
                    return K
                });
                return K
            };
            v._zod.run = (K, x) => {
                let j = v._zod.parse(K, x);
                if (j instanceof Promise) {
                    if (x.async === !1) throw new M9;
                    return j.then((B) => N(B, V, x))
                }
                return N(j, V, x)
            }
        }
        v["~standard"] = {
            validate: (N) => {
                try {
                    let K = A5(v, N);
                    return K.success ? {
                        value: K.data
                    } : {
                        issues: K.error?.issues
                    }
                } catch (K) {
                    return $5(v, N).then((x) => x.success ? {
                        value: x.data
                    } : {
                        issues: x.error?.issues
                    })
                }
            },
            vendor: "zod",
            version: 1
        }
    }),
    Z5 = Y("$ZodString", (v, z) => {
        i6.init(v, z), v._zod.pattern = [...v?._zod.bag?.patterns ?? []].pop() ?? cA(v._zod.bag), v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = String(U.value)
            } catch (N) {}
            if (typeof U.value === "string") return U;
            return U.issues.push({
                expected: "string",
                code: "invalid_type",
                input: U.value,
                inst: v
            }), U
        }
    }),
    S0 = Y("$ZodStringFormat", (v, z) => {
        K1.init(v, z), Z5.init(v, z)
    }),
    Gj = Y("$ZodGUID", (v, z) => {
        z.pattern ?? (z.pattern = SA), S0.init(v, z)
    }),
    Ij = Y("$ZodUUID", (v, z) => {
        if (z.version) {
            let V = {
                v1: 1,
                v2: 2,
                v3: 3,
                v4: 4,
                v5: 5,
                v6: 6,
                v7: 7,
                v8: 8
            } [z.version];
            if (V === void 0) throw Error(`Invalid UUID version: "${z.version}"`);
            z.pattern ?? (z.pattern = Z7(V))
        } else z.pattern ?? (z.pattern = Z7());
        S0.init(v, z)
    }),
    Mj = Y("$ZodEmail", (v, z) => {
        z.pattern ?? (z.pattern = PA), S0.init(v, z)
    }),
    bj = Y("$ZodURL", (v, z) => {
        S0.init(v, z), v._zod.check = (U) => {
            try {
                let V = U.value,
                    N = new URL(V),
                    K = N.href;
                if (z.hostname) {
                    if (z.hostname.lastIndex = 0, !z.hostname.test(N.hostname)) U.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid hostname",
                        pattern: yA.source,
                        input: U.value,
                        inst: v,
                        continue: !z.abort
                    })
                }
                if (z.protocol) {
                    if (z.protocol.lastIndex = 0, !z.protocol.test(N.protocol.endsWith(":") ? N.protocol.slice(0, -1) : N.protocol)) U.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid protocol",
                        pattern: z.protocol.source,
                        input: U.value,
                        inst: v,
                        continue: !z.abort
                    })
                }
                if (!V.endsWith("/") && K.endsWith("/")) U.value = K.slice(0, -1);
                else U.value = K;
                return
            } catch (V) {
                U.issues.push({
                    code: "invalid_format",
                    format: "url",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    }),
    Rj = Y("$ZodEmoji", (v, z) => {
        z.pattern ?? (z.pattern = _A()), S0.init(v, z)
    }),
    Wj = Y("$ZodNanoID", (v, z) => {
        z.pattern ?? (z.pattern = WA), S0.init(v, z)
    }),
    Ej = Y("$ZodCUID", (v, z) => {
        z.pattern ?? (z.pattern = GA), S0.init(v, z)
    }),
    Sj = Y("$ZodCUID2", (v, z) => {
        z.pattern ?? (z.pattern = IA), S0.init(v, z)
    }),
    Pj = Y("$ZodULID", (v, z) => {
        z.pattern ?? (z.pattern = MA), S0.init(v, z)
    }),
    _j = Y("$ZodXID", (v, z) => {
        z.pattern ?? (z.pattern = bA), S0.init(v, z)
    }),
    Cj = Y("$ZodKSUID", (v, z) => {
        z.pattern ?? (z.pattern = RA), S0.init(v, z)
    }),
    $$ = Y("$ZodISODateTime", (v, z) => {
        z.pattern ?? (z.pattern = gA(z)), S0.init(v, z)
    }),
    w$ = Y("$ZodISODate", (v, z) => {
        z.pattern ?? (z.pattern = mA), S0.init(v, z)
    }),
    Z$ = Y("$ZodISOTime", (v, z) => {
        z.pattern ?? (z.pattern = XA(z)), S0.init(v, z)
    }),
    L$ = Y("$ZodISODuration", (v, z) => {
        z.pattern ?? (z.pattern = EA), S0.init(v, z)
    }),
    fj = Y("$ZodIPv4", (v, z) => {
        z.pattern ?? (z.pattern = CA), S0.init(v, z), v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.format = "ipv4"
        })
    }),
    Tj = Y("$ZodIPv6", (v, z) => {
        z.pattern ?? (z.pattern = fA), S0.init(v, z), v._zod.onattach.push((U) => {
            let V = U._zod.bag;
            V.format = "ipv6"
        }), v._zod.check = (U) => {
            try {
                new URL(`http://[${U.value}]`)
            } catch {
                U.issues.push({
                    code: "invalid_format",
                    format: "ipv6",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    }),
    Yj = Y("$ZodCIDRv4", (v, z) => {
        z.pattern ?? (z.pattern = TA), S0.init(v, z)
    }),
    uj = Y("$ZodCIDRv6", (v, z) => {
        z.pattern ?? (z.pattern = YA), S0.init(v, z), v._zod.check = (U) => {
            let [V, N] = U.value.split("/");
            try {
                if (!N) throw Error();
                let K = Number(N);
                if (`${K}` !== N) throw Error();
                if (K < 0 || K > 128) throw Error();
                new URL(`http://[${V}]`)
            } catch {
                U.issues.push({
                    code: "invalid_format",
                    format: "cidrv6",
                    input: U.value,
                    inst: v,
                    continue: !z.abort
                })
            }
        }
    });

function F$(v) {
    if (v === "") return !0;
    if (v.length % 4 !== 0) return !1;
    try {
        return atob(v), !0
    } catch {
        return !1
    }
}
var yj = Y("$ZodBase64", (v, z) => {
    z.pattern ?? (z.pattern = uA), S0.init(v, z), v._zod.onattach.push((U) => {
        U._zod.bag.contentEncoding = "base64"
    }), v._zod.check = (U) => {
        if (F$(U.value)) return;
        U.issues.push({
            code: "invalid_format",
            format: "base64",
            input: U.value,
            inst: v,
            continue: !z.abort
        })
    }
});

function Ku(v) {
    if (!Aj.test(v)) return !1;
    let z = v.replace(/[-_]/g, (V) => V === "-" ? "+" : "/"),
        U = z.padEnd(Math.ceil(z.length / 4) * 4, "=");
    return F$(U)
}
var kj = Y("$ZodBase64URL", (v, z) => {
        z.pattern ?? (z.pattern = Aj), S0.init(v, z), v._zod.onattach.push((U) => {
            U._zod.bag.contentEncoding = "base64url"
        }), v._zod.check = (U) => {
            if (Ku(U.value)) return;
            U.issues.push({
                code: "invalid_format",
                format: "base64url",
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    mj = Y("$ZodE164", (v, z) => {
        z.pattern ?? (z.pattern = kA), S0.init(v, z)
    });

function xu(v, z = null) {
    try {
        let U = v.split(".");
        if (U.length !== 3) return !1;
        let [V] = U;
        if (!V) return !1;
        let N = JSON.parse(atob(V));
        if ("typ" in N && N?.typ !== "JWT") return !1;
        if (!N.alg) return !1;
        if (z && (!("alg" in N) || N.alg !== z)) return !1;
        return !0
    } catch {
        return !1
    }
}
var Xj = Y("$ZodJWT", (v, z) => {
        S0.init(v, z), v._zod.check = (U) => {
            if (xu(U.value, z.alg)) return;
            U.issues.push({
                code: "invalid_format",
                format: "jwt",
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    gj = Y("$ZodCustomStringFormat", (v, z) => {
        S0.init(v, z), v._zod.check = (U) => {
            if (z.fn(U.value)) return;
            U.issues.push({
                code: "invalid_format",
                format: z.format,
                input: U.value,
                inst: v,
                continue: !z.abort
            })
        }
    }),
    hU = Y("$ZodNumber", (v, z) => {
        i6.init(v, z), v._zod.pattern = v._zod.bag.pattern ?? hA, v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = Number(U.value)
            } catch (x) {}
            let N = U.value;
            if (typeof N === "number" && !Number.isNaN(N) && Number.isFinite(N)) return U;
            let K = typeof N === "number" ? Number.isNaN(N) ? "NaN" : !Number.isFinite(N) ? "Infinity" : void 0 : void 0;
            return U.issues.push({
                expected: "number",
                code: "invalid_type",
                input: N,
                inst: v,
                ...K ? {
                    received: K
                } : {}
            }), U
        }
    }),
    cj = Y("$ZodNumber", (v, z) => {
        aA.init(v, z), hU.init(v, z)
    }),
    x1 = Y("$ZodBoolean", (v, z) => {
        i6.init(v, z), v._zod.pattern = pA, v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = Boolean(U.value)
            } catch (K) {}
            let N = U.value;
            if (typeof N === "boolean") return U;
            return U.issues.push({
                expected: "boolean",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    pU = Y("$ZodBigInt", (v, z) => {
        i6.init(v, z), v._zod.pattern = iA, v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = BigInt(U.value)
            } catch (N) {}
            if (typeof U.value === "bigint") return U;
            return U.issues.push({
                expected: "bigint",
                code: "invalid_type",
                input: U.value,
                inst: v
            }), U
        }
    }),
    ij = Y("$ZodBigInt", (v, z) => {
        tA.init(v, z), pU.init(v, z)
    }),
    lj = Y("$ZodSymbol", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (typeof N === "symbol") return U;
            return U.issues.push({
                expected: "symbol",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    hj = Y("$ZodUndefined", (v, z) => {
        i6.init(v, z), v._zod.pattern = QA, v._zod.values = new Set([void 0]), v._zod.optin = "optional", v._zod.optout = "optional", v._zod.parse = (U, V) => {
            let N = U.value;
            if (typeof N > "u") return U;
            return U.issues.push({
                expected: "undefined",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    pj = Y("$ZodNull", (v, z) => {
        i6.init(v, z), v._zod.pattern = nA, v._zod.values = new Set([null]), v._zod.parse = (U, V) => {
            let N = U.value;
            if (N === null) return U;
            return U.issues.push({
                expected: "null",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    nj = Y("$ZodAny", (v, z) => {
        i6.init(v, z), v._zod.parse = (U) => U
    }),
    L7 = Y("$ZodUnknown", (v, z) => {
        i6.init(v, z), v._zod.parse = (U) => U
    }),
    Qj = Y("$ZodNever", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            return U.issues.push({
                expected: "never",
                code: "invalid_type",
                input: U.value,
                inst: v
            }), U
        }
    }),
    dj = Y("$ZodVoid", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (typeof N > "u") return U;
            return U.issues.push({
                expected: "void",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    oj = Y("$ZodDate", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            if (z.coerce) try {
                U.value = new Date(U.value)
            } catch (j) {}
            let N = U.value,
                K = N instanceof Date;
            if (K && !Number.isNaN(N.getTime())) return U;
            return U.issues.push({
                expected: "date",
                code: "invalid_type",
                input: N,
                ...K ? {
                    received: "Invalid Date"
                } : {},
                inst: v
            }), U
        }
    });

function oY(v, z, U) {
    if (v.issues.length) z.issues.push(...L3(U, v.issues));
    z.value[U] = v.value
}
var j1 = Y("$ZodArray", (v, z) => {
    i6.init(v, z), v._zod.parse = (U, V) => {
        let N = U.value;
        if (!Array.isArray(N)) return U.issues.push({
            expected: "array",
            code: "invalid_type",
            input: N,
            inst: v
        }), U;
        U.value = Array(N.length);
        let K = [];
        for (let x = 0; x < N.length; x++) {
            let j = N[x],
                B = z.element._zod.run({
                    value: j,
                    issues: []
                }, V);
            if (B instanceof Promise) K.push(B.then((O) => oY(O, U, x)));
            else oY(B, U, x)
        }
        if (K.length) return Promise.all(K).then(() => U);
        return U
    }
});

function Lj(v, z, U) {
    if (v.issues.length) z.issues.push(...L3(U, v.issues));
    z.value[U] = v.value
}

function rY(v, z, U, V) {
    if (v.issues.length)
        if (V[U] === void 0)
            if (U in V) z.value[U] = void 0;
            else z.value[U] = v.value;
    else z.issues.push(...L3(U, v.issues));
    else if (v.value === void 0) {
        if (U in V) z.value[U] = void 0
    } else z.value[U] = v.value
}
var nU = Y("$ZodObject", (v, z) => {
    i6.init(v, z);
    let U = mU(() => {
        let q = Object.keys(z.shape);
        for (let D of q)
            if (!(z.shape[D] instanceof i6)) throw Error(`Invalid element at key "${D}": expected a Zod schema`);
        let H = wA(z.shape);
        return {
            shape: z.shape,
            keys: q,
            keySet: new Set(q),
            numKeys: q.length,
            optionalKeys: new Set(H)
        }
    });
    G0(v._zod, "propValues", () => {
        let q = z.shape,
            H = {};
        for (let D in q) {
            let A = q[D]._zod;
            if (A.values) {
                H[D] ?? (H[D] = new Set);
                for (let w of A.values) H[D].add(w)
            }
        }
        return H
    });
    let V = (q) => {
            let H = new Zj(["shape", "payload", "ctx"]),
                D = U.value,
                A = (F) => {
                    let L = D7(F);
                    return `shape[${L}]._zod.run({ value: input[${L}], issues: [] }, ctx)`
                };
            H.write("const input = payload.value;");
            let w = Object.create(null),
                Z = 0;
            for (let F of D.keys) w[F] = `key_${Z++}`;
            H.write("const newResult = {}");
            for (let F of D.keys)
                if (D.optionalKeys.has(F)) {
                    let L = w[F];
                    H.write(`const ${L} = ${A(F)};`);
                    let G = D7(F);
                    H.write(`
        if (${L}.issues.length) {
          if (input[${G}] === undefined) {
            if (${G} in input) {
              newResult[${G}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${L}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${G}, ...iss.path] : [${G}],
              }))
            );
          }
        } else if (${L}.value === undefined) {
          if (${G} in input) newResult[${G}] = undefined;
        } else {
          newResult[${G}] = ${L}.value;
        }
        `)
                } else {
                    let L = w[F];
                    H.write(`const ${L} = ${A(F)};`), H.write(`
          if (${L}.issues.length) payload.issues = payload.issues.concat(${L}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${D7(F)}, ...iss.path] : [${D7(F)}]
          })));`), H.write(`newResult[${D7(F)}] = ${L}.value`)
                } H.write("payload.value = newResult;"), H.write("return payload;");
            let $ = H.compile();
            return (F, L) => $(q, F, L)
        },
        N, K = v1,
        x = !uU.jitless,
        B = x && AA.value,
        O = z.catchall,
        J;
    v._zod.parse = (q, H) => {
        J ?? (J = U.value);
        let D = q.value;
        if (!K(D)) return q.issues.push({
            expected: "object",
            code: "invalid_type",
            input: D,
            inst: v
        }), q;
        let A = [];
        if (x && B && H?.async === !1 && H.jitless !== !0) {
            if (!N) N = V(z.shape);
            q = N(q, H)
        } else {
            q.value = {};
            let L = J.shape;
            for (let G of J.keys) {
                let I = L[G],
                    M = I._zod.run({
                        value: D[G],
                        issues: []
                    }, H),
                    b = I._zod.optin === "optional" && I._zod.optout === "optional";
                if (M instanceof Promise) A.push(M.then((W) => b ? rY(W, q, G, D) : Lj(W, q, G)));
                else if (b) rY(M, q, G, D);
                else Lj(M, q, G)
            }
        }
        if (!O) return A.length ? Promise.all(A).then(() => q) : q;
        let w = [],
            Z = J.keySet,
            $ = O._zod,
            F = $.def.type;
        for (let L of Object.keys(D)) {
            if (Z.has(L)) continue;
            if (F === "never") {
                w.push(L);
                continue
            }
            let G = $.run({
                value: D[L],
                issues: []
            }, H);
            if (G instanceof Promise) A.push(G.then((I) => Lj(I, q, L)));
            else Lj(G, q, L)
        }
        if (w.length) q.issues.push({
            code: "unrecognized_keys",
            keys: w,
            input: D,
            inst: v
        });
        if (!A.length) return q;
        return Promise.all(A).then(() => {
            return q
        })
    }
});

function aY(v, z, U, V) {
    for (let N of v)
        if (N.issues.length === 0) return z.value = N.value, z;
    return z.issues.push({
        code: "invalid_union",
        input: z.value,
        inst: U,
        errors: v.map((N) => N.issues.map((K) => u3(K, V, V4())))
    }), z
}
var QU = Y("$ZodUnion", (v, z) => {
        i6.init(v, z), G0(v._zod, "optin", () => z.options.some((U) => U._zod.optin === "optional") ? "optional" : void 0), G0(v._zod, "optout", () => z.options.some((U) => U._zod.optout === "optional") ? "optional" : void 0), G0(v._zod, "values", () => {
            if (z.options.every((U) => U._zod.values)) return new Set(z.options.flatMap((U) => Array.from(U._zod.values)));
            return
        }), G0(v._zod, "pattern", () => {
            if (z.options.every((U) => U._zod.pattern)) {
                let U = z.options.map((V) => V._zod.pattern);
                return new RegExp(`^(${U.map((V)=>XU(V.source)).join("|")})$`)
            }
            return
        }), v._zod.parse = (U, V) => {
            let N = !1,
                K = [];
            for (let x of z.options) {
                let j = x._zod.run({
                    value: U.value,
                    issues: []
                }, V);
                if (j instanceof Promise) K.push(j), N = !0;
                else {
                    if (j.issues.length === 0) return j;
                    K.push(j)
                }
            }
            if (!N) return aY(K, U, v, V);
            return Promise.all(K).then((x) => {
                return aY(x, U, v, V)
            })
        }
    }),
    rj = Y("$ZodDiscriminatedUnion", (v, z) => {
        QU.init(v, z);
        let U = v._zod.parse;
        G0(v._zod, "propValues", () => {
            let N = {};
            for (let K of z.options) {
                let x = K._zod.propValues;
                if (!x || Object.keys(x).length === 0) throw Error(`Invalid discriminated union option at index "${z.options.indexOf(K)}"`);
                for (let [j, B] of Object.entries(x)) {
                    if (!N[j]) N[j] = new Set;
                    for (let O of B) N[j].add(O)
                }
            }
            return N
        });
        let V = mU(() => {
            let N = z.options,
                K = new Map;
            for (let x of N) {
                let j = x._zod.propValues[z.discriminator];
                if (!j || j.size === 0) throw Error(`Invalid discriminated union option at index "${z.options.indexOf(x)}"`);
                for (let B of j) {
                    if (K.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
                    K.set(B, x)
                }
            }
            return K
        });
        v._zod.parse = (N, K) => {
            let x = N.value;
            if (!v1(x)) return N.issues.push({
                code: "invalid_type",
                expected: "object",
                input: x,
                inst: v
            }), N;
            let j = V.value.get(x?.[z.discriminator]);
            if (j) return j._zod.run(N, K);
            if (z.unionFallback) return U(N, K);
            return N.issues.push({
                code: "invalid_union",
                errors: [],
                note: "No matching discriminator",
                input: x,
                path: [z.discriminator],
                inst: v
            }), N
        }
    }),
    aj = Y("$ZodIntersection", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value,
                K = z.left._zod.run({
                    value: N,
                    issues: []
                }, V),
                x = z.right._zod.run({
                    value: N,
                    issues: []
                }, V);
            if (K instanceof Promise || x instanceof Promise) return Promise.all([K, x]).then(([B, O]) => {
                return tY(U, B, O)
            });
            return tY(U, K, x)
        }
    });

function A$(v, z) {
    if (v === z) return {
        valid: !0,
        data: v
    };
    if (v instanceof Date && z instanceof Date && +v === +z) return {
        valid: !0,
        data: v
    };
    if (z1(v) && z1(z)) {
        let U = Object.keys(z),
            V = Object.keys(v).filter((K) => U.indexOf(K) !== -1),
            N = {
                ...v,
                ...z
            };
        for (let K of V) {
            let x = A$(v[K], z[K]);
            if (!x.valid) return {
                valid: !1,
                mergeErrorPath: [K, ...x.mergeErrorPath]
            };
            N[K] = x.data
        }
        return {
            valid: !0,
            data: N
        }
    }
    if (Array.isArray(v) && Array.isArray(z)) {
        if (v.length !== z.length) return {
            valid: !1,
            mergeErrorPath: []
        };
        let U = [];
        for (let V = 0; V < v.length; V++) {
            let N = v[V],
                K = z[V],
                x = A$(N, K);
            if (!x.valid) return {
                valid: !1,
                mergeErrorPath: [V, ...x.mergeErrorPath]
            };
            U.push(x.data)
        }
        return {
            valid: !0,
            data: U
        }
    }
    return {
        valid: !1,
        mergeErrorPath: []
    }
}

function tY(v, z, U) {
    if (z.issues.length) v.issues.push(...z.issues);
    if (U.issues.length) v.issues.push(...U.issues);
    if (A7(v)) return v;
    let V = A$(z.value, U.value);
    if (!V.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(V.mergeErrorPath)}`);
    return v.value = V.data, v
}
var L5 = Y("$ZodTuple", (v, z) => {
    i6.init(v, z);
    let U = z.items,
        V = U.length - [...U].reverse().findIndex((N) => N._zod.optin !== "optional");
    v._zod.parse = (N, K) => {
        let x = N.value;
        if (!Array.isArray(x)) return N.issues.push({
            input: x,
            inst: v,
            expected: "tuple",
            code: "invalid_type"
        }), N;
        N.value = [];
        let j = [];
        if (!z.rest) {
            let O = x.length > U.length,
                J = x.length < V - 1;
            if (O || J) return N.issues.push({
                input: x,
                inst: v,
                origin: "array",
                ...O ? {
                    code: "too_big",
                    maximum: U.length
                } : {
                    code: "too_small",
                    minimum: U.length
                }
            }), N
        }
        let B = -1;
        for (let O of U) {
            if (B++, B >= x.length) {
                if (B >= V) continue
            }
            let J = O._zod.run({
                value: x[B],
                issues: []
            }, K);
            if (J instanceof Promise) j.push(J.then((q) => Fj(q, N, B)));
            else Fj(J, N, B)
        }
        if (z.rest) {
            let O = x.slice(U.length);
            for (let J of O) {
                B++;
                let q = z.rest._zod.run({
                    value: J,
                    issues: []
                }, K);
                if (q instanceof Promise) j.push(q.then((H) => Fj(H, N, B)));
                else Fj(q, N, B)
            }
        }
        if (j.length) return Promise.all(j).then(() => N);
        return N
    }
});

function Fj(v, z, U) {
    if (v.issues.length) z.issues.push(...L3(U, v.issues));
    z.value[U] = v.value
}
var tj = Y("$ZodRecord", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (!z1(N)) return U.issues.push({
                expected: "record",
                code: "invalid_type",
                input: N,
                inst: v
            }), U;
            let K = [];
            if (z.keyType._zod.values) {
                let x = z.keyType._zod.values;
                U.value = {};
                for (let B of x)
                    if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
                        let O = z.valueType._zod.run({
                            value: N[B],
                            issues: []
                        }, V);
                        if (O instanceof Promise) K.push(O.then((J) => {
                            if (J.issues.length) U.issues.push(...L3(B, J.issues));
                            U.value[B] = J.value
                        }));
                        else {
                            if (O.issues.length) U.issues.push(...L3(B, O.issues));
                            U.value[B] = O.value
                        }
                    } let j;
                for (let B in N)
                    if (!x.has(B)) j = j ?? [], j.push(B);
                if (j && j.length > 0) U.issues.push({
                    code: "unrecognized_keys",
                    input: N,
                    inst: v,
                    keys: j
                })
            } else {
                U.value = {};
                for (let x of Reflect.ownKeys(N)) {
                    if (x === "__proto__") continue;
                    let j = z.keyType._zod.run({
                        value: x,
                        issues: []
                    }, V);
                    if (j instanceof Promise) throw Error("Async schemas not supported in object keys currently");
                    if (j.issues.length) {
                        U.issues.push({
                            origin: "record",
                            code: "invalid_key",
                            issues: j.issues.map((O) => u3(O, V, V4())),
                            input: x,
                            path: [x],
                            inst: v
                        }), U.value[j.value] = j.value;
                        continue
                    }
                    let B = z.valueType._zod.run({
                        value: N[x],
                        issues: []
                    }, V);
                    if (B instanceof Promise) K.push(B.then((O) => {
                        if (O.issues.length) U.issues.push(...L3(x, O.issues));
                        U.value[j.value] = O.value
                    }));
                    else {
                        if (B.issues.length) U.issues.push(...L3(x, B.issues));
                        U.value[j.value] = B.value
                    }
                }
            }
            if (K.length) return Promise.all(K).then(() => U);
            return U
        }
    }),
    sj = Y("$ZodMap", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (!(N instanceof Map)) return U.issues.push({
                expected: "map",
                code: "invalid_type",
                input: N,
                inst: v
            }), U;
            let K = [];
            U.value = new Map;
            for (let [x, j] of N) {
                let B = z.keyType._zod.run({
                        value: x,
                        issues: []
                    }, V),
                    O = z.valueType._zod.run({
                        value: j,
                        issues: []
                    }, V);
                if (B instanceof Promise || O instanceof Promise) K.push(Promise.all([B, O]).then(([J, q]) => {
                    sY(J, q, U, x, N, v, V)
                }));
                else sY(B, O, U, x, N, v, V)
            }
            if (K.length) return Promise.all(K).then(() => U);
            return U
        }
    });

function sY(v, z, U, V, N, K, x) {
    if (v.issues.length)
        if (gU.has(typeof V)) U.issues.push(...L3(V, v.issues));
        else U.issues.push({
            origin: "map",
            code: "invalid_key",
            input: N,
            inst: K,
            issues: v.issues.map((j) => u3(j, x, V4()))
        });
    if (z.issues.length)
        if (gU.has(typeof V)) U.issues.push(...L3(V, z.issues));
        else U.issues.push({
            origin: "map",
            code: "invalid_element",
            input: N,
            inst: K,
            key: V,
            issues: z.issues.map((j) => u3(j, x, V4()))
        });
    U.value.set(v.value, z.value)
}
var ej = Y("$ZodSet", (v, z) => {
    i6.init(v, z), v._zod.parse = (U, V) => {
        let N = U.value;
        if (!(N instanceof Set)) return U.issues.push({
            input: N,
            inst: v,
            expected: "set",
            code: "invalid_type"
        }), U;
        let K = [];
        U.value = new Set;
        for (let x of N) {
            let j = z.valueType._zod.run({
                value: x,
                issues: []
            }, V);
            if (j instanceof Promise) K.push(j.then((B) => eY(B, U)));
            else eY(j, U)
        }
        if (K.length) return Promise.all(K).then(() => U);
        return U
    }
});

function eY(v, z) {
    if (v.issues.length) z.issues.push(...v.issues);
    z.value.add(v.value)
}
var vB = Y("$ZodEnum", (v, z) => {
        i6.init(v, z);
        let U = kU(z.entries);
        v._zod.values = new Set(U), v._zod.pattern = new RegExp(`^(${U.filter((V)=>gU.has(typeof V)).map((V)=>typeof V==="string"?b9(V):V.toString()).join("|")})$`), v._zod.parse = (V, N) => {
            let K = V.value;
            if (v._zod.values.has(K)) return V;
            return V.issues.push({
                code: "invalid_value",
                values: U,
                input: K,
                inst: v
            }), V
        }
    }),
    zB = Y("$ZodLiteral", (v, z) => {
        i6.init(v, z), v._zod.values = new Set(z.values), v._zod.pattern = new RegExp(`^(${z.values.map((U)=>typeof U==="string"?b9(U):U?U.toString():String(U)).join("|")})$`), v._zod.parse = (U, V) => {
            let N = U.value;
            if (v._zod.values.has(N)) return U;
            return U.issues.push({
                code: "invalid_value",
                values: z.values,
                input: N,
                inst: v
            }), U
        }
    }),
    UB = Y("$ZodFile", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = U.value;
            if (N instanceof File) return U;
            return U.issues.push({
                expected: "file",
                code: "invalid_type",
                input: N,
                inst: v
            }), U
        }
    }),
    B1 = Y("$ZodTransform", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = z.transform(U.value, U);
            if (V.async) return (N instanceof Promise ? N : Promise.resolve(N)).then((x) => {
                return U.value = x, U
            });
            if (N instanceof Promise) throw new M9;
            return U.value = N, U
        }
    }),
    VB = Y("$ZodOptional", (v, z) => {
        i6.init(v, z), v._zod.optin = "optional", v._zod.optout = "optional", G0(v._zod, "values", () => {
            return z.innerType._zod.values ? new Set([...z.innerType._zod.values, void 0]) : void 0
        }), G0(v._zod, "pattern", () => {
            let U = z.innerType._zod.pattern;
            return U ? new RegExp(`^(${XU(U.source)})?$`) : void 0
        }), v._zod.parse = (U, V) => {
            if (z.innerType._zod.optin === "optional") return z.innerType._zod.run(U, V);
            if (U.value === void 0) return U;
            return z.innerType._zod.run(U, V)
        }
    }),
    NB = Y("$ZodNullable", (v, z) => {
        i6.init(v, z), G0(v._zod, "optin", () => z.innerType._zod.optin), G0(v._zod, "optout", () => z.innerType._zod.optout), G0(v._zod, "pattern", () => {
            let U = z.innerType._zod.pattern;
            return U ? new RegExp(`^(${XU(U.source)}|null)$`) : void 0
        }), G0(v._zod, "values", () => {
            return z.innerType._zod.values ? new Set([...z.innerType._zod.values, null]) : void 0
        }), v._zod.parse = (U, V) => {
            if (U.value === null) return U;
            return z.innerType._zod.run(U, V)
        }
    }),
    KB = Y("$ZodDefault", (v, z) => {
        i6.init(v, z), v._zod.optin = "optional", G0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            if (U.value === void 0) return U.value = z.defaultValue, U;
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => vu(K, z));
            return vu(N, z)
        }
    });

function vu(v, z) {
    if (v.value === void 0) v.value = z.defaultValue;
    return v
}
var xB = Y("$ZodPrefault", (v, z) => {
        i6.init(v, z), v._zod.optin = "optional", G0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            if (U.value === void 0) U.value = z.defaultValue;
            return z.innerType._zod.run(U, V)
        }
    }),
    jB = Y("$ZodNonOptional", (v, z) => {
        i6.init(v, z), G0(v._zod, "values", () => {
            let U = z.innerType._zod.values;
            return U ? new Set([...U].filter((V) => V !== void 0)) : void 0
        }), v._zod.parse = (U, V) => {
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => zu(K, v));
            return zu(N, v)
        }
    });

function zu(v, z) {
    if (!v.issues.length && v.value === void 0) v.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: v.value,
        inst: z
    });
    return v
}
var BB = Y("$ZodSuccess", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => {
                return U.value = K.issues.length === 0, U
            });
            return U.value = N.issues.length === 0, U
        }
    }),
    OB = Y("$ZodCatch", (v, z) => {
        i6.init(v, z), v._zod.optin = "optional", G0(v._zod, "optout", () => z.innerType._zod.optout), G0(v._zod, "values", () => z.innerType._zod.values), v._zod.parse = (U, V) => {
            let N = z.innerType._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => {
                if (U.value = K.value, K.issues.length) U.value = z.catchValue({
                    ...U,
                    error: {
                        issues: K.issues.map((x) => u3(x, V, V4()))
                    },
                    input: U.value
                }), U.issues = [];
                return U
            });
            if (U.value = N.value, N.issues.length) U.value = z.catchValue({
                ...U,
                error: {
                    issues: N.issues.map((K) => u3(K, V, V4()))
                },
                input: U.value
            }), U.issues = [];
            return U
        }
    }),
    JB = Y("$ZodNaN", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            if (typeof U.value !== "number" || !Number.isNaN(U.value)) return U.issues.push({
                input: U.value,
                inst: v,
                expected: "nan",
                code: "invalid_type"
            }), U;
            return U
        }
    }),
    O1 = Y("$ZodPipe", (v, z) => {
        i6.init(v, z), G0(v._zod, "values", () => z.in._zod.values), G0(v._zod, "optin", () => z.in._zod.optin), G0(v._zod, "optout", () => z.out._zod.optout), v._zod.parse = (U, V) => {
            let N = z.in._zod.run(U, V);
            if (N instanceof Promise) return N.then((K) => Uu(K, z, V));
            return Uu(N, z, V)
        }
    });

function Uu(v, z, U) {
    if (A7(v)) return v;
    return z.out._zod.run({
        value: v.value,
        issues: v.issues
    }, U)
}
var qB = Y("$ZodReadonly", (v, z) => {
    i6.init(v, z), G0(v._zod, "propValues", () => z.innerType._zod.propValues), G0(v._zod, "values", () => z.innerType._zod.values), G0(v._zod, "optin", () => z.innerType._zod.optin), G0(v._zod, "optout", () => z.innerType._zod.optout), v._zod.parse = (U, V) => {
        let N = z.innerType._zod.run(U, V);
        if (N instanceof Promise) return N.then(Vu);
        return Vu(N)
    }
});

function Vu(v) {
    return v.value = Object.freeze(v.value), v
}
var HB = Y("$ZodTemplateLiteral", (v, z) => {
        i6.init(v, z);
        let U = [];
        for (let V of z.parts)
            if (V instanceof i6) {
                if (!V._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...V._zod.traits].shift()}`);
                let N = V._zod.pattern instanceof RegExp ? V._zod.pattern.source : V._zod.pattern;
                if (!N) throw Error(`Invalid template literal part: ${V._zod.traits}`);
                let K = N.startsWith("^") ? 1 : 0,
                    x = N.endsWith("$") ? N.length - 1 : N.length;
                U.push(N.slice(K, x))
            } else if (V === null || $A.has(typeof V)) U.push(b9(`${V}`));
        else throw Error(`Invalid template literal part: ${V}`);
        v._zod.pattern = new RegExp(`^${U.join("")}$`), v._zod.parse = (V, N) => {
            if (typeof V.value !== "string") return V.issues.push({
                input: V.value,
                inst: v,
                expected: "template_literal",
                code: "invalid_type"
            }), V;
            if (v._zod.pattern.lastIndex = 0, !v._zod.pattern.test(V.value)) return V.issues.push({
                input: V.value,
                inst: v,
                code: "invalid_format",
                format: "template_literal",
                pattern: v._zod.pattern.source
            }), V;
            return V
        }
    }),
    DB = Y("$ZodPromise", (v, z) => {
        i6.init(v, z), v._zod.parse = (U, V) => {
            return Promise.resolve(U.value).then((N) => z.innerType._zod.run({
                value: N,
                issues: []
            }, V))
        }
    }),
    AB = Y("$ZodLazy", (v, z) => {
        i6.init(v, z), G0(v._zod, "innerType", () => z.getter()), G0(v._zod, "pattern", () => v._zod.innerType._zod.pattern), G0(v._zod, "propValues", () => v._zod.innerType._zod.propValues), G0(v._zod, "optin", () => v._zod.innerType._zod.optin), G0(v._zod, "optout", () => v._zod.innerType._zod.optout), v._zod.parse = (U, V) => {
            return v._zod.innerType._zod.run(U, V)
        }
    }),
    $B = Y("$ZodCustom", (v, z) => {
        h0.init(v, z), i6.init(v, z), v._zod.parse = (U, V) => {
            return U
        }, v._zod.check = (U) => {
            let V = U.value,
                N = z.fn(V);
            if (N instanceof Promise) return N.then((K) => Nu(K, U, V, v));
            Nu(N, U, V, v);
            return
        }
    });

function Nu(v, z, U, V) {
    if (!v) {
        let N = {
            code: "custom",
            input: U,
            inst: V,
            path: [...V._zod.def.path ?? []],
            continue: !V._zod.def.abort
        };
        if (V._zod.def.params) N.params = V._zod.def.params;
        z.issues.push(FA(N))
    }
}
var J1 = {};
S8(J1, {
    zhTW: () => Vw,
    zhCN: () => Uw,
    vi: () => zw,
    ur: () => vw,
    ua: () => e$,
    tr: () => s$,
    th: () => t$,
    ta: () => a$,
    sv: () => r$,
    sl: () => o$,
    ru: () => d$,
    pt: () => Q$,
    ps: () => p$,
    pl: () => n$,
    ota: () => h$,
    no: () => l$,
    nl: () => i$,
    ms: () => c$,
    mk: () => g$,
    ko: () => X$,
    kh: () => m$,
    ja: () => k$,
    it: () => y$,
    id: () => u$,
    hu: () => Y$,
    he: () => T$,
    frCA: () => f$,
    fr: () => C$,
    fi: () => _$,
    fa: () => P$,
    es: () => S$,
    eo: () => E$,
    en: () => dU,
    de: () => W$,
    cs: () => R$,
    ca: () => b$,
    be: () => M$,
    az: () => I$,
    ar: () => G$
});
var ZV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: " "
        },
        file: {
            unit: "",
            verb: " "
        },
        array: {
            unit: "",
            verb: " "
        },
        set: {
            unit: "",
            verb: " "
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: " ",
            url: "",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "   ISO",
            date: "  ISO",
            time: "  ISO",
            duration: "  ISO",
            ipv4: " IPv4",
            ipv6: " IPv6",
            cidrv4: "   IPv4",
            cidrv6: "   IPv6",
            base64: "  base64-encoded",
            base64url: "  base64url-encoded",
            json_string: "   JSON",
            e164: "   E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `  :   ${N.expected}    ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `  :   ${K6(N.values[0])}`;
                return `  :     : ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `   :    ${N.origin??""} ${K} ${N.maximum.toString()} ${x.unit??""}`;
                return `  :    ${N.origin??""} ${K} ${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `  :   ${N.origin}   ${K} ${N.minimum.toString()} ${x.unit}`;
                return `  :   ${N.origin}   ${K} ${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `  :     "${N.prefix}"`;
                if (K.format === "ends_with") return `  :     "${K.suffix}"`;
                if (K.format === "includes") return `  :    "${K.includes}"`;
                if (K.format === "regex") return `  :     ${K.pattern}`;
                return `${V[K.format]??N.format}  `
            }
            case "not_multiple_of":
                return `  :      ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""} ${N.keys.length>1?"":""}: ${h(N.keys," ")}`;
            case "invalid_key":
                return `    ${N.origin}`;
            case "invalid_union":
                return "  ";
            case "invalid_element":
                return `    ${N.origin}`;
            default:
                return "  "
        }
    }
};

function G$() {
    return {
        localeError: ZV6()
    }
}
var LV6 = () => {
    let v = {
        string: {
            unit: "simvol",
            verb: "olmaldr"
        },
        file: {
            unit: "bayt",
            verb: "olmaldr"
        },
        array: {
            unit: "element",
            verb: "olmaldr"
        },
        set: {
            unit: "element",
            verb: "olmaldr"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "input",
            email: "email address",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO datetime",
            date: "ISO date",
            time: "ISO time",
            duration: "ISO duration",
            ipv4: "IPv4 address",
            ipv6: "IPv6 address",
            cidrv4: "IPv4 range",
            cidrv6: "IPv6 range",
            base64: "base64-encoded string",
            base64url: "base64url-encoded string",
            json_string: "JSON string",
            e164: "E.164 number",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Yanl dyr: gzlniln ${N.expected}, daxil olan ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Yanl dyr: gzlniln ${K6(N.values[0])}`;
                return `Yanl seim: aadaklardan biri olmaldr: ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `ox byk: gzlniln ${N.origin??"dyr"} ${K}${N.maximum.toString()} ${x.unit??"element"}`;
                return `ox byk: gzlniln ${N.origin??"dyr"} ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `ox kiik: gzlniln ${N.origin} ${K}${N.minimum.toString()} ${x.unit}`;
                return `ox kiik: gzlniln ${N.origin} ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Yanl mtn: "${K.prefix}" il balamaldr`;
                if (K.format === "ends_with") return `Yanl mtn: "${K.suffix}" il bitmlidir`;
                if (K.format === "includes") return `Yanl mtn: "${K.includes}" daxil olmaldr`;
                if (K.format === "regex") return `Yanl mtn: ${K.pattern} ablonuna uyun olmaldr`;
                return `Yanl ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Yanl dd: ${N.divisor} il bln biln olmaldr`;
            case "unrecognized_keys":
                return `Tannmayan aar${N.keys.length>1?"lar":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `${N.origin} daxilind yanl aar`;
            case "invalid_union":
                return "Yanl dyr";
            case "invalid_element":
                return `${N.origin} daxilind yanl dyr`;
            default:
                return "Yanl dyr"
        }
    }
};

function I$() {
    return {
        localeError: LV6()
    }
}

function Bu(v, z, U, V) {
    let N = Math.abs(v),
        K = N % 10,
        x = N % 100;
    if (x >= 11 && x <= 19) return V;
    if (K === 1) return z;
    if (K >= 2 && K <= 4) return U;
    return V
}
var FV6 = () => {
    let v = {
        string: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        array: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        set: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        file: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "email ",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO   ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "   base64",
            base64url: "   base64url",
            json_string: "JSON ",
            e164: " E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :  ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])}`;
                return ` :    ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) {
                    let j = Number(N.maximum),
                        B = Bu(j, x.unit.one, x.unit.few, x.unit.many);
                    return ` : ,  ${N.origin??""}  ${x.verb} ${K}${N.maximum.toString()} ${B}`
                }
                return ` : ,  ${N.origin??""}   ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) {
                    let j = Number(N.minimum),
                        B = Bu(j, x.unit.one, x.unit.few, x.unit.many);
                    return ` : ,  ${N.origin}  ${x.verb} ${K}${N.minimum.toString()} ${B}`
                }
                return ` : ,  ${N.origin}   ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :    "${K.prefix}"`;
                if (K.format === "ends_with") return ` :    "${K.suffix}"`;
                if (K.format === "includes") return ` :   "${K.includes}"`;
                if (K.format === "regex") return ` :    ${K.pattern}`;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` :    ${N.divisor}`;
            case "unrecognized_keys":
                return ` ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return " "
        }
    }
};

function M$() {
    return {
        localeError: FV6()
    }
}
var GV6 = () => {
    let v = {
        string: {
            unit: "carcters",
            verb: "contenir"
        },
        file: {
            unit: "bytes",
            verb: "contenir"
        },
        array: {
            unit: "elements",
            verb: "contenir"
        },
        set: {
            unit: "elements",
            verb: "contenir"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "entrada",
            email: "adrea electrnica",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "data i hora ISO",
            date: "data ISO",
            time: "hora ISO",
            duration: "durada ISO",
            ipv4: "adrea IPv4",
            ipv6: "adrea IPv6",
            cidrv4: "rang IPv4",
            cidrv6: "rang IPv6",
            base64: "cadena codificada en base64",
            base64url: "cadena codificada en base64url",
            json_string: "cadena JSON",
            e164: "nmero E.164",
            jwt: "JWT",
            template_literal: "entrada"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Tipus invlid: s'esperava ${N.expected}, s'ha rebut ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Valor invlid: s'esperava ${K6(N.values[0])}`;
                return `Opci invlida: s'esperava una de ${h(N.values," o ")}`;
            case "too_big": {
                let K = N.inclusive ? "com a mxim" : "menys de",
                    x = z(N.origin);
                if (x) return `Massa gran: s'esperava que ${N.origin??"el valor"} contingus ${K} ${N.maximum.toString()} ${x.unit??"elements"}`;
                return `Massa gran: s'esperava que ${N.origin??"el valor"} fos ${K} ${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? "com a mnim" : "ms de",
                    x = z(N.origin);
                if (x) return `Massa petit: s'esperava que ${N.origin} contingus ${K} ${N.minimum.toString()} ${x.unit}`;
                return `Massa petit: s'esperava que ${N.origin} fos ${K} ${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Format invlid: ha de comenar amb "${K.prefix}"`;
                if (K.format === "ends_with") return `Format invlid: ha d'acabar amb "${K.suffix}"`;
                if (K.format === "includes") return `Format invlid: ha d'incloure "${K.includes}"`;
                if (K.format === "regex") return `Format invlid: ha de coincidir amb el patr ${K.pattern}`;
                return `Format invlid per a ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Nmero invlid: ha de ser mltiple de ${N.divisor}`;
            case "unrecognized_keys":
                return `Clau${N.keys.length>1?"s":""} no reconeguda${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Clau invlida a ${N.origin}`;
            case "invalid_union":
                return "Entrada invlida";
            case "invalid_element":
                return `Element invlid a ${N.origin}`;
            default:
                return "Entrada invlida"
        }
    }
};

function b$() {
    return {
        localeError: GV6()
    }
}
var IV6 = () => {
    let v = {
        string: {
            unit: "znak",
            verb: "mt"
        },
        file: {
            unit: "bajt",
            verb: "mt"
        },
        array: {
            unit: "prvk",
            verb: "mt"
        },
        set: {
            unit: "prvk",
            verb: "mt"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "slo";
                case "string":
                    return "etzec";
                case "boolean":
                    return "boolean";
                case "bigint":
                    return "bigint";
                case "function":
                    return "funkce";
                case "symbol":
                    return "symbol";
                case "undefined":
                    return "undefined";
                case "object": {
                    if (Array.isArray(N)) return "pole";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "regulrn vraz",
            email: "e-mailov adresa",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "datum a as ve formtu ISO",
            date: "datum ve formtu ISO",
            time: "as ve formtu ISO",
            duration: "doba trvn ISO",
            ipv4: "IPv4 adresa",
            ipv6: "IPv6 adresa",
            cidrv4: "rozsah IPv4",
            cidrv6: "rozsah IPv6",
            base64: "etzec zakdovan ve formtu base64",
            base64url: "etzec zakdovan ve formtu base64url",
            json_string: "etzec ve formtu JSON",
            e164: "slo E.164",
            jwt: "JWT",
            template_literal: "vstup"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Neplatn vstup: oekvno ${N.expected}, obdreno ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Neplatn vstup: oekvno ${K6(N.values[0])}`;
                return `Neplatn monost: oekvna jedna z hodnot ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Hodnota je pli velk: ${N.origin??"hodnota"} mus mt ${K}${N.maximum.toString()} ${x.unit??"prvk"}`;
                return `Hodnota je pli velk: ${N.origin??"hodnota"} mus bt ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Hodnota je pli mal: ${N.origin??"hodnota"} mus mt ${K}${N.minimum.toString()} ${x.unit??"prvk"}`;
                return `Hodnota je pli mal: ${N.origin??"hodnota"} mus bt ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Neplatn etzec: mus zanat na "${K.prefix}"`;
                if (K.format === "ends_with") return `Neplatn etzec: mus konit na "${K.suffix}"`;
                if (K.format === "includes") return `Neplatn etzec: mus obsahovat "${K.includes}"`;
                if (K.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${K.pattern}`;
                return `Neplatn formt ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Neplatn slo: mus bt nsobkem ${N.divisor}`;
            case "unrecognized_keys":
                return `Neznm kle: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Neplatn kl v ${N.origin}`;
            case "invalid_union":
                return "Neplatn vstup";
            case "invalid_element":
                return `Neplatn hodnota v ${N.origin}`;
            default:
                return "Neplatn vstup"
        }
    }
};

function R$() {
    return {
        localeError: IV6()
    }
}
var MV6 = () => {
    let v = {
        string: {
            unit: "Zeichen",
            verb: "zu haben"
        },
        file: {
            unit: "Bytes",
            verb: "zu haben"
        },
        array: {
            unit: "Elemente",
            verb: "zu haben"
        },
        set: {
            unit: "Elemente",
            verb: "zu haben"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "Zahl";
                case "object": {
                    if (Array.isArray(N)) return "Array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "Eingabe",
            email: "E-Mail-Adresse",
            url: "URL",
            emoji: "Emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO-Datum und -Uhrzeit",
            date: "ISO-Datum",
            time: "ISO-Uhrzeit",
            duration: "ISO-Dauer",
            ipv4: "IPv4-Adresse",
            ipv6: "IPv6-Adresse",
            cidrv4: "IPv4-Bereich",
            cidrv6: "IPv6-Bereich",
            base64: "Base64-codierter String",
            base64url: "Base64-URL-codierter String",
            json_string: "JSON-String",
            e164: "E.164-Nummer",
            jwt: "JWT",
            template_literal: "Eingabe"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Ungltige Eingabe: erwartet ${N.expected}, erhalten ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Ungltige Eingabe: erwartet ${K6(N.values[0])}`;
                return `Ungltige Option: erwartet eine von ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Zu gro: erwartet, dass ${N.origin??"Wert"} ${K}${N.maximum.toString()} ${x.unit??"Elemente"} hat`;
                return `Zu gro: erwartet, dass ${N.origin??"Wert"} ${K}${N.maximum.toString()} ist`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Zu klein: erwartet, dass ${N.origin} ${K}${N.minimum.toString()} ${x.unit} hat`;
                return `Zu klein: erwartet, dass ${N.origin} ${K}${N.minimum.toString()} ist`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Ungltiger String: muss mit "${K.prefix}" beginnen`;
                if (K.format === "ends_with") return `Ungltiger String: muss mit "${K.suffix}" enden`;
                if (K.format === "includes") return `Ungltiger String: muss "${K.includes}" enthalten`;
                if (K.format === "regex") return `Ungltiger String: muss dem Muster ${K.pattern} entsprechen`;
                return `Ungltig: ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Ungltige Zahl: muss ein Vielfaches von ${N.divisor} sein`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"Unbekannte Schlssel":"Unbekannter Schlssel"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Ungltiger Schlssel in ${N.origin}`;
            case "invalid_union":
                return "Ungltige Eingabe";
            case "invalid_element":
                return `Ungltiger Wert in ${N.origin}`;
            default:
                return "Ungltige Eingabe"
        }
    }
};

function W$() {
    return {
        localeError: MV6()
    }
}
var bV6 = (v) => {
        let z = typeof v;
        switch (z) {
            case "number":
                return Number.isNaN(v) ? "NaN" : "number";
            case "object": {
                if (Array.isArray(v)) return "array";
                if (v === null) return "null";
                if (Object.getPrototypeOf(v) !== Object.prototype && v.constructor) return v.constructor.name
            }
        }
        return z
    },
    RV6 = () => {
        let v = {
            string: {
                unit: "characters",
                verb: "to have"
            },
            file: {
                unit: "bytes",
                verb: "to have"
            },
            array: {
                unit: "items",
                verb: "to have"
            },
            set: {
                unit: "items",
                verb: "to have"
            }
        };

        function z(V) {
            return v[V] ?? null
        }
        let U = {
            regex: "input",
            email: "email address",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO datetime",
            date: "ISO date",
            time: "ISO time",
            duration: "ISO duration",
            ipv4: "IPv4 address",
            ipv6: "IPv6 address",
            cidrv4: "IPv4 range",
            cidrv6: "IPv6 range",
            base64: "base64-encoded string",
            base64url: "base64url-encoded string",
            json_string: "JSON string",
            e164: "E.164 number",
            jwt: "JWT",
            template_literal: "input"
        };
        return (V) => {
            switch (V.code) {
                case "invalid_type":
                    return `Invalid input: expected ${V.expected}, received ${bV6(V.input)}`;
                case "invalid_value":
                    if (V.values.length === 1) return `Invalid input: expected ${K6(V.values[0])}`;
                    return `Invalid option: expected one of ${h(V.values,"|")}`;
                case "too_big": {
                    let N = V.inclusive ? "<=" : "<",
                        K = z(V.origin);
                    if (K) return `Too big: expected ${V.origin??"value"} to have ${N}${V.maximum.toString()} ${K.unit??"elements"}`;
                    return `Too big: expected ${V.origin??"value"} to be ${N}${V.maximum.toString()}`
                }
                case "too_small": {
                    let N = V.inclusive ? ">=" : ">",
                        K = z(V.origin);
                    if (K) return `Too small: expected ${V.origin} to have ${N}${V.minimum.toString()} ${K.unit}`;
                    return `Too small: expected ${V.origin} to be ${N}${V.minimum.toString()}`
                }
                case "invalid_format": {
                    let N = V;
                    if (N.format === "starts_with") return `Invalid string: must start with "${N.prefix}"`;
                    if (N.format === "ends_with") return `Invalid string: must end with "${N.suffix}"`;
                    if (N.format === "includes") return `Invalid string: must include "${N.includes}"`;
                    if (N.format === "regex") return `Invalid string: must match pattern ${N.pattern}`;
                    return `Invalid ${U[N.format]??V.format}`
                }
                case "not_multiple_of":
                    return `Invalid number: must be a multiple of ${V.divisor}`;
                case "unrecognized_keys":
                    return `Unrecognized key${V.keys.length>1?"s":""}: ${h(V.keys,", ")}`;
                case "invalid_key":
                    return `Invalid key in ${V.origin}`;
                case "invalid_union":
                    return "Invalid input";
                case "invalid_element":
                    return `Invalid value in ${V.origin}`;
                default:
                    return "Invalid input"
            }
        }
    };

function dU() {
    return {
        localeError: RV6()
    }
}
var WV6 = (v) => {
        let z = typeof v;
        switch (z) {
            case "number":
                return Number.isNaN(v) ? "NaN" : "nombro";
            case "object": {
                if (Array.isArray(v)) return "tabelo";
                if (v === null) return "senvalora";
                if (Object.getPrototypeOf(v) !== Object.prototype && v.constructor) return v.constructor.name
            }
        }
        return z
    },
    EV6 = () => {
        let v = {
            string: {
                unit: "karaktrojn",
                verb: "havi"
            },
            file: {
                unit: "bajtojn",
                verb: "havi"
            },
            array: {
                unit: "elementojn",
                verb: "havi"
            },
            set: {
                unit: "elementojn",
                verb: "havi"
            }
        };

        function z(V) {
            return v[V] ?? null
        }
        let U = {
            regex: "enigo",
            email: "retadreso",
            url: "URL",
            emoji: "emoio",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO-datotempo",
            date: "ISO-dato",
            time: "ISO-tempo",
            duration: "ISO-daro",
            ipv4: "IPv4-adreso",
            ipv6: "IPv6-adreso",
            cidrv4: "IPv4-rango",
            cidrv6: "IPv6-rango",
            base64: "64-ume kodita karaktraro",
            base64url: "URL-64-ume kodita karaktraro",
            json_string: "JSON-karaktraro",
            e164: "E.164-nombro",
            jwt: "JWT",
            template_literal: "enigo"
        };
        return (V) => {
            switch (V.code) {
                case "invalid_type":
                    return `Nevalida enigo: atendiis ${V.expected}, riceviis ${WV6(V.input)}`;
                case "invalid_value":
                    if (V.values.length === 1) return `Nevalida enigo: atendiis ${K6(V.values[0])}`;
                    return `Nevalida opcio: atendiis unu el ${h(V.values,"|")}`;
                case "too_big": {
                    let N = V.inclusive ? "<=" : "<",
                        K = z(V.origin);
                    if (K) return `Tro granda: atendiis ke ${V.origin??"valoro"} havu ${N}${V.maximum.toString()} ${K.unit??"elementojn"}`;
                    return `Tro granda: atendiis ke ${V.origin??"valoro"} havu ${N}${V.maximum.toString()}`
                }
                case "too_small": {
                    let N = V.inclusive ? ">=" : ">",
                        K = z(V.origin);
                    if (K) return `Tro malgranda: atendiis ke ${V.origin} havu ${N}${V.minimum.toString()} ${K.unit}`;
                    return `Tro malgranda: atendiis ke ${V.origin} estu ${N}${V.minimum.toString()}`
                }
                case "invalid_format": {
                    let N = V;
                    if (N.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${N.prefix}"`;
                    if (N.format === "ends_with") return `Nevalida karaktraro: devas finii per "${N.suffix}"`;
                    if (N.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${N.includes}"`;
                    if (N.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${N.pattern}`;
                    return `Nevalida ${U[N.format]??V.format}`
                }
                case "not_multiple_of":
                    return `Nevalida nombro: devas esti oblo de ${V.divisor}`;
                case "unrecognized_keys":
                    return `Nekonata${V.keys.length>1?"j":""} losilo${V.keys.length>1?"j":""}: ${h(V.keys,", ")}`;
                case "invalid_key":
                    return `Nevalida losilo en ${V.origin}`;
                case "invalid_union":
                    return "Nevalida enigo";
                case "invalid_element":
                    return `Nevalida valoro en ${V.origin}`;
                default:
                    return "Nevalida enigo"
            }
        }
    };

function E$() {
    return {
        localeError: EV6()
    }
}
var SV6 = () => {
    let v = {
        string: {
            unit: "caracteres",
            verb: "tener"
        },
        file: {
            unit: "bytes",
            verb: "tener"
        },
        array: {
            unit: "elementos",
            verb: "tener"
        },
        set: {
            unit: "elementos",
            verb: "tener"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "nmero";
                case "object": {
                    if (Array.isArray(N)) return "arreglo";
                    if (N === null) return "nulo";
                    if (Object.getPrototypeOf(N) !== Object.prototype) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "entrada",
            email: "direccin de correo electrnico",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "fecha y hora ISO",
            date: "fecha ISO",
            time: "hora ISO",
            duration: "duracin ISO",
            ipv4: "direccin IPv4",
            ipv6: "direccin IPv6",
            cidrv4: "rango IPv4",
            cidrv6: "rango IPv6",
            base64: "cadena codificada en base64",
            base64url: "URL codificada en base64",
            json_string: "cadena JSON",
            e164: "nmero E.164",
            jwt: "JWT",
            template_literal: "entrada"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Entrada invlida: se esperaba ${N.expected}, recibido ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Entrada invlida: se esperaba ${K6(N.values[0])}`;
                return `Opcin invlida: se esperaba una de ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Demasiado grande: se esperaba que ${N.origin??"valor"} tuviera ${K}${N.maximum.toString()} ${x.unit??"elementos"}`;
                return `Demasiado grande: se esperaba que ${N.origin??"valor"} fuera ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Demasiado pequeo: se esperaba que ${N.origin} tuviera ${K}${N.minimum.toString()} ${x.unit}`;
                return `Demasiado pequeo: se esperaba que ${N.origin} fuera ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Cadena invlida: debe comenzar con "${K.prefix}"`;
                if (K.format === "ends_with") return `Cadena invlida: debe terminar en "${K.suffix}"`;
                if (K.format === "includes") return `Cadena invlida: debe incluir "${K.includes}"`;
                if (K.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${K.pattern}`;
                return `Invlido ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Nmero invlido: debe ser mltiplo de ${N.divisor}`;
            case "unrecognized_keys":
                return `Llave${N.keys.length>1?"s":""} desconocida${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Llave invlida en ${N.origin}`;
            case "invalid_union":
                return "Entrada invlida";
            case "invalid_element":
                return `Valor invlido en ${N.origin}`;
            default:
                return "Entrada invlida"
        }
    }
};

function S$() {
    return {
        localeError: SV6()
    }
}
var PV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: " "
        },
        file: {
            unit: "",
            verb: " "
        },
        array: {
            unit: "",
            verb: " "
        },
        set: {
            unit: "",
            verb: " "
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: " ",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "   ",
            date: " ",
            time: " ",
            duration: "  ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "base64-encoded ",
            base64url: "base64url-encoded ",
            json_string: "JSON ",
            e164: "E.164 ",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :  ${N.expected}  ${U(N.input)}  `;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])} `;
                return ` :    ${h(N.values,"|")} `;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` : ${N.origin??""}  ${K}${N.maximum.toString()} ${x.unit??""} `;
                return ` : ${N.origin??""}  ${K}${N.maximum.toString()} `
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` : ${N.origin}  ${K}${N.minimum.toString()} ${x.unit} `;
                return ` : ${N.origin}  ${K}${N.minimum.toString()} `
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :   "${K.prefix}"  `;
                if (K.format === "ends_with") return ` :   "${K.suffix}"  `;
                if (K.format === "includes") return ` :   "${K.includes}" `;
                if (K.format === "regex") return ` :    ${K.pattern}   `;
                return `${V[K.format]??N.format} `
            }
            case "not_multiple_of":
                return ` :   ${N.divisor} `;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""} : ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return " "
        }
    }
};

function P$() {
    return {
        localeError: PV6()
    }
}
var _V6 = () => {
    let v = {
        string: {
            unit: "merkki",
            subject: "merkkijonon"
        },
        file: {
            unit: "tavua",
            subject: "tiedoston"
        },
        array: {
            unit: "alkiota",
            subject: "listan"
        },
        set: {
            unit: "alkiota",
            subject: "joukon"
        },
        number: {
            unit: "",
            subject: "luvun"
        },
        bigint: {
            unit: "",
            subject: "suuren kokonaisluvun"
        },
        int: {
            unit: "",
            subject: "kokonaisluvun"
        },
        date: {
            unit: "",
            subject: "pivmrn"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "snnllinen lauseke",
            email: "shkpostiosoite",
            url: "URL-osoite",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO-aikaleima",
            date: "ISO-pivmr",
            time: "ISO-aika",
            duration: "ISO-kesto",
            ipv4: "IPv4-osoite",
            ipv6: "IPv6-osoite",
            cidrv4: "IPv4-alue",
            cidrv6: "IPv6-alue",
            base64: "base64-koodattu merkkijono",
            base64url: "base64url-koodattu merkkijono",
            json_string: "JSON-merkkijono",
            e164: "E.164-luku",
            jwt: "JWT",
            template_literal: "templaattimerkkijono"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Virheellinen tyyppi: odotettiin ${N.expected}, oli ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Virheellinen syte: tytyy olla ${K6(N.values[0])}`;
                return `Virheellinen valinta: tytyy olla yksi seuraavista: ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Liian suuri: ${x.subject} tytyy olla ${K}${N.maximum.toString()} ${x.unit}`.trim();
                return `Liian suuri: arvon tytyy olla ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Liian pieni: ${x.subject} tytyy olla ${K}${N.minimum.toString()} ${x.unit}`.trim();
                return `Liian pieni: arvon tytyy olla ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${K.prefix}"`;
                if (K.format === "ends_with") return `Virheellinen syte: tytyy loppua "${K.suffix}"`;
                if (K.format === "includes") return `Virheellinen syte: tytyy sislt "${K.includes}"`;
                if (K.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${K.pattern}`;
                return `Virheellinen ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Virheellinen luku: tytyy olla luvun ${N.divisor} monikerta`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"Tuntemattomat avaimet":"Tuntematon avain"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return "Virheellinen avain tietueessa";
            case "invalid_union":
                return "Virheellinen unioni";
            case "invalid_element":
                return "Virheellinen arvo joukossa";
            default:
                return "Virheellinen syte"
        }
    }
};

function _$() {
    return {
        localeError: _V6()
    }
}
var CV6 = () => {
    let v = {
        string: {
            unit: "caractres",
            verb: "avoir"
        },
        file: {
            unit: "octets",
            verb: "avoir"
        },
        array: {
            unit: "lments",
            verb: "avoir"
        },
        set: {
            unit: "lments",
            verb: "avoir"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "nombre";
                case "object": {
                    if (Array.isArray(N)) return "tableau";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "entre",
            email: "adresse e-mail",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "date et heure ISO",
            date: "date ISO",
            time: "heure ISO",
            duration: "dure ISO",
            ipv4: "adresse IPv4",
            ipv6: "adresse IPv6",
            cidrv4: "plage IPv4",
            cidrv6: "plage IPv6",
            base64: "chane encode en base64",
            base64url: "chane encode en base64url",
            json_string: "chane JSON",
            e164: "numro E.164",
            jwt: "JWT",
            template_literal: "entre"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Entre invalide : ${N.expected} attendu, ${U(N.input)} reu`;
            case "invalid_value":
                if (N.values.length === 1) return `Entre invalide : ${K6(N.values[0])} attendu`;
                return `Option invalide : une valeur parmi ${h(N.values,"|")} attendue`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Trop grand : ${N.origin??"valeur"} doit ${x.verb} ${K}${N.maximum.toString()} ${x.unit??"lment(s)"}`;
                return `Trop grand : ${N.origin??"valeur"} doit tre ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Trop petit : ${N.origin} doit ${x.verb} ${K}${N.minimum.toString()} ${x.unit}`;
                return `Trop petit : ${N.origin} doit tre ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Chane invalide : doit commencer par "${K.prefix}"`;
                if (K.format === "ends_with") return `Chane invalide : doit se terminer par "${K.suffix}"`;
                if (K.format === "includes") return `Chane invalide : doit inclure "${K.includes}"`;
                if (K.format === "regex") return `Chane invalide : doit correspondre au modle ${K.pattern}`;
                return `${V[K.format]??N.format} invalide`
            }
            case "not_multiple_of":
                return `Nombre invalide : doit tre un multiple de ${N.divisor}`;
            case "unrecognized_keys":
                return `Cl${N.keys.length>1?"s":""} non reconnue${N.keys.length>1?"s":""} : ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Cl invalide dans ${N.origin}`;
            case "invalid_union":
                return "Entre invalide";
            case "invalid_element":
                return `Valeur invalide dans ${N.origin}`;
            default:
                return "Entre invalide"
        }
    }
};

function C$() {
    return {
        localeError: CV6()
    }
}
var fV6 = () => {
    let v = {
        string: {
            unit: "caractres",
            verb: "avoir"
        },
        file: {
            unit: "octets",
            verb: "avoir"
        },
        array: {
            unit: "lments",
            verb: "avoir"
        },
        set: {
            unit: "lments",
            verb: "avoir"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "entre",
            email: "adresse courriel",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "date-heure ISO",
            date: "date ISO",
            time: "heure ISO",
            duration: "dure ISO",
            ipv4: "adresse IPv4",
            ipv6: "adresse IPv6",
            cidrv4: "plage IPv4",
            cidrv6: "plage IPv6",
            base64: "chane encode en base64",
            base64url: "chane encode en base64url",
            json_string: "chane JSON",
            e164: "numro E.164",
            jwt: "JWT",
            template_literal: "entre"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Entre invalide : attendu ${N.expected}, reu ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Entre invalide : attendu ${K6(N.values[0])}`;
                return `Option invalide : attendu l'une des valeurs suivantes ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "" : "<",
                    x = z(N.origin);
                if (x) return `Trop grand : attendu que ${N.origin??"la valeur"} ait ${K}${N.maximum.toString()} ${x.unit}`;
                return `Trop grand : attendu que ${N.origin??"la valeur"} soit ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? "" : ">",
                    x = z(N.origin);
                if (x) return `Trop petit : attendu que ${N.origin} ait ${K}${N.minimum.toString()} ${x.unit}`;
                return `Trop petit : attendu que ${N.origin} soit ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Chane invalide : doit commencer par "${K.prefix}"`;
                if (K.format === "ends_with") return `Chane invalide : doit se terminer par "${K.suffix}"`;
                if (K.format === "includes") return `Chane invalide : doit inclure "${K.includes}"`;
                if (K.format === "regex") return `Chane invalide : doit correspondre au motif ${K.pattern}`;
                return `${V[K.format]??N.format} invalide`
            }
            case "not_multiple_of":
                return `Nombre invalide : doit tre un multiple de ${N.divisor}`;
            case "unrecognized_keys":
                return `Cl${N.keys.length>1?"s":""} non reconnue${N.keys.length>1?"s":""} : ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Cl invalide dans ${N.origin}`;
            case "invalid_union":
                return "Entre invalide";
            case "invalid_element":
                return `Valeur invalide dans ${N.origin}`;
            default:
                return "Entre invalide"
        }
    }
};

function f$() {
    return {
        localeError: fV6()
    }
}
var TV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: " ",
            url: " ",
            emoji: "'",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "  ISO",
            date: " ISO",
            time: " ISO",
            duration: "  ISO",
            ipv4: " IPv4",
            ipv6: " IPv6",
            cidrv4: " IPv4",
            cidrv6: " IPv6",
            base64: "  64",
            base64url: "  64  ",
            json_string: " JSON",
            e164: " E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `  :  ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `  :  ${K6(N.values[0])}`;
                return `  :     ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` : ${N.origin??"value"}   ${K}${N.maximum.toString()} ${x.unit??"elements"}`;
                return ` : ${N.origin??"value"}   ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` : ${N.origin}   ${K}${N.minimum.toString()} ${x.unit}`;
                return ` : ${N.origin}   ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `  :   "${K.prefix}"`;
                if (K.format === "ends_with") return `  :    "${K.suffix}"`;
                if (K.format === "includes") return `  :   "${K.includes}"`;
                if (K.format === "regex") return `  :    ${K.pattern}`;
                return `${V[K.format]??N.format}  `
            }
            case "not_multiple_of":
                return `  :     ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""}  ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return "  ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return "  "
        }
    }
};

function T$() {
    return {
        localeError: TV6()
    }
}
var YV6 = () => {
    let v = {
        string: {
            unit: "karakter",
            verb: "legyen"
        },
        file: {
            unit: "byte",
            verb: "legyen"
        },
        array: {
            unit: "elem",
            verb: "legyen"
        },
        set: {
            unit: "elem",
            verb: "legyen"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "szm";
                case "object": {
                    if (Array.isArray(N)) return "tmb";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "bemenet",
            email: "email cm",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO idblyeg",
            date: "ISO dtum",
            time: "ISO id",
            duration: "ISO idintervallum",
            ipv4: "IPv4 cm",
            ipv6: "IPv6 cm",
            cidrv4: "IPv4 tartomny",
            cidrv6: "IPv6 tartomny",
            base64: "base64-kdolt string",
            base64url: "base64url-kdolt string",
            json_string: "JSON string",
            e164: "E.164 szm",
            jwt: "JWT",
            template_literal: "bemenet"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `rvnytelen bemenet: a vrt rtk ${N.expected}, a kapott rtk ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${K6(N.values[0])}`;
                return `rvnytelen opci: valamelyik rtk vrt ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Tl nagy: ${N.origin??"rtk"} mrete tl nagy ${K}${N.maximum.toString()} ${x.unit??"elem"}`;
                return `Tl nagy: a bemeneti rtk ${N.origin??"rtk"} tl nagy: ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Tl kicsi: a bemeneti rtk ${N.origin} mrete tl kicsi ${K}${N.minimum.toString()} ${x.unit}`;
                return `Tl kicsi: a bemeneti rtk ${N.origin} tl kicsi ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `rvnytelen string: "${K.prefix}" rtkkel kell kezddnie`;
                if (K.format === "ends_with") return `rvnytelen string: "${K.suffix}" rtkkel kell vgzdnie`;
                if (K.format === "includes") return `rvnytelen string: "${K.includes}" rtket kell tartalmaznia`;
                if (K.format === "regex") return `rvnytelen string: ${K.pattern} mintnak kell megfelelnie`;
                return `rvnytelen ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `rvnytelen szm: ${N.divisor} tbbszrsnek kell lennie`;
            case "unrecognized_keys":
                return `Ismeretlen kulcs${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `rvnytelen kulcs ${N.origin}`;
            case "invalid_union":
                return "rvnytelen bemenet";
            case "invalid_element":
                return `rvnytelen rtk: ${N.origin}`;
            default:
                return "rvnytelen bemenet"
        }
    }
};

function Y$() {
    return {
        localeError: YV6()
    }
}
var uV6 = () => {
    let v = {
        string: {
            unit: "karakter",
            verb: "memiliki"
        },
        file: {
            unit: "byte",
            verb: "memiliki"
        },
        array: {
            unit: "item",
            verb: "memiliki"
        },
        set: {
            unit: "item",
            verb: "memiliki"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "input",
            email: "alamat email",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "tanggal dan waktu format ISO",
            date: "tanggal format ISO",
            time: "jam format ISO",
            duration: "durasi format ISO",
            ipv4: "alamat IPv4",
            ipv6: "alamat IPv6",
            cidrv4: "rentang alamat IPv4",
            cidrv6: "rentang alamat IPv6",
            base64: "string dengan enkode base64",
            base64url: "string dengan enkode base64url",
            json_string: "string JSON",
            e164: "angka E.164",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Input tidak valid: diharapkan ${N.expected}, diterima ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Input tidak valid: diharapkan ${K6(N.values[0])}`;
                return `Pilihan tidak valid: diharapkan salah satu dari ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Terlalu besar: diharapkan ${N.origin??"value"} memiliki ${K}${N.maximum.toString()} ${x.unit??"elemen"}`;
                return `Terlalu besar: diharapkan ${N.origin??"value"} menjadi ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Terlalu kecil: diharapkan ${N.origin} memiliki ${K}${N.minimum.toString()} ${x.unit}`;
                return `Terlalu kecil: diharapkan ${N.origin} menjadi ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `String tidak valid: harus dimulai dengan "${K.prefix}"`;
                if (K.format === "ends_with") return `String tidak valid: harus berakhir dengan "${K.suffix}"`;
                if (K.format === "includes") return `String tidak valid: harus menyertakan "${K.includes}"`;
                if (K.format === "regex") return `String tidak valid: harus sesuai pola ${K.pattern}`;
                return `${V[K.format]??N.format} tidak valid`
            }
            case "not_multiple_of":
                return `Angka tidak valid: harus kelipatan dari ${N.divisor}`;
            case "unrecognized_keys":
                return `Kunci tidak dikenali ${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Kunci tidak valid di ${N.origin}`;
            case "invalid_union":
                return "Input tidak valid";
            case "invalid_element":
                return `Nilai tidak valid di ${N.origin}`;
            default:
                return "Input tidak valid"
        }
    }
};

function u$() {
    return {
        localeError: uV6()
    }
}
var yV6 = () => {
    let v = {
        string: {
            unit: "caratteri",
            verb: "avere"
        },
        file: {
            unit: "byte",
            verb: "avere"
        },
        array: {
            unit: "elementi",
            verb: "avere"
        },
        set: {
            unit: "elementi",
            verb: "avere"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "numero";
                case "object": {
                    if (Array.isArray(N)) return "vettore";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "input",
            email: "indirizzo email",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "data e ora ISO",
            date: "data ISO",
            time: "ora ISO",
            duration: "durata ISO",
            ipv4: "indirizzo IPv4",
            ipv6: "indirizzo IPv6",
            cidrv4: "intervallo IPv4",
            cidrv6: "intervallo IPv6",
            base64: "stringa codificata in base64",
            base64url: "URL codificata in base64",
            json_string: "stringa JSON",
            e164: "numero E.164",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Input non valido: atteso ${N.expected}, ricevuto ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Input non valido: atteso ${K6(N.values[0])}`;
                return `Opzione non valida: atteso uno tra ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Troppo grande: ${N.origin??"valore"} deve avere ${K}${N.maximum.toString()} ${x.unit??"elementi"}`;
                return `Troppo grande: ${N.origin??"valore"} deve essere ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Troppo piccolo: ${N.origin} deve avere ${K}${N.minimum.toString()} ${x.unit}`;
                return `Troppo piccolo: ${N.origin} deve essere ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Stringa non valida: deve iniziare con "${K.prefix}"`;
                if (K.format === "ends_with") return `Stringa non valida: deve terminare con "${K.suffix}"`;
                if (K.format === "includes") return `Stringa non valida: deve includere "${K.includes}"`;
                if (K.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${K.pattern}`;
                return `Invalid ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Numero non valido: deve essere un multiplo di ${N.divisor}`;
            case "unrecognized_keys":
                return `Chiav${N.keys.length>1?"i":"e"} non riconosciut${N.keys.length>1?"e":"a"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Chiave non valida in ${N.origin}`;
            case "invalid_union":
                return "Input non valido";
            case "invalid_element":
                return `Valore non valido in ${N.origin}`;
            default:
                return "Input non valido"
        }
    }
};

function y$() {
    return {
        localeError: yV6()
    }
}
var kV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO",
            date: "ISO",
            time: "ISO",
            duration: "ISO",
            ipv4: "IPv4",
            ipv6: "IPv6",
            cidrv4: "IPv4",
            cidrv6: "IPv6",
            base64: "base64",
            base64url: "base64url",
            json_string: "JSON",
            e164: "E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `: ${N.expected}${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `: ${K6(N.values[0])}`;
                return `: ${h(N.values,"")}`;
            case "too_big": {
                let K = N.inclusive ? "" : "",
                    x = z(N.origin);
                if (x) return `: ${N.origin??""}${N.maximum.toString()}${x.unit??""}${K}`;
                return `: ${N.origin??""}${N.maximum.toString()}${K}`
            }
            case "too_small": {
                let K = N.inclusive ? "" : "",
                    x = z(N.origin);
                if (x) return `: ${N.origin}${N.minimum.toString()}${x.unit}${K}`;
                return `: ${N.origin}${N.minimum.toString()}${K}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `: "${K.prefix}"`;
                if (K.format === "ends_with") return `: "${K.suffix}"`;
                if (K.format === "includes") return `: "${K.includes}"`;
                if (K.format === "regex") return `: ${K.pattern}`;
                return `${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `: ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""}: ${h(N.keys,"")}`;
            case "invalid_key":
                return `${N.origin}`;
            case "invalid_union":
                return "";
            case "invalid_element":
                return `${N.origin}`;
            default:
                return ""
        }
    }
};

function k$() {
    return {
        localeError: kV6()
    }
}
var mV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? " (NaN)" : "";
                case "object": {
                    if (Array.isArray(N)) return " (Array)";
                    if (N === null) return " (null)";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "  ISO",
            date: " ISO",
            time: " ISO",
            duration: " ISO",
            ipv4: " IPv4",
            ipv6: " IPv6",
            cidrv4: " IPv4",
            cidrv6: " IPv6",
            base64: " base64",
            base64url: " base64url",
            json_string: " JSON",
            e164: " E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `  ${N.expected}  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `  ${K6(N.values[0])}`;
                return `  ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `  ${N.origin??""} ${K} ${N.maximum.toString()} ${x.unit??""}`;
                return `  ${N.origin??""} ${K} ${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `  ${N.origin} ${K} ${N.minimum.toString()} ${x.unit}`;
                return `  ${N.origin} ${K} ${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `  "${K.prefix}"`;
                if (K.format === "ends_with") return `  "${K.suffix}"`;
                if (K.format === "includes") return `  "${K.includes}"`;
                if (K.format === "regex") return `  ${K.pattern}`;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `  ${N.divisor}`;
            case "unrecognized_keys":
                return ` ${h(N.keys,", ")}`;
            case "invalid_key":
                return ` ${N.origin}`;
            case "invalid_union":
                return "";
            case "invalid_element":
                return ` ${N.origin}`;
            default:
                return ""
        }
    }
};

function m$() {
    return {
        localeError: mV6()
    }
}
var XV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: "to have"
        },
        file: {
            unit: "",
            verb: "to have"
        },
        array: {
            unit: "",
            verb: "to have"
        },
        set: {
            unit: "",
            verb: "to have"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: " ",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "base64  ",
            base64url: "base64url  ",
            json_string: "JSON ",
            e164: "E.164 ",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :   ${N.expected},   ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])}  `;
                return ` : ${h(N.values," ")}   `;
            case "too_big": {
                let K = N.inclusive ? "" : "",
                    x = K === "" ? " " : " ",
                    j = z(N.origin),
                    B = j?.unit ?? "";
                if (j) return `${N.origin??""}  : ${N.maximum.toString()}${B} ${K}${x}`;
                return `${N.origin??""}  : ${N.maximum.toString()} ${K}${x}`
            }
            case "too_small": {
                let K = N.inclusive ? "" : "",
                    x = K === "" ? " " : " ",
                    j = z(N.origin),
                    B = j?.unit ?? "";
                if (j) return `${N.origin??""}  : ${N.minimum.toString()}${B} ${K}${x}`;
                return `${N.origin??""}  : ${N.minimum.toString()} ${K}${x}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` : "${K.prefix}"()  `;
                if (K.format === "ends_with") return ` : "${K.suffix}"()  `;
                if (K.format === "includes") return ` : "${K.includes}"()  `;
                if (K.format === "regex") return ` :  ${K.pattern}   `;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` : ${N.divisor}  `;
            case "unrecognized_keys":
                return `   : ${h(N.keys,", ")}`;
            case "invalid_key":
                return ` : ${N.origin}`;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return ` : ${N.origin}`;
            default:
                return " "
        }
    }
};

function X$() {
    return {
        localeError: XV6()
    }
}
var gV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: " "
        },
        file: {
            unit: "",
            verb: " "
        },
        array: {
            unit: "",
            verb: " "
        },
        set: {
            unit: "",
            verb: " "
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "  -",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO   ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "base64- ",
            base64url: "base64url- ",
            json_string: "JSON ",
            e164: "E.164 ",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :   ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Invalid input: expected ${K6(N.values[0])}`;
                return ` :    ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` :   ${N.origin??""}   ${K}${N.maximum.toString()} ${x.unit??""}`;
                return ` :   ${N.origin??""}   ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` :   ${N.origin}   ${K}${N.minimum.toString()} ${x.unit}`;
                return ` :   ${N.origin}   ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :     "${K.prefix}"`;
                if (K.format === "ends_with") return ` :     "${K.suffix}"`;
                if (K.format === "includes") return ` :    "${K.includes}"`;
                if (K.format === "regex") return ` :      ${K.pattern}`;
                return `Invalid ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` :      ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?" ":" "}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return " "
        }
    }
};

function g$() {
    return {
        localeError: gV6()
    }
}
var cV6 = () => {
    let v = {
        string: {
            unit: "aksara",
            verb: "mempunyai"
        },
        file: {
            unit: "bait",
            verb: "mempunyai"
        },
        array: {
            unit: "elemen",
            verb: "mempunyai"
        },
        set: {
            unit: "elemen",
            verb: "mempunyai"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "nombor";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "input",
            email: "alamat e-mel",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "tarikh masa ISO",
            date: "tarikh ISO",
            time: "masa ISO",
            duration: "tempoh ISO",
            ipv4: "alamat IPv4",
            ipv6: "alamat IPv6",
            cidrv4: "julat IPv4",
            cidrv6: "julat IPv6",
            base64: "string dikodkan base64",
            base64url: "string dikodkan base64url",
            json_string: "string JSON",
            e164: "nombor E.164",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Input tidak sah: dijangka ${N.expected}, diterima ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Input tidak sah: dijangka ${K6(N.values[0])}`;
                return `Pilihan tidak sah: dijangka salah satu daripada ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Terlalu besar: dijangka ${N.origin??"nilai"} ${x.verb} ${K}${N.maximum.toString()} ${x.unit??"elemen"}`;
                return `Terlalu besar: dijangka ${N.origin??"nilai"} adalah ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Terlalu kecil: dijangka ${N.origin} ${x.verb} ${K}${N.minimum.toString()} ${x.unit}`;
                return `Terlalu kecil: dijangka ${N.origin} adalah ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `String tidak sah: mesti bermula dengan "${K.prefix}"`;
                if (K.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${K.suffix}"`;
                if (K.format === "includes") return `String tidak sah: mesti mengandungi "${K.includes}"`;
                if (K.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${K.pattern}`;
                return `${V[K.format]??N.format} tidak sah`
            }
            case "not_multiple_of":
                return `Nombor tidak sah: perlu gandaan ${N.divisor}`;
            case "unrecognized_keys":
                return `Kunci tidak dikenali: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Kunci tidak sah dalam ${N.origin}`;
            case "invalid_union":
                return "Input tidak sah";
            case "invalid_element":
                return `Nilai tidak sah dalam ${N.origin}`;
            default:
                return "Input tidak sah"
        }
    }
};

function c$() {
    return {
        localeError: cV6()
    }
}
var iV6 = () => {
    let v = {
        string: {
            unit: "tekens"
        },
        file: {
            unit: "bytes"
        },
        array: {
            unit: "elementen"
        },
        set: {
            unit: "elementen"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "getal";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "invoer",
            email: "emailadres",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO datum en tijd",
            date: "ISO datum",
            time: "ISO tijd",
            duration: "ISO duur",
            ipv4: "IPv4-adres",
            ipv6: "IPv6-adres",
            cidrv4: "IPv4-bereik",
            cidrv6: "IPv6-bereik",
            base64: "base64-gecodeerde tekst",
            base64url: "base64 URL-gecodeerde tekst",
            json_string: "JSON string",
            e164: "E.164-nummer",
            jwt: "JWT",
            template_literal: "invoer"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Ongeldige invoer: verwacht ${N.expected}, ontving ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Ongeldige invoer: verwacht ${K6(N.values[0])}`;
                return `Ongeldige optie: verwacht n van ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Te lang: verwacht dat ${N.origin??"waarde"} ${K}${N.maximum.toString()} ${x.unit??"elementen"} bevat`;
                return `Te lang: verwacht dat ${N.origin??"waarde"} ${K}${N.maximum.toString()} is`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Te kort: verwacht dat ${N.origin} ${K}${N.minimum.toString()} ${x.unit} bevat`;
                return `Te kort: verwacht dat ${N.origin} ${K}${N.minimum.toString()} is`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Ongeldige tekst: moet met "${K.prefix}" beginnen`;
                if (K.format === "ends_with") return `Ongeldige tekst: moet op "${K.suffix}" eindigen`;
                if (K.format === "includes") return `Ongeldige tekst: moet "${K.includes}" bevatten`;
                if (K.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${K.pattern}`;
                return `Ongeldig: ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Ongeldig getal: moet een veelvoud van ${N.divisor} zijn`;
            case "unrecognized_keys":
                return `Onbekende key${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Ongeldige key in ${N.origin}`;
            case "invalid_union":
                return "Ongeldige invoer";
            case "invalid_element":
                return `Ongeldige waarde in ${N.origin}`;
            default:
                return "Ongeldige invoer"
        }
    }
};

function i$() {
    return {
        localeError: iV6()
    }
}
var lV6 = () => {
    let v = {
        string: {
            unit: "tegn",
            verb: " ha"
        },
        file: {
            unit: "bytes",
            verb: " ha"
        },
        array: {
            unit: "elementer",
            verb: " inneholde"
        },
        set: {
            unit: "elementer",
            verb: " inneholde"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "tall";
                case "object": {
                    if (Array.isArray(N)) return "liste";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "input",
            email: "e-postadresse",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO dato- og klokkeslett",
            date: "ISO-dato",
            time: "ISO-klokkeslett",
            duration: "ISO-varighet",
            ipv4: "IPv4-omrde",
            ipv6: "IPv6-omrde",
            cidrv4: "IPv4-spekter",
            cidrv6: "IPv6-spekter",
            base64: "base64-enkodet streng",
            base64url: "base64url-enkodet streng",
            json_string: "JSON-streng",
            e164: "E.164-nummer",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Ugyldig input: forventet ${N.expected}, fikk ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Ugyldig verdi: forventet ${K6(N.values[0])}`;
                return `Ugyldig valg: forventet en av ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `For stor(t): forventet ${N.origin??"value"} til  ha ${K}${N.maximum.toString()} ${x.unit??"elementer"}`;
                return `For stor(t): forventet ${N.origin??"value"} til  ha ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `For lite(n): forventet ${N.origin} til  ha ${K}${N.minimum.toString()} ${x.unit}`;
                return `For lite(n): forventet ${N.origin} til  ha ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Ugyldig streng: m starte med "${K.prefix}"`;
                if (K.format === "ends_with") return `Ugyldig streng: m ende med "${K.suffix}"`;
                if (K.format === "includes") return `Ugyldig streng: m inneholde "${K.includes}"`;
                if (K.format === "regex") return `Ugyldig streng: m matche mnsteret ${K.pattern}`;
                return `Ugyldig ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Ugyldig tall: m vre et multiplum av ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"Ukjente nkler":"Ukjent nkkel"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Ugyldig nkkel i ${N.origin}`;
            case "invalid_union":
                return "Ugyldig input";
            case "invalid_element":
                return `Ugyldig verdi i ${N.origin}`;
            default:
                return "Ugyldig input"
        }
    }
};

function l$() {
    return {
        localeError: lV6()
    }
}
var hV6 = () => {
    let v = {
        string: {
            unit: "harf",
            verb: "olmaldr"
        },
        file: {
            unit: "bayt",
            verb: "olmaldr"
        },
        array: {
            unit: "unsur",
            verb: "olmaldr"
        },
        set: {
            unit: "unsur",
            verb: "olmaldr"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "numara";
                case "object": {
                    if (Array.isArray(N)) return "saf";
                    if (N === null) return "gayb";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "giren",
            email: "epostagh",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO hengm",
            date: "ISO tarihi",
            time: "ISO zaman",
            duration: "ISO mddeti",
            ipv4: "IPv4 nin",
            ipv6: "IPv6 nin",
            cidrv4: "IPv4 menzili",
            cidrv6: "IPv6 menzili",
            base64: "base64-ifreli metin",
            base64url: "base64url-ifreli metin",
            json_string: "JSON metin",
            e164: "E.164 says",
            jwt: "JWT",
            template_literal: "giren"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Fsit giren: umulan ${N.expected}, alnan ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Fsit giren: umulan ${K6(N.values[0])}`;
                return `Fsit tercih: mteberler ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Fazla byk: ${N.origin??"value"}, ${K}${N.maximum.toString()} ${x.unit??"elements"} sahip olmalyd.`;
                return `Fazla byk: ${N.origin??"value"}, ${K}${N.maximum.toString()} olmalyd.`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Fazla kk: ${N.origin}, ${K}${N.minimum.toString()} ${x.unit} sahip olmalyd.`;
                return `Fazla kk: ${N.origin}, ${K}${N.minimum.toString()} olmalyd.`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Fsit metin: "${K.prefix}" ile balamal.`;
                if (K.format === "ends_with") return `Fsit metin: "${K.suffix}" ile bitmeli.`;
                if (K.format === "includes") return `Fsit metin: "${K.includes}" ihtiv etmeli.`;
                if (K.format === "regex") return `Fsit metin: ${K.pattern} nakna uymal.`;
                return `Fsit ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Fsit say: ${N.divisor} kat olmalyd.`;
            case "unrecognized_keys":
                return `Tannmayan anahtar ${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `${N.origin} iin tannmayan anahtar var.`;
            case "invalid_union":
                return "Giren tannamad.";
            case "invalid_element":
                return `${N.origin} iin tannmayan kymet var.`;
            default:
                return "Kymet tannamad."
        }
    }
};

function h$() {
    return {
        localeError: hV6()
    }
}
var pV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "  ",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "  ",
            date: "",
            time: "",
            duration: "",
            ipv4: " IPv4 ",
            ipv6: " IPv6 ",
            cidrv4: " IPv4 ",
            cidrv6: " IPv6 ",
            base64: "base64-encoded ",
            base64url: "base64url-encoded ",
            json_string: "JSON ",
            e164: " E.164 ",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :  ${N.expected} ,  ${U(N.input)}  `;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])} `;
                return ` :    ${h(N.values,"|")}  `;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` : ${N.origin??""}  ${K}${N.maximum.toString()} ${x.unit??""} `;
                return ` : ${N.origin??""}  ${K}${N.maximum.toString()} `
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` : ${N.origin}  ${K}${N.minimum.toString()} ${x.unit} `;
                return ` : ${N.origin}  ${K}${N.minimum.toString()} `
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :   "${K.prefix}"   `;
                if (K.format === "ends_with") return ` :   "${K.suffix}"    `;
                if (K.format === "includes") return ` :  "${K.includes}" `;
                if (K.format === "regex") return ` :   ${K.pattern}   `;
                return `${V[K.format]??N.format}  `
            }
            case "not_multiple_of":
                return ` :   ${N.divisor}  `;
            case "unrecognized_keys":
                return ` ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin} `;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return `   ${N.origin} `;
            default:
                return " "
        }
    }
};

function p$() {
    return {
        localeError: pV6()
    }
}
var nV6 = () => {
    let v = {
        string: {
            unit: "znakw",
            verb: "mie"
        },
        file: {
            unit: "bajtw",
            verb: "mie"
        },
        array: {
            unit: "elementw",
            verb: "mie"
        },
        set: {
            unit: "elementw",
            verb: "mie"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "liczba";
                case "object": {
                    if (Array.isArray(N)) return "tablica";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "wyraenie",
            email: "adres email",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "data i godzina w formacie ISO",
            date: "data w formacie ISO",
            time: "godzina w formacie ISO",
            duration: "czas trwania ISO",
            ipv4: "adres IPv4",
            ipv6: "adres IPv6",
            cidrv4: "zakres IPv4",
            cidrv6: "zakres IPv6",
            base64: "cig znakw zakodowany w formacie base64",
            base64url: "cig znakw zakodowany w formacie base64url",
            json_string: "cig znakw w formacie JSON",
            e164: "liczba E.164",
            jwt: "JWT",
            template_literal: "wejcie"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Nieprawidowe dane wejciowe: oczekiwano ${N.expected}, otrzymano ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${K6(N.values[0])}`;
                return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Za dua warto: oczekiwano, e ${N.origin??"warto"} bdzie mie ${K}${N.maximum.toString()} ${x.unit??"elementw"}`;
                return `Zbyt du(y/a/e): oczekiwano, e ${N.origin??"warto"} bdzie wynosi ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Za maa warto: oczekiwano, e ${N.origin??"warto"} bdzie mie ${K}${N.minimum.toString()} ${x.unit??"elementw"}`;
                return `Zbyt ma(y/a/e): oczekiwano, e ${N.origin??"warto"} bdzie wynosi ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${K.prefix}"`;
                if (K.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${K.suffix}"`;
                if (K.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${K.includes}"`;
                if (K.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${K.pattern}`;
                return `Nieprawidow(y/a/e) ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Nieprawidowa liczba: musi by wielokrotnoci ${N.divisor}`;
            case "unrecognized_keys":
                return `Nierozpoznane klucze${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Nieprawidowy klucz w ${N.origin}`;
            case "invalid_union":
                return "Nieprawidowe dane wejciowe";
            case "invalid_element":
                return `Nieprawidowa warto w ${N.origin}`;
            default:
                return "Nieprawidowe dane wejciowe"
        }
    }
};

function n$() {
    return {
        localeError: nV6()
    }
}
var QV6 = () => {
    let v = {
        string: {
            unit: "caracteres",
            verb: "ter"
        },
        file: {
            unit: "bytes",
            verb: "ter"
        },
        array: {
            unit: "itens",
            verb: "ter"
        },
        set: {
            unit: "itens",
            verb: "ter"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "nmero";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "nulo";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "padro",
            email: "endereo de e-mail",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "data e hora ISO",
            date: "data ISO",
            time: "hora ISO",
            duration: "durao ISO",
            ipv4: "endereo IPv4",
            ipv6: "endereo IPv6",
            cidrv4: "faixa de IPv4",
            cidrv6: "faixa de IPv6",
            base64: "texto codificado em base64",
            base64url: "URL codificada em base64",
            json_string: "texto JSON",
            e164: "nmero E.164",
            jwt: "JWT",
            template_literal: "entrada"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Tipo invlido: esperado ${N.expected}, recebido ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Entrada invlida: esperado ${K6(N.values[0])}`;
                return `Opo invlida: esperada uma das ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Muito grande: esperado que ${N.origin??"valor"} tivesse ${K}${N.maximum.toString()} ${x.unit??"elementos"}`;
                return `Muito grande: esperado que ${N.origin??"valor"} fosse ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Muito pequeno: esperado que ${N.origin} tivesse ${K}${N.minimum.toString()} ${x.unit}`;
                return `Muito pequeno: esperado que ${N.origin} fosse ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Texto invlido: deve comear com "${K.prefix}"`;
                if (K.format === "ends_with") return `Texto invlido: deve terminar com "${K.suffix}"`;
                if (K.format === "includes") return `Texto invlido: deve incluir "${K.includes}"`;
                if (K.format === "regex") return `Texto invlido: deve corresponder ao padro ${K.pattern}`;
                return `${V[K.format]??N.format} invlido`
            }
            case "not_multiple_of":
                return `Nmero invlido: deve ser mltiplo de ${N.divisor}`;
            case "unrecognized_keys":
                return `Chave${N.keys.length>1?"s":""} desconhecida${N.keys.length>1?"s":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Chave invlida em ${N.origin}`;
            case "invalid_union":
                return "Entrada invlida";
            case "invalid_element":
                return `Valor invlido em ${N.origin}`;
            default:
                return "Campo invlido"
        }
    }
};

function Q$() {
    return {
        localeError: QV6()
    }
}

function Ou(v, z, U, V) {
    let N = Math.abs(v),
        K = N % 10,
        x = N % 100;
    if (x >= 11 && x <= 19) return V;
    if (K === 1) return z;
    if (K >= 2 && K <= 4) return U;
    return V
}
var dV6 = () => {
    let v = {
        string: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        file: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        array: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        },
        set: {
            unit: {
                one: "",
                few: "",
                many: ""
            },
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "email ",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO   ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "   base64",
            base64url: "   base64url",
            json_string: "JSON ",
            e164: " E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :  ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])}`;
                return ` :    ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) {
                    let j = Number(N.maximum),
                        B = Ou(j, x.unit.one, x.unit.few, x.unit.many);
                    return `  : ,  ${N.origin??""}   ${K}${N.maximum.toString()} ${B}`
                }
                return `  : ,  ${N.origin??""}  ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) {
                    let j = Number(N.minimum),
                        B = Ou(j, x.unit.one, x.unit.few, x.unit.many);
                    return `  : ,  ${N.origin}   ${K}${N.minimum.toString()} ${B}`
                }
                return `  : ,  ${N.origin}  ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :    "${K.prefix}"`;
                if (K.format === "ends_with") return ` :    "${K.suffix}"`;
                if (K.format === "includes") return ` :   "${K.includes}"`;
                if (K.format === "regex") return ` :    ${K.pattern}`;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` :    ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""} ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return "  ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return "  "
        }
    }
};

function d$() {
    return {
        localeError: dV6()
    }
}
var oV6 = () => {
    let v = {
        string: {
            unit: "znakov",
            verb: "imeti"
        },
        file: {
            unit: "bajtov",
            verb: "imeti"
        },
        array: {
            unit: "elementov",
            verb: "imeti"
        },
        set: {
            unit: "elementov",
            verb: "imeti"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "tevilo";
                case "object": {
                    if (Array.isArray(N)) return "tabela";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "vnos",
            email: "e-potni naslov",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO datum in as",
            date: "ISO datum",
            time: "ISO as",
            duration: "ISO trajanje",
            ipv4: "IPv4 naslov",
            ipv6: "IPv6 naslov",
            cidrv4: "obseg IPv4",
            cidrv6: "obseg IPv6",
            base64: "base64 kodiran niz",
            base64url: "base64url kodiran niz",
            json_string: "JSON niz",
            e164: "E.164 tevilka",
            jwt: "JWT",
            template_literal: "vnos"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Neveljaven vnos: priakovano ${N.expected}, prejeto ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Neveljaven vnos: priakovano ${K6(N.values[0])}`;
                return `Neveljavna monost: priakovano eno izmed ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Preveliko: priakovano, da bo ${N.origin??"vrednost"} imelo ${K}${N.maximum.toString()} ${x.unit??"elementov"}`;
                return `Preveliko: priakovano, da bo ${N.origin??"vrednost"} ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Premajhno: priakovano, da bo ${N.origin} imelo ${K}${N.minimum.toString()} ${x.unit}`;
                return `Premajhno: priakovano, da bo ${N.origin} ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${K.prefix}"`;
                if (K.format === "ends_with") return `Neveljaven niz: mora se konati z "${K.suffix}"`;
                if (K.format === "includes") return `Neveljaven niz: mora vsebovati "${K.includes}"`;
                if (K.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${K.pattern}`;
                return `Neveljaven ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Neveljavno tevilo: mora biti vekratnik ${N.divisor}`;
            case "unrecognized_keys":
                return `Neprepoznan${N.keys.length>1?"i kljui":" klju"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Neveljaven klju v ${N.origin}`;
            case "invalid_union":
                return "Neveljaven vnos";
            case "invalid_element":
                return `Neveljavna vrednost v ${N.origin}`;
            default:
                return "Neveljaven vnos"
        }
    }
};

function o$() {
    return {
        localeError: oV6()
    }
}
var rV6 = () => {
    let v = {
        string: {
            unit: "tecken",
            verb: "att ha"
        },
        file: {
            unit: "bytes",
            verb: "att ha"
        },
        array: {
            unit: "objekt",
            verb: "att innehlla"
        },
        set: {
            unit: "objekt",
            verb: "att innehlla"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "antal";
                case "object": {
                    if (Array.isArray(N)) return "lista";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "reguljrt uttryck",
            email: "e-postadress",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO-datum och tid",
            date: "ISO-datum",
            time: "ISO-tid",
            duration: "ISO-varaktighet",
            ipv4: "IPv4-intervall",
            ipv6: "IPv6-intervall",
            cidrv4: "IPv4-spektrum",
            cidrv6: "IPv6-spektrum",
            base64: "base64-kodad strng",
            base64url: "base64url-kodad strng",
            json_string: "JSON-strng",
            e164: "E.164-nummer",
            jwt: "JWT",
            template_literal: "mall-literal"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `Ogiltig inmatning: frvntat ${N.expected}, fick ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `Ogiltig inmatning: frvntat ${K6(N.values[0])}`;
                return `Ogiltigt val: frvntade en av ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Fr stor(t): frvntade ${N.origin??"vrdet"} att ha ${K}${N.maximum.toString()} ${x.unit??"element"}`;
                return `Fr stor(t): frvntat ${N.origin??"vrdet"} att ha ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Fr lite(t): frvntade ${N.origin??"vrdet"} att ha ${K}${N.minimum.toString()} ${x.unit}`;
                return `Fr lite(t): frvntade ${N.origin??"vrdet"} att ha ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Ogiltig strng: mste brja med "${K.prefix}"`;
                if (K.format === "ends_with") return `Ogiltig strng: mste sluta med "${K.suffix}"`;
                if (K.format === "includes") return `Ogiltig strng: mste innehlla "${K.includes}"`;
                if (K.format === "regex") return `Ogiltig strng: mste matcha mnstret "${K.pattern}"`;
                return `Ogiltig(t) ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `Ogiltigt tal: mste vara en multipel av ${N.divisor}`;
            case "unrecognized_keys":
                return `${N.keys.length>1?"Oknda nycklar":"Oknd nyckel"}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Ogiltig nyckel i ${N.origin??"vrdet"}`;
            case "invalid_union":
                return "Ogiltig input";
            case "invalid_element":
                return `Ogiltigt vrde i ${N.origin??"vrdet"}`;
            default:
                return "Ogiltig input"
        }
    }
};

function r$() {
    return {
        localeError: rV6()
    }
}
var aV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: " "
        },
        file: {
            unit: "",
            verb: " "
        },
        array: {
            unit: "",
            verb: " "
        },
        set: {
            unit: "",
            verb: " "
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? " " : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: " ",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO  ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO  ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "base64-encoded ",
            base64url: "base64url-encoded ",
            json_string: "JSON ",
            e164: "E.164 ",
            jwt: "JWT",
            template_literal: "input"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` :  ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` :  ${K6(N.values[0])}`;
                return ` :  ${h(N.values,"|")}  `;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` :  ${N.origin??""} ${K}${N.maximum.toString()} ${x.unit??""}   `;
                return ` :  ${N.origin??""} ${K}${N.maximum.toString()}   `
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` :  ${N.origin} ${K}${N.minimum.toString()} ${x.unit}   `;
                return ` :  ${N.origin} ${K}${N.minimum.toString()}   `
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` : "${K.prefix}"   `;
                if (K.format === "ends_with") return ` : "${K.suffix}"   `;
                if (K.format === "includes") return ` : "${K.includes}"   `;
                if (K.format === "regex") return ` : ${K.pattern}   `;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` : ${N.divisor}    `;
            case "unrecognized_keys":
                return `  ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `${N.origin}   `;
            case "invalid_union":
                return " ";
            case "invalid_element":
                return `${N.origin}   `;
            default:
                return " "
        }
    }
};

function a$() {
    return {
        localeError: aV6()
    }
}
var tV6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? " (NaN)" : "";
                case "object": {
                    if (Array.isArray(N)) return " (Array)";
                    if (N === null) return " (null)";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: " ISO",
            date: " ISO",
            time: " ISO",
            duration: " ISO",
            ipv4: " IPv4",
            ipv6: " IPv6",
            cidrv4: " IP  IPv4",
            cidrv6: " IP  IPv6",
            base64: " Base64",
            base64url: " Base64  URL",
            json_string: " JSON",
            e164: " (E.164)",
            jwt: " JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `:  ${N.expected}  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `:  ${K6(N.values[0])}`;
                return `:  ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "" : "",
                    x = z(N.origin);
                if (x) return `: ${N.origin??""} ${K} ${N.maximum.toString()} ${x.unit??""}`;
                return `: ${N.origin??""} ${K} ${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? "" : "",
                    x = z(N.origin);
                if (x) return `: ${N.origin} ${K} ${N.minimum.toString()} ${x.unit}`;
                return `: ${N.origin} ${K} ${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `:  "${K.prefix}"`;
                if (K.format === "ends_with") return `:  "${K.suffix}"`;
                if (K.format === "includes") return `:  "${K.includes}" `;
                if (K.format === "regex") return `:  ${K.pattern}`;
                return `: ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return `:  ${N.divisor} `;
            case "unrecognized_keys":
                return `: ${h(N.keys,", ")}`;
            case "invalid_key":
                return ` ${N.origin}`;
            case "invalid_union":
                return ": ";
            case "invalid_element":
                return ` ${N.origin}`;
            default:
                return ""
        }
    }
};

function t$() {
    return {
        localeError: tV6()
    }
}
var sV6 = (v) => {
        let z = typeof v;
        switch (z) {
            case "number":
                return Number.isNaN(v) ? "NaN" : "number";
            case "object": {
                if (Array.isArray(v)) return "array";
                if (v === null) return "null";
                if (Object.getPrototypeOf(v) !== Object.prototype && v.constructor) return v.constructor.name
            }
        }
        return z
    },
    eV6 = () => {
        let v = {
            string: {
                unit: "karakter",
                verb: "olmal"
            },
            file: {
                unit: "bayt",
                verb: "olmal"
            },
            array: {
                unit: "e",
                verb: "olmal"
            },
            set: {
                unit: "e",
                verb: "olmal"
            }
        };

        function z(V) {
            return v[V] ?? null
        }
        let U = {
            regex: "girdi",
            email: "e-posta adresi",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO tarih ve saat",
            date: "ISO tarih",
            time: "ISO saat",
            duration: "ISO sre",
            ipv4: "IPv4 adresi",
            ipv6: "IPv6 adresi",
            cidrv4: "IPv4 aral",
            cidrv6: "IPv6 aral",
            base64: "base64 ile ifrelenmi metin",
            base64url: "base64url ile ifrelenmi metin",
            json_string: "JSON dizesi",
            e164: "E.164 says",
            jwt: "JWT",
            template_literal: "ablon dizesi"
        };
        return (V) => {
            switch (V.code) {
                case "invalid_type":
                    return `Geersiz deer: beklenen ${V.expected}, alnan ${sV6(V.input)}`;
                case "invalid_value":
                    if (V.values.length === 1) return `Geersiz deer: beklenen ${K6(V.values[0])}`;
                    return `Geersiz seenek: aadakilerden biri olmal: ${h(V.values,"|")}`;
                case "too_big": {
                    let N = V.inclusive ? "<=" : "<",
                        K = z(V.origin);
                    if (K) return `ok byk: beklenen ${V.origin??"deer"} ${N}${V.maximum.toString()} ${K.unit??"e"}`;
                    return `ok byk: beklenen ${V.origin??"deer"} ${N}${V.maximum.toString()}`
                }
                case "too_small": {
                    let N = V.inclusive ? ">=" : ">",
                        K = z(V.origin);
                    if (K) return `ok kk: beklenen ${V.origin} ${N}${V.minimum.toString()} ${K.unit}`;
                    return `ok kk: beklenen ${V.origin} ${N}${V.minimum.toString()}`
                }
                case "invalid_format": {
                    let N = V;
                    if (N.format === "starts_with") return `Geersiz metin: "${N.prefix}" ile balamal`;
                    if (N.format === "ends_with") return `Geersiz metin: "${N.suffix}" ile bitmeli`;
                    if (N.format === "includes") return `Geersiz metin: "${N.includes}" iermeli`;
                    if (N.format === "regex") return `Geersiz metin: ${N.pattern} desenine uymal`;
                    return `Geersiz ${U[N.format]??V.format}`
                }
                case "not_multiple_of":
                    return `Geersiz say: ${V.divisor} ile tam blnebilmeli`;
                case "unrecognized_keys":
                    return `Tannmayan anahtar${V.keys.length>1?"lar":""}: ${h(V.keys,", ")}`;
                case "invalid_key":
                    return `${V.origin} iinde geersiz anahtar`;
                case "invalid_union":
                    return "Geersiz deer";
                case "invalid_element":
                    return `${V.origin} iinde geersiz deer`;
                default:
                    return "Geersiz deer"
            }
        }
    };

function s$() {
    return {
        localeError: eV6()
    }
}
var vN6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: " ",
            email: "  ",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "   ISO",
            date: " ISO",
            time: " ISO",
            duration: " ISO",
            ipv4: " IPv4",
            ipv6: " IPv6",
            cidrv4: " IPv4",
            cidrv6: " IPv6",
            base64: "   base64",
            base64url: "   base64url",
            json_string: " JSON",
            e164: " E.164",
            jwt: "JWT",
            template_literal: " "
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `  :  ${N.expected},  ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `  :  ${K6(N.values[0])}`;
                return ` :    ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` : ,  ${N.origin??""} ${x.verb} ${K}${N.maximum.toString()} ${x.unit??""}`;
                return ` : ,  ${N.origin??""}  ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` : ,  ${N.origin} ${x.verb} ${K}${N.minimum.toString()} ${x.unit}`;
                return ` : ,  ${N.origin}  ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` :    "${K.prefix}"`;
                if (K.format === "ends_with") return ` :    "${K.suffix}"`;
                if (K.format === "includes") return ` :   "${K.includes}"`;
                if (K.format === "regex") return ` :    ${K.pattern}`;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` :    ${N.divisor}`;
            case "unrecognized_keys":
                return ` ${N.keys.length>1?"":""}: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `   ${N.origin}`;
            case "invalid_union":
                return "  ";
            case "invalid_element":
                return `   ${N.origin}`;
            default:
                return "  "
        }
    }
};

function e$() {
    return {
        localeError: vN6()
    }
}
var zN6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: " ",
            email: "  ",
            url: "  ",
            emoji: "",
            uuid: "   ",
            uuidv4: "     4",
            uuidv6: "     6",
            nanoid: "  ",
            guid: "   ",
            cuid: "   ",
            cuid2: "    2",
            ulid: "   ",
            xid: "  ",
            ksuid: "    ",
            datetime: "    ",
            date: "   ",
            time: "   ",
            duration: "   ",
            ipv4: "   4 ",
            ipv6: "   6 ",
            cidrv4: "   4 ",
            cidrv6: "   6 ",
            base64: " 64   ",
            base64url: " 64      ",
            json_string: "    ",
            e164: " 164 ",
            jwt: "  ",
            template_literal: " "
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `  : ${N.expected}   ${U(N.input)}  `;
            case "invalid_value":
                if (N.values.length === 1) return `  : ${K6(N.values[0])}  `;
                return ` : ${h(N.values,"|")}     `;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` : ${N.origin??""}  ${K}${N.maximum.toString()} ${x.unit??""}   `;
                return ` : ${N.origin??""}  ${K}${N.maximum.toString()}   `
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` : ${N.origin}  ${K}${N.minimum.toString()} ${x.unit}   `;
                return ` : ${N.origin}  ${K}${N.minimum.toString()}   `
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` : "${K.prefix}"    `;
                if (K.format === "ends_with") return ` : "${K.suffix}"    `;
                if (K.format === "includes") return ` : "${K.includes}"   `;
                if (K.format === "regex") return ` :  ${K.pattern}    `;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` : ${N.divisor}    `;
            case "unrecognized_keys":
                return `   ${N.keys.length>1?"":""}: ${h(N.keys," ")}`;
            case "invalid_key":
                return `${N.origin}   `;
            case "invalid_union":
                return "  ";
            case "invalid_element":
                return `${N.origin}   `;
            default:
                return "  "
        }
    }
};

function vw() {
    return {
        localeError: zN6()
    }
}
var UN6 = () => {
    let v = {
        string: {
            unit: "k t",
            verb: "c"
        },
        file: {
            unit: "byte",
            verb: "c"
        },
        array: {
            unit: "phn t",
            verb: "c"
        },
        set: {
            unit: "phn t",
            verb: "c"
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "s";
                case "object": {
                    if (Array.isArray(N)) return "mng";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "u vo",
            email: "a ch email",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ngy gi ISO",
            date: "ngy ISO",
            time: "gi ISO",
            duration: "khong thi gian ISO",
            ipv4: "a ch IPv4",
            ipv6: "a ch IPv6",
            cidrv4: "di IPv4",
            cidrv6: "di IPv6",
            base64: "chui m ha base64",
            base64url: "chui m ha base64url",
            json_string: "chui JSON",
            e164: "s E.164",
            jwt: "JWT",
            template_literal: "u vo"
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return `u vo khng hp l: mong i ${N.expected}, nhn c ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return `u vo khng hp l: mong i ${K6(N.values[0])}`;
                return `Ty chn khng hp l: mong i mt trong cc gi tr ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return `Qu ln: mong i ${N.origin??"gi tr"} ${x.verb} ${K}${N.maximum.toString()} ${x.unit??"phn t"}`;
                return `Qu ln: mong i ${N.origin??"gi tr"} ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return `Qu nh: mong i ${N.origin} ${x.verb} ${K}${N.minimum.toString()} ${x.unit}`;
                return `Qu nh: mong i ${N.origin} ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return `Chui khng hp l: phi bt u bng "${K.prefix}"`;
                if (K.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${K.suffix}"`;
                if (K.format === "includes") return `Chui khng hp l: phi bao gm "${K.includes}"`;
                if (K.format === "regex") return `Chui khng hp l: phi khp vi mu ${K.pattern}`;
                return `${V[K.format]??N.format} khng hp l`
            }
            case "not_multiple_of":
                return `S khng hp l: phi l bi s ca ${N.divisor}`;
            case "unrecognized_keys":
                return `Kha khng c nhn dng: ${h(N.keys,", ")}`;
            case "invalid_key":
                return `Kha khng hp l trong ${N.origin}`;
            case "invalid_union":
                return "u vo khng hp l";
            case "invalid_element":
                return `Gi tr khng hp l trong ${N.origin}`;
            default:
                return "u vo khng hp l"
        }
    }
};

function zw() {
    return {
        localeError: UN6()
    }
}
var VN6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "(NaN)" : "";
                case "object": {
                    if (Array.isArray(N)) return "";
                    if (N === null) return "(null)";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "URL",
            emoji: "",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO",
            date: "ISO",
            time: "ISO",
            duration: "ISO",
            ipv4: "IPv4",
            ipv6: "IPv6",
            cidrv4: "IPv4",
            cidrv6: "IPv6",
            base64: "base64",
            base64url: "base64url",
            json_string: "JSON",
            e164: "E.164",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` ${N.expected} ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` ${K6(N.values[0])}`;
                return ` ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` ${N.origin??""} ${K}${N.maximum.toString()} ${x.unit??""}`;
                return ` ${N.origin??""} ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` ${N.origin} ${K}${N.minimum.toString()} ${x.unit}`;
                return ` ${N.origin} ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` "${K.prefix}" `;
                if (K.format === "ends_with") return ` "${K.suffix}" `;
                if (K.format === "includes") return ` "${K.includes}"`;
                if (K.format === "regex") return ` ${K.pattern}`;
                return `${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` ${N.divisor} `;
            case "unrecognized_keys":
                return `(key): ${h(N.keys,", ")}`;
            case "invalid_key":
                return `${N.origin} (key)`;
            case "invalid_union":
                return "";
            case "invalid_element":
                return `${N.origin} (value)`;
            default:
                return ""
        }
    }
};

function Uw() {
    return {
        localeError: VN6()
    }
}
var NN6 = () => {
    let v = {
        string: {
            unit: "",
            verb: ""
        },
        file: {
            unit: "",
            verb: ""
        },
        array: {
            unit: "",
            verb: ""
        },
        set: {
            unit: "",
            verb: ""
        }
    };

    function z(N) {
        return v[N] ?? null
    }
    let U = (N) => {
            let K = typeof N;
            switch (K) {
                case "number":
                    return Number.isNaN(N) ? "NaN" : "number";
                case "object": {
                    if (Array.isArray(N)) return "array";
                    if (N === null) return "null";
                    if (Object.getPrototypeOf(N) !== Object.prototype && N.constructor) return N.constructor.name
                }
            }
            return K
        },
        V = {
            regex: "",
            email: "",
            url: "URL",
            emoji: "emoji",
            uuid: "UUID",
            uuidv4: "UUIDv4",
            uuidv6: "UUIDv6",
            nanoid: "nanoid",
            guid: "GUID",
            cuid: "cuid",
            cuid2: "cuid2",
            ulid: "ULID",
            xid: "XID",
            ksuid: "KSUID",
            datetime: "ISO ",
            date: "ISO ",
            time: "ISO ",
            duration: "ISO ",
            ipv4: "IPv4 ",
            ipv6: "IPv6 ",
            cidrv4: "IPv4 ",
            cidrv6: "IPv6 ",
            base64: "base64 ",
            base64url: "base64url ",
            json_string: "JSON ",
            e164: "E.164 ",
            jwt: "JWT",
            template_literal: ""
        };
    return (N) => {
        switch (N.code) {
            case "invalid_type":
                return ` ${N.expected} ${U(N.input)}`;
            case "invalid_value":
                if (N.values.length === 1) return ` ${K6(N.values[0])}`;
                return ` ${h(N.values,"|")}`;
            case "too_big": {
                let K = N.inclusive ? "<=" : "<",
                    x = z(N.origin);
                if (x) return ` ${N.origin??""}  ${K}${N.maximum.toString()} ${x.unit??""}`;
                return ` ${N.origin??""}  ${K}${N.maximum.toString()}`
            }
            case "too_small": {
                let K = N.inclusive ? ">=" : ">",
                    x = z(N.origin);
                if (x) return ` ${N.origin}  ${K}${N.minimum.toString()} ${x.unit}`;
                return ` ${N.origin}  ${K}${N.minimum.toString()}`
            }
            case "invalid_format": {
                let K = N;
                if (K.format === "starts_with") return ` "${K.prefix}" `;
                if (K.format === "ends_with") return ` "${K.suffix}" `;
                if (K.format === "includes") return ` "${K.includes}"`;
                if (K.format === "regex") return ` ${K.pattern}`;
                return ` ${V[K.format]??N.format}`
            }
            case "not_multiple_of":
                return ` ${N.divisor} `;
            case "unrecognized_keys":
                return `${N.keys.length>1?"":""}${h(N.keys,"")}`;
            case "invalid_key":
                return `${N.origin} `;
            case "invalid_union":
                return "";
            case "invalid_element":
                return `${N.origin} `;
            default:
                return ""
        }
    }
};

function Vw() {
    return {
        localeError: NN6()
    }
}
var wB = Symbol("ZodOutput"),
    ZB = Symbol("ZodInput");
class oU {
    constructor() {
        this._map = new WeakMap, this._idmap = new Map
    }
    add(v, ...z) {
        let U = z[0];
        if (this._map.set(v, U), U && typeof U === "object" && "id" in U) {
            if (this._idmap.has(U.id)) throw Error(`ID ${U.id} already exists in the registry`);
            this._idmap.set(U.id, v)
        }
        return this
    }
    remove(v) {
        return this._map.delete(v), this
    }
    get(v) {
        let z = v._zod.parent;
        if (z) {
            let U = {
                ...this.get(z) ?? {}
            };
            return delete U.id, {
                ...U,
                ...this._map.get(v)
            }
        }
        return this._map.get(v)
    }
    has(v) {
        return this._map.has(v)
    }
}

function rU() {
    return new oU
}
var A8 = rU();

function LB(v, z) {
    return new v({
        type: "string",
        ...e(z)
    })
}

function Nw(v, z) {
    return new v({
        type: "string",
        coerce: !0,
        ...e(z)
    })
}

function aU(v, z) {
    return new v({
        type: "string",
        format: "email",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function q1(v, z) {
    return new v({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function tU(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function sU(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v4",
        ...e(z)
    })
}

function eU(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v6",
        ...e(z)
    })
}

function vV(v, z) {
    return new v({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v7",
        ...e(z)
    })
}

function zV(v, z) {
    return new v({
        type: "string",
        format: "url",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function UV(v, z) {
    return new v({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function VV(v, z) {
    return new v({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function NV(v, z) {
    return new v({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function KV(v, z) {
    return new v({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function xV(v, z) {
    return new v({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function jV(v, z) {
    return new v({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function BV(v, z) {
    return new v({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function OV(v, z) {
    return new v({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function JV(v, z) {
    return new v({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function qV(v, z) {
    return new v({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function HV(v, z) {
    return new v({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function DV(v, z) {
    return new v({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function AV(v, z) {
    return new v({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function $V(v, z) {
    return new v({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}

function wV(v, z) {
    return new v({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: !1,
        ...e(z)
    })
}
var FB = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
};

function Kw(v, z) {
    return new v({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: !1,
        local: !1,
        precision: null,
        ...e(z)
    })
}

function xw(v, z) {
    return new v({
        type: "string",
        format: "date",
        check: "string_format",
        ...e(z)
    })
}

function jw(v, z) {
    return new v({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...e(z)
    })
}

function Bw(v, z) {
    return new v({
        type: "string",
        format: "duration",
        check: "string_format",
        ...e(z)
    })
}

function GB(v, z) {
    return new v({
        type: "number",
        checks: [],
        ...e(z)
    })
}

function Ow(v, z) {
    return new v({
        type: "number",
        coerce: !0,
        checks: [],
        ...e(z)
    })
}

function IB(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "safeint",
        ...e(z)
    })
}

function MB(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "float32",
        ...e(z)
    })
}

function bB(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "float64",
        ...e(z)
    })
}

function RB(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "int32",
        ...e(z)
    })
}

function WB(v, z) {
    return new v({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "uint32",
        ...e(z)
    })
}

function EB(v, z) {
    return new v({
        type: "boolean",
        ...e(z)
    })
}

function Jw(v, z) {
    return new v({
        type: "boolean",
        coerce: !0,
        ...e(z)
    })
}

function SB(v, z) {
    return new v({
        type: "bigint",
        ...e(z)
    })
}

function qw(v, z) {
    return new v({
        type: "bigint",
        coerce: !0,
        ...e(z)
    })
}

function PB(v, z) {
    return new v({
        type: "bigint",
        check: "bigint_format",
        abort: !1,
        format: "int64",
        ...e(z)
    })
}

function _B(v, z) {
    return new v({
        type: "bigint",
        check: "bigint_format",
        abort: !1,
        format: "uint64",
        ...e(z)
    })
}

function CB(v, z) {
    return new v({
        type: "symbol",
        ...e(z)
    })
}

function fB(v, z) {
    return new v({
        type: "undefined",
        ...e(z)
    })
}

function TB(v, z) {
    return new v({
        type: "null",
        ...e(z)
    })
}

function YB(v) {
    return new v({
        type: "any"
    })
}

function F7(v) {
    return new v({
        type: "unknown"
    })
}

function uB(v, z) {
    return new v({
        type: "never",
        ...e(z)
    })
}

function yB(v, z) {
    return new v({
        type: "void",
        ...e(z)
    })
}

function kB(v, z) {
    return new v({
        type: "date",
        ...e(z)
    })
}

function Hw(v, z) {
    return new v({
        type: "date",
        coerce: !0,
        ...e(z)
    })
}

function mB(v, z) {
    return new v({
        type: "nan",
        ...e(z)
    })
}

function R9(v, z) {
    return new $j({
        check: "less_than",
        ...e(z),
        value: v,
        inclusive: !1
    })
}

function n3(v, z) {
    return new $j({
        check: "less_than",
        ...e(z),
        value: v,
        inclusive: !0
    })
}

function W9(v, z) {
    return new wj({
        check: "greater_than",
        ...e(z),
        value: v,
        inclusive: !1
    })
}

function F3(v, z) {
    return new wj({
        check: "greater_than",
        ...e(z),
        value: v,
        inclusive: !0
    })
}

function Dw(v) {
    return W9(0, v)
}

function Aw(v) {
    return R9(0, v)
}

function $w(v) {
    return n3(0, v)
}

function ww(v) {
    return F3(0, v)
}

function G7(v, z) {
    return new rA({
        check: "multiple_of",
        ...e(z),
        value: v
    })
}

function H1(v, z) {
    return new sA({
        check: "max_size",
        ...e(z),
        maximum: v
    })
}

function I7(v, z) {
    return new eA({
        check: "min_size",
        ...e(z),
        minimum: v
    })
}

function ZV(v, z) {
    return new v$({
        check: "size_equals",
        ...e(z),
        size: v
    })
}

function D1(v, z) {
    return new z$({
        check: "max_length",
        ...e(z),
        maximum: v
    })
}

function F5(v, z) {
    return new U$({
        check: "min_length",
        ...e(z),
        minimum: v
    })
}

function A1(v, z) {
    return new V$({
        check: "length_equals",
        ...e(z),
        length: v
    })
}

function LV(v, z) {
    return new N$({
        check: "string_format",
        format: "regex",
        ...e(z),
        pattern: v
    })
}

function FV(v) {
    return new K$({
        check: "string_format",
        format: "lowercase",
        ...e(v)
    })
}

function GV(v) {
    return new x$({
        check: "string_format",
        format: "uppercase",
        ...e(v)
    })
}

function IV(v, z) {
    return new j$({
        check: "string_format",
        format: "includes",
        ...e(z),
        includes: v
    })
}

function MV(v, z) {
    return new B$({
        check: "string_format",
        format: "starts_with",
        ...e(z),
        prefix: v
    })
}

function bV(v, z) {
    return new O$({
        check: "string_format",
        format: "ends_with",
        ...e(z),
        suffix: v
    })
}

function Zw(v, z, U) {
    return new J$({
        check: "property",
        property: v,
        schema: z,
        ...e(U)
    })
}

function RV(v, z) {
    return new q$({
        check: "mime_type",
        mime: v,
        ...e(z)
    })
}

function E9(v) {
    return new H$({
        check: "overwrite",
        tx: v
    })
}

function WV(v) {
    return E9((z) => z.normalize(v))
}

function EV() {
    return E9((v) => v.trim())
}

function SV() {
    return E9((v) => v.toLowerCase())
}

function PV() {
    return E9((v) => v.toUpperCase())
}

function _V(v, z, U) {
    return new v({
        type: "array",
        element: z,
        ...e(U)
    })
}

function KN6(v, z, U) {
    return new v({
        type: "union",
        options: z,
        ...e(U)
    })
}

function xN6(v, z, U, V) {
    return new v({
        type: "union",
        options: U,
        discriminator: z,
        ...e(V)
    })
}

function jN6(v, z, U) {
    return new v({
        type: "intersection",
        left: z,
        right: U
    })
}

function Lw(v, z, U, V) {
    let N = U instanceof i6;
    return new v({
        type: "tuple",
        items: z,
        rest: N ? U : null,
        ...e(N ? V : U)
    })
}

function BN6(v, z, U, V) {
    return new v({
        type: "record",
        keyType: z,
        valueType: U,
        ...e(V)
    })
}

function ON6(v, z, U, V) {
    return new v({
        type: "map",
        keyType: z,
        valueType: U,
        ...e(V)
    })
}

function JN6(v, z, U) {
    return new v({
        type: "set",
        valueType: z,
        ...e(U)
    })
}

function qN6(v, z, U) {
    let V = Array.isArray(z) ? Object.fromEntries(z.map((N) => [N, N])) : z;
    return new v({
        type: "enum",
        entries: V,
        ...e(U)
    })
}

function HN6(v, z, U) {
    return new v({
        type: "enum",
        entries: z,
        ...e(U)
    })
}

function DN6(v, z, U) {
    return new v({
        type: "literal",
        values: Array.isArray(z) ? z : [z],
        ...e(U)
    })
}

function XB(v, z) {
    return new v({
        type: "file",
        ...e(z)
    })
}

function AN6(v, z) {
    return new v({
        type: "transform",
        transform: z
    })
}

function $N6(v, z) {
    return new v({
        type: "optional",
        innerType: z
    })
}

function wN6(v, z) {
    return new v({
        type: "nullable",
        innerType: z
    })
}

function ZN6(v, z, U) {
    return new v({
        type: "default",
        innerType: z,
        get defaultValue() {
            return typeof U === "function" ? U() : U
        }
    })
}

function LN6(v, z, U) {
    return new v({
        type: "nonoptional",
        innerType: z,
        ...e(U)
    })
}

function FN6(v, z) {
    return new v({
        type: "success",
        innerType: z
    })
}

function GN6(v, z, U) {
    return new v({
        type: "catch",
        innerType: z,
        catchValue: typeof U === "function" ? U : () => U
    })
}

function IN6(v, z, U) {
    return new v({
        type: "pipe",
        in: z,
        out: U
    })
}

function MN6(v, z) {
    return new v({
        type: "readonly",
        innerType: z
    })
}

function bN6(v, z, U) {
    return new v({
        type: "template_literal",
        parts: z,
        ...e(U)
    })
}

function RN6(v, z) {
    return new v({
        type: "lazy",
        getter: z
    })
}

function WN6(v, z) {
    return new v({
        type: "promise",
        innerType: z
    })
}

function gB(v, z, U) {
    let V = e(U);
    return V.abort ?? (V.abort = !0), new v({
        type: "custom",
        check: "custom",
        fn: z,
        ...V
    })
}

function cB(v, z, U) {
    return new v({
        type: "custom",
        check: "custom",
        fn: z,
        ...e(U)
    })
}

function iB(v, z) {
    let U = e(z),
        V = U.truthy ?? ["true", "1", "yes", "on", "y", "enabled"],
        N = U.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (U.case !== "sensitive") V = V.map((A) => typeof A === "string" ? A.toLowerCase() : A), N = N.map((A) => typeof A === "string" ? A.toLowerCase() : A);
    let K = new Set(V),
        x = new Set(N),
        j = v.Pipe ?? O1,
        B = v.Boolean ?? x1,
        O = v.String ?? Z5,
        q = new(v.Transform ?? B1)({
            type: "transform",
            transform: (A, w) => {
                let Z = A;
                if (U.case !== "sensitive") Z = Z.toLowerCase();
                if (K.has(Z)) return !0;
                else if (x.has(Z)) return !1;
                else return w.issues.push({
                    code: "invalid_value",
                    expected: "stringbool",
                    values: [...K, ...x],
                    input: w.value,
                    inst: q
                }), {}
            },
            error: U.error
        }),
        H = new j({
            type: "pipe",
            in: new O({
                type: "string",
                error: U.error
            }),
            out: q,
            error: U.error
        });
    return new j({
        type: "pipe",
        in: H,
        out: new B({
            type: "boolean",
            error: U.error
        }),
        error: U.error
    })
}

function lB(v, z, U, V = {}) {
    let N = e(V),
        K = {
            ...e(V),
            check: "string_format",
            type: "string",
            format: z,
            fn: typeof U === "function" ? U : (j) => U.test(j),
            ...N
        };
    if (U instanceof RegExp) K.pattern = U;
    return new v(K)
}
class Fw {
    constructor(v) {
        this._def = v, this.def = v
    }
    implement(v) {
        if (typeof v !== "function") throw Error("implement() must be called with a function");
        let z = (...U) => {
            let V = this._def.input ? $7(this._def.input, U, void 0, {
                callee: z
            }) : U;
            if (!Array.isArray(V)) throw Error("Invalid arguments schema: not an array or tuple schema.");
            let N = v(...V);
            return this._def.output ? $7(this._def.output, N, void 0, {
                callee: z
            }) : N
        };
        return z
    }
    implementAsync(v) {
        if (typeof v !== "function") throw Error("implement() must be called with a function");
        let z = async (...U) => {
            let V = this._def.input ? await w7(this._def.input, U, void 0, {
                callee: z
            }) : U;
            if (!Array.isArray(V)) throw Error("Invalid arguments schema: not an array or tuple schema.");
            let N = await v(...V);
            return this._def.output ? w7(this._def.output, N, void 0, {
                callee: z
            }) : N
        };
        return z
    }
    input(...v) {
        let z = this.constructor;
        if (Array.isArray(v[0])) return new z({
            type: "function",
            input: new L5({
                type: "tuple",
                items: v[0],
                rest: v[1]
            }),
            output: this._def.output
        });
        return new z({
            type: "function",
            input: v[0],
            output: this._def.output
        })
    }
    output(v) {
        return new this.constructor({
            type: "function",
            input: this._def.input,
            output: v
        })
    }
}

function hB(v) {
    return new Fw({
        type: "function",
        input: Array.isArray(v?.input) ? Lw(L5, v?.input) : v?.input ?? _V(j1, F7(L7)),
        output: v?.output ?? F7(L7)
    })
}
class pB {
    constructor(v) {
        this.counter = 0, this.metadataRegistry = v?.metadata ?? A8, this.target = v?.target ?? "draft-2020-12", this.unrepresentable = v?.unrepresentable ?? "throw", this.override = v?.override ?? (() => {}), this.io = v?.io ?? "output", this.seen = new Map
    }
    process(v, z = {
        path: [],
        schemaPath: []
    }) {
        var U;
        let V = v._zod.def,
            N = {
                guid: "uuid",
                url: "uri",
                datetime: "date-time",
                json_string: "json-string",
                regex: ""
            },
            K = this.seen.get(v);
        if (K) {
            if (K.count++, z.schemaPath.includes(v)) K.cycle = z.path;
            return K.schema
        }
        let x = {
            schema: {},
            count: 1,
            cycle: void 0,
            path: z.path
        };
        this.seen.set(v, x);
        let j = v._zod.toJSONSchema?.();
        if (j) x.schema = j;
        else {
            let J = {
                    ...z,
                    schemaPath: [...z.schemaPath, v],
                    path: z.path
                },
                q = v._zod.parent;
            if (q) x.ref = q, this.process(q, J), this.seen.get(q).isParent = !0;
            else {
                let H = x.schema;
                switch (V.type) {
                    case "string": {
                        let D = H;
                        D.type = "string";
                        let {
                            minimum: A,
                            maximum: w,
                            format: Z,
                            patterns: $,
                            contentEncoding: F
                        } = v._zod.bag;
                        if (typeof A === "number") D.minLength = A;
                        if (typeof w === "number") D.maxLength = w;
                        if (Z) {
                            if (D.format = N[Z] ?? Z, D.format === "") delete D.format
                        }
                        if (F) D.contentEncoding = F;
                        if ($ && $.size > 0) {
                            let L = [...$];
                            if (L.length === 1) D.pattern = L[0].source;
                            else if (L.length > 1) x.schema.allOf = [...L.map((G) => ({
                                ...this.target === "draft-7" ? {
                                    type: "string"
                                } : {},
                                pattern: G.source
                            }))]
                        }
                        break
                    }
                    case "number": {
                        let D = H,
                            {
                                minimum: A,
                                maximum: w,
                                format: Z,
                                multipleOf: $,
                                exclusiveMaximum: F,
                                exclusiveMinimum: L
                            } = v._zod.bag;
                        if (typeof Z === "string" && Z.includes("int")) D.type = "integer";
                        else D.type = "number";
                        if (typeof L === "number") D.exclusiveMinimum = L;
                        if (typeof A === "number") {
                            if (D.minimum = A, typeof L === "number")
                                if (L >= A) delete D.minimum;
                                else delete D.exclusiveMinimum
                        }
                        if (typeof F === "number") D.exclusiveMaximum = F;
                        if (typeof w === "number") {
                            if (D.maximum = w, typeof F === "number")
                                if (F <= w) delete D.maximum;
                                else delete D.exclusiveMaximum
                        }
                        if (typeof $ === "number") D.multipleOf = $;
                        break
                    }
                    case "boolean": {
                        let D = H;
                        D.type = "boolean";
                        break
                    }
                    case "bigint": {
                        if (this.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
                        break
                    }
                    case "symbol": {
                        if (this.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
                        break
                    }
                    case "null": {
                        H.type = "null";
                        break
                    }
                    case "any":
                        break;
                    case "unknown":
                        break;
                    case "undefined":
                    case "never": {
                        H.not = {};
                        break
                    }
                    case "void": {
                        if (this.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
                        break
                    }
                    case "date": {
                        if (this.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
                        break
                    }
                    case "array": {
                        let D = H,
                            {
                                minimum: A,
                                maximum: w
                            } = v._zod.bag;
                        if (typeof A === "number") D.minItems = A;
                        if (typeof w === "number") D.maxItems = w;
                        D.type = "array", D.items = this.process(V.element, {
                            ...J,
                            path: [...J.path, "items"]
                        });
                        break
                    }
                    case "object": {
                        let D = H;
                        D.type = "object", D.properties = {};
                        let A = V.shape;
                        for (let $ in A) D.properties[$] = this.process(A[$], {
                            ...J,
                            path: [...J.path, "properties", $]
                        });
                        let w = new Set(Object.keys(A)),
                            Z = new Set([...w].filter(($) => {
                                let F = V.shape[$]._zod;
                                if (this.io === "input") return F.optin === void 0;
                                else return F.optout === void 0
                            }));
                        if (Z.size > 0) D.required = Array.from(Z);
                        if (V.catchall?._zod.def.type === "never") D.additionalProperties = !1;
                        else if (!V.catchall) {
                            if (this.io === "output") D.additionalProperties = !1
                        } else if (V.catchall) D.additionalProperties = this.process(V.catchall, {
                            ...J,
                            path: [...J.path, "additionalProperties"]
                        });
                        break
                    }
                    case "union": {
                        let D = H;
                        D.anyOf = V.options.map((A, w) => this.process(A, {
                            ...J,
                            path: [...J.path, "anyOf", w]
                        }));
                        break
                    }
                    case "intersection": {
                        let D = H,
                            A = this.process(V.left, {
                                ...J,
                                path: [...J.path, "allOf", 0]
                            }),
                            w = this.process(V.right, {
                                ...J,
                                path: [...J.path, "allOf", 1]
                            }),
                            Z = (F) => ("allOf" in F) && Object.keys(F).length === 1,
                            $ = [...Z(A) ? A.allOf : [A], ...Z(w) ? w.allOf : [w]];
                        D.allOf = $;
                        break
                    }
                    case "tuple": {
                        let D = H;
                        D.type = "array";
                        let A = V.items.map(($, F) => this.process($, {
                            ...J,
                            path: [...J.path, "prefixItems", F]
                        }));
                        if (this.target === "draft-2020-12") D.prefixItems = A;
                        else D.items = A;
                        if (V.rest) {
                            let $ = this.process(V.rest, {
                                ...J,
                                path: [...J.path, "items"]
                            });
                            if (this.target === "draft-2020-12") D.items = $;
                            else D.additionalItems = $
                        }
                        if (V.rest) D.items = this.process(V.rest, {
                            ...J,
                            path: [...J.path, "items"]
                        });
                        let {
                            minimum: w,
                            maximum: Z
                        } = v._zod.bag;
                        if (typeof w === "number") D.minItems = w;
                        if (typeof Z === "number") D.maxItems = Z;
                        break
                    }
                    case "record": {
                        let D = H;
                        D.type = "object", D.propertyNames = this.process(V.keyType, {
                            ...J,
                            path: [...J.path, "propertyNames"]
                        }), D.additionalProperties = this.process(V.valueType, {
                            ...J,
                            path: [...J.path, "additionalProperties"]
                        });
                        break
                    }
                    case "map": {
                        if (this.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
                        break
                    }
                    case "set": {
                        if (this.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
                        break
                    }
                    case "enum": {
                        let D = H,
                            A = kU(V.entries);
                        if (A.every((w) => typeof w === "number")) D.type = "number";
                        if (A.every((w) => typeof w === "string")) D.type = "string";
                        D.enum = A;
                        break
                    }
                    case "literal": {
                        let D = H,
                            A = [];
                        for (let w of V.values)
                            if (w === void 0) {
                                if (this.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema")
                            } else if (typeof w === "bigint")
                            if (this.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
                            else A.push(Number(w));
                        else A.push(w);
                        if (A.length === 0);
                        else if (A.length === 1) {
                            let w = A[0];
                            D.type = w === null ? "null" : typeof w, D.const = w
                        } else {
                            if (A.every((w) => typeof w === "number")) D.type = "number";
                            if (A.every((w) => typeof w === "string")) D.type = "string";
                            if (A.every((w) => typeof w === "boolean")) D.type = "string";
                            if (A.every((w) => w === null)) D.type = "null";
                            D.enum = A
                        }
                        break
                    }
                    case "file": {
                        let D = H,
                            A = {
                                type: "string",
                                format: "binary",
                                contentEncoding: "binary"
                            },
                            {
                                minimum: w,
                                maximum: Z,
                                mime: $
                            } = v._zod.bag;
                        if (w !== void 0) A.minLength = w;
                        if (Z !== void 0) A.maxLength = Z;
                        if ($)
                            if ($.length === 1) A.contentMediaType = $[0], Object.assign(D, A);
                            else D.anyOf = $.map((F) => {
                                return {
                                    ...A,
                                    contentMediaType: F
                                }
                            });
                        else Object.assign(D, A);
                        break
                    }
                    case "transform": {
                        if (this.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
                        break
                    }
                    case "nullable": {
                        let D = this.process(V.innerType, J);
                        H.anyOf = [D, {
                            type: "null"
                        }];
                        break
                    }
                    case "nonoptional": {
                        this.process(V.innerType, J), x.ref = V.innerType;
                        break
                    }
                    case "success": {
                        let D = H;
                        D.type = "boolean";
                        break
                    }
                    case "default": {
                        this.process(V.innerType, J), x.ref = V.innerType, H.default = JSON.parse(JSON.stringify(V.defaultValue));
                        break
                    }
                    case "prefault": {
                        if (this.process(V.innerType, J), x.ref = V.innerType, this.io === "input") H._prefault = JSON.parse(JSON.stringify(V.defaultValue));
                        break
                    }
                    case "catch": {
                        this.process(V.innerType, J), x.ref = V.innerType;
                        let D;
                        try {
                            D = V.catchValue(void 0)
                        } catch {
                            throw Error("Dynamic catch values are not supported in JSON Schema")
                        }
                        H.default = D;
                        break
                    }
                    case "nan": {
                        if (this.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
                        break
                    }
                    case "template_literal": {
                        let D = H,
                            A = v._zod.pattern;
                        if (!A) throw Error("Pattern not found in template literal");
                        D.type = "string", D.pattern = A.source;
                        break
                    }
                    case "pipe": {
                        let D = this.io === "input" ? V.in._zod.def.type === "transform" ? V.out : V.in : V.out;
                        this.process(D, J), x.ref = D;
                        break
                    }
                    case "readonly": {
                        this.process(V.innerType, J), x.ref = V.innerType, H.readOnly = !0;
                        break
                    }
                    case "promise": {
                        this.process(V.innerType, J), x.ref = V.innerType;
                        break
                    }
                    case "optional": {
                        this.process(V.innerType, J), x.ref = V.innerType;
                        break
                    }
                    case "lazy": {
                        let D = v._zod.innerType;
                        this.process(D, J), x.ref = D;
                        break
                    }
                    case "custom": {
                        if (this.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
                        break
                    }
                    default:
                }
            }
        }
        let B = this.metadataRegistry.get(v);
        if (B) Object.assign(x.schema, B);
        if (this.io === "input" && L4(v)) delete x.schema.examples, delete x.schema.default;
        if (this.io === "input" && x.schema._prefault)(U = x.schema).default ?? (U.default = x.schema._prefault);
        return delete x.schema._prefault, this.seen.get(v).schema
    }
    emit(v, z) {
        let U = {
                cycles: z?.cycles ?? "ref",
                reused: z?.reused ?? "inline",
                external: z?.external ?? void 0
            },
            V = this.seen.get(v);
        if (!V) throw Error("Unprocessed schema. This is a bug in Zod.");
        let N = (O) => {
                let J = this.target === "draft-2020-12" ? "$defs" : "definitions";
                if (U.external) {
                    let A = U.external.registry.get(O[0])?.id;
                    if (A) return {
                        ref: U.external.uri(A)
                    };
                    let w = O[1].defId ?? O[1].schema.id ?? `schema${this.counter++}`;
                    return O[1].defId = w, {
                        defId: w,
                        ref: `${U.external.uri("__shared")}#/${J}/${w}`
                    }
                }
                if (O[1] === V) return {
                    ref: "#"
                };
                let H = `${"#"}/${J}/`,
                    D = O[1].schema.id ?? `__schema${this.counter++}`;
                return {
                    defId: D,
                    ref: H + D
                }
            },
            K = (O) => {
                if (O[1].schema.$ref) return;
                let J = O[1],
                    {
                        ref: q,
                        defId: H
                    } = N(O);
                if (J.def = {
                        ...J.schema
                    }, H) J.defId = H;
                let D = J.schema;
                for (let A in D) delete D[A];
                D.$ref = q
            };
        for (let O of this.seen.entries()) {
            let J = O[1];
            if (v === O[0]) {
                K(O);
                continue
            }
            if (U.external) {
                let H = U.external.registry.get(O[0])?.id;
                if (v !== O[0] && H) {
                    K(O);
                    continue
                }
            }
            if (this.metadataRegistry.get(O[0])?.id) {
                K(O);
                continue
            }
            if (J.cycle) {
                if (U.cycles === "throw") throw Error(`Cycle detected: #/${J.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
                else if (U.cycles === "ref") K(O);
                continue
            }
            if (J.count > 1) {
                if (U.reused === "ref") {
                    K(O);
                    continue
                }
            }
        }
        let x = (O, J) => {
            let q = this.seen.get(O),
                H = q.def ?? q.schema,
                D = {
                    ...H
                };
            if (q.ref === null) return;
            let A = q.ref;
            if (q.ref = null, A) {
                x(A, J);
                let w = this.seen.get(A).schema;
                if (w.$ref && J.target === "draft-7") H.allOf = H.allOf ?? [], H.allOf.push(w);
                else Object.assign(H, w), Object.assign(H, D)
            }
            if (!q.isParent) this.override({
                zodSchema: O,
                jsonSchema: H,
                path: q.path ?? []
            })
        };
        for (let O of [...this.seen.entries()].reverse()) x(O[0], {
            target: this.target
        });
        let j = {};
        if (this.target === "draft-2020-12") j.$schema = "https://json-schema.org/draft/2020-12/schema";
        else if (this.target === "draft-7") j.$schema = "http://json-schema.org/draft-07/schema#";
        else console.warn(`Invalid target: ${this.target}`);
        Object.assign(j, V.def);
        let B = U.external?.defs ?? {};
        for (let O of this.seen.entries()) {
            let J = O[1];
            if (J.def && J.defId) B[J.defId] = J.def
        }
        if (!U.external && Object.keys(B).length > 0)
            if (this.target === "draft-2020-12") j.$defs = B;
            else j.definitions = B;
        try {
            return JSON.parse(JSON.stringify(j))
        } catch (O) {
            throw Error("Error converting schema to JSON.")
        }
    }
}

function $1(v, z) {
    if (v instanceof oU) {
        let V = new pB(z),
            N = {};
        for (let j of v._idmap.entries()) {
            let [B, O] = j;
            V.process(O)
        }
        let K = {},
            x = {
                registry: v,
                uri: z?.uri || ((j) => j),
                defs: N
            };
        for (let j of v._idmap.entries()) {
            let [B, O] = j;
            K[B] = V.emit(O, {
                ...z,
                external: x
            })
        }
        if (Object.keys(N).length > 0) {
            let j = V.target === "draft-2020-12" ? "$defs" : "definitions";
            K.__shared = {
                [j]: N
            }
        }
        return {
            schemas: K
        }
    }
    let U = new pB(z);
    return U.process(v), U.emit(v, z)
}

function L4(v, z) {
    let U = z ?? {
        seen: new Set
    };
    if (U.seen.has(v)) return !1;
    U.seen.add(v);
    let N = v._zod.def;
    switch (N.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
            return !1;
        case "array":
            return L4(N.element, U);
        case "object": {
            for (let K in N.shape)
                if (L4(N.shape[K], U)) return !0;
            return !1
        }
        case "union": {
            for (let K of N.options)
                if (L4(K, U)) return !0;
            return !1
        }
        case "intersection":
            return L4(N.left, U) || L4(N.right, U);
        case "tuple": {
            for (let K of N.items)
                if (L4(K, U)) return !0;
            if (N.rest && L4(N.rest, U)) return !0;
            return !1
        }
        case "record":
            return L4(N.keyType, U) || L4(N.valueType, U);
        case "map":
            return L4(N.keyType, U) || L4(N.valueType, U);
        case "set":
            return L4(N.valueType, U);
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
            return L4(N.innerType, U);
        case "lazy":
            return L4(N.getter(), U);
        case "default":
            return L4(N.innerType, U);
        case "prefault":
            return L4(N.innerType, U);
        case "custom":
            return !1;
        case "transform":
            return !0;
        case "pipe":
            return L4(N.in, U) || L4(N.out, U);
        case "success":
            return !1;
        case "catch":
            return !1;
        default:
    }
    throw Error(`Unknown schema type: ${N.type}`)
}
var Ju = {};
var SN6 = Y("ZodMiniType", (v, z) => {
    if (!v._zod) throw Error("Uninitialized schema in ZodMiniType.");
    i6.init(v, z), v.def = z, v.parse = (U, V) => $7(v, U, V, {
        callee: v.parse
    }), v.safeParse = (U, V) => A5(v, U, V), v.parseAsync = async (U, V) => w7(v, U, V, {
        callee: v.parseAsync
    }), v.safeParseAsync = async (U, V) => $5(v, U, V), v.check = (...U) => {
        return v.clone({
            ...z,
            checks: [...z.checks ?? [], ...U.map((V) => typeof V === "function" ? {
                _zod: {
                    check: V,
                    def: {
                        check: "custom"
                    },
                    onattach: []
                }
            } : V)]
        })
    }, v.clone = (U, V) => p4(v, U, V), v.brand = () => v, v.register = (U, V) => {
        return U.add(v, V), v
    }
});
var PN6 = Y("ZodMiniObject", (v, z) => {
    nU.init(v, z), SN6.init(v, z), v6.defineLazy(v, "shape", () => z.shape)
});

function Gw(v, z) {
    let U = {
        type: "object",
        get shape() {
            return v6.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        ...v6.normalizeParams(z)
    };
    return new PN6(U)
}

function z3(v) {
    return !!v._zod
}

function w1(v) {
    let z = Object.values(v);
    if (z.length === 0) return Gw({});
    let U = z.every(z3),
        V = z.every((N) => !z3(N));
    if (U) return Gw(v);
    if (V) return vD(v);
    throw Error("Mixed Zod versions detected in object shape.")
}

function U3(v, z) {
    if (z3(v)) return A5(v, z);
    return v.safeParse(z)
}
async function nB(v, z) {
    if (z3(v)) return await $5(v, z);
    return await v.safeParseAsync(z)
}

function l8(v) {
    var z, U;
    if (!v) return;
    let V;
    if (z3(v)) V = (U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.shape;
    else V = v.shape;
    if (!V) return;
    if (typeof V === "function") try {
        return V()
    } catch (N) {
        return
    }
    return V
}

function Z1(v) {
    var z;
    if (!v) return;
    if (typeof v === "object") {
        let U = v,
            V = v;
        if (!U._def && !V._zod) {
            let N = Object.values(v);
            if (N.length > 0 && N.every((K) => typeof K === "object" && K !== null && (K._def !== void 0 || K._zod !== void 0 || typeof K.parse === "function"))) return w1(v)
        }
    }
    if (z3(v)) {
        let V = (z = v._zod) === null || z === void 0 ? void 0 : z.def;
        if (V && (V.type === "object" || V.shape !== void 0)) return v
    } else if (v.shape !== void 0) return v;
    return
}

function QB(v) {
    if (v && typeof v === "object") {
        if ("message" in v && typeof v.message === "string") return v.message;
        if ("issues" in v && Array.isArray(v.issues) && v.issues.length > 0) {
            let z = v.issues[0];
            if (z && typeof z === "object" && "message" in z) return String(z.message)
        }
        try {
            return JSON.stringify(v)
        } catch (z) {
            return String(v)
        }
    }
    return String(v)
}

function qu(v) {
    var z, U, V, N;
    if (z3(v)) return (U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.description;
    let K = v;
    return (V = v.description) !== null && V !== void 0 ? V : (N = K._def) === null || N === void 0 ? void 0 : N.description
}

function Hu(v) {
    var z, U, V;
    if (z3(v)) return ((U = (z = v._zod) === null || z === void 0 ? void 0 : z.def) === null || U === void 0 ? void 0 : U.type) === "optional";
    let N = v;
    if (typeof v.isOptional === "function") return v.isOptional();
    return ((V = N._def) === null || V === void 0 ? void 0 : V.typeName) === "ZodOptional"
}

function dB(v) {
    var z;
    if (z3(v)) {
        let x = (z = v._zod) === null || z === void 0 ? void 0 : z.def;
        if (x) {
            if (x.value !== void 0) return x.value;
            if (Array.isArray(x.values) && x.values.length > 0) return x.values[0]
        }
    }
    let V = v._def;
    if (V) {
        if (V.value !== void 0) return V.value;
        if (Array.isArray(V.values) && V.values.length > 0) return V.values[0]
    }
    let N = v.value;
    if (N !== void 0) return N;
    return
}
var C6 = {};
S8(C6, {
    xid: () => nN6,
    void: () => HK6,
    uuidv7: () => XN6,
    uuidv6: () => mN6,
    uuidv4: () => kN6,
    uuid: () => yN6,
    url: () => gN6,
    uppercase: () => GV,
    unknown: () => N4,
    union: () => P0,
    undefined: () => JK6,
    ulid: () => pN6,
    uint64: () => BK6,
    uint32: () => KK6,
    tuple: () => wK6,
    trim: () => EV,
    treeifyError: () => Bj,
    transform: () => sw,
    toUpperCase: () => PV,
    toLowerCase: () => SV,
    toJSONSchema: () => $1,
    templateLiteral: () => WK6,
    symbol: () => OK6,
    superRefine: () => ru,
    success: () => bK6,
    stringbool: () => PK6,
    stringFormat: () => zK6,
    string: () => c,
    strictObject: () => $K6,
    startsWith: () => MV,
    size: () => ZV,
    setErrorMap: () => fK6,
    set: () => FK6,
    safeParseAsync: () => Pw,
    safeParse: () => Sw,
    registry: () => rU,
    regexes: () => w5,
    regex: () => LV,
    refine: () => ou,
    record: () => v4,
    readonly: () => lu,
    property: () => Zw,
    promise: () => EK6,
    prettifyError: () => Oj,
    preprocess: () => xO,
    prefault: () => yu,
    positive: () => Dw,
    pipe: () => vO,
    partialRecord: () => ZK6,
    parseAsync: () => Ew,
    parse: () => Ww,
    overwrite: () => E9,
    optional: () => M6,
    object: () => V6,
    number: () => W0,
    nullish: () => MK6,
    nullable: () => eB,
    null: () => yV,
    normalize: () => WV,
    nonpositive: () => $w,
    nonoptional: () => ku,
    nonnegative: () => ww,
    never: () => zO,
    negative: () => Aw,
    nativeEnum: () => GK6,
    nanoid: () => iN6,
    nan: () => RK6,
    multipleOf: () => G7,
    minSize: () => I7,
    minLength: () => F5,
    mime: () => RV,
    maxSize: () => H1,
    maxLength: () => D1,
    map: () => LK6,
    lte: () => n3,
    lt: () => R9,
    lowercase: () => FV,
    looseObject: () => y3,
    locales: () => J1,
    literal: () => b6,
    length: () => A1,
    lazy: () => nu,
    ksuid: () => QN6,
    keyof: () => AK6,
    jwt: () => vK6,
    json: () => _K6,
    iso: () => L1,
    ipv6: () => oN6,
    ipv4: () => dN6,
    intersection: () => kV,
    int64: () => jK6,
    int32: () => NK6,
    int: () => _w,
    instanceof: () => SK6,
    includes: () => IV,
    guid: () => uN6,
    gte: () => F3,
    gt: () => W9,
    globalRegistry: () => A8,
    getErrorMap: () => TK6,
    function: () => hB,
    formatError: () => N1,
    float64: () => VK6,
    float32: () => UK6,
    flattenError: () => V1,
    file: () => IK6,
    enum: () => E4,
    endsWith: () => bV,
    emoji: () => cN6,
    email: () => YN6,
    e164: () => eN6,
    discriminatedUnion: () => NO,
    date: () => DK6,
    custom: () => UZ,
    cuid2: () => hN6,
    cuid: () => lN6,
    core: () => $8,
    config: () => V4,
    coerce: () => VZ,
    clone: () => p4,
    cidrv6: () => aN6,
    cidrv4: () => rN6,
    check: () => du,
    catch: () => gu,
    boolean: () => F4,
    bigint: () => xK6,
    base64url: () => sN6,
    base64: () => tN6,
    array: () => B0,
    any: () => qK6,
    _default: () => Yu,
    _ZodString: () => Cw,
    ZodXID: () => Xw,
    ZodVoid: () => Mu,
    ZodUnknown: () => Gu,
    ZodUnion: () => rw,
    ZodUndefined: () => Zu,
    ZodUUID: () => S9,
    ZodURL: () => Tw,
    ZodULID: () => mw,
    ZodType: () => U0,
    ZodTuple: () => Eu,
    ZodTransform: () => tw,
    ZodTemplateLiteral: () => hu,
    ZodSymbol: () => wu,
    ZodSuccess: () => mu,
    ZodStringFormat: () => u0,
    ZodString: () => fV,
    ZodSet: () => Pu,
    ZodRecord: () => aw,
    ZodRealError: () => F1,
    ZodReadonly: () => iu,
    ZodPromise: () => Qu,
    ZodPrefault: () => uu,
    ZodPipe: () => zZ,
    ZodOptional: () => ew,
    ZodObject: () => VO,
    ZodNumberFormat: () => G1,
    ZodNumber: () => TV,
    ZodNullable: () => fu,
    ZodNull: () => Lu,
    ZodNonOptional: () => vZ,
    ZodNever: () => Iu,
    ZodNanoID: () => uw,
    ZodNaN: () => cu,
    ZodMap: () => Su,
    ZodLiteral: () => _u,
    ZodLazy: () => pu,
    ZodKSUID: () => gw,
    ZodJWT: () => dw,
    ZodIssueCode: () => CK6,
    ZodIntersection: () => Wu,
    ZodISOTime: () => aB,
    ZodISODuration: () => tB,
    ZodISODateTime: () => oB,
    ZodISODate: () => rB,
    ZodIPv6: () => iw,
    ZodIPv4: () => cw,
    ZodGUID: () => sB,
    ZodFile: () => Cu,
    ZodError: () => fN6,
    ZodEnum: () => CV,
    ZodEmoji: () => Yw,
    ZodEmail: () => fw,
    ZodE164: () => Qw,
    ZodDiscriminatedUnion: () => Ru,
    ZodDefault: () => Tu,
    ZodDate: () => UO,
    ZodCustomStringFormat: () => $u,
    ZodCustom: () => KO,
    ZodCatch: () => Xu,
    ZodCUID2: () => kw,
    ZodCUID: () => yw,
    ZodCIDRv6: () => hw,
    ZodCIDRv4: () => lw,
    ZodBoolean: () => YV,
    ZodBigIntFormat: () => ow,
    ZodBigInt: () => uV,
    ZodBase64URL: () => nw,
    ZodBase64: () => pw,
    ZodArray: () => bu,
    ZodAny: () => Fu,
    TimePrecision: () => FB,
    NEVER: () => Kj,
    $output: () => wB,
    $input: () => ZB,
    $brand: () => xj
});
var L1 = {};
S8(L1, {
    time: () => bw,
    duration: () => Rw,
    datetime: () => Iw,
    date: () => Mw,
    ZodISOTime: () => aB,
    ZodISODuration: () => tB,
    ZodISODateTime: () => oB,
    ZodISODate: () => rB
});
var oB = Y("ZodISODateTime", (v, z) => {
    $$.init(v, z), u0.init(v, z)
});

function Iw(v) {
    return Kw(oB, v)
}
var rB = Y("ZodISODate", (v, z) => {
    w$.init(v, z), u0.init(v, z)
});

function Mw(v) {
    return xw(rB, v)
}
var aB = Y("ZodISOTime", (v, z) => {
    Z$.init(v, z), u0.init(v, z)
});

function bw(v) {
    return jw(aB, v)
}
var tB = Y("ZodISODuration", (v, z) => {
    L$.init(v, z), u0.init(v, z)
});

function Rw(v) {
    return Bw(tB, v)
}
var Au = (v, z) => {
        lU.init(v, z), v.name = "ZodError", Object.defineProperties(v, {
            format: {
                value: (U) => N1(v, U)
            },
            flatten: {
                value: (U) => V1(v, U)
            },
            addIssue: {
                value: (U) => v.issues.push(U)
            },
            addIssues: {
                value: (U) => v.issues.push(...U)
            },
            isEmpty: {
                get() {
                    return v.issues.length === 0
                }
            }
        })
    },
    fN6 = Y("ZodError", Au),
    F1 = Y("ZodError", Au, {
        Parent: Error
    });
var Ww = Jj(F1),
    Ew = qj(F1),
    Sw = Hj(F1),
    Pw = Dj(F1);
var U0 = Y("ZodType", (v, z) => {
        return i6.init(v, z), v.def = z, Object.defineProperty(v, "_def", {
            value: z
        }), v.check = (...U) => {
            return v.clone({
                ...z,
                checks: [...z.checks ?? [], ...U.map((V) => typeof V === "function" ? {
                    _zod: {
                        check: V,
                        def: {
                            check: "custom"
                        },
                        onattach: []
                    }
                } : V)]
            })
        }, v.clone = (U, V) => p4(v, U, V), v.brand = () => v, v.register = (U, V) => {
            return U.add(v, V), v
        }, v.parse = (U, V) => Ww(v, U, V, {
            callee: v.parse
        }), v.safeParse = (U, V) => Sw(v, U, V), v.parseAsync = async (U, V) => Ew(v, U, V, {
            callee: v.parseAsync
        }), v.safeParseAsync = async (U, V) => Pw(v, U, V), v.spa = v.safeParseAsync, v.refine = (U, V) => v.check(ou(U, V)), v.superRefine = (U) => v.check(ru(U)), v.overwrite = (U) => v.check(E9(U)), v.optional = () => M6(v), v.nullable = () => eB(v), v.nullish = () => M6(eB(v)), v.nonoptional = (U) => ku(v, U), v.array = () => B0(v), v.or = (U) => P0([v, U]), v.and = (U) => kV(v, U), v.transform = (U) => vO(v, sw(U)), v.default = (U) => Yu(v, U), v.prefault = (U) => yu(v, U), v.catch = (U) => gu(v, U), v.pipe = (U) => vO(v, U), v.readonly = () => lu(v), v.describe = (U) => {
            let V = v.clone();
            return A8.add(V, {
                description: U
            }), V
        }, Object.defineProperty(v, "description", {
            get() {
                return A8.get(v)?.description
            },
            configurable: !0
        }), v.meta = (...U) => {
            if (U.length === 0) return A8.get(v);
            let V = v.clone();
            return A8.add(V, U[0]), V
        }, v.isOptional = () => v.safeParse(void 0).success, v.isNullable = () => v.safeParse(null).success, v
    }),
    Cw = Y("_ZodString", (v, z) => {
        Z5.init(v, z), U0.init(v, z);
        let U = v._zod.bag;
        v.format = U.format ?? null, v.minLength = U.minimum ?? null, v.maxLength = U.maximum ?? null, v.regex = (...V) => v.check(LV(...V)), v.includes = (...V) => v.check(IV(...V)), v.startsWith = (...V) => v.check(MV(...V)), v.endsWith = (...V) => v.check(bV(...V)), v.min = (...V) => v.check(F5(...V)), v.max = (...V) => v.check(D1(...V)), v.length = (...V) => v.check(A1(...V)), v.nonempty = (...V) => v.check(F5(1, ...V)), v.lowercase = (V) => v.check(FV(V)), v.uppercase = (V) => v.check(GV(V)), v.trim = () => v.check(EV()), v.normalize = (...V) => v.check(WV(...V)), v.toLowerCase = () => v.check(SV()), v.toUpperCase = () => v.check(PV())
    }),
    fV = Y("ZodString", (v, z) => {
        Z5.init(v, z), Cw.init(v, z), v.email = (U) => v.check(aU(fw, U)), v.url = (U) => v.check(zV(Tw, U)), v.jwt = (U) => v.check(wV(dw, U)), v.emoji = (U) => v.check(UV(Yw, U)), v.guid = (U) => v.check(q1(sB, U)), v.uuid = (U) => v.check(tU(S9, U)), v.uuidv4 = (U) => v.check(sU(S9, U)), v.uuidv6 = (U) => v.check(eU(S9, U)), v.uuidv7 = (U) => v.check(vV(S9, U)), v.nanoid = (U) => v.check(VV(uw, U)), v.guid = (U) => v.check(q1(sB, U)), v.cuid = (U) => v.check(NV(yw, U)), v.cuid2 = (U) => v.check(KV(kw, U)), v.ulid = (U) => v.check(xV(mw, U)), v.base64 = (U) => v.check(DV(pw, U)), v.base64url = (U) => v.check(AV(nw, U)), v.xid = (U) => v.check(jV(Xw, U)), v.ksuid = (U) => v.check(BV(gw, U)), v.ipv4 = (U) => v.check(OV(cw, U)), v.ipv6 = (U) => v.check(JV(iw, U)), v.cidrv4 = (U) => v.check(qV(lw, U)), v.cidrv6 = (U) => v.check(HV(hw, U)), v.e164 = (U) => v.check($V(Qw, U)), v.datetime = (U) => v.check(Iw(U)), v.date = (U) => v.check(Mw(U)), v.time = (U) => v.check(bw(U)), v.duration = (U) => v.check(Rw(U))
    });

function c(v) {
    return LB(fV, v)
}
var u0 = Y("ZodStringFormat", (v, z) => {
        S0.init(v, z), Cw.init(v, z)
    }),
    fw = Y("ZodEmail", (v, z) => {
        Mj.init(v, z), u0.init(v, z)
    });

function YN6(v) {
    return aU(fw, v)
}
var sB = Y("ZodGUID", (v, z) => {
    Gj.init(v, z), u0.init(v, z)
});

function uN6(v) {
    return q1(sB, v)
}
var S9 = Y("ZodUUID", (v, z) => {
    Ij.init(v, z), u0.init(v, z)
});

function yN6(v) {
    return tU(S9, v)
}

function kN6(v) {
    return sU(S9, v)
}

function mN6(v) {
    return eU(S9, v)
}

function XN6(v) {
    return vV(S9, v)
}
var Tw = Y("ZodURL", (v, z) => {
    bj.init(v, z), u0.init(v, z)
});

function gN6(v) {
    return zV(Tw, v)
}
var Yw = Y("ZodEmoji", (v, z) => {
    Rj.init(v, z), u0.init(v, z)
});

function cN6(v) {
    return UV(Yw, v)
}
var uw = Y("ZodNanoID", (v, z) => {
    Wj.init(v, z), u0.init(v, z)
});

function iN6(v) {
    return VV(uw, v)
}
var yw = Y("ZodCUID", (v, z) => {
    Ej.init(v, z), u0.init(v, z)
});

function lN6(v) {
    return NV(yw, v)
}
var kw = Y("ZodCUID2", (v, z) => {
    Sj.init(v, z), u0.init(v, z)
});

function hN6(v) {
    return KV(kw, v)
}
var mw = Y("ZodULID", (v, z) => {
    Pj.init(v, z), u0.init(v, z)
});

function pN6(v) {
    return xV(mw, v)
}
var Xw = Y("ZodXID", (v, z) => {
    _j.init(v, z), u0.init(v, z)
});

function nN6(v) {
    return jV(Xw, v)
}
var gw = Y("ZodKSUID", (v, z) => {
    Cj.init(v, z), u0.init(v, z)
});

function QN6(v) {
    return BV(gw, v)
}
var cw = Y("ZodIPv4", (v, z) => {
    fj.init(v, z), u0.init(v, z)
});

function dN6(v) {
    return OV(cw, v)
}
var iw = Y("ZodIPv6", (v, z) => {
    Tj.init(v, z), u0.init(v, z)
});

function oN6(v) {
    return JV(iw, v)
}
var lw = Y("ZodCIDRv4", (v, z) => {
    Yj.init(v, z), u0.init(v, z)
});

function rN6(v) {
    return qV(lw, v)
}
var hw = Y("ZodCIDRv6", (v, z) => {
    uj.init(v, z), u0.init(v, z)
});

function aN6(v) {
    return HV(hw, v)
}
var pw = Y("ZodBase64", (v, z) => {
    yj.init(v, z), u0.init(v, z)
});

function tN6(v) {
    return DV(pw, v)
}
var nw = Y("ZodBase64URL", (v, z) => {
    kj.init(v, z), u0.init(v, z)
});

function sN6(v) {
    return AV(nw, v)
}
var Qw = Y("ZodE164", (v, z) => {
    mj.init(v, z), u0.init(v, z)
});

function eN6(v) {
    return $V(Qw, v)
}
var dw = Y("ZodJWT", (v, z) => {
    Xj.init(v, z), u0.init(v, z)
});

function vK6(v) {
    return wV(dw, v)
}
var $u = Y("ZodCustomStringFormat", (v, z) => {
    gj.init(v, z), u0.init(v, z)
});

function zK6(v, z, U = {}) {
    return lB($u, v, z, U)
}
var TV = Y("ZodNumber", (v, z) => {
    hU.init(v, z), U0.init(v, z), v.gt = (V, N) => v.check(W9(V, N)), v.gte = (V, N) => v.check(F3(V, N)), v.min = (V, N) => v.check(F3(V, N)), v.lt = (V, N) => v.check(R9(V, N)), v.lte = (V, N) => v.check(n3(V, N)), v.max = (V, N) => v.check(n3(V, N)), v.int = (V) => v.check(_w(V)), v.safe = (V) => v.check(_w(V)), v.positive = (V) => v.check(W9(0, V)), v.nonnegative = (V) => v.check(F3(0, V)), v.negative = (V) => v.check(R9(0, V)), v.nonpositive = (V) => v.check(n3(0, V)), v.multipleOf = (V, N) => v.check(G7(V, N)), v.step = (V, N) => v.check(G7(V, N)), v.finite = () => v;
    let U = v._zod.bag;
    v.minValue = Math.max(U.minimum ?? Number.NEGATIVE_INFINITY, U.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, v.maxValue = Math.min(U.maximum ?? Number.POSITIVE_INFINITY, U.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, v.isInt = (U.format ?? "").includes("int") || Number.isSafeInteger(U.multipleOf ?? 0.5), v.isFinite = !0, v.format = U.format ?? null
});

function W0(v) {
    return GB(TV, v)
}
var G1 = Y("ZodNumberFormat", (v, z) => {
    cj.init(v, z), TV.init(v, z)
});

function _w(v) {
    return IB(G1, v)
}

function UK6(v) {
    return MB(G1, v)
}

function VK6(v) {
    return bB(G1, v)
}

function NK6(v) {
    return RB(G1, v)
}

function KK6(v) {
    return WB(G1, v)
}
var YV = Y("ZodBoolean", (v, z) => {
    x1.init(v, z), U0.init(v, z)
});

function F4(v) {
    return EB(YV, v)
}
var uV = Y("ZodBigInt", (v, z) => {
    pU.init(v, z), U0.init(v, z), v.gte = (V, N) => v.check(F3(V, N)), v.min = (V, N) => v.check(F3(V, N)), v.gt = (V, N) => v.check(W9(V, N)), v.gte = (V, N) => v.check(F3(V, N)), v.min = (V, N) => v.check(F3(V, N)), v.lt = (V, N) => v.check(R9(V, N)), v.lte = (V, N) => v.check(n3(V, N)), v.max = (V, N) => v.check(n3(V, N)), v.positive = (V) => v.check(W9(BigInt(0), V)), v.negative = (V) => v.check(R9(BigInt(0), V)), v.nonpositive = (V) => v.check(n3(BigInt(0), V)), v.nonnegative = (V) => v.check(F3(BigInt(0), V)), v.multipleOf = (V, N) => v.check(G7(V, N));
    let U = v._zod.bag;
    v.minValue = U.minimum ?? null, v.maxValue = U.maximum ?? null, v.format = U.format ?? null
});

function xK6(v) {
    return SB(uV, v)
}
var ow = Y("ZodBigIntFormat", (v, z) => {
    ij.init(v, z), uV.init(v, z)
});

function jK6(v) {
    return PB(ow, v)
}

function BK6(v) {
    return _B(ow, v)
}
var wu = Y("ZodSymbol", (v, z) => {
    lj.init(v, z), U0.init(v, z)
});

function OK6(v) {
    return CB(wu, v)
}
var Zu = Y("ZodUndefined", (v, z) => {
    hj.init(v, z), U0.init(v, z)
});

function JK6(v) {
    return fB(Zu, v)
}
var Lu = Y("ZodNull", (v, z) => {
    pj.init(v, z), U0.init(v, z)
});

function yV(v) {
    return TB(Lu, v)
}
var Fu = Y("ZodAny", (v, z) => {
    nj.init(v, z), U0.init(v, z)
});

function qK6() {
    return YB(Fu)
}
var Gu = Y("ZodUnknown", (v, z) => {
    L7.init(v, z), U0.init(v, z)
});

function N4() {
    return F7(Gu)
}
var Iu = Y("ZodNever", (v, z) => {
    Qj.init(v, z), U0.init(v, z)
});

function zO(v) {
    return uB(Iu, v)
}
var Mu = Y("ZodVoid", (v, z) => {
    dj.init(v, z), U0.init(v, z)
});

function HK6(v) {
    return yB(Mu, v)
}
var UO = Y("ZodDate", (v, z) => {
    oj.init(v, z), U0.init(v, z), v.min = (V, N) => v.check(F3(V, N)), v.max = (V, N) => v.check(n3(V, N));
    let U = v._zod.bag;
    v.minDate = U.minimum ? new Date(U.minimum) : null, v.maxDate = U.maximum ? new Date(U.maximum) : null
});

function DK6(v) {
    return kB(UO, v)
}
var bu = Y("ZodArray", (v, z) => {
    j1.init(v, z), U0.init(v, z), v.element = z.element, v.min = (U, V) => v.check(F5(U, V)), v.nonempty = (U) => v.check(F5(1, U)), v.max = (U, V) => v.check(D1(U, V)), v.length = (U, V) => v.check(A1(U, V)), v.unwrap = () => v.element
});

function B0(v, z) {
    return _V(bu, v, z)
}

function AK6(v) {
    let z = v._zod.def.shape;
    return b6(Object.keys(z))
}
var VO = Y("ZodObject", (v, z) => {
    nU.init(v, z), U0.init(v, z), v6.defineLazy(v, "shape", () => z.shape), v.keyof = () => E4(Object.keys(v._zod.def.shape)), v.catchall = (U) => v.clone({
        ...v._zod.def,
        catchall: U
    }), v.passthrough = () => v.clone({
        ...v._zod.def,
        catchall: N4()
    }), v.loose = () => v.clone({
        ...v._zod.def,
        catchall: N4()
    }), v.strict = () => v.clone({
        ...v._zod.def,
        catchall: zO()
    }), v.strip = () => v.clone({
        ...v._zod.def,
        catchall: void 0
    }), v.extend = (U) => {
        return v6.extend(v, U)
    }, v.merge = (U) => v6.merge(v, U), v.pick = (U) => v6.pick(v, U), v.omit = (U) => v6.omit(v, U), v.partial = (...U) => v6.partial(ew, v, U[0]), v.required = (...U) => v6.required(vZ, v, U[0])
});

function V6(v, z) {
    let U = {
        type: "object",
        get shape() {
            return v6.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        ...v6.normalizeParams(z)
    };
    return new VO(U)
}

function $K6(v, z) {
    return new VO({
        type: "object",
        get shape() {
            return v6.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        catchall: zO(),
        ...v6.normalizeParams(z)
    })
}

function y3(v, z) {
    return new VO({
        type: "object",
        get shape() {
            return v6.assignProp(this, "shape", {
                ...v
            }), this.shape
        },
        catchall: N4(),
        ...v6.normalizeParams(z)
    })
}
var rw = Y("ZodUnion", (v, z) => {
    QU.init(v, z), U0.init(v, z), v.options = z.options
});

function P0(v, z) {
    return new rw({
        type: "union",
        options: v,
        ...v6.normalizeParams(z)
    })
}
var Ru = Y("ZodDiscriminatedUnion", (v, z) => {
    rw.init(v, z), rj.init(v, z)
});

function NO(v, z, U) {
    return new Ru({
        type: "union",
        options: z,
        discriminator: v,
        ...v6.normalizeParams(U)
    })
}
var Wu = Y("ZodIntersection", (v, z) => {
    aj.init(v, z), U0.init(v, z)
});

function kV(v, z) {
    return new Wu({
        type: "intersection",
        left: v,
        right: z
    })
}
var Eu = Y("ZodTuple", (v, z) => {
    L5.init(v, z), U0.init(v, z), v.rest = (U) => v.clone({
        ...v._zod.def,
        rest: U
    })
});

function wK6(v, z, U) {
    let V = z instanceof i6,
        N = V ? U : z;
    return new Eu({
        type: "tuple",
        items: v,
        rest: V ? z : null,
        ...v6.normalizeParams(N)
    })
}
var aw = Y("ZodRecord", (v, z) => {
    tj.init(v, z), U0.init(v, z), v.keyType = z.keyType, v.valueType = z.valueType
});

function v4(v, z, U) {
    return new aw({
        type: "record",
        keyType: v,
        valueType: z,
        ...v6.normalizeParams(U)
    })
}

function ZK6(v, z, U) {
    return new aw({
        type: "record",
        keyType: P0([v, zO()]),
        valueType: z,
        ...v6.normalizeParams(U)
    })
}
var Su = Y("ZodMap", (v, z) => {
    sj.init(v, z), U0.init(v, z), v.keyType = z.keyType, v.valueType = z.valueType
});

function LK6(v, z, U) {
    return new Su({
        type: "map",
        keyType: v,
        valueType: z,
        ...v6.normalizeParams(U)
    })
}
var Pu = Y("ZodSet", (v, z) => {
    ej.init(v, z), U0.init(v, z), v.min = (...U) => v.check(I7(...U)), v.nonempty = (U) => v.check(I7(1, U)), v.max = (...U) => v.check(H1(...U)), v.size = (...U) => v.check(ZV(...U))
});

function FK6(v, z) {
    return new Pu({
        type: "set",
        valueType: v,
        ...v6.normalizeParams(z)
    })
}
var CV = Y("ZodEnum", (v, z) => {
    vB.init(v, z), U0.init(v, z), v.enum = z.entries, v.options = Object.values(z.entries);
    let U = new Set(Object.keys(z.entries));
    v.extract = (V, N) => {
        let K = {};
        for (let x of V)
            if (U.has(x)) K[x] = z.entries[x];
            else throw Error(`Key ${x} not found in enum`);
        return new CV({
            ...z,
            checks: [],
            ...v6.normalizeParams(N),
            entries: K
        })
    }, v.exclude = (V, N) => {
        let K = {
            ...z.entries
        };
        for (let x of V)
            if (U.has(x)) delete K[x];
            else throw Error(`Key ${x} not found in enum`);
        return new CV({
            ...z,
            checks: [],
            ...v6.normalizeParams(N),
            entries: K
        })
    }
});

function E4(v, z) {
    let U = Array.isArray(v) ? Object.fromEntries(v.map((V) => [V, V])) : v;
    return new CV({
        type: "enum",
        entries: U,
        ...v6.normalizeParams(z)
    })
}

function GK6(v, z) {
    return new CV({
        type: "enum",
        entries: v,
        ...v6.normalizeParams(z)
    })
}
var _u = Y("ZodLiteral", (v, z) => {
    zB.init(v, z), U0.init(v, z), v.values = new Set(z.values), Object.defineProperty(v, "value", {
        get() {
            if (z.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
            return z.values[0]
        }
    })
});

function b6(v, z) {
    return new _u({
        type: "literal",
        values: Array.isArray(v) ? v : [v],
        ...v6.normalizeParams(z)
    })
}
var Cu = Y("ZodFile", (v, z) => {
    UB.init(v, z), U0.init(v, z), v.min = (U, V) => v.check(I7(U, V)), v.max = (U, V) => v.check(H1(U, V)), v.mime = (U, V) => v.check(RV(Array.isArray(U) ? U : [U], V))
});

function IK6(v) {
    return XB(Cu, v)
}
var tw = Y("ZodTransform", (v, z) => {
    B1.init(v, z), U0.init(v, z), v._zod.parse = (U, V) => {
        U.addIssue = (K) => {
            if (typeof K === "string") U.issues.push(v6.issue(K, U.value, z));
            else {
                let x = K;
                if (x.fatal) x.continue = !1;
                x.code ?? (x.code = "custom"), x.input ?? (x.input = U.value), x.inst ?? (x.inst = v), x.continue ?? (x.continue = !0), U.issues.push(v6.issue(x))
            }
        };
        let N = z.transform(U.value, U);
        if (N instanceof Promise) return N.then((K) => {
            return U.value = K, U
        });
        return U.value = N, U
    }
});

function sw(v) {
    return new tw({
        type: "transform",
        transform: v
    })
}
var ew = Y("ZodOptional", (v, z) => {
    VB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function M6(v) {
    return new ew({
        type: "optional",
        innerType: v
    })
}
var fu = Y("ZodNullable", (v, z) => {
    NB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function eB(v) {
    return new fu({
        type: "nullable",
        innerType: v
    })
}

function MK6(v) {
    return M6(eB(v))
}
var Tu = Y("ZodDefault", (v, z) => {
    KB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType, v.removeDefault = v.unwrap
});

function Yu(v, z) {
    return new Tu({
        type: "default",
        innerType: v,
        get defaultValue() {
            return typeof z === "function" ? z() : z
        }
    })
}
var uu = Y("ZodPrefault", (v, z) => {
    xB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function yu(v, z) {
    return new uu({
        type: "prefault",
        innerType: v,
        get defaultValue() {
            return typeof z === "function" ? z() : z
        }
    })
}
var vZ = Y("ZodNonOptional", (v, z) => {
    jB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function ku(v, z) {
    return new vZ({
        type: "nonoptional",
        innerType: v,
        ...v6.normalizeParams(z)
    })
}
var mu = Y("ZodSuccess", (v, z) => {
    BB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function bK6(v) {
    return new mu({
        type: "success",
        innerType: v
    })
}
var Xu = Y("ZodCatch", (v, z) => {
    OB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType, v.removeCatch = v.unwrap
});

function gu(v, z) {
    return new Xu({
        type: "catch",
        innerType: v,
        catchValue: typeof z === "function" ? z : () => z
    })
}
var cu = Y("ZodNaN", (v, z) => {
    JB.init(v, z), U0.init(v, z)
});

function RK6(v) {
    return mB(cu, v)
}
var zZ = Y("ZodPipe", (v, z) => {
    O1.init(v, z), U0.init(v, z), v.in = z.in, v.out = z.out
});

function vO(v, z) {
    return new zZ({
        type: "pipe",
        in: v,
        out: z
    })
}
var iu = Y("ZodReadonly", (v, z) => {
    qB.init(v, z), U0.init(v, z)
});

function lu(v) {
    return new iu({
        type: "readonly",
        innerType: v
    })
}
var hu = Y("ZodTemplateLiteral", (v, z) => {
    HB.init(v, z), U0.init(v, z)
});

function WK6(v, z) {
    return new hu({
        type: "template_literal",
        parts: v,
        ...v6.normalizeParams(z)
    })
}
var pu = Y("ZodLazy", (v, z) => {
    AB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.getter()
});

function nu(v) {
    return new pu({
        type: "lazy",
        getter: v
    })
}
var Qu = Y("ZodPromise", (v, z) => {
    DB.init(v, z), U0.init(v, z), v.unwrap = () => v._zod.def.innerType
});

function EK6(v) {
    return new Qu({
        type: "promise",
        innerType: v
    })
}
var KO = Y("ZodCustom", (v, z) => {
    $B.init(v, z), U0.init(v, z)
});

function du(v, z) {
    let U = new h0({
        check: "custom",
        ...v6.normalizeParams(z)
    });
    return U._zod.check = v, U
}

function UZ(v, z) {
    return gB(KO, v ?? (() => !0), z)
}

function ou(v, z = {}) {
    return cB(KO, v, z)
}

function ru(v, z) {
    let U = du((V) => {
        return V.addIssue = (N) => {
            if (typeof N === "string") V.issues.push(v6.issue(N, V.value, U._zod.def));
            else {
                let K = N;
                if (K.fatal) K.continue = !1;
                K.code ?? (K.code = "custom"), K.input ?? (K.input = V.value), K.inst ?? (K.inst = U), K.continue ?? (K.continue = !U._zod.def.abort), V.issues.push(v6.issue(K))
            }
        }, v(V.value, V)
    }, z);
    return U
}

function SK6(v, z = {
    error: `Input not instance of ${v.name}`
}) {
    let U = new KO({
        type: "custom",
        check: "custom",
        fn: (V) => V instanceof v,
        abort: !0,
        ...v6.normalizeParams(z)
    });
    return U._zod.bag.Class = v, U
}
var PK6 = (...v) => iB({
    Pipe: zZ,
    Boolean: YV,
    String: fV,
    Transform: tw
}, ...v);

function _K6(v) {
    let z = nu(() => {
        return P0([c(v), W0(), F4(), yV(), B0(z), v4(c(), z)])
    });
    return z
}

function xO(v, z) {
    return vO(sw(v), z)
}
var CK6 = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
};

function fK6(v) {
    V4({
        customError: v
    })
}

function TK6() {
    return V4().customError
}
var VZ = {};
S8(VZ, {
    string: () => YK6,
    number: () => uK6,
    date: () => mK6,
    boolean: () => yK6,
    bigint: () => kK6
});

function YK6(v) {
    return Nw(fV, v)
}

function uK6(v) {
    return Ow(TV, v)
}

function yK6(v) {
    return Jw(YV, v)
}

function kK6(v) {
    return qw(uV, v)
}

function mK6(v) {
    return Hw(UO, v)
}
V4(dU());
var mV = "2025-11-25";
var BO = [mV, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"],
    p8 = "io.modelcontextprotocol/related-task",
    OO = "2.0",
    h8 = UZ((v) => v !== null && (typeof v === "object" || typeof v === "function")),
    au = P0([c(), W0().int()]),
    tu = c(),
    XK6 = y3({
        ttl: P0([W0(), yV()]).optional(),
        pollInterval: W0().optional()
    }),
    NZ = y3({
        taskId: c()
    }),
    gK6 = y3({
        progressToken: au.optional(),
        [p8]: NZ.optional()
    }),
    G3 = y3({
        task: XK6.optional(),
        _meta: gK6.optional()
    }),
    u4 = V6({
        method: c(),
        params: G3.optional()
    }),
    M7 = y3({
        _meta: V6({
            [p8]: M6(NZ)
        }).passthrough().optional()
    }),
    Q3 = V6({
        method: c(),
        params: M7.optional()
    }),
    n4 = y3({
        _meta: y3({
            [p8]: NZ.optional()
        }).optional()
    }),
    JO = P0([c(), W0().int()]),
    su = V6({
        jsonrpc: b6(OO),
        id: JO,
        ...u4.shape
    }).strict(),
    KZ = (v) => su.safeParse(v).success,
    eu = V6({
        jsonrpc: b6(OO),
        ...Q3.shape
    }).strict(),
    vy = (v) => eu.safeParse(v).success,
    zy = V6({
        jsonrpc: b6(OO),
        id: JO,
        result: n4
    }).strict(),
    XV = (v) => zy.safeParse(v).success,
    H6;
(function(v) {
    v[v.ConnectionClosed = -32000] = "ConnectionClosed", v[v.RequestTimeout = -32001] = "RequestTimeout", v[v.ParseError = -32700] = "ParseError", v[v.InvalidRequest = -32600] = "InvalidRequest", v[v.MethodNotFound = -32601] = "MethodNotFound", v[v.InvalidParams = -32602] = "InvalidParams", v[v.InternalError = -32603] = "InternalError", v[v.UrlElicitationRequired = -32042] = "UrlElicitationRequired"
})(H6 || (H6 = {}));
var Uy = V6({
        jsonrpc: b6(OO),
        id: JO,
        error: V6({
            code: W0().int(),
            message: c(),
            data: M6(N4())
        })
    }).strict(),
    Vy = (v) => Uy.safeParse(v).success,
    qO = P0([su, eu, zy, Uy]),
    P9 = n4.strict(),
    cK6 = M7.extend({
        requestId: JO,
        reason: c().optional()
    }),
    HO = Q3.extend({
        method: b6("notifications/cancelled"),
        params: cK6
    }),
    iK6 = V6({
        src: c(),
        mimeType: c().optional(),
        sizes: B0(c()).optional()
    }),
    gV = V6({
        icons: B0(iK6).optional()
    }),
    I1 = V6({
        name: c(),
        title: c().optional()
    }),
    Ny = I1.extend({
        ...I1.shape,
        ...gV.shape,
        version: c(),
        websiteUrl: c().optional()
    }),
    lK6 = kV(V6({
        applyDefaults: F4().optional()
    }), v4(c(), N4())),
    hK6 = xO((v) => {
        if (v && typeof v === "object" && !Array.isArray(v)) {
            if (Object.keys(v).length === 0) return {
                form: {}
            }
        }
        return v
    }, kV(V6({
        form: lK6.optional(),
        url: h8.optional()
    }), v4(c(), N4()).optional())),
    pK6 = V6({
        list: M6(V6({}).passthrough()),
        cancel: M6(V6({}).passthrough()),
        requests: M6(V6({
            sampling: M6(V6({
                createMessage: M6(V6({}).passthrough())
            }).passthrough()),
            elicitation: M6(V6({
                create: M6(V6({}).passthrough())
            }).passthrough())
        }).passthrough())
    }).passthrough(),
    nK6 = V6({
        list: M6(V6({}).passthrough()),
        cancel: M6(V6({}).passthrough()),
        requests: M6(V6({
            tools: M6(V6({
                call: M6(V6({}).passthrough())
            }).passthrough())
        }).passthrough())
    }).passthrough(),
    QK6 = V6({
        experimental: v4(c(), h8).optional(),
        sampling: V6({
            context: h8.optional(),
            tools: h8.optional()
        }).optional(),
        elicitation: hK6.optional(),
        roots: V6({
            listChanged: F4().optional()
        }).optional(),
        tasks: M6(pK6)
    }),
    dK6 = G3.extend({
        protocolVersion: c(),
        capabilities: QK6,
        clientInfo: Ny
    }),
    xZ = u4.extend({
        method: b6("initialize"),
        params: dK6
    });
var oK6 = V6({
        experimental: v4(c(), h8).optional(),
        logging: h8.optional(),
        completions: h8.optional(),
        prompts: M6(V6({
            listChanged: M6(F4())
        })),
        resources: V6({
            subscribe: F4().optional(),
            listChanged: F4().optional()
        }).optional(),
        tools: V6({
            listChanged: F4().optional()
        }).optional(),
        tasks: M6(nK6)
    }).passthrough(),
    jZ = n4.extend({
        protocolVersion: c(),
        capabilities: oK6,
        serverInfo: Ny,
        instructions: c().optional()
    }),
    BZ = Q3.extend({
        method: b6("notifications/initialized")
    });
var DO = u4.extend({
        method: b6("ping")
    }),
    rK6 = V6({
        progress: W0(),
        total: M6(W0()),
        message: M6(c())
    }),
    aK6 = V6({
        ...M7.shape,
        ...rK6.shape,
        progressToken: au
    }),
    AO = Q3.extend({
        method: b6("notifications/progress"),
        params: aK6
    }),
    tK6 = G3.extend({
        cursor: tu.optional()
    }),
    cV = u4.extend({
        params: tK6.optional()
    }),
    iV = n4.extend({
        nextCursor: M6(tu)
    }),
    lV = V6({
        taskId: c(),
        status: E4(["working", "input_required", "completed", "failed", "cancelled"]),
        ttl: P0([W0(), yV()]),
        createdAt: c(),
        lastUpdatedAt: c(),
        pollInterval: M6(W0()),
        statusMessage: M6(c())
    }),
    _9 = n4.extend({
        task: lV
    }),
    sK6 = M7.merge(lV),
    hV = Q3.extend({
        method: b6("notifications/tasks/status"),
        params: sK6
    }),
    $O = u4.extend({
        method: b6("tasks/get"),
        params: G3.extend({
            taskId: c()
        })
    }),
    wO = n4.merge(lV),
    ZO = u4.extend({
        method: b6("tasks/result"),
        params: G3.extend({
            taskId: c()
        })
    }),
    LO = cV.extend({
        method: b6("tasks/list")
    }),
    FO = iV.extend({
        tasks: B0(lV)
    }),
    Ky = u4.extend({
        method: b6("tasks/cancel"),
        params: G3.extend({
            taskId: c()
        })
    }),
    xy = n4.merge(lV),
    jy = V6({
        uri: c(),
        mimeType: M6(c()),
        _meta: v4(c(), N4()).optional()
    }),
    By = jy.extend({
        text: c()
    }),
    OZ = c().refine((v) => {
        try {
            return atob(v), !0
        } catch (z) {
            return !1
        }
    }, {
        message: "Invalid Base64 string"
    }),
    Oy = jy.extend({
        blob: OZ
    }),
    M1 = V6({
        audience: B0(E4(["user", "assistant"])).optional(),
        priority: W0().min(0).max(1).optional(),
        lastModified: L1.datetime({
            offset: !0
        }).optional()
    }),
    Jy = V6({
        ...I1.shape,
        ...gV.shape,
        uri: c(),
        description: M6(c()),
        mimeType: M6(c()),
        annotations: M1.optional(),
        _meta: M6(y3({}))
    }),
    eK6 = V6({
        ...I1.shape,
        ...gV.shape,
        uriTemplate: c(),
        description: M6(c()),
        mimeType: M6(c()),
        annotations: M1.optional(),
        _meta: M6(y3({}))
    }),
    GO = cV.extend({
        method: b6("resources/list")
    }),
    JZ = iV.extend({
        resources: B0(Jy)
    }),
    IO = cV.extend({
        method: b6("resources/templates/list")
    }),
    qZ = iV.extend({
        resourceTemplates: B0(eK6)
    }),
    HZ = G3.extend({
        uri: c()
    }),
    vx6 = HZ,
    MO = u4.extend({
        method: b6("resources/read"),
        params: vx6
    }),
    DZ = n4.extend({
        contents: B0(P0([By, Oy]))
    }),
    zx6 = Q3.extend({
        method: b6("notifications/resources/list_changed")
    }),
    Ux6 = HZ,
    Vx6 = u4.extend({
        method: b6("resources/subscribe"),
        params: Ux6
    }),
    Nx6 = HZ,
    Kx6 = u4.extend({
        method: b6("resources/unsubscribe"),
        params: Nx6
    }),
    xx6 = M7.extend({
        uri: c()
    }),
    jx6 = Q3.extend({
        method: b6("notifications/resources/updated"),
        params: xx6
    }),
    Bx6 = V6({
        name: c(),
        description: M6(c()),
        required: M6(F4())
    }),
    Ox6 = V6({
        ...I1.shape,
        ...gV.shape,
        description: M6(c()),
        arguments: M6(B0(Bx6)),
        _meta: M6(y3({}))
    }),
    bO = cV.extend({
        method: b6("prompts/list")
    }),
    AZ = iV.extend({
        prompts: B0(Ox6)
    }),
    Jx6 = G3.extend({
        name: c(),
        arguments: v4(c(), c()).optional()
    }),
    RO = u4.extend({
        method: b6("prompts/get"),
        params: Jx6
    }),
    $Z = V6({
        type: b6("text"),
        text: c(),
        annotations: M1.optional(),
        _meta: v4(c(), N4()).optional()
    }),
    wZ = V6({
        type: b6("image"),
        data: OZ,
        mimeType: c(),
        annotations: M1.optional(),
        _meta: v4(c(), N4()).optional()
    }),
    ZZ = V6({
        type: b6("audio"),
        data: OZ,
        mimeType: c(),
        annotations: M1.optional(),
        _meta: v4(c(), N4()).optional()
    }),
    qx6 = V6({
        type: b6("tool_use"),
        name: c(),
        id: c(),
        input: V6({}).passthrough(),
        _meta: M6(V6({}).passthrough())
    }).passthrough(),
    Hx6 = V6({
        type: b6("resource"),
        resource: P0([By, Oy]),
        annotations: M1.optional(),
        _meta: v4(c(), N4()).optional()
    }),
    Dx6 = Jy.extend({
        type: b6("resource_link")
    }),
    LZ = P0([$Z, wZ, ZZ, Dx6, Hx6]),
    Ax6 = V6({
        role: E4(["user", "assistant"]),
        content: LZ
    }),
    FZ = n4.extend({
        description: M6(c()),
        messages: B0(Ax6)
    }),
    $x6 = Q3.extend({
        method: b6("notifications/prompts/list_changed")
    }),
    wx6 = V6({
        title: c().optional(),
        readOnlyHint: F4().optional(),
        destructiveHint: F4().optional(),
        idempotentHint: F4().optional(),
        openWorldHint: F4().optional()
    }),
    Zx6 = V6({
        taskSupport: E4(["required", "optional", "forbidden"]).optional()
    }),
    qy = V6({
        ...I1.shape,
        ...gV.shape,
        description: c().optional(),
        inputSchema: V6({
            type: b6("object"),
            properties: v4(c(), h8).optional(),
            required: B0(c()).optional()
        }).catchall(N4()),
        outputSchema: V6({
            type: b6("object"),
            properties: v4(c(), h8).optional(),
            required: B0(c()).optional()
        }).catchall(N4()).optional(),
        annotations: M6(wx6),
        execution: M6(Zx6),
        _meta: v4(c(), N4()).optional()
    }),
    WO = cV.extend({
        method: b6("tools/list")
    }),
    GZ = iV.extend({
        tools: B0(qy)
    }),
    w8 = n4.extend({
        content: B0(LZ).default([]),
        structuredContent: v4(c(), N4()).optional(),
        isError: M6(F4())
    }),
    XT6 = w8.or(n4.extend({
        toolResult: N4()
    })),
    Lx6 = G3.extend({
        name: c(),
        arguments: M6(v4(c(), N4()))
    }),
    b1 = u4.extend({
        method: b6("tools/call"),
        params: Lx6
    }),
    Fx6 = Q3.extend({
        method: b6("notifications/tools/list_changed")
    }),
    pV = E4(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]),
    Gx6 = G3.extend({
        level: pV
    }),
    IZ = u4.extend({
        method: b6("logging/setLevel"),
        params: Gx6
    }),
    Ix6 = M7.extend({
        level: pV,
        logger: c().optional(),
        data: N4()
    }),
    Mx6 = Q3.extend({
        method: b6("notifications/message"),
        params: Ix6
    }),
    bx6 = V6({
        name: c().optional()
    }),
    Rx6 = V6({
        hints: M6(B0(bx6)),
        costPriority: M6(W0().min(0).max(1)),
        speedPriority: M6(W0().min(0).max(1)),
        intelligencePriority: M6(W0().min(0).max(1))
    }),
    Wx6 = V6({
        mode: M6(E4(["auto", "required", "none"]))
    }),
    Ex6 = V6({
        type: b6("tool_result"),
        toolUseId: c().describe("The unique identifier for the corresponding tool call."),
        content: B0(LZ).default([]),
        structuredContent: V6({}).passthrough().optional(),
        isError: M6(F4()),
        _meta: M6(V6({}).passthrough())
    }).passthrough(),
    Sx6 = NO("type", [$Z, wZ, ZZ]),
    jO = NO("type", [$Z, wZ, ZZ, qx6, Ex6]),
    Px6 = V6({
        role: E4(["user", "assistant"]),
        content: P0([jO, B0(jO)]),
        _meta: M6(V6({}).passthrough())
    }).passthrough(),
    _x6 = G3.extend({
        messages: B0(Px6),
        modelPreferences: Rx6.optional(),
        systemPrompt: c().optional(),
        includeContext: E4(["none", "thisServer", "allServers"]).optional(),
        temperature: W0().optional(),
        maxTokens: W0().int(),
        stopSequences: B0(c()).optional(),
        metadata: h8.optional(),
        tools: M6(B0(qy)),
        toolChoice: M6(Wx6)
    }),
    MZ = u4.extend({
        method: b6("sampling/createMessage"),
        params: _x6
    }),
    nV = n4.extend({
        model: c(),
        stopReason: M6(E4(["endTurn", "stopSequence", "maxTokens"]).or(c())),
        role: E4(["user", "assistant"]),
        content: Sx6
    }),
    bZ = n4.extend({
        model: c(),
        stopReason: M6(E4(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(c())),
        role: E4(["user", "assistant"]),
        content: P0([jO, B0(jO)])
    }),
    Cx6 = V6({
        type: b6("boolean"),
        title: c().optional(),
        description: c().optional(),
        default: F4().optional()
    }),
    fx6 = V6({
        type: b6("string"),
        title: c().optional(),
        description: c().optional(),
        minLength: W0().optional(),
        maxLength: W0().optional(),
        format: E4(["email", "uri", "date", "date-time"]).optional(),
        default: c().optional()
    }),
    Tx6 = V6({
        type: E4(["number", "integer"]),
        title: c().optional(),
        description: c().optional(),
        minimum: W0().optional(),
        maximum: W0().optional(),
        default: W0().optional()
    }),
    Yx6 = V6({
        type: b6("string"),
        title: c().optional(),
        description: c().optional(),
        enum: B0(c()),
        default: c().optional()
    }),
    ux6 = V6({
        type: b6("string"),
        title: c().optional(),
        description: c().optional(),
        oneOf: B0(V6({
            const: c(),
            title: c()
        })),
        default: c().optional()
    }),
    yx6 = V6({
        type: b6("string"),
        title: c().optional(),
        description: c().optional(),
        enum: B0(c()),
        enumNames: B0(c()).optional(),
        default: c().optional()
    }),
    kx6 = P0([Yx6, ux6]),
    mx6 = V6({
        type: b6("array"),
        title: c().optional(),
        description: c().optional(),
        minItems: W0().optional(),
        maxItems: W0().optional(),
        items: V6({
            type: b6("string"),
            enum: B0(c())
        }),
        default: B0(c()).optional()
    }),
    Xx6 = V6({
        type: b6("array"),
        title: c().optional(),
        description: c().optional(),
        minItems: W0().optional(),
        maxItems: W0().optional(),
        items: V6({
            anyOf: B0(V6({
                const: c(),
                title: c()
            }))
        }),
        default: B0(c()).optional()
    }),
    gx6 = P0([mx6, Xx6]),
    cx6 = P0([yx6, kx6, gx6]),
    ix6 = P0([cx6, Cx6, fx6, Tx6]),
    lx6 = G3.extend({
        mode: b6("form").optional(),
        message: c(),
        requestedSchema: V6({
            type: b6("object"),
            properties: v4(c(), ix6),
            required: B0(c()).optional()
        })
    }),
    hx6 = G3.extend({
        mode: b6("url"),
        message: c(),
        elicitationId: c(),
        url: c().url()
    }),
    px6 = P0([lx6, hx6]),
    RZ = u4.extend({
        method: b6("elicitation/create"),
        params: px6
    }),
    nx6 = M7.extend({
        elicitationId: c()
    }),
    Qx6 = Q3.extend({
        method: b6("notifications/elicitation/complete"),
        params: nx6
    }),
    R1 = n4.extend({
        action: E4(["accept", "decline", "cancel"]),
        content: xO((v) => v === null ? void 0 : v, v4(c(), P0([c(), W0(), F4(), B0(c())])).optional())
    }),
    dx6 = V6({
        type: b6("ref/resource"),
        uri: c()
    });
var ox6 = V6({
        type: b6("ref/prompt"),
        name: c()
    }),
    rx6 = G3.extend({
        ref: P0([ox6, dx6]),
        argument: V6({
            name: c(),
            value: c()
        }),
        context: V6({
            arguments: v4(c(), c()).optional()
        }).optional()
    }),
    EO = u4.extend({
        method: b6("completion/complete"),
        params: rx6
    });

function Hy(v) {
    if (v.params.ref.type !== "ref/prompt") throw TypeError(`Expected CompleteRequestPrompt, but got ${v.params.ref.type}`)
}

function Dy(v) {
    if (v.params.ref.type !== "ref/resource") throw TypeError(`Expected CompleteRequestResourceTemplate, but got ${v.params.ref.type}`)
}
var WZ = n4.extend({
        completion: y3({
            values: B0(c()).max(100),
            total: M6(W0().int()),
            hasMore: M6(F4())
        })
    }),
    ax6 = V6({
        uri: c().startsWith("file://"),
        name: c().optional(),
        _meta: v4(c(), N4()).optional()
    }),
    tx6 = u4.extend({
        method: b6("roots/list")
    }),
    EZ = n4.extend({
        roots: B0(ax6)
    }),
    sx6 = Q3.extend({
        method: b6("notifications/roots/list_changed")
    }),
    gT6 = P0([DO, xZ, EO, IZ, RO, bO, GO, IO, MO, Vx6, Kx6, b1, WO, $O, ZO, LO]),
    cT6 = P0([HO, AO, BZ, sx6, hV]),
    iT6 = P0([P9, nV, bZ, R1, EZ, wO, FO, _9]),
    lT6 = P0([DO, MZ, RZ, tx6, $O, ZO, LO]),
    hT6 = P0([HO, AO, Mx6, jx6, zx6, Fx6, $x6, hV, Qx6]),
    pT6 = P0([P9, jZ, WZ, FZ, AZ, JZ, qZ, DZ, w8, GZ, wO, FO, _9]);
class x6 extends Error {
    constructor(v, z, U) {
        super(`MCP error ${v}: ${z}`);
        this.code = v, this.data = U, this.name = "McpError"
    }
    static fromError(v, z, U) {
        if (v === H6.UrlElicitationRequired && U) {
            let V = U;
            if (V.elicitations) return new Ay(V.elicitations, z)
        }
        return new x6(v, z, U)
    }
}
class Ay extends x6 {
    constructor(v, z = `URL elicitation${v.length>1?"s":""} required`) {
        super(H6.UrlElicitationRequired, z, {
            elicitations: v
        })
    }
    get elicitations() {
        var v, z;
        return (z = (v = this.data) === null || v === void 0 ? void 0 : v.elicitations) !== null && z !== void 0 ? z : []
    }
}

function G5(v) {
    return v === "completed" || v === "failed" || v === "cancelled"
}
var wy = Symbol("Let zodToJsonSchema decide on which parser to use");
var $y = {
        name: void 0,
        $refStrategy: "root",
        basePath: ["#"],
        effectStrategy: "input",
        pipeStrategy: "all",
        dateStrategy: "format:date-time",
        mapStrategy: "entries",
        removeAdditionalStrategy: "passthrough",
        allowedAdditionalProperties: !0,
        rejectedAdditionalProperties: !1,
        definitionPath: "definitions",
        target: "jsonSchema7",
        strictUnions: !1,
        definitions: {},
        errorMessages: !1,
        markdownDescription: !1,
        patternStrategy: "escape",
        applyRegexFlags: !1,
        emailStrategy: "format:email",
        base64Strategy: "contentEncoding:base64",
        nameStrategy: "ref",
        openAiAnyTypeName: "OpenAiAnyType"
    },
    Zy = (v) => typeof v === "string" ? {
        ...$y,
        name: v
    } : {
        ...$y,
        ...v
    };
var Ly = (v) => {
    let z = Zy(v),
        U = z.name !== void 0 ? [...z.basePath, z.definitionPath, z.name] : z.basePath;
    return {
        ...z,
        flags: {
            hasReferencedOpenAiAnyType: !1
        },
        currentPath: U,
        propertyPath: void 0,
        seen: new Map(Object.entries(z.definitions).map(([V, N]) => [N._def, {
            def: N._def,
            path: [...z.basePath, z.definitionPath, V],
            jsonSchema: void 0
        }]))
    }
};

function SZ(v, z, U, V) {
    if (!V?.errorMessages) return;
    if (U) v.errorMessage = {
        ...v.errorMessage,
        [z]: U
    }
}

function O0(v, z, U, V, N) {
    v[z] = U, SZ(v, z, V, N)
}
var SO = (v, z) => {
    let U = 0;
    for (; U < v.length && U < z.length; U++)
        if (v[U] !== z[U]) break;
    return [(v.length - U).toString(), ...z.slice(U)].join("/")
};

function p0(v) {
    if (v.target !== "openAi") return {};
    let z = [...v.basePath, v.definitionPath, v.openAiAnyTypeName];
    return v.flags.hasReferencedOpenAiAnyType = !0, {
        $ref: v.$refStrategy === "relative" ? SO(z, v.currentPath) : z.join("/")
    }
}

function Fy(v, z) {
    let U = {
        type: "array"
    };
    if (v.type?._def && v.type?._def?.typeName !== a.ZodAny) U.items = g6(v.type._def, {
        ...z,
        currentPath: [...z.currentPath, "items"]
    });
    if (v.minLength) O0(U, "minItems", v.minLength.value, v.minLength.message, z);
    if (v.maxLength) O0(U, "maxItems", v.maxLength.value, v.maxLength.message, z);
    if (v.exactLength) O0(U, "minItems", v.exactLength.value, v.exactLength.message, z), O0(U, "maxItems", v.exactLength.value, v.exactLength.message, z);
    return U
}

function Gy(v, z) {
    let U = {
        type: "integer",
        format: "int64"
    };
    if (!v.checks) return U;
    for (let V of v.checks) switch (V.kind) {
        case "min":
            if (z.target === "jsonSchema7")
                if (V.inclusive) O0(U, "minimum", V.value, V.message, z);
                else O0(U, "exclusiveMinimum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMinimum = !0;
                O0(U, "minimum", V.value, V.message, z)
            }
            break;
        case "max":
            if (z.target === "jsonSchema7")
                if (V.inclusive) O0(U, "maximum", V.value, V.message, z);
                else O0(U, "exclusiveMaximum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMaximum = !0;
                O0(U, "maximum", V.value, V.message, z)
            }
            break;
        case "multipleOf":
            O0(U, "multipleOf", V.value, V.message, z);
            break
    }
    return U
}

function Iy() {
    return {
        type: "boolean"
    }
}

function PO(v, z) {
    return g6(v.type._def, z)
}
var My = (v, z) => {
    return g6(v.innerType._def, z)
};

function PZ(v, z, U) {
    let V = U ?? z.dateStrategy;
    if (Array.isArray(V)) return {
        anyOf: V.map((N, K) => PZ(v, z, N))
    };
    switch (V) {
        case "string":
        case "format:date-time":
            return {
                type: "string", format: "date-time"
            };
        case "format:date":
            return {
                type: "string", format: "date"
            };
        case "integer":
            return ex6(v, z)
    }
}
var ex6 = (v, z) => {
    let U = {
        type: "integer",
        format: "unix-time"
    };
    if (z.target === "openApi3") return U;
    for (let V of v.checks) switch (V.kind) {
        case "min":
            O0(U, "minimum", V.value, V.message, z);
            break;
        case "max":
            O0(U, "maximum", V.value, V.message, z);
            break
    }
    return U
};

function by(v, z) {
    return {
        ...g6(v.innerType._def, z),
        default: v.defaultValue()
    }
}

function Ry(v, z) {
    return z.effectStrategy === "input" ? g6(v.schema._def, z) : p0(z)
}

function Wy(v) {
    return {
        type: "string",
        enum: Array.from(v.values)
    }
}
var vj6 = (v) => {
    if ("type" in v && v.type === "string") return !1;
    return "allOf" in v
};

function Ey(v, z) {
    let U = [g6(v.left._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", "0"]
        }), g6(v.right._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", "1"]
        })].filter((K) => !!K),
        V = z.target === "jsonSchema2019-09" ? {
            unevaluatedProperties: !1
        } : void 0,
        N = [];
    return U.forEach((K) => {
        if (vj6(K)) {
            if (N.push(...K.allOf), K.unevaluatedProperties === void 0) V = void 0
        } else {
            let x = K;
            if ("additionalProperties" in K && K.additionalProperties === !1) {
                let {
                    additionalProperties: j,
                    ...B
                } = K;
                x = B
            } else V = void 0;
            N.push(x)
        }
    }), N.length ? {
        allOf: N,
        ...V
    } : void 0
}

function Sy(v, z) {
    let U = typeof v.value;
    if (U !== "bigint" && U !== "number" && U !== "boolean" && U !== "string") return {
        type: Array.isArray(v.value) ? "array" : "object"
    };
    if (z.target === "openApi3") return {
        type: U === "bigint" ? "integer" : U,
        enum: [v.value]
    };
    return {
        type: U === "bigint" ? "integer" : U,
        const: v.value
    }
}
var _Z = void 0,
    Z8 = {
        cuid: /^[cC][^\s-]{8,}$/,
        cuid2: /^[0-9a-z]+$/,
        ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
        email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
        emoji: () => {
            if (_Z === void 0) _Z = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
            return _Z
        },
        uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
        ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
        ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
        base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
        nanoid: /^[a-zA-Z0-9_-]{21}$/,
        jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };

function _O(v, z) {
    let U = {
        type: "string"
    };
    if (v.checks)
        for (let V of v.checks) switch (V.kind) {
            case "min":
                O0(U, "minLength", typeof U.minLength === "number" ? Math.max(U.minLength, V.value) : V.value, V.message, z);
                break;
            case "max":
                O0(U, "maxLength", typeof U.maxLength === "number" ? Math.min(U.maxLength, V.value) : V.value, V.message, z);
                break;
            case "email":
                switch (z.emailStrategy) {
                    case "format:email":
                        L8(U, "email", V.message, z);
                        break;
                    case "format:idn-email":
                        L8(U, "idn-email", V.message, z);
                        break;
                    case "pattern:zod":
                        V3(U, Z8.email, V.message, z);
                        break
                }
                break;
            case "url":
                L8(U, "uri", V.message, z);
                break;
            case "uuid":
                L8(U, "uuid", V.message, z);
                break;
            case "regex":
                V3(U, V.regex, V.message, z);
                break;
            case "cuid":
                V3(U, Z8.cuid, V.message, z);
                break;
            case "cuid2":
                V3(U, Z8.cuid2, V.message, z);
                break;
            case "startsWith":
                V3(U, RegExp(`^${CZ(V.value,z)}`), V.message, z);
                break;
            case "endsWith":
                V3(U, RegExp(`${CZ(V.value,z)}$`), V.message, z);
                break;
            case "datetime":
                L8(U, "date-time", V.message, z);
                break;
            case "date":
                L8(U, "date", V.message, z);
                break;
            case "time":
                L8(U, "time", V.message, z);
                break;
            case "duration":
                L8(U, "duration", V.message, z);
                break;
            case "length":
                O0(U, "minLength", typeof U.minLength === "number" ? Math.max(U.minLength, V.value) : V.value, V.message, z), O0(U, "maxLength", typeof U.maxLength === "number" ? Math.min(U.maxLength, V.value) : V.value, V.message, z);
                break;
            case "includes": {
                V3(U, RegExp(CZ(V.value, z)), V.message, z);
                break
            }
            case "ip": {
                if (V.version !== "v6") L8(U, "ipv4", V.message, z);
                if (V.version !== "v4") L8(U, "ipv6", V.message, z);
                break
            }
            case "base64url":
                V3(U, Z8.base64url, V.message, z);
                break;
            case "jwt":
                V3(U, Z8.jwt, V.message, z);
                break;
            case "cidr": {
                if (V.version !== "v6") V3(U, Z8.ipv4Cidr, V.message, z);
                if (V.version !== "v4") V3(U, Z8.ipv6Cidr, V.message, z);
                break
            }
            case "emoji":
                V3(U, Z8.emoji(), V.message, z);
                break;
            case "ulid": {
                V3(U, Z8.ulid, V.message, z);
                break
            }
            case "base64": {
                switch (z.base64Strategy) {
                    case "format:binary": {
                        L8(U, "binary", V.message, z);
                        break
                    }
                    case "contentEncoding:base64": {
                        O0(U, "contentEncoding", "base64", V.message, z);
                        break
                    }
                    case "pattern:zod": {
                        V3(U, Z8.base64, V.message, z);
                        break
                    }
                }
                break
            }
            case "nanoid":
                V3(U, Z8.nanoid, V.message, z);
            case "toLowerCase":
            case "toUpperCase":
            case "trim":
                break;
            default:
                ((N) => {})(V)
        }
    return U
}

function CZ(v, z) {
    return z.patternStrategy === "escape" ? Uj6(v) : v
}
var zj6 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

function Uj6(v) {
    let z = "";
    for (let U = 0; U < v.length; U++) {
        if (!zj6.has(v[U])) z += "\\";
        z += v[U]
    }
    return z
}

function L8(v, z, U, V) {
    if (v.format || v.anyOf?.some((N) => N.format)) {
        if (!v.anyOf) v.anyOf = [];
        if (v.format) {
            if (v.anyOf.push({
                    format: v.format,
                    ...v.errorMessage && V.errorMessages && {
                        errorMessage: {
                            format: v.errorMessage.format
                        }
                    }
                }), delete v.format, v.errorMessage) {
                if (delete v.errorMessage.format, Object.keys(v.errorMessage).length === 0) delete v.errorMessage
            }
        }
        v.anyOf.push({
            format: z,
            ...U && V.errorMessages && {
                errorMessage: {
                    format: U
                }
            }
        })
    } else O0(v, "format", z, U, V)
}

function V3(v, z, U, V) {
    if (v.pattern || v.allOf?.some((N) => N.pattern)) {
        if (!v.allOf) v.allOf = [];
        if (v.pattern) {
            if (v.allOf.push({
                    pattern: v.pattern,
                    ...v.errorMessage && V.errorMessages && {
                        errorMessage: {
                            pattern: v.errorMessage.pattern
                        }
                    }
                }), delete v.pattern, v.errorMessage) {
                if (delete v.errorMessage.pattern, Object.keys(v.errorMessage).length === 0) delete v.errorMessage
            }
        }
        v.allOf.push({
            pattern: Py(z, V),
            ...U && V.errorMessages && {
                errorMessage: {
                    pattern: U
                }
            }
        })
    } else O0(v, "pattern", Py(z, V), U, V)
}

function Py(v, z) {
    if (!z.applyRegexFlags || !v.flags) return v.source;
    let U = {
            i: v.flags.includes("i"),
            m: v.flags.includes("m"),
            s: v.flags.includes("s")
        },
        V = U.i ? v.source.toLowerCase() : v.source,
        N = "",
        K = !1,
        x = !1,
        j = !1;
    for (let B = 0; B < V.length; B++) {
        if (K) {
            N += V[B], K = !1;
            continue
        }
        if (U.i) {
            if (x) {
                if (V[B].match(/[a-z]/)) {
                    if (j) N += V[B], N += `${V[B-2]}-${V[B]}`.toUpperCase(), j = !1;
                    else if (V[B + 1] === "-" && V[B + 2]?.match(/[a-z]/)) N += V[B], j = !0;
                    else N += `${V[B]}${V[B].toUpperCase()}`;
                    continue
                }
            } else if (V[B].match(/[a-z]/)) {
                N += `[${V[B]}${V[B].toUpperCase()}]`;
                continue
            }
        }
        if (U.m) {
            if (V[B] === "^") {
                N += `(^|(?<=[\r
]))`;
                continue
            } else if (V[B] === "$") {
                N += `($|(?=[\r
]))`;
                continue
            }
        }
        if (U.s && V[B] === ".") {
            N += x ? `${V[B]}\r
` : `[${V[B]}\r
]`;
            continue
        }
        if (N += V[B], V[B] === "\\") K = !0;
        else if (x && V[B] === "]") x = !1;
        else if (!x && V[B] === "[") x = !0
    }
    try {
        new RegExp(N)
    } catch {
        return console.warn(`Could not convert regex pattern at ${z.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), v.source
    }
    return N
}

function CO(v, z) {
    if (z.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    if (z.target === "openApi3" && v.keyType?._def.typeName === a.ZodEnum) return {
        type: "object",
        required: v.keyType._def.values,
        properties: v.keyType._def.values.reduce((V, N) => ({
            ...V,
            [N]: g6(v.valueType._def, {
                ...z,
                currentPath: [...z.currentPath, "properties", N]
            }) ?? p0(z)
        }), {}),
        additionalProperties: z.rejectedAdditionalProperties
    };
    let U = {
        type: "object",
        additionalProperties: g6(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "additionalProperties"]
        }) ?? z.allowedAdditionalProperties
    };
    if (z.target === "openApi3") return U;
    if (v.keyType?._def.typeName === a.ZodString && v.keyType._def.checks?.length) {
        let {
            type: V,
            ...N
        } = _O(v.keyType._def, z);
        return {
            ...U,
            propertyNames: N
        }
    } else if (v.keyType?._def.typeName === a.ZodEnum) return {
        ...U,
        propertyNames: {
            enum: v.keyType._def.values
        }
    };
    else if (v.keyType?._def.typeName === a.ZodBranded && v.keyType._def.type._def.typeName === a.ZodString && v.keyType._def.type._def.checks?.length) {
        let {
            type: V,
            ...N
        } = PO(v.keyType._def, z);
        return {
            ...U,
            propertyNames: N
        }
    }
    return U
}

function _y(v, z) {
    if (z.mapStrategy === "record") return CO(v, z);
    let U = g6(v.keyType._def, {
            ...z,
            currentPath: [...z.currentPath, "items", "items", "0"]
        }) || p0(z),
        V = g6(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "items", "items", "1"]
        }) || p0(z);
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [U, V],
            minItems: 2,
            maxItems: 2
        }
    }
}

function Cy(v) {
    let z = v.values,
        V = Object.keys(v.values).filter((K) => {
            return typeof z[z[K]] !== "number"
        }).map((K) => z[K]),
        N = Array.from(new Set(V.map((K) => typeof K)));
    return {
        type: N.length === 1 ? N[0] === "string" ? "string" : "number" : ["string", "number"],
        enum: V
    }
}

function fy(v) {
    return v.target === "openAi" ? void 0 : {
        not: p0({
            ...v,
            currentPath: [...v.currentPath, "not"]
        })
    }
}

function Ty(v) {
    return v.target === "openApi3" ? {
        enum: ["null"],
        nullable: !0
    } : {
        type: "null"
    }
}
var QV = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
};

function uy(v, z) {
    if (z.target === "openApi3") return Yy(v, z);
    let U = v.options instanceof Map ? Array.from(v.options.values()) : v.options;
    if (U.every((V) => (V._def.typeName in QV) && (!V._def.checks || !V._def.checks.length))) {
        let V = U.reduce((N, K) => {
            let x = QV[K._def.typeName];
            return x && !N.includes(x) ? [...N, x] : N
        }, []);
        return {
            type: V.length > 1 ? V : V[0]
        }
    } else if (U.every((V) => V._def.typeName === "ZodLiteral" && !V.description)) {
        let V = U.reduce((N, K) => {
            let x = typeof K._def.value;
            switch (x) {
                case "string":
                case "number":
                case "boolean":
                    return [...N, x];
                case "bigint":
                    return [...N, "integer"];
                case "object":
                    if (K._def.value === null) return [...N, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return N
            }
        }, []);
        if (V.length === U.length) {
            let N = V.filter((K, x, j) => j.indexOf(K) === x);
            return {
                type: N.length > 1 ? N : N[0],
                enum: U.reduce((K, x) => {
                    return K.includes(x._def.value) ? K : [...K, x._def.value]
                }, [])
            }
        }
    } else if (U.every((V) => V._def.typeName === "ZodEnum")) return {
        type: "string",
        enum: U.reduce((V, N) => [...V, ...N._def.values.filter((K) => !V.includes(K))], [])
    };
    return Yy(v, z)
}
var Yy = (v, z) => {
    let U = (v.options instanceof Map ? Array.from(v.options.values()) : v.options).map((V, N) => g6(V._def, {
        ...z,
        currentPath: [...z.currentPath, "anyOf", `${N}`]
    })).filter((V) => !!V && (!z.strictUnions || typeof V === "object" && Object.keys(V).length > 0));
    return U.length ? {
        anyOf: U
    } : void 0
};

function yy(v, z) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(v.innerType._def.typeName) && (!v.innerType._def.checks || !v.innerType._def.checks.length)) {
        if (z.target === "openApi3") return {
            type: QV[v.innerType._def.typeName],
            nullable: !0
        };
        return {
            type: [QV[v.innerType._def.typeName], "null"]
        }
    }
    if (z.target === "openApi3") {
        let V = g6(v.innerType._def, {
            ...z,
            currentPath: [...z.currentPath]
        });
        if (V && "$ref" in V) return {
            allOf: [V],
            nullable: !0
        };
        return V && {
            ...V,
            nullable: !0
        }
    }
    let U = g6(v.innerType._def, {
        ...z,
        currentPath: [...z.currentPath, "anyOf", "0"]
    });
    return U && {
        anyOf: [U, {
            type: "null"
        }]
    }
}

function ky(v, z) {
    let U = {
        type: "number"
    };
    if (!v.checks) return U;
    for (let V of v.checks) switch (V.kind) {
        case "int":
            U.type = "integer", SZ(U, "type", V.message, z);
            break;
        case "min":
            if (z.target === "jsonSchema7")
                if (V.inclusive) O0(U, "minimum", V.value, V.message, z);
                else O0(U, "exclusiveMinimum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMinimum = !0;
                O0(U, "minimum", V.value, V.message, z)
            }
            break;
        case "max":
            if (z.target === "jsonSchema7")
                if (V.inclusive) O0(U, "maximum", V.value, V.message, z);
                else O0(U, "exclusiveMaximum", V.value, V.message, z);
            else {
                if (!V.inclusive) U.exclusiveMaximum = !0;
                O0(U, "maximum", V.value, V.message, z)
            }
            break;
        case "multipleOf":
            O0(U, "multipleOf", V.value, V.message, z);
            break
    }
    return U
}

function my(v, z) {
    let U = z.target === "openAi",
        V = {
            type: "object",
            properties: {}
        },
        N = [],
        K = v.shape();
    for (let j in K) {
        let B = K[j];
        if (B === void 0 || B._def === void 0) continue;
        let O = Nj6(B);
        if (O && U) {
            if (B._def.typeName === "ZodOptional") B = B._def.innerType;
            if (!B.isNullable()) B = B.nullable();
            O = !1
        }
        let J = g6(B._def, {
            ...z,
            currentPath: [...z.currentPath, "properties", j],
            propertyPath: [...z.currentPath, "properties", j]
        });
        if (J === void 0) continue;
        if (V.properties[j] = J, !O) N.push(j)
    }
    if (N.length) V.required = N;
    let x = Vj6(v, z);
    if (x !== void 0) V.additionalProperties = x;
    return V
}

function Vj6(v, z) {
    if (v.catchall._def.typeName !== "ZodNever") return g6(v.catchall._def, {
        ...z,
        currentPath: [...z.currentPath, "additionalProperties"]
    });
    switch (v.unknownKeys) {
        case "passthrough":
            return z.allowedAdditionalProperties;
        case "strict":
            return z.rejectedAdditionalProperties;
        case "strip":
            return z.removeAdditionalStrategy === "strict" ? z.allowedAdditionalProperties : z.rejectedAdditionalProperties
    }
}

function Nj6(v) {
    try {
        return v.isOptional()
    } catch {
        return !0
    }
}
var Xy = (v, z) => {
    if (z.currentPath.toString() === z.propertyPath?.toString()) return g6(v.innerType._def, z);
    let U = g6(v.innerType._def, {
        ...z,
        currentPath: [...z.currentPath, "anyOf", "1"]
    });
    return U ? {
        anyOf: [{
            not: p0(z)
        }, U]
    } : p0(z)
};
var gy = (v, z) => {
    if (z.pipeStrategy === "input") return g6(v.in._def, z);
    else if (z.pipeStrategy === "output") return g6(v.out._def, z);
    let U = g6(v.in._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", "0"]
        }),
        V = g6(v.out._def, {
            ...z,
            currentPath: [...z.currentPath, "allOf", U ? "1" : "0"]
        });
    return {
        allOf: [U, V].filter((N) => N !== void 0)
    }
};

function cy(v, z) {
    return g6(v.type._def, z)
}

function iy(v, z) {
    let V = {
        type: "array",
        uniqueItems: !0,
        items: g6(v.valueType._def, {
            ...z,
            currentPath: [...z.currentPath, "items"]
        })
    };
    if (v.minSize) O0(V, "minItems", v.minSize.value, v.minSize.message, z);
    if (v.maxSize) O0(V, "maxItems", v.maxSize.value, v.maxSize.message, z);
    return V
}

function ly(v, z) {
    if (v.rest) return {
        type: "array",
        minItems: v.items.length,
        items: v.items.map((U, V) => g6(U._def, {
            ...z,
            currentPath: [...z.currentPath, "items", `${V}`]
        })).reduce((U, V) => V === void 0 ? U : [...U, V], []),
        additionalItems: g6(v.rest._def, {
            ...z,
            currentPath: [...z.currentPath, "additionalItems"]
        })
    };
    else return {
        type: "array",
        minItems: v.items.length,
        maxItems: v.items.length,
        items: v.items.map((U, V) => g6(U._def, {
            ...z,
            currentPath: [...z.currentPath, "items", `${V}`]
        })).reduce((U, V) => V === void 0 ? U : [...U, V], [])
    }
}

function hy(v) {
    return {
        not: p0(v)
    }
}

function py(v) {
    return p0(v)
}
var ny = (v, z) => {
    return g6(v.innerType._def, z)
};
var Qy = (v, z, U) => {
    switch (z) {
        case a.ZodString:
            return _O(v, U);
        case a.ZodNumber:
            return ky(v, U);
        case a.ZodObject:
            return my(v, U);
        case a.ZodBigInt:
            return Gy(v, U);
        case a.ZodBoolean:
            return Iy();
        case a.ZodDate:
            return PZ(v, U);
        case a.ZodUndefined:
            return hy(U);
        case a.ZodNull:
            return Ty(U);
        case a.ZodArray:
            return Fy(v, U);
        case a.ZodUnion:
        case a.ZodDiscriminatedUnion:
            return uy(v, U);
        case a.ZodIntersection:
            return Ey(v, U);
        case a.ZodTuple:
            return ly(v, U);
        case a.ZodRecord:
            return CO(v, U);
        case a.ZodLiteral:
            return Sy(v, U);
        case a.ZodEnum:
            return Wy(v);
        case a.ZodNativeEnum:
            return Cy(v);
        case a.ZodNullable:
            return yy(v, U);
        case a.ZodOptional:
            return Xy(v, U);
        case a.ZodMap:
            return _y(v, U);
        case a.ZodSet:
            return iy(v, U);
        case a.ZodLazy:
            return () => v.getter()._def;
        case a.ZodPromise:
            return cy(v, U);
        case a.ZodNaN:
        case a.ZodNever:
            return fy(U);
        case a.ZodEffects:
            return Ry(v, U);
        case a.ZodAny:
            return p0(U);
        case a.ZodUnknown:
            return py(U);
        case a.ZodDefault:
            return by(v, U);
        case a.ZodBranded:
            return PO(v, U);
        case a.ZodReadonly:
            return ny(v, U);
        case a.ZodCatch:
            return My(v, U);
        case a.ZodPipeline:
            return gy(v, U);
        case a.ZodFunction:
        case a.ZodVoid:
        case a.ZodSymbol:
            return;
        default:
            return ((V) => {
                return
            })(z)
    }
};

function g6(v, z, U = !1) {
    let V = z.seen.get(v);
    if (z.override) {
        let j = z.override?.(v, z, V, U);
        if (j !== wy) return j
    }
    if (V && !U) {
        let j = Kj6(V, z);
        if (j !== void 0) return j
    }
    let N = {
        def: v,
        path: z.currentPath,
        jsonSchema: void 0
    };
    z.seen.set(v, N);
    let K = Qy(v, v.typeName, z),
        x = typeof K === "function" ? g6(K(), z) : K;
    if (x) xj6(v, z, x);
    if (z.postProcess) {
        let j = z.postProcess(x, v, z);
        return N.jsonSchema = x, j
    }
    return N.jsonSchema = x, x
}
var Kj6 = (v, z) => {
        switch (z.$refStrategy) {
            case "root":
                return {
                    $ref: v.path.join("/")
                };
            case "relative":
                return {
                    $ref: SO(z.currentPath, v.path)
                };
            case "none":
            case "seen": {
                if (v.path.length < z.currentPath.length && v.path.every((U, V) => z.currentPath[V] === U)) return console.warn(`Recursive reference detected at ${z.currentPath.join("/")}! Defaulting to any`), p0(z);
                return z.$refStrategy === "seen" ? p0(z) : void 0
            }
        }
    },
    xj6 = (v, z, U) => {
        if (v.description) {
            if (U.description = v.description, z.markdownDescription) U.markdownDescription = v.description
        }
        return U
    };
var fZ = (v, z) => {
    let U = Ly(z),
        V = typeof z === "object" && z.definitions ? Object.entries(z.definitions).reduce((B, [O, J]) => ({
            ...B,
            [O]: g6(J._def, {
                ...U,
                currentPath: [...U.basePath, U.definitionPath, O]
            }, !0) ?? p0(U)
        }), {}) : void 0,
        N = typeof z === "string" ? z : z?.nameStrategy === "title" ? void 0 : z?.name,
        K = g6(v._def, N === void 0 ? U : {
            ...U,
            currentPath: [...U.basePath, U.definitionPath, N]
        }, !1) ?? p0(U),
        x = typeof z === "object" && z.name !== void 0 && z.nameStrategy === "title" ? z.name : void 0;
    if (x !== void 0) K.title = x;
    if (U.flags.hasReferencedOpenAiAnyType) {
        if (!V) V = {};
        if (!V[U.openAiAnyTypeName]) V[U.openAiAnyTypeName] = {
            type: ["string", "number", "integer", "boolean", "array", "null"],
            items: {
                $ref: U.$refStrategy === "relative" ? "1" : [...U.basePath, U.definitionPath, U.openAiAnyTypeName].join("/")
            }
        }
    }
    let j = N === void 0 ? V ? {
        ...K,
        [U.definitionPath]: V
    } : K : {
        $ref: [...U.$refStrategy === "relative" ? [] : U.basePath, U.definitionPath, N].join("/"),
        [U.definitionPath]: {
            ...V,
            [N]: K
        }
    };
    if (U.target === "jsonSchema7") j.$schema = "http://json-schema.org/draft-07/schema#";
    else if (U.target === "jsonSchema2019-09" || U.target === "openAi") j.$schema = "https://json-schema.org/draft/2019-09/schema#";
    if (U.target === "openAi" && (("anyOf" in j) || ("oneOf" in j) || ("allOf" in j) || ("type" in j) && Array.isArray(j.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    return j
};

function jj6(v) {
    if (!v) return "draft-7";
    if (v === "jsonSchema7" || v === "draft-7") return "draft-7";
    if (v === "jsonSchema2019-09" || v === "draft-2020-12") return "draft-2020-12";
    return "draft-7"
}

function TZ(v, z) {
    var U, V, N;
    if (z3(v)) return $1(v, {
        target: jj6(z === null || z === void 0 ? void 0 : z.target),
        io: (U = z === null || z === void 0 ? void 0 : z.pipeStrategy) !== null && U !== void 0 ? U : "input"
    });
    return fZ(v, {
        strictUnions: (V = z === null || z === void 0 ? void 0 : z.strictUnions) !== null && V !== void 0 ? V : !0,
        pipeStrategy: (N = z === null || z === void 0 ? void 0 : z.pipeStrategy) !== null && N !== void 0 ? N : "input"
    })
}

function YZ(v) {
    let z = l8(v),
        U = z === null || z === void 0 ? void 0 : z.method;
    if (!U) throw Error("Schema is missing a method literal");
    let V = dB(U);
    if (typeof V !== "string") throw Error("Schema method literal must be a string");
    return V
}

function uZ(v, z) {
    let U = U3(v, z);
    if (!U.success) throw U.error;
    return U.data
}
var Bj6 = 60000;
class dV {
    constructor(v) {
        if (this._options = v, this._requestMessageId = 0, this._requestHandlers = new Map, this._requestHandlerAbortControllers = new Map, this._notificationHandlers = new Map, this._responseHandlers = new Map, this._progressHandlers = new Map, this._timeoutInfo = new Map, this._pendingDebouncedNotifications = new Set, this._taskProgressTokens = new Map, this._requestResolvers = new Map, this.setNotificationHandler(HO, (z) => {
                this._oncancel(z)
            }), this.setNotificationHandler(AO, (z) => {
                this._onprogress(z)
            }), this.setRequestHandler(DO, (z) => ({})), this._taskStore = v === null || v === void 0 ? void 0 : v.taskStore, this._taskMessageQueue = v === null || v === void 0 ? void 0 : v.taskMessageQueue, this._taskStore) this.setRequestHandler($O, async (z, U) => {
            let V = await this._taskStore.getTask(z.params.taskId, U.sessionId);
            if (!V) throw new x6(H6.InvalidParams, "Failed to retrieve task: Task not found");
            return {
                ...V
            }
        }), this.setRequestHandler(ZO, async (z, U) => {
            let V = async () => {
                var N;
                let K = z.params.taskId;
                if (this._taskMessageQueue) {
                    let j;
                    while (j = await this._taskMessageQueue.dequeue(K, U.sessionId)) {
                        if (j.type === "response" || j.type === "error") {
                            let B = j.message,
                                O = B.id,
                                J = this._requestResolvers.get(O);
                            if (J)
                                if (this._requestResolvers.delete(O), j.type === "response") J(B);
                                else {
                                    let q = B,
                                        H = new x6(q.error.code, q.error.message, q.error.data);
                                    J(H)
                                }
                            else {
                                let q = j.type === "response" ? "Response" : "Error";
                                this._onerror(Error(`${q} handler missing for request ${O}`))
                            }
                            continue
                        }
                        await ((N = this._transport) === null || N === void 0 ? void 0 : N.send(j.message, {
                            relatedRequestId: U.requestId
                        }))
                    }
                }
                let x = await this._taskStore.getTask(K, U.sessionId);
                if (!x) throw new x6(H6.InvalidParams, `Task not found: ${K}`);
                if (!G5(x.status)) return await this._waitForTaskUpdate(K, U.signal), await V();
                if (G5(x.status)) {
                    let j = await this._taskStore.getTaskResult(K, U.sessionId);
                    return this._clearTaskQueue(K), {
                        ...j,
                        _meta: {
                            ...j._meta,
                            [p8]: {
                                taskId: K
                            }
                        }
                    }
                }
                return await V()
            };
            return await V()
        }), this.setRequestHandler(LO, async (z, U) => {
            var V;
            try {
                let {
                    tasks: N,
                    nextCursor: K
                } = await this._taskStore.listTasks((V = z.params) === null || V === void 0 ? void 0 : V.cursor, U.sessionId);
                return {
                    tasks: N,
                    nextCursor: K,
                    _meta: {}
                }
            } catch (N) {
                throw new x6(H6.InvalidParams, `Failed to list tasks: ${N instanceof Error?N.message:String(N)}`)
            }
        }), this.setRequestHandler(Ky, async (z, U) => {
            try {
                let V = await this._taskStore.getTask(z.params.taskId, U.sessionId);
                if (!V) throw new x6(H6.InvalidParams, `Task not found: ${z.params.taskId}`);
                if (G5(V.status)) throw new x6(H6.InvalidParams, `Cannot cancel task in terminal status: ${V.status}`);
                await this._taskStore.updateTaskStatus(z.params.taskId, "cancelled", "Client cancelled task execution.", U.sessionId), this._clearTaskQueue(z.params.taskId);
                let N = await this._taskStore.getTask(z.params.taskId, U.sessionId);
                if (!N) throw new x6(H6.InvalidParams, `Task not found after cancellation: ${z.params.taskId}`);
                return {
                    _meta: {},
                    ...N
                }
            } catch (V) {
                if (V instanceof x6) throw V;
                throw new x6(H6.InvalidRequest, `Failed to cancel task: ${V instanceof Error?V.message:String(V)}`)
            }
        })
    }
    async _oncancel(v) {
        let z = this._requestHandlerAbortControllers.get(v.params.requestId);
        z === null || z === void 0 || z.abort(v.params.reason)
    }
    _setupTimeout(v, z, U, V, N = !1) {
        this._timeoutInfo.set(v, {
            timeoutId: setTimeout(V, z),
            startTime: Date.now(),
            timeout: z,
            maxTotalTimeout: U,
            resetTimeoutOnProgress: N,
            onTimeout: V
        })
    }
    _resetTimeout(v) {
        let z = this._timeoutInfo.get(v);
        if (!z) return !1;
        let U = Date.now() - z.startTime;
        if (z.maxTotalTimeout && U >= z.maxTotalTimeout) throw this._timeoutInfo.delete(v), x6.fromError(H6.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: z.maxTotalTimeout,
            totalElapsed: U
        });
        return clearTimeout(z.timeoutId), z.timeoutId = setTimeout(z.onTimeout, z.timeout), !0
    }
    _cleanupTimeout(v) {
        let z = this._timeoutInfo.get(v);
        if (z) clearTimeout(z.timeoutId), this._timeoutInfo.delete(v)
    }
    async connect(v) {
        var z, U, V;
        this._transport = v;
        let N = (z = this.transport) === null || z === void 0 ? void 0 : z.onclose;
        this._transport.onclose = () => {
            N === null || N === void 0 || N(), this._onclose()
        };
        let K = (U = this.transport) === null || U === void 0 ? void 0 : U.onerror;
        this._transport.onerror = (j) => {
            K === null || K === void 0 || K(j), this._onerror(j)
        };
        let x = (V = this._transport) === null || V === void 0 ? void 0 : V.onmessage;
        this._transport.onmessage = (j, B) => {
            if (x === null || x === void 0 || x(j, B), XV(j) || Vy(j)) this._onresponse(j);
            else if (KZ(j)) this._onrequest(j, B);
            else if (vy(j)) this._onnotification(j);
            else this._onerror(Error(`Unknown message type: ${JSON.stringify(j)}`))
        }, await this._transport.start()
    }
    _onclose() {
        var v;
        let z = this._responseHandlers;
        this._responseHandlers = new Map, this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
        let U = x6.fromError(H6.ConnectionClosed, "Connection closed");
        this._transport = void 0, (v = this.onclose) === null || v === void 0 || v.call(this);
        for (let V of z.values()) V(U)
    }
    _onerror(v) {
        var z;
        (z = this.onerror) === null || z === void 0 || z.call(this, v)
    }
    _onnotification(v) {
        var z;
        let U = (z = this._notificationHandlers.get(v.method)) !== null && z !== void 0 ? z : this.fallbackNotificationHandler;
        if (U === void 0) return;
        Promise.resolve().then(() => U(v)).catch((V) => this._onerror(Error(`Uncaught error in notification handler: ${V}`)))
    }
    _onrequest(v, z) {
        var U, V, N, K, x, j;
        let B = (U = this._requestHandlers.get(v.method)) !== null && U !== void 0 ? U : this.fallbackRequestHandler,
            O = this._transport,
            J = (K = (N = (V = v.params) === null || V === void 0 ? void 0 : V._meta) === null || N === void 0 ? void 0 : N[p8]) === null || K === void 0 ? void 0 : K.taskId;
        if (B === void 0) {
            let w = {
                jsonrpc: "2.0",
                id: v.id,
                error: {
                    code: H6.MethodNotFound,
                    message: "Method not found"
                }
            };
            if (J && this._taskMessageQueue) this._enqueueTaskMessage(J, {
                type: "error",
                message: w,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId).catch((Z) => this._onerror(Error(`Failed to enqueue error response: ${Z}`)));
            else O === null || O === void 0 || O.send(w).catch((Z) => this._onerror(Error(`Failed to send an error response: ${Z}`)));
            return
        }
        let q = new AbortController;
        this._requestHandlerAbortControllers.set(v.id, q);
        let H = (x = v.params) === null || x === void 0 ? void 0 : x.task,
            D = this._taskStore ? this.requestTaskStore(v, O === null || O === void 0 ? void 0 : O.sessionId) : void 0,
            A = {
                signal: q.signal,
                sessionId: O === null || O === void 0 ? void 0 : O.sessionId,
                _meta: (j = v.params) === null || j === void 0 ? void 0 : j._meta,
                sendNotification: async (w) => {
                    let Z = {
                        relatedRequestId: v.id
                    };
                    if (J) Z.relatedTask = {
                        taskId: J
                    };
                    await this.notification(w, Z)
                },
                sendRequest: async (w, Z, $) => {
                    var F, L;
                    let G = {
                        ...$,
                        relatedRequestId: v.id
                    };
                    if (J && !G.relatedTask) G.relatedTask = {
                        taskId: J
                    };
                    let I = (L = (F = G.relatedTask) === null || F === void 0 ? void 0 : F.taskId) !== null && L !== void 0 ? L : J;
                    if (I && D) await D.updateTaskStatus(I, "input_required");
                    return await this.request(w, Z, G)
                },
                authInfo: z === null || z === void 0 ? void 0 : z.authInfo,
                requestId: v.id,
                requestInfo: z === null || z === void 0 ? void 0 : z.requestInfo,
                taskId: J,
                taskStore: D,
                taskRequestedTtl: H === null || H === void 0 ? void 0 : H.ttl,
                closeSSEStream: z === null || z === void 0 ? void 0 : z.closeSSEStream,
                closeStandaloneSSEStream: z === null || z === void 0 ? void 0 : z.closeStandaloneSSEStream
            };
        Promise.resolve().then(() => {
            if (H) this.assertTaskHandlerCapability(v.method)
        }).then(() => B(v, A)).then(async (w) => {
            if (q.signal.aborted) return;
            let Z = {
                result: w,
                jsonrpc: "2.0",
                id: v.id
            };
            if (J && this._taskMessageQueue) await this._enqueueTaskMessage(J, {
                type: "response",
                message: Z,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId);
            else await (O === null || O === void 0 ? void 0 : O.send(Z))
        }, async (w) => {
            var Z;
            if (q.signal.aborted) return;
            let $ = {
                jsonrpc: "2.0",
                id: v.id,
                error: {
                    code: Number.isSafeInteger(w.code) ? w.code : H6.InternalError,
                    message: (Z = w.message) !== null && Z !== void 0 ? Z : "Internal error",
                    ...w.data !== void 0 && {
                        data: w.data
                    }
                }
            };
            if (J && this._taskMessageQueue) await this._enqueueTaskMessage(J, {
                type: "error",
                message: $,
                timestamp: Date.now()
            }, O === null || O === void 0 ? void 0 : O.sessionId);
            else await (O === null || O === void 0 ? void 0 : O.send($))
        }).catch((w) => this._onerror(Error(`Failed to send response: ${w}`))).finally(() => {
            this._requestHandlerAbortControllers.delete(v.id)
        })
    }
    _onprogress(v) {
        let {
            progressToken: z,
            ...U
        } = v.params, V = Number(z), N = this._progressHandlers.get(V);
        if (!N) {
            this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(v)}`));
            return
        }
        let K = this._responseHandlers.get(V),
            x = this._timeoutInfo.get(V);
        if (x && K && x.resetTimeoutOnProgress) try {
            this._resetTimeout(V)
        } catch (j) {
            this._responseHandlers.delete(V), this._progressHandlers.delete(V), this._cleanupTimeout(V), K(j);
            return
        }
        N(U)
    }
    _onresponse(v) {
        let z = Number(v.id),
            U = this._requestResolvers.get(z);
        if (U) {
            if (this._requestResolvers.delete(z), XV(v)) U(v);
            else {
                let K = new x6(v.error.code, v.error.message, v.error.data);
                U(K)
            }
            return
        }
        let V = this._responseHandlers.get(z);
        if (V === void 0) {
            this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(v)}`));
            return
        }
        this._responseHandlers.delete(z), this._cleanupTimeout(z);
        let N = !1;
        if (XV(v) && v.result && typeof v.result === "object") {
            let K = v.result;
            if (K.task && typeof K.task === "object") {
                let x = K.task;
                if (typeof x.taskId === "string") N = !0, this._taskProgressTokens.set(x.taskId, z)
            }
        }
        if (!N) this._progressHandlers.delete(z);
        if (XV(v)) V(v);
        else {
            let K = x6.fromError(v.error.code, v.error.message, v.error.data);
            V(K)
        }
    }
    get transport() {
        return this._transport
    }
    async close() {
        var v;
        await ((v = this._transport) === null || v === void 0 ? void 0 : v.close())
    }
    async * requestStream(v, z, U) {
        var V, N, K, x;
        let {
            task: j
        } = U !== null && U !== void 0 ? U : {};
        if (!j) {
            try {
                yield {
                    type: "result",
                    result: await this.request(v, z, U)
                }
            } catch (O) {
                yield {
                    type: "error",
                    error: O instanceof x6 ? O : new x6(H6.InternalError, String(O))
                }
            }
            return
        }
        let B;
        try {
            let O = await this.request(v, _9, U);
            if (O.task) B = O.task.taskId, yield {
                type: "taskCreated",
                task: O.task
            };
            else throw new x6(H6.InternalError, "Task creation did not return a task");
            while (!0) {
                let J = await this.getTask({
                    taskId: B
                }, U);
                if (yield {
                        type: "taskStatus",
                        task: J
                    }, G5(J.status)) {
                    if (J.status === "completed") yield {
                        type: "result",
                        result: await this.getTaskResult({
                            taskId: B
                        }, z, U)
                    };
                    else if (J.status === "failed") yield {
                        type: "error",
                        error: new x6(H6.InternalError, `Task ${B} failed`)
                    };
                    else if (J.status === "cancelled") yield {
                        type: "error",
                        error: new x6(H6.InternalError, `Task ${B} was cancelled`)
                    };
                    return
                }
                if (J.status === "input_required") {
                    yield {
                        type: "result",
                        result: await this.getTaskResult({
                            taskId: B
                        }, z, U)
                    };
                    return
                }
                let q = (K = (V = J.pollInterval) !== null && V !== void 0 ? V : (N = this._options) === null || N === void 0 ? void 0 : N.defaultTaskPollInterval) !== null && K !== void 0 ? K : 1000;
                await new Promise((H) => setTimeout(H, q)), (x = U === null || U === void 0 ? void 0 : U.signal) === null || x === void 0 || x.throwIfAborted()
            }
        } catch (O) {
            yield {
                type: "error",
                error: O instanceof x6 ? O : new x6(H6.InternalError, String(O))
            }
        }
    }
    request(v, z, U) {
        let {
            relatedRequestId: V,
            resumptionToken: N,
            onresumptiontoken: K,
            task: x,
            relatedTask: j
        } = U !== null && U !== void 0 ? U : {};
        return new Promise((B, O) => {
            var J, q, H, D, A, w, Z;
            let $ = (W) => {
                O(W)
            };
            if (!this._transport) {
                $(Error("Not connected"));
                return
            }
            if (((J = this._options) === null || J === void 0 ? void 0 : J.enforceStrictCapabilities) === !0) try {
                if (this.assertCapabilityForMethod(v.method), x) this.assertTaskCapability(v.method)
            } catch (W) {
                $(W);
                return
            }(q = U === null || U === void 0 ? void 0 : U.signal) === null || q === void 0 || q.throwIfAborted();
            let F = this._requestMessageId++,
                L = {
                    ...v,
                    jsonrpc: "2.0",
                    id: F
                };
            if (U === null || U === void 0 ? void 0 : U.onprogress) this._progressHandlers.set(F, U.onprogress), L.params = {
                ...v.params,
                _meta: {
                    ...((H = v.params) === null || H === void 0 ? void 0 : H._meta) || {},
                    progressToken: F
                }
            };
            if (x) L.params = {
                ...L.params,
                task: x
            };
            if (j) L.params = {
                ...L.params,
                _meta: {
                    ...((D = L.params) === null || D === void 0 ? void 0 : D._meta) || {},
                    [p8]: j
                }
            };
            let G = (W) => {
                var E;
                this._responseHandlers.delete(F), this._progressHandlers.delete(F), this._cleanupTimeout(F), (E = this._transport) === null || E === void 0 || E.send({
                    jsonrpc: "2.0",
                    method: "notifications/cancelled",
                    params: {
                        requestId: F,
                        reason: String(W)
                    }
                }, {
                    relatedRequestId: V,
                    resumptionToken: N,
                    onresumptiontoken: K
                }).catch((T) => this._onerror(Error(`Failed to send cancellation: ${T}`)));
                let y = W instanceof x6 ? W : new x6(H6.RequestTimeout, String(W));
                O(y)
            };
            this._responseHandlers.set(F, (W) => {
                var E;
                if ((E = U === null || U === void 0 ? void 0 : U.signal) === null || E === void 0 ? void 0 : E.aborted) return;
                if (W instanceof Error) return O(W);
                try {
                    let y = U3(z, W.result);
                    if (!y.success) O(y.error);
                    else B(y.data)
                } catch (y) {
                    O(y)
                }
            }), (A = U === null || U === void 0 ? void 0 : U.signal) === null || A === void 0 || A.addEventListener("abort", () => {
                var W;
                G((W = U === null || U === void 0 ? void 0 : U.signal) === null || W === void 0 ? void 0 : W.reason)
            });
            let I = (w = U === null || U === void 0 ? void 0 : U.timeout) !== null && w !== void 0 ? w : Bj6,
                M = () => G(x6.fromError(H6.RequestTimeout, "Request timed out", {
                    timeout: I
                }));
            this._setupTimeout(F, I, U === null || U === void 0 ? void 0 : U.maxTotalTimeout, M, (Z = U === null || U === void 0 ? void 0 : U.resetTimeoutOnProgress) !== null && Z !== void 0 ? Z : !1);
            let b = j === null || j === void 0 ? void 0 : j.taskId;
            if (b) {
                let W = (E) => {
                    let y = this._responseHandlers.get(F);
                    if (y) y(E);
                    else this._onerror(Error(`Response handler missing for side-channeled request ${F}`))
                };
                this._requestResolvers.set(F, W), this._enqueueTaskMessage(b, {
                    type: "request",
                    message: L,
                    timestamp: Date.now()
                }).catch((E) => {
                    this._cleanupTimeout(F), O(E)
                })
            } else this._transport.send(L, {
                relatedRequestId: V,
                resumptionToken: N,
                onresumptiontoken: K
            }).catch((W) => {
                this._cleanupTimeout(F), O(W)
            })
        })
    }
    async getTask(v, z) {
        return this.request({
            method: "tasks/get",
            params: v
        }, wO, z)
    }
    async getTaskResult(v, z, U) {
        return this.request({
            method: "tasks/result",
            params: v
        }, z, U)
    }
    async listTasks(v, z) {
        return this.request({
            method: "tasks/list",
            params: v
        }, FO, z)
    }
    async cancelTask(v, z) {
        return this.request({
            method: "tasks/cancel",
            params: v
        }, xy, z)
    }
    async notification(v, z) {
        var U, V, N, K, x;
        if (!this._transport) throw Error("Not connected");
        this.assertNotificationCapability(v.method);
        let j = (U = z === null || z === void 0 ? void 0 : z.relatedTask) === null || U === void 0 ? void 0 : U.taskId;
        if (j) {
            let q = {
                ...v,
                jsonrpc: "2.0",
                params: {
                    ...v.params,
                    _meta: {
                        ...((V = v.params) === null || V === void 0 ? void 0 : V._meta) || {},
                        [p8]: z.relatedTask
                    }
                }
            };
            await this._enqueueTaskMessage(j, {
                type: "notification",
                message: q,
                timestamp: Date.now()
            });
            return
        }
        if (((K = (N = this._options) === null || N === void 0 ? void 0 : N.debouncedNotificationMethods) !== null && K !== void 0 ? K : []).includes(v.method) && !v.params && !(z === null || z === void 0 ? void 0 : z.relatedRequestId) && !(z === null || z === void 0 ? void 0 : z.relatedTask)) {
            if (this._pendingDebouncedNotifications.has(v.method)) return;
            this._pendingDebouncedNotifications.add(v.method), Promise.resolve().then(() => {
                var q, H;
                if (this._pendingDebouncedNotifications.delete(v.method), !this._transport) return;
                let D = {
                    ...v,
                    jsonrpc: "2.0"
                };
                if (z === null || z === void 0 ? void 0 : z.relatedTask) D = {
                    ...D,
                    params: {
                        ...D.params,
                        _meta: {
                            ...((q = D.params) === null || q === void 0 ? void 0 : q._meta) || {},
                            [p8]: z.relatedTask
                        }
                    }
                };
                (H = this._transport) === null || H === void 0 || H.send(D, z).catch((A) => this._onerror(A))
            });
            return
        }
        let J = {
            ...v,
            jsonrpc: "2.0"
        };
        if (z === null || z === void 0 ? void 0 : z.relatedTask) J = {
            ...J,
            params: {
                ...J.params,
                _meta: {
                    ...((x = J.params) === null || x === void 0 ? void 0 : x._meta) || {},
                    [p8]: z.relatedTask
                }
            }
        };
        await this._transport.send(J, z)
    }
    setRequestHandler(v, z) {
        let U = YZ(v);
        this.assertRequestHandlerCapability(U), this._requestHandlers.set(U, (V, N) => {
            let K = uZ(v, V);
            return Promise.resolve(z(K, N))
        })
    }
    removeRequestHandler(v) {
        this._requestHandlers.delete(v)
    }
    assertCanSetRequestHandler(v) {
        if (this._requestHandlers.has(v)) throw Error(`A request handler for ${v} already exists, which would be overridden`)
    }
    setNotificationHandler(v, z) {
        let U = YZ(v);
        this._notificationHandlers.set(U, (V) => {
            let N = uZ(v, V);
            return Promise.resolve(z(N))
        })
    }
    removeNotificationHandler(v) {
        this._notificationHandlers.delete(v)
    }
    _cleanupTaskProgressHandler(v) {
        let z = this._taskProgressTokens.get(v);
        if (z !== void 0) this._progressHandlers.delete(z), this._taskProgressTokens.delete(v)
    }
    async _enqueueTaskMessage(v, z, U) {
        var V;
        if (!this._taskStore || !this._taskMessageQueue) throw Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
        let N = (V = this._options) === null || V === void 0 ? void 0 : V.maxTaskQueueSize;
        await this._taskMessageQueue.enqueue(v, z, U, N)
    }
    async _clearTaskQueue(v, z) {
        if (this._taskMessageQueue) {
            let U = await this._taskMessageQueue.dequeueAll(v, z);
            for (let V of U)
                if (V.type === "request" && KZ(V.message)) {
                    let N = V.message.id,
                        K = this._requestResolvers.get(N);
                    if (K) K(new x6(H6.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(N);
                    else this._onerror(Error(`Resolver missing for request ${N} during task ${v} cleanup`))
                }
        }
    }
    async _waitForTaskUpdate(v, z) {
        var U, V, N;
        let K = (V = (U = this._options) === null || U === void 0 ? void 0 : U.defaultTaskPollInterval) !== null && V !== void 0 ? V : 1000;
        try {
            let x = await ((N = this._taskStore) === null || N === void 0 ? void 0 : N.getTask(v));
            if (x === null || x === void 0 ? void 0 : x.pollInterval) K = x.pollInterval
        } catch (x) {}
        return new Promise((x, j) => {
            if (z.aborted) {
                j(new x6(H6.InvalidRequest, "Request cancelled"));
                return
            }
            let B = setTimeout(x, K);
            z.addEventListener("abort", () => {
                clearTimeout(B), j(new x6(H6.InvalidRequest, "Request cancelled"))
            }, {
                once: !0
            })
        })
    }
    requestTaskStore(v, z) {
        let U = this._taskStore;
        if (!U) throw Error("No task store configured");
        return {
            createTask: async (V) => {
                if (!v) throw Error("No request provided");
                return await U.createTask(V, v.id, {
                    method: v.method,
                    params: v.params
                }, z)
            },
            getTask: async (V) => {
                let N = await U.getTask(V, z);
                if (!N) throw new x6(H6.InvalidParams, "Failed to retrieve task: Task not found");
                return N
            },
            storeTaskResult: async (V, N, K) => {
                await U.storeTaskResult(V, N, K, z);
                let x = await U.getTask(V, z);
                if (x) {
                    let j = hV.parse({
                        method: "notifications/tasks/status",
                        params: x
                    });
                    if (await this.notification(j), G5(x.status)) this._cleanupTaskProgressHandler(V)
                }
            },
            getTaskResult: (V) => {
                return U.getTaskResult(V, z)
            },
            updateTaskStatus: async (V, N, K) => {
                let x = await U.getTask(V, z);
                if (!x) throw new x6(H6.InvalidParams, `Task "${V}" not found - it may have been cleaned up`);
                if (G5(x.status)) throw new x6(H6.InvalidParams, `Cannot update task "${V}" from terminal status "${x.status}" to "${N}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
                await U.updateTaskStatus(V, N, K, z);
                let j = await U.getTask(V, z);
                if (j) {
                    let B = hV.parse({
                        method: "notifications/tasks/status",
                        params: j
                    });
                    if (await this.notification(B), G5(j.status)) this._cleanupTaskProgressHandler(V)
                }
            },
            listTasks: (V) => {
                return U.listTasks(V, z)
            }
        }
    }
}

function dy(v) {
    return v !== null && typeof v === "object" && !Array.isArray(v)
}

function fO(v, z) {
    let U = {
        ...v
    };
    for (let V in z) {
        let N = V,
            K = z[N];
        if (K === void 0) continue;
        let x = U[N];
        if (dy(x) && dy(K)) U[N] = {
            ...x,
            ...K
        };
        else U[N] = K
    }
    return U
}
var vg = o(BF(), 1),
    zg = o(eX(), 1);

function tH6() {
    let v = new vg.Ajv({
        strict: !1,
        validateFormats: !0,
        validateSchema: !1,
        allErrors: !0
    });
    return zg.default(v), v
}
class FN {
    constructor(v) {
        this._ajv = v !== null && v !== void 0 ? v : tH6()
    }
    getValidator(v) {
        var z;
        let U = "$id" in v && typeof v.$id === "string" ? (z = this._ajv.getSchema(v.$id)) !== null && z !== void 0 ? z : this._ajv.compile(v) : this._ajv.compile(v);
        return (V) => {
            if (U(V)) return {
                valid: !0,
                data: V,
                errorMessage: void 0
            };
            else return {
                valid: !1,
                data: void 0,
                errorMessage: this._ajv.errorsText(U.errors)
            }
        }
    }
}
class wF {
    constructor(v) {
        this._client = v
    }
    async * callToolStream(v, z = w8, U) {
        var V;
        let N = this._client,
            K = {
                ...U,
                task: (V = U === null || U === void 0 ? void 0 : U.task) !== null && V !== void 0 ? V : N.isToolTask(v.name) ? {} : void 0
            },
            x = N.requestStream({
                method: "tools/call",
                params: v
            }, z, K),
            j = N.getToolOutputValidator(v.name);
        for await (let B of x) {
            if (B.type === "result" && j) {
                let O = B.result;
                if (!O.structuredContent && !O.isError) {
                    yield {
                        type: "error",
                        error: new x6(H6.InvalidRequest, `Tool ${v.name} has an output schema but did not return structured content`)
                    };
                    return
                }
                if (O.structuredContent) try {
                    let J = j(O.structuredContent);
                    if (!J.valid) {
                        yield {
                            type: "error",
                            error: new x6(H6.InvalidParams, `Structured content does not match the tool's output schema: ${J.errorMessage}`)
                        };
                        return
                    }
                } catch (J) {
                    if (J instanceof x6) {
                        yield {
                            type: "error",
                            error: J
                        };
                        return
                    }
                    yield {
                        type: "error",
                        error: new x6(H6.InvalidParams, `Failed to validate structured content: ${J instanceof Error?J.message:String(J)}`)
                    };
                    return
                }
            }
            yield B
        }
    }
    async getTask(v, z) {
        return this._client.getTask({
            taskId: v
        }, z)
    }
    async getTaskResult(v, z, U) {
        return this._client.getTaskResult({
            taskId: v
        }, z, U)
    }
    async listTasks(v, z) {
        return this._client.listTasks(v ? {
            cursor: v
        } : void 0, z)
    }
    async cancelTask(v, z) {
        return this._client.cancelTask({
            taskId: v
        }, z)
    }
    requestStream(v, z, U) {
        return this._client.requestStream(v, z, U)
    }
}

function $J(v, z, U) {
    var V;
    if (!v) throw Error(`${U} does not support task creation (required for ${z})`);
    switch (z) {
        case "tools/call":
            if (!((V = v.tools) === null || V === void 0 ? void 0 : V.call)) throw Error(`${U} does not support task creation for tools/call (required for ${z})`);
            break;
        default:
            break
    }
}

function wJ(v, z, U) {
    var V, N;
    if (!v) throw Error(`${U} does not support task creation (required for ${z})`);
    switch (z) {
        case "sampling/createMessage":
            if (!((V = v.sampling) === null || V === void 0 ? void 0 : V.createMessage)) throw Error(`${U} does not support task creation for sampling/createMessage (required for ${z})`);
            break;
        case "elicitation/create":
            if (!((N = v.elicitation) === null || N === void 0 ? void 0 : N.create)) throw Error(`${U} does not support task creation for elicitation/create (required for ${z})`);
            break;
        default:
            break
    }
}

function ZJ(v, z) {
    if (!v || z === null || typeof z !== "object") return;
    if (v.type === "object" && v.properties && typeof v.properties === "object") {
        let U = z,
            V = v.properties;
        for (let N of Object.keys(V)) {
            let K = V[N];
            if (U[N] === void 0 && Object.prototype.hasOwnProperty.call(K, "default")) U[N] = K.default;
            if (U[N] !== void 0) ZJ(K, U[N])
        }
    }
    if (Array.isArray(v.anyOf))
        for (let U of v.anyOf) ZJ(U, z);
    if (Array.isArray(v.oneOf))
        for (let U of v.oneOf) ZJ(U, z)
}

function sH6(v) {
    if (!v) return {
        supportsFormMode: !1,
        supportsUrlMode: !1
    };
    let z = v.form !== void 0,
        U = v.url !== void 0;
    return {
        supportsFormMode: z || !z && !U,
        supportsUrlMode: U
    }
}
class ZF extends dV {
    constructor(v, z) {
        var U, V;
        super(z);
        this._clientInfo = v, this._cachedToolOutputValidators = new Map, this._cachedKnownTaskTools = new Set, this._cachedRequiredTaskTools = new Set, this._capabilities = (U = z === null || z === void 0 ? void 0 : z.capabilities) !== null && U !== void 0 ? U : {}, this._jsonSchemaValidator = (V = z === null || z === void 0 ? void 0 : z.jsonSchemaValidator) !== null && V !== void 0 ? V : new FN
    }
    get experimental() {
        if (!this._experimental) this._experimental = {
            tasks: new wF(this)
        };
        return this._experimental
    }
    registerCapabilities(v) {
        if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
        this._capabilities = fO(this._capabilities, v)
    }
    setRequestHandler(v, z) {
        var U, V, N;
        let K = l8(v),
            x = K === null || K === void 0 ? void 0 : K.method;
        if (!x) throw Error("Schema is missing a method literal");
        let j;
        if (z3(x)) {
            let O = x,
                J = (U = O._zod) === null || U === void 0 ? void 0 : U.def;
            j = (V = J === null || J === void 0 ? void 0 : J.value) !== null && V !== void 0 ? V : O.value
        } else {
            let O = x,
                J = O._def;
            j = (N = J === null || J === void 0 ? void 0 : J.value) !== null && N !== void 0 ? N : O.value
        }
        if (typeof j !== "string") throw Error("Schema method literal must be a string");
        let B = j;
        if (B === "elicitation/create") {
            let O = async (J, q) => {
                var H, D, A;
                let w = U3(RZ, J);
                if (!w.success) {
                    let W = w.error instanceof Error ? w.error.message : String(w.error);
                    throw new x6(H6.InvalidParams, `Invalid elicitation request: ${W}`)
                }
                let {
                    params: Z
                } = w.data, $ = (H = Z.mode) !== null && H !== void 0 ? H : "form", {
                    supportsFormMode: F,
                    supportsUrlMode: L
                } = sH6(this._capabilities.elicitation);
                if ($ === "form" && !F) throw new x6(H6.InvalidParams, "Client does not support form-mode elicitation requests");
                if ($ === "url" && !L) throw new x6(H6.InvalidParams, "Client does not support URL-mode elicitation requests");
                let G = await Promise.resolve(z(J, q));
                if (Z.task) {
                    let W = U3(_9, G);
                    if (!W.success) {
                        let E = W.error instanceof Error ? W.error.message : String(W.error);
                        throw new x6(H6.InvalidParams, `Invalid task creation result: ${E}`)
                    }
                    return W.data
                }
                let I = U3(R1, G);
                if (!I.success) {
                    let W = I.error instanceof Error ? I.error.message : String(I.error);
                    throw new x6(H6.InvalidParams, `Invalid elicitation result: ${W}`)
                }
                let M = I.data,
                    b = $ === "form" ? Z.requestedSchema : void 0;
                if ($ === "form" && M.action === "accept" && M.content && b) {
                    if ((A = (D = this._capabilities.elicitation) === null || D === void 0 ? void 0 : D.form) === null || A === void 0 ? void 0 : A.applyDefaults) try {
                        ZJ(b, M.content)
                    } catch (W) {}
                }
                return M
            };
            return super.setRequestHandler(v, O)
        }
        if (B === "sampling/createMessage") {
            let O = async (J, q) => {
                let H = U3(MZ, J);
                if (!H.success) {
                    let Z = H.error instanceof Error ? H.error.message : String(H.error);
                    throw new x6(H6.InvalidParams, `Invalid sampling request: ${Z}`)
                }
                let {
                    params: D
                } = H.data, A = await Promise.resolve(z(J, q));
                if (D.task) {
                    let Z = U3(_9, A);
                    if (!Z.success) {
                        let $ = Z.error instanceof Error ? Z.error.message : String(Z.error);
                        throw new x6(H6.InvalidParams, `Invalid task creation result: ${$}`)
                    }
                    return Z.data
                }
                let w = U3(nV, A);
                if (!w.success) {
                    let Z = w.error instanceof Error ? w.error.message : String(w.error);
                    throw new x6(H6.InvalidParams, `Invalid sampling result: ${Z}`)
                }
                return w.data
            };
            return super.setRequestHandler(v, O)
        }
        return super.setRequestHandler(v, z)
    }
    assertCapability(v, z) {
        var U;
        if (!((U = this._serverCapabilities) === null || U === void 0 ? void 0 : U[v])) throw Error(`Server does not support ${v} (required for ${z})`)
    }
    async connect(v, z) {
        if (await super.connect(v), v.sessionId !== void 0) return;
        try {
            let U = await this.request({
                method: "initialize",
                params: {
                    protocolVersion: mV,
                    capabilities: this._capabilities,
                    clientInfo: this._clientInfo
                }
            }, jZ, z);
            if (U === void 0) throw Error(`Server sent invalid initialize result: ${U}`);
            if (!BO.includes(U.protocolVersion)) throw Error(`Server's protocol version is not supported: ${U.protocolVersion}`);
            if (this._serverCapabilities = U.capabilities, this._serverVersion = U.serverInfo, v.setProtocolVersion) v.setProtocolVersion(U.protocolVersion);
            this._instructions = U.instructions, await this.notification({
                method: "notifications/initialized"
            })
        } catch (U) {
            throw this.close(), U
        }
    }
    getServerCapabilities() {
        return this._serverCapabilities
    }
    getServerVersion() {
        return this._serverVersion
    }
    getInstructions() {
        return this._instructions
    }
    assertCapabilityForMethod(v) {
        var z, U, V, N, K;
        switch (v) {
            case "logging/setLevel":
                if (!((z = this._serverCapabilities) === null || z === void 0 ? void 0 : z.logging)) throw Error(`Server does not support logging (required for ${v})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!((U = this._serverCapabilities) === null || U === void 0 ? void 0 : U.prompts)) throw Error(`Server does not support prompts (required for ${v})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
            case "resources/subscribe":
            case "resources/unsubscribe":
                if (!((V = this._serverCapabilities) === null || V === void 0 ? void 0 : V.resources)) throw Error(`Server does not support resources (required for ${v})`);
                if (v === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) throw Error(`Server does not support resource subscriptions (required for ${v})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!((N = this._serverCapabilities) === null || N === void 0 ? void 0 : N.tools)) throw Error(`Server does not support tools (required for ${v})`);
                break;
            case "completion/complete":
                if (!((K = this._serverCapabilities) === null || K === void 0 ? void 0 : K.completions)) throw Error(`Server does not support completions (required for ${v})`);
                break;
            case "initialize":
                break;
            case "ping":
                break
        }
    }
    assertNotificationCapability(v) {
        var z;
        switch (v) {
            case "notifications/roots/list_changed":
                if (!((z = this._capabilities.roots) === null || z === void 0 ? void 0 : z.listChanged)) throw Error(`Client does not support roots list changed notifications (required for ${v})`);
                break;
            case "notifications/initialized":
                break;
            case "notifications/cancelled":
                break;
            case "notifications/progress":
                break
        }
    }
    assertRequestHandlerCapability(v) {
        if (!this._capabilities) return;
        switch (v) {
            case "sampling/createMessage":
                if (!this._capabilities.sampling) throw Error(`Client does not support sampling capability (required for ${v})`);
                break;
            case "elicitation/create":
                if (!this._capabilities.elicitation) throw Error(`Client does not support elicitation capability (required for ${v})`);
                break;
            case "roots/list":
                if (!this._capabilities.roots) throw Error(`Client does not support roots capability (required for ${v})`);
                break;
            case "tasks/get":
            case "tasks/list":
            case "tasks/result":
            case "tasks/cancel":
                if (!this._capabilities.tasks) throw Error(`Client does not support tasks capability (required for ${v})`);
                break;
            case "ping":
                break
        }
    }
    assertTaskCapability(v) {
        var z, U;
        $J((U = (z = this._serverCapabilities) === null || z === void 0 ? void 0 : z.tasks) === null || U === void 0 ? void 0 : U.requests, v, "Server")
    }
    assertTaskHandlerCapability(v) {
        var z;
        if (!this._capabilities) return;
        wJ((z = this._capabilities.tasks) === null || z === void 0 ? void 0 : z.requests, v, "Client")
    }
    async ping(v) {
        return this.request({
            method: "ping"
        }, P9, v)
    }
    async complete(v, z) {
        return this.request({
            method: "completion/complete",
            params: v
        }, WZ, z)
    }
    async setLoggingLevel(v, z) {
        return this.request({
            method: "logging/setLevel",
            params: {
                level: v
            }
        }, P9, z)
    }
    async getPrompt(v, z) {
        return this.request({
            method: "prompts/get",
            params: v
        }, FZ, z)
    }
    async listPrompts(v, z) {
        return this.request({
            method: "prompts/list",
            params: v
        }, AZ, z)
    }
    async listResources(v, z) {
        return this.request({
            method: "resources/list",
            params: v
        }, JZ, z)
    }
    async listResourceTemplates(v, z) {
        return this.request({
            method: "resources/templates/list",
            params: v
        }, qZ, z)
    }
    async readResource(v, z) {
        return this.request({
            method: "resources/read",
            params: v
        }, DZ, z)
    }
    async subscribeResource(v, z) {
        return this.request({
            method: "resources/subscribe",
            params: v
        }, P9, z)
    }
    async unsubscribeResource(v, z) {
        return this.request({
            method: "resources/unsubscribe",
            params: v
        }, P9, z)
    }
    async callTool(v, z = w8, U) {
        if (this.isToolTaskRequired(v.name)) throw new x6(H6.InvalidRequest, `Tool "${v.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
        let V = await this.request({
                method: "tools/call",
                params: v
            }, z, U),
            N = this.getToolOutputValidator(v.name);
        if (N) {
            if (!V.structuredContent && !V.isError) throw new x6(H6.InvalidRequest, `Tool ${v.name} has an output schema but did not return structured content`);
            if (V.structuredContent) try {
                let K = N(V.structuredContent);
                if (!K.valid) throw new x6(H6.InvalidParams, `Structured content does not match the tool's output schema: ${K.errorMessage}`)
            } catch (K) {
                if (K instanceof x6) throw K;
                throw new x6(H6.InvalidParams, `Failed to validate structured content: ${K instanceof Error?K.message:String(K)}`)
            }
        }
        return V
    }
    isToolTask(v) {
        var z, U, V, N;
        if (!((N = (V = (U = (z = this._serverCapabilities) === null || z === void 0 ? void 0 : z.tasks) === null || U === void 0 ? void 0 : U.requests) === null || V === void 0 ? void 0 : V.tools) === null || N === void 0 ? void 0 : N.call)) return !1;
        return this._cachedKnownTaskTools.has(v)
    }
    isToolTaskRequired(v) {
        return this._cachedRequiredTaskTools.has(v)
    }
    cacheToolMetadata(v) {
        var z;
        this._cachedToolOutputValidators.clear(), this._cachedKnownTaskTools.clear(), this._cachedRequiredTaskTools.clear();
        for (let U of v) {
            if (U.outputSchema) {
                let N = this._jsonSchemaValidator.getValidator(U.outputSchema);
                this._cachedToolOutputValidators.set(U.name, N)
            }
            let V = (z = U.execution) === null || z === void 0 ? void 0 : z.taskSupport;
            if (V === "required" || V === "optional") this._cachedKnownTaskTools.add(U.name);
            if (V === "required") this._cachedRequiredTaskTools.add(U.name)
        }
    }
    getToolOutputValidator(v) {
        return this._cachedToolOutputValidators.get(v)
    }
    async listTools(v, z) {
        let U = await this.request({
            method: "tools/list",
            params: v
        }, GZ, z);
        return this.cacheToolMetadata(U.tools), U
    }
    async sendRootsListChanged() {
        return this.notification({
            method: "notifications/roots/list_changed"
        })
    }
}
var Vg = o(eJ(), 1),
    GN = o(require("node:process")),
    Ng = require("node:stream");
class LF {
    append(v) {
        this._buffer = this._buffer ? Buffer.concat([this._buffer, v]) : v
    }
    readMessage() {
        if (!this._buffer) return null;
        let v = this._buffer.indexOf(`
`);
        if (v === -1) return null;
        let z = this._buffer.toString("utf8", 0, v).replace(/\r$/, "");
        return this._buffer = this._buffer.subarray(v + 1), eH6(z)
    }
    clear() {
        this._buffer = void 0
    }
}

function eH6(v) {
    return qO.parse(JSON.parse(v))
}

function Ug(v) {
    return JSON.stringify(v) + `
`
}
var vD6 = GN.default.platform === "win32" ? ["APPDATA", "HOMEDRIVE", "HOMEPATH", "LOCALAPPDATA", "PATH", "PROCESSOR_ARCHITECTURE", "SYSTEMDRIVE", "SYSTEMROOT", "TEMP", "USERNAME", "USERPROFILE", "PROGRAMFILES"] : ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"];

function zD6() {
    let v = {};
    for (let z of vD6) {
        let U = GN.default.env[z];
        if (U === void 0) continue;
        if (U.startsWith("()")) continue;
        v[z] = U
    }
    return v
}
class FF {
    constructor(v) {
        if (this._readBuffer = new LF, this._stderrStream = null, this._serverParams = v, v.stderr === "pipe" || v.stderr === "overlapped") this._stderrStream = new Ng.PassThrough
    }
    async start() {
        if (this._process) throw Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        return new Promise((v, z) => {
            var U, V, N, K, x;
            if (this._process = Vg.default(this._serverParams.command, (U = this._serverParams.args) !== null && U !== void 0 ? U : [], {
                    env: {
                        ...zD6(),
                        ...this._serverParams.env
                    },
                    stdio: ["pipe", "pipe", (V = this._serverParams.stderr) !== null && V !== void 0 ? V : "inherit"],
                    shell: !1,
                    windowsHide: GN.default.platform === "win32" && UD6(),
                    cwd: this._serverParams.cwd
                }), this._process.on("error", (j) => {
                    var B;
                    z(j), (B = this.onerror) === null || B === void 0 || B.call(this, j)
                }), this._process.on("spawn", () => {
                    v()
                }), this._process.on("close", (j) => {
                    var B;
                    this._process = void 0, (B = this.onclose) === null || B === void 0 || B.call(this)
                }), (N = this._process.stdin) === null || N === void 0 || N.on("error", (j) => {
                    var B;
                    (B = this.onerror) === null || B === void 0 || B.call(this, j)
                }), (K = this._process.stdout) === null || K === void 0 || K.on("data", (j) => {
                    this._readBuffer.append(j), this.processReadBuffer()
                }), (x = this._process.stdout) === null || x === void 0 || x.on("error", (j) => {
                    var B;
                    (B = this.onerror) === null || B === void 0 || B.call(this, j)
                }), this._stderrStream && this._process.stderr) this._process.stderr.pipe(this._stderrStream)
        })
    }
    get stderr() {
        var v, z;
        if (this._stderrStream) return this._stderrStream;
        return (z = (v = this._process) === null || v === void 0 ? void 0 : v.stderr) !== null && z !== void 0 ? z : null
    }
    get pid() {
        var v, z;
        return (z = (v = this._process) === null || v === void 0 ? void 0 : v.pid) !== null && z !== void 0 ? z : null
    }
    processReadBuffer() {
        var v, z;
        while (!0) try {
            let U = this._readBuffer.readMessage();
            if (U === null) break;
            (v = this.onmessage) === null || v === void 0 || v.call(this, U)
        } catch (U) {
            (z = this.onerror) === null || z === void 0 || z.call(this, U)
        }
    }
    async close() {
        var v;
        if (this._process) {
            let z = this._process;
            this._process = void 0;
            let U = new Promise((V) => {
                z.once("close", () => {
                    V()
                })
            });
            try {
                (v = z.stdin) === null || v === void 0 || v.end()
            } catch (V) {}
            if (await Promise.race([U, new Promise((V) => setTimeout(V, 2000).unref())]), z.exitCode === null) {
                try {
                    z.kill("SIGTERM")
                } catch (V) {}
                await Promise.race([U, new Promise((V) => setTimeout(V, 2000).unref())])
            }
            if (z.exitCode === null) try {
                z.kill("SIGKILL")
            } catch (V) {}
        }
        this._readBuffer.clear()
    }
    send(v) {
        return new Promise((z) => {
            var U;
            if (!((U = this._process) === null || U === void 0 ? void 0 : U.stdin)) throw Error("Not connected");
            let V = Ug(v);
            if (this._process.stdin.write(V)) z();
            else this._process.stdin.once("drain", z)
        })
    }
}

function UD6() {
    return "type" in GN.default
}
class IN {
    output;
    getClaudeBinary;
    client = null;
    transport = null;
    constructor(v, z) {
        this.output = v;
        this.getClaudeBinary = z
    }
    async connect() {
        if (this.client) return !0;
        try {
            let {
                pathToClaudeCodeExecutable: v,
                executableArgs: z,
                env: U
            } = this.getClaudeBinary(), V, N;
            if (z.length > 0) V = v, N = [...z, "--claude-in-chrome-mcp"];
            else if (v.endsWith(".js")) V = "node", N = [v, "--claude-in-chrome-mcp"];
            else V = v, N = ["--claude-in-chrome-mcp"];
            return this.output.info(`Chrome MCP: Connecting to server with command: ${V} ${N.join(" ")}`), this.transport = new FF({
                command: V,
                args: N,
                env: {
                    ...U,
                    USER_TYPE: "external"
                }
            }), this.client = new ZF({
                name: "claude-vscode-chrome-mcp-client",
                version: "2.1.42"
            }, {
                capabilities: {}
            }), await this.client.connect(this.transport), this.output.info("Chrome MCP: Successfully connected to server"), !0
        } catch (v) {
            return this.output.error(`Chrome MCP: Failed to connect to server: ${v}`), this.client = null, this.transport = null, !1
        }
    }
    async disconnect() {
        if (this.client) {
            try {
                await this.client.close(), this.output.info("Chrome MCP: Disconnected from server")
            } catch (v) {
                this.output.error(`Chrome MCP: Error disconnecting: ${v}`)
            }
            this.client = null
        }
        if (this.transport) {
            try {
                await this.transport.close()
            } catch {}
            this.transport = null
        }
    }
    async createNewBrowserTab() {
        if (!await this.connect() || !this.client) throw Error("Failed to connect to Chrome MCP server");
        try {
            let z = await this.client.callTool({
                name: "tabs_context_mcp",
                arguments: {
                    createIfEmpty: !0
                }
            }, w8);
            if (z.isError) {
                let V = Kg(z.content);
                throw Error(`Failed to create new tab: ${V}`)
            }
            let U = z.content;
            if (Array.isArray(U) && U.length > 0) {
                let V = U.find((N) => N.type === "text");
                if (V && "text" in V) {
                    let N = JSON.parse(V.text);
                    return {
                        tabGroupId: String(N.tabGroupId),
                        tabId: N.tabId
                    }
                }
            }
            throw Error("Unexpected response format from tabs_create")
        } catch (z) {
            throw this.output.error(`Chrome MCP: Error calling tabs_create: ${z}`), await this.disconnect(), z
        }
    }
    async getBrowserTabs() {
        if (!await this.connect() || !this.client) return [];
        try {
            let z = await this.client.callTool({
                    name: "tabs_context_mcp",
                    arguments: {
                        createIfEmpty: !1
                    }
                }, w8),
                U = {
                    tabGroupId: "",
                    tabId: 0,
                    title: "new tab",
                    url: ""
                };
            if (z.isError) {
                if (Kg(z.content).includes("No tab available")) return [U];
                return this.output.warn(`Chrome MCP: tabs_context returned error: ${JSON.stringify(z.content)}`), []
            }
            let V = z.content;
            if (Array.isArray(V) && V.length > 0) {
                let N = V.find((K) => K.type === "text");
                if (N && "text" in N) try {
                    let K = JSON.parse(N.text),
                        x = String(K.tabGroupId),
                        j = (K.availableTabs || []).map((B) => ({
                            ...B,
                            tabGroupId: x
                        }));
                    return j.push(U), j
                } catch (K) {
                    if (N.text.includes("No MCP tab groups found.")) return [U];
                    this.output.warn(`Chrome MCP: Failed to parse tabs_context response: ${K}`), this.output.warn(`Response text: ${N.text}`)
                }
            }
            return []
        } catch (z) {
            return this.output.error(`Chrome MCP: Error calling tabs_context: ${z}`), await this.disconnect(), []
        }
    }
}

function Kg(v) {
    if (typeof v === "string") return v;
    if (Array.isArray(v)) return v.map((z) => {
        if (z && typeof z === "object" && "text" in z && typeof z.text === "string") return z.text
    }).join("");
    return ""
}
var GF = require("fs/promises"),
    xg = require("os"),
    c1 = require("path"),
    jg = "https://claude.ai/chrome",
    VD6 = "fcoeoabgfenejglbffodgkkbkcdhcgfn";

function ND6() {
    return [VD6]
}
var KD6 = ["chrome", "brave", "arc", "edge", "chromium", "vivaldi", "opera"],
    xD6 = {
        chrome: {
            macos: ["Library", "Application Support", "Google", "Chrome"],
            linux: [".config", "google-chrome"],
            windows: {
                path: ["Google", "Chrome", "User Data"]
            }
        },
        brave: {
            macos: ["Library", "Application Support", "BraveSoftware", "Brave-Browser"],
            linux: [".config", "BraveSoftware", "Brave-Browser"],
            windows: {
                path: ["BraveSoftware", "Brave-Browser", "User Data"]
            }
        },
        arc: {
            macos: ["Library", "Application Support", "Arc", "User Data"],
            linux: [],
            windows: {
                path: ["Arc", "User Data"]
            }
        },
        chromium: {
            macos: ["Library", "Application Support", "Chromium"],
            linux: [".config", "chromium"],
            windows: {
                path: ["Chromium", "User Data"]
            }
        },
        edge: {
            macos: ["Library", "Application Support", "Microsoft Edge"],
            linux: [".config", "microsoft-edge"],
            windows: {
                path: ["Microsoft", "Edge", "User Data"]
            }
        },
        vivaldi: {
            macos: ["Library", "Application Support", "Vivaldi"],
            linux: [".config", "vivaldi"],
            windows: {
                path: ["Vivaldi", "User Data"]
            }
        },
        opera: {
            macos: ["Library", "Application Support", "com.operasoftware.Opera"],
            linux: [".config", "opera"],
            windows: {
                path: ["Opera Software", "Opera Stable"],
                useRoaming: !0
            }
        }
    };

function jD6() {
    let v = xg.homedir(),
        z = [];
    for (let U of KD6) {
        let V = xD6[U],
            N;
        switch (process.platform) {
            case "darwin":
                N = V.macos;
                break;
            case "linux":
                N = V.linux;
                break;
            case "win32": {
                if (V.windows.path.length > 0) {
                    let K = V.windows.useRoaming ? c1.join(v, "AppData", "Roaming") : c1.join(v, "AppData", "Local");
                    z.push({
                        browser: U,
                        path: c1.join(K, ...V.windows.path)
                    })
                }
                continue
            }
        }
        if (N && N.length > 0) z.push({
            browser: U,
            path: c1.join(v, ...N)
        })
    }
    return z
}
async function BD6(v, z) {
    if (v.length === 0) return z?.("[Claude in Chrome] No browser paths to check"), {
        isInstalled: !1,
        browser: null
    };
    let U = ND6();
    for (let {
            browser: V,
            path: N
        }
        of v) {
        let K = [];
        try {
            K = await GF.readdir(N, {
                withFileTypes: !0
            })
        } catch (j) {
            let B = j.code;
            if (B === "ENOENT" || B === "EACCES" || B === "EPERM") continue;
            throw j
        }
        let x = K.filter((j) => j.isDirectory()).filter((j) => j.name === "Default" || j.name.startsWith("Profile ")).map((j) => j.name);
        if (x.length > 0) z?.(`[Claude in Chrome] Found ${V} profiles: ${x.join(", ")}`);
        for (let j of x)
            for (let B of U) {
                let O = c1.join(N, j, "Extensions", B);
                try {
                    return await GF.readdir(O), z?.(`[Claude in Chrome] Extension ${B} found in ${V} ${j}`), {
                        isInstalled: !0,
                        browser: V
                    }
                } catch {}
            }
    }
    return z?.("[Claude in Chrome] Extension not found in any browser"), {
        isInstalled: !1,
        browser: null
    }
}
async function OD6(v, z) {
    return (await BD6(v, z)).isInstalled
}
async function Bg(v) {
    let z = jD6();
    return OD6(z, v)
}
var IF = o(require("vscode"));
var Og = s.object({
        command: s.literal("get_status")
    }),
    Jg = s.object({
        command: s.literal("get_stack_trace"),
        threadId: s.number().optional().describe("Thread ID to get stack trace for. Defaults to the main thread."),
        startFrame: s.number().optional().describe("Index of the first frame to return (0-based)"),
        levels: s.number().optional().describe("Maximum number of frames to return")
    }),
    qg = s.object({
        command: s.literal("get_scopes"),
        frameId: s.number().optional().describe("The frame ID to get scopes for. Defaults to the current frame.")
    }),
    Hg = s.object({
        command: s.literal("get_variables"),
        variablesReference: s.number().describe("The reference ID for the variables scope. Use get_scopes first to get available scope references."),
        filter: s.enum(["indexed", "named"]).optional().describe("Filter to only indexed or named variables"),
        start: s.number().optional().describe("Index of the first variable to return"),
        count: s.number().optional().describe("Number of variables to return")
    }),
    Dg = s.object({
        command: s.literal("evaluate"),
        expression: s.string().describe("The expression to evaluate"),
        frameId: s.number().optional().describe("The frame ID for context. Defaults to the current frame."),
        context: s.enum(["watch", "repl", "hover", "clipboard"]).optional().describe("The context in which the expression is evaluated. Affects formatting and side effects.")
    }),
    Ag = s.object({
        command: s.literal("step_over"),
        threadId: s.number().optional().describe("Thread ID to step. Defaults to the main thread.")
    }),
    $g = s.object({
        command: s.literal("step_into"),
        threadId: s.number().optional().describe("Thread ID to step. Defaults to the main thread.")
    }),
    wg = s.object({
        command: s.literal("step_out"),
        threadId: s.number().optional().describe("Thread ID to step. Defaults to the main thread.")
    }),
    Zg = s.object({
        command: s.literal("continue"),
        threadId: s.number().optional().describe("Thread ID to continue. Defaults to the main thread.")
    }),
    Lg = s.object({
        command: s.literal("pause"),
        threadId: s.number().optional().describe("Thread ID to pause. Defaults to the main thread.")
    }),
    Fg = s.object({
        command: s.literal("set_breakpoint"),
        filePath: s.string().describe("Absolute path to the source file"),
        line: s.number().describe("Line number for the breakpoint (1-based)"),
        condition: s.string().optional().describe("Optional condition expression that must be true for the breakpoint to trigger"),
        hitCondition: s.string().optional().describe('Optional hit count expression (e.g., ">5" to break after 5 hits)'),
        logMessage: s.string().optional().describe("Optional log message to print instead of breaking. Supports {} interpolation.")
    }),
    Gg = s.object({
        command: s.literal("remove_breakpoints"),
        filePath: s.string().describe("Absolute path to the source file")
    }),
    Ig = s.object({
        command: s.literal("get_threads")
    }),
    Mg = s.object({
        command: s.literal("get_loaded_sources")
    }),
    bg = s.object({
        command: s.literal("set_exception_breakpoints"),
        filters: s.array(s.string()).describe('Exception filter IDs to enable. Common values: "all" (all exceptions), "uncaught" (uncaught exceptions only)')
    }),
    JD6 = [Og, Jg, qg, Hg, Dg, Ag, $g, wg, Zg, Lg, Fg, Gg, Ig, Mg, bg];

function qD6() {
    let v = [],
        z = {};
    for (let U of JD6)
        for (let [V, N] of Object.entries(U.shape))
            if (V === "command") v.push(N.value);
            else if (!z[V]) z[V] = N.isOptional() ? N : N.optional();
    return z.command = s.enum(v).describe("The debugger command to execute"), z
}
var _m6 = qD6(),
    Cm6 = s.discriminatedUnion("command", [Og, Jg, qg, Hg, Dg, Ag, $g, wg, Zg, Lg, Fg, Gg, Ig, Mg, bg]);
var x3 = o(require("vscode"));
var Ym6 = x3.NotebookCellOutputItem.error(Error("")).mime;
var Rg = 30000,
    LJ = 600000,
    FJ = 50000;
var Wg = C6.strictObject({
        command: C6.literal("get_status")
    }),
    Eg = C6.strictObject({
        command: C6.literal("execute_code"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        code: C6.string().describe("Code to execute directly on the kernel"),
        timeout: C6.number().min(1).max(LJ).optional().describe(`Timeout in milliseconds (default: ${Rg}, max: ${LJ}). Execution is interrupted when timeout is reached.`),
        max_chars: C6.number().min(1).optional().describe(`Maximum characters of text output to return (default: ${FJ}). Output beyond this limit is truncated.`)
    }),
    Sg = C6.strictObject({
        command: C6.literal("execute_cell"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        cell_id: C6.string().optional().describe("Stable cell ID (preferred, from get_cells output)"),
        cell_index: C6.number().optional().describe("Cell index (0-based, use if cell_id not available)"),
        timeout: C6.number().min(0).max(LJ).optional().describe(`Timeout in milliseconds (default: ${Rg}, max: ${LJ}). Set to 0 for fire-and-forget execution (returns immediately, use get_cell_output to poll).`),
        max_chars: C6.number().min(1).optional().describe(`Maximum characters of text output to return (default: ${FJ}). Output beyond this limit is truncated.`)
    }),
    Pg = C6.strictObject({
        command: C6.literal("get_cells"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        includeOutputs: C6.boolean().optional().describe("Include cell outputs in the response"),
        max_chars: C6.number().min(1).optional().describe(`Maximum characters of output text per cell (default: ${FJ}). Only applies when includeOutputs is true.`)
    }),
    _g = C6.strictObject({
        command: C6.literal("add_cell"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        content: C6.string().describe("Content for the new cell"),
        cell_type: C6.enum(["code", "markdown"]).optional().describe("Type of cell to add. Defaults to code."),
        cell_id: C6.string().optional().describe("Reference cell ID (from get_cells output). Use with insert_position."),
        cell_index: C6.number().optional().describe("Reference cell index (0-based). Use with insert_position."),
        insert_position: C6.enum(["before", "after"]).optional().describe("Insert before or after the reference cell. Defaults to after. If no cell reference provided, inserts at end of notebook.")
    }),
    Cg = C6.strictObject({
        command: C6.literal("delete_cell"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        cell_id: C6.string().optional().describe("Stable cell ID (preferred, from get_cells output)"),
        cell_index: C6.number().optional().describe("Cell index (0-based, use if cell_id not available)")
    }),
    fg = C6.strictObject({
        command: C6.literal("str_replace_cell"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        cell_id: C6.string().optional().describe("Stable cell ID (preferred, from get_cells output)"),
        cell_index: C6.number().optional().describe("Cell index (0-based, use if cell_id not available)"),
        old_str: C6.string().describe("Text to find in the cell (must match exactly, including whitespace)"),
        new_str: C6.string().describe("Text to replace old_str with"),
        cell_type: C6.enum(["code", "markdown"]).optional().describe("Optionally change the cell type")
    }),
    Tg = C6.strictObject({
        command: C6.literal("interrupt"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)")
    }),
    Yg = C6.strictObject({
        command: C6.literal("get_cell_output"),
        notebook_path: C6.string().describe("Path to the notebook (from get_status output)"),
        cell_id: C6.string().optional().describe("Stable cell ID (from get_cells output). Omit both cell_id and cell_index to get outputs for all code cells."),
        cell_index: C6.number().optional().describe("Cell index (0-based). Omit both cell_id and cell_index to get outputs for all code cells."),
        max_chars: C6.number().min(1).optional().describe(`Maximum characters of text output to return (default: ${FJ}). Output beyond this limit is truncated.`)
    }),
    um6 = C6.discriminatedUnion("command", [Wg, Eg, Sg, Pg, _g, Cg, fg, Tg, Yg]),
    HD6 = [Wg, Eg, Sg, Pg, _g, Cg, fg, Tg, Yg];

function DD6() {
    let v = [],
        z = {};
    for (let U of HD6)
        for (let [V, N] of Object.entries(U.shape))
            if (V === "command") v.push(N.value);
            else if (!z[V]) z[V] = N.isOptional() ? N : N.optional();
    return z.command = C6.enum(v).describe("The jupyter notebook command to execute"), z
}
var ym6 = DD6();

function ug(v, z) {
    let U = pK({
            name: "claude-vscode-extension",
            version: "2.1.42",
            tools: []
        }),
        V = {
            getState: () => ({
                hasActiveSession: !1
            }),
            onStateChange: () => () => {}
        },
        N;
    return {
        config: U,
        debuggerController: V,
        jupyterController: N
    }
}
var AD6 = `
# VSCode Extension Context

You are running inside a VSCode native extension environment.

## Code References in Text
IMPORTANT: When referencing files or code locations, use markdown link syntax to make them clickable:
- For files: [filename.ts](src/filename.ts)
- For specific lines: [filename.ts:42](src/filename.ts#L42)
- For a range of lines: [filename.ts:42-51](src/filename.ts#L42-L51)
- For folders: [src/utils/](src/utils/)
Unless explicitly asked for by the user, DO NOT USE backtickets \` or HTML tags like code for file references - always use markdown [text](link) format.
The URL links should be relative paths from the root of  the user's workspace.

## User Selection Context
The user's IDE selection (if any) is included in the conversation context and marked with ide_selection tags. This represents code or text the user has highlighted in their editor and may or may not be relevant to their request.`;
class IJ extends S2 {
    context;
    cwd;
    settings;
    webview;
    output;
    leftTempFileProvider;
    rightTempFileProvider;
    readOnlyTempFileProvider;
    acceptOrRejectDiffs;
    getCurrentSelection;
    isVisible;
    makeVisible;
    panelTab;
    requestUsageBroadcast;
    sendQueue = Promise.resolve();
    speechToTextChannels = new Map;
    resolveClientReady;
    clientReady = new Promise((v) => {
        this.resolveClientReady = v
    });
    chromeMcpClient;
    browserTabsCache;
    extensionMcpServer;
    constructor(v, z, U, V, N, K, x, j, B, O, J, q, H, D, A, w) {
        let Z = v.globalState.get("experimentGates") || {},
            $ = v.globalState.get("showTerminalBanner");
        super(z, i1(N), U, !!A, $ === void 0 ? !0 : $, Z, new YU(i1(N), GJ(), R4("disableLoginPrompt")));
        this.context = v;
        this.cwd = z;
        this.settings = U;
        this.webview = V;
        this.output = N;
        this.leftTempFileProvider = j;
        this.rightTempFileProvider = B;
        this.readOnlyTempFileProvider = O;
        this.acceptOrRejectDiffs = J;
        this.getCurrentSelection = q;
        this.isVisible = H;
        this.makeVisible = D;
        this.panelTab = A;
        this.requestUsageBroadcast = w;
        this.checkAndUpdateReviewUpsellBanner(), this.extensionMcpServer = ug(v, N), this.extensionMcpServer.debuggerController.onStateChange((F) => {
            this.updateDebuggerStateForAllChannels(F)
        }), this.extensionMcpServer.jupyterController?.onStateChange((F) => {
            this.updateJupyterStateForAllChannels(F)
        }), K((F) => {
            if (this.send({
                    type: "request",
                    channelId: "",
                    requestId: "",
                    request: {
                        type: "insert_at_mention",
                        text: F
                    }
                }), this.panelTab) this.panelTab.reveal()
        }), x((F) => {
            this.send({
                type: "request",
                channelId: "",
                requestId: "",
                request: {
                    type: "selection_changed",
                    selection: F
                }
            })
        }), setTimeout(() => {
            this.notifyVisibilityChange(this.isVisible())
        }, 100), v.subscriptions.push(z6.workspace.onDidChangeConfiguration((F) => {
            if (F.affectsConfiguration("claudeCode.hideOnboarding")) this.pushStateUpdate()
        }))
    }
    async fromClient(v) {
        return this.resolveClientReady(), super.fromClient(v)
    }
    notifyVisibilityChange(v) {
        if (this.send({
                type: "request",
                channelId: "",
                requestId: "",
                request: {
                    type: "visibility_changed",
                    isVisible: v
                }
            }), v) this.checkAndUpdateReviewUpsellBanner()
    }
    notifyFontConfigurationChange(v) {
        this.send({
            type: "request",
            channelId: "",
            requestId: "",
            request: {
                type: "font_configuration_changed",
                fontConfig: v
            }
        })
    }
    notifyCreateNewConversation() {
        this.send({
            type: "request",
            channelId: "",
            requestId: "",
            request: {
                type: "create_new_conversation"
            }
        })
    }
    async notifyOpenPluginsDialog(v, z) {
        await this.clientReady, this.send({
            type: "request",
            channelId: "",
            requestId: "",
            request: {
                type: "open_plugins_dialog",
                pluginName: v,
                marketplaceSource: z
            }
        })
    }
    send(v) {
        this.sendQueue = this.sendQueue.then(() => {
            return this.webview.postMessage({
                type: "from-extension",
                message: v
            }).then(() => {})
        }), this.checkAndUpdateReviewUpsellBanner()
    }
    async processRequest(v, z) {
        if (v.request.type === "get_current_selection") return {
            type: "get_current_selection_response",
            selection: this.getCurrentSelection()
        };
        else if (v.request.type === "new_conversation_tab") return await z6.commands.executeCommand("claude-vscode.editor.open", v.request.sessionId, v.request.initialPrompt), {
            type: "new_conversation_tab_response"
        };
        else if (v.request.type === "rename_tab") {
            if (this.panelTab) {
                this.panelTab.title = v.request.title;
                let U;
                if (v.request.hasPendingPermissions) U = "claude-logo-pending.svg";
                else if (v.request.hasUnseenCompletion) U = "claude-logo-done.svg";
                else U = "claude-logo.svg";
                this.panelTab.iconPath = z6.Uri.file(S4.join(this.context.extensionPath, "resources", U))
            }
            return {
                type: "rename_tab_response"
            }
        } else if (v.request.type === "show_notification") {
            let {
                message: U,
                severity: V,
                buttons: N,
                onlyIfNotVisible: K
            } = v.request;
            if (K && this.isVisible()) return {
                type: "show_notification_response"
            };
            let x;
            switch (V) {
                case "error":
                    x = await z6.window.showErrorMessage(U, ...N || []);
                    break;
                case "warning":
                    x = await z6.window.showWarningMessage(U, ...N || []);
                    break;
                case "info":
                default:
                    x = await z6.window.showInformationMessage(U, ...N || []);
                    break
            }
            if (x) this.makeVisible();
            return {
                type: "show_notification_response",
                buttonValue: x
            }
        }
        return super.processRequest(v, z)
    }
    async spawnClaude(v, z, U, V, N, K, x, j, B = {}) {
        ZD6();
        let O = new xA(i1(this.output)),
            J = (z6.workspace.workspaceFolders || []).map((F) => isForceLocalMode() ? F.uri.path : F.uri.fsPath);
        J.shift();
        let q = {
                cwd: N || this.cwd,
                resume: z,
                canUseTool: U,
                permissionMode: K,
                additionalDirectories: J,
                allowDangerouslySkipPermissions: x,
                model: V === null ? "default" : V,
                stderr: (F) => {
                    if (F.includes("An update to our Consumer Terms and Privacy Policy")) z6.window.showErrorMessage("An update to our Consumer Terms and Privacy Policy has taken effect on October 8, 2025. You must run claude in the terminal to review the updated terms.", "Resolve in Terminal").then((L) => {
                        if (L === "Resolve in Terminal") this.openClaudeInTerminal()
                    });
                    this.output.info(`From claude: ${F}`)
                },
                systemPrompt: {
                    type: "preset",
                    preset: "claude_code",
                    append: AD6
                },
                enableFileCheckpointing: !0,
                maxThinkingTokens: j,
                includePartialMessages: !z6.env.remoteName,
                hooks: {
                    PreToolUse: [{
                        matcher: "Edit|Write|MultiEdit",
                        hooks: [(F) => O.captureBaseline(F)]
                    }, {
                        matcher: "Edit|Write|Read",
                        hooks: [(F) => this.saveFileIfNeeded(F)]
                    }],
                    PostToolUse: [{
                        matcher: "Edit|Write|MultiEdit",
                        hooks: [(F) => O.findDiagnosticsProblems(F)]
                    }]
                },
                settingSources: ["user", "project", "local"],
                extraArgs: {
                    debug: null,
                    "debug-to-stderr": null,
                    "enable-auth-status": null,
                    "no-chrome": null
                },
                mcpServers: B
            };
        // --- forceLocal: disable built-in file tools, use local cwd ---
        if (isForceLocalMode()) {
            q.cwd = getForceLocalCwd();
            q.disallowedTools = [
                "Read", "Write", "Edit", "MultiEdit",
                "Glob", "Grep", "Bash", "NotebookEdit"
            ];
            q.allowedTools = [
                "mcp__claude-vscode__read_file",
                "mcp__claude-vscode__glob",
                "mcp__claude-vscode__grep",
                "mcp__claude-vscode__bash",
                "mcp__claude-vscode__write_file",
                "mcp__claude-vscode__edit_file"
            ];
            // Review mode logic is handled inside the MCP tool handlers themselves
            // (remote-tools.js), so all tools are always auto-approved here.
            // --- forceLocal: add MCP-aware hooks for diagnostics tracking ---
            var _adaptMcpEvent = function(F) {
                var _a = Object.assign({}, F);
                if (_a.tool_name && _a.tool_name.startsWith("mcp__claude-vscode__")) {
                    var _n = _a.tool_name.replace("mcp__claude-vscode__", "");
                    if (_n === "edit_file") _a.tool_name = "Edit";
                    else if (_n === "write_file") _a.tool_name = "Write";
                    else if (_n === "read_file") _a.tool_name = "Read";
                }
                if (_a.tool_input && _a.tool_input.file_path) {
                    try {
                        var _rt = require("./src/remote-tools");
                        var _remUri = _rt.getRemoteUri(_a.tool_input.file_path);
                        _a.tool_input = Object.assign({}, _a.tool_input, { file_path: _remUri.toString(true) });
                    } catch(_e) {}
                }
                return _a;
            };
            q.hooks.PreToolUse.push({
                matcher: "mcp__claude-vscode__edit_file|mcp__claude-vscode__write_file",
                hooks: [(F) => O.captureBaseline(_adaptMcpEvent(F))]
            });
            q.hooks.PreToolUse.push({
                matcher: "mcp__claude-vscode__edit_file|mcp__claude-vscode__write_file|mcp__claude-vscode__read_file",
                hooks: [(F) => this.saveFileIfNeeded(_adaptMcpEvent(F))]
            });
            q.hooks.PostToolUse.push({
                matcher: "mcp__claude-vscode__edit_file|mcp__claude-vscode__write_file",
                hooks: [(F) => O.findDiagnosticsProblems(_adaptMcpEvent(F))]
            });
            this.output.info("forceLocal: CLI will run locally, built-in file tools disabled, MCP hooks added");
            this.output.info(`forceLocal: cwd=${q.cwd}, disallowedTools=${q.disallowedTools.join(",")}, allowedTools=${q.allowedTools.join(",")}, permissionMode=${K}, canUseTool=${!!U}`);
        } else {
            this.output.info(`forceLocal: NOT active. forceLocal=${require("vscode").workspace.getConfiguration("claudeCode").get("forceLocal")}, remoteName=${require("vscode").env.remoteName}, remoteAuthority=${require("vscode").env.remoteAuthority}, folderScheme=${(require("vscode").workspace.workspaceFolders||[])[0]?.uri?.scheme}`);
        }
        let {
                pathToClaudeCodeExecutable: H,
                executableArgs: D,
                env: A
            } = this.getClaudeBinary(),
            w = R4("usePythonEnvironment") ?? !0,
            Z = w ? await BY(A) : A;
        if (w && Z !== A) {
            let F = ["PATH", "VIRTUAL_ENV", "CONDA_PREFIX", "CONDA_DEFAULT_ENV"];
            for (let L of F)
                if (Z[L] !== A[L]) this.output.info(`Python env: ${L}=${Z[L]}`)
        }
        q.pathToClaudeCodeExecutable = H, q.executableArgs = D, q.env = Z;
        // Prevent "nested session" detection when another Claude Code instance is running
        delete q.env.CLAUDECODE;
        let $ = "2.1.42";
        return this.output.info(`Spawning Claude with SDK query function - cwd: ${q.cwd}, permission mode: ${K}, version: ${$}, ${q.pathToClaudeCodeExecutable}, resume: ${z}`), nK({
            prompt: v,
            options: q
        })
    }
    getClaudeBinary() {
        let v, z = [],
            U = !1;
        {
            let N = wD6(this.context);
            if (N) v = N
        }
        if (!v) {
            let N = this.context.asAbsolutePath(S4.join("resources", "claude-code", "cli.js"));
            if (!P4.existsSync(N)) throw Error(`Unsupported platform: ${process.platform}-${process.arch}. No compatible Claude Code binary found.`);
            LD6(), U = !0, v = N
        }
        let V = R4("claudeProcessWrapper");
        if (V) {
            if (z = [v], U) z.unshift("node");
            v = V
        }
        return {
            pathToClaudeCodeExecutable: v,
            executableArgs: z,
            env: GJ()
        }
    }
    getChromeMcpServerConfig() {
        let {
            pathToClaudeCodeExecutable: v
        } = this.getClaudeBinary();
        if (v.endsWith(".js")) return {
            type: "stdio",
            command: "node",
            args: [v, "--claude-in-chrome-mcp"]
        };
        return {
            type: "stdio",
            command: v,
            args: ["--claude-in-chrome-mcp"]
        }
    }
    async onExperimentGatesUpdated(v) {
        this.experimentGates = v, this.context.globalState.update("experimentGates", v), await this.checkAndUpdateReviewUpsellBanner()
    }
    async onUsageUpdateRequested() {
        await this.requestUsageBroadcast()
    }
    claudeLaunched(v) {
        let z = {
            appName: z6.env.appName,
            version: z6.version
        };
        if (this.logEvent(v, "claude_launched", {
                ide: z
            }), this.extensionMcpServer.debuggerController.getState().hasActiveSession) this.addDebuggerMcpToChannel(v);
        this.pushChannelStateUpdate(v)
    }
    async openFile(v, z) {
        // --- Patch 12: forceLocal  open file on remote server via remote URI ---
        if (isForceLocalMode()) {
            try {
                var _rt = require("./src/remote-tools");
                var _remoteUri = _rt.getRemoteUri(v);
                z6.window.showTextDocument(_remoteUri).then((N) => {
                    if (z?.searchText) {
                        let K = N.document,
                            j = K.getText().indexOf(z.searchText);
                        if (j !== -1) {
                            let B = K.positionAt(j),
                                O = K.positionAt(j + z.searchText.length),
                                J = new z6.Range(B, O);
                            N.revealRange(J, z6.TextEditorRevealType.InCenter), N.selection = new z6.Selection(B, O)
                        }
                    } else if (z) {
                        let K = new z6.Range(new z6.Position((z.startLine || 1) - 1, 0), new z6.Position((z.endLine || z.startLine || 1) - 1, 0));
                        N.revealRange(K, z6.TextEditorRevealType.InCenter), N.selection = new z6.Selection(K.start, K.end)
                    }
                });
                return;
            } catch (_e) {
                // fall through to normal path
            }
        }
        let U = S4.isAbsolute(v) ? v : S4.join(this.cwd, v);
        if (!P4.existsSync(U) && S4.isAbsolute(v)) {
            let N = v.match(/^\/[^/]+\/[^/]+\/(.+)$/);
            if (N) {
                let K = N[1],
                    x = S4.join(this.cwd, K);
                if (P4.existsSync(x)) U = x
            }
        }
        if (!P4.existsSync(U) && !S4.isAbsolute(v)) {
            let N = await C2(v);
            if (N.length > 0) U = S4.join(this.cwd, N[0].path)
        }
        let V = z6.Uri.file(U);
        if (P4.existsSync(U) && P4.statSync(U).isDirectory()) {
            z6.commands.executeCommand("revealInExplorer", V);
            return
        }
        z6.window.showTextDocument(V).then((N) => {
            if (z?.searchText) {
                let K = N.document,
                    j = K.getText().indexOf(z.searchText);
                if (j !== -1) {
                    let B = K.positionAt(j),
                        O = K.positionAt(j + z.searchText.length),
                        J = new z6.Range(B, O);
                    N.revealRange(J, z6.TextEditorRevealType.InCenter), N.selection = new z6.Selection(B, O)
                }
            } else if (z) {
                let K = new z6.Range(new z6.Position((z.startLine || 1) - 1, 0), new z6.Position((z.endLine || z.startLine || 1) - 1, 0));
                N.revealRange(K, z6.TextEditorRevealType.InCenter), N.selection = new z6.Selection(K.start, K.end)
            }
        })
    }
    openConfigFile(v) {
        let z, U = `{
  "mcpServers": {}
}
`,
            V = S4.join(process.env.CLAUDE_CONFIG_DIR || kg.homedir(), ".claude.json");
        switch (v) {
            case "mcp-local":
            case "mcp-user":
                z = V;
                break;
            case "mcp-project":
                z = S4.join(this.cwd, ".mcp.json");
                break;
            default:
                z = V;
                break
        }
        if (!P4.existsSync(z)) P4.writeFileSync(z, `{
  "mcpServers": {}
}
`, "utf-8");
        let N = z6.Uri.file(z);
        z6.workspace.openTextDocument(N).then((K) => {
            z6.window.showTextDocument(K, {
                preview: !1
            })
        }, (K) => {
            this.output.error(`Failed to open config file ${z}: ${K}`)
        })
    }
    async openContent(v, z, U, V) {
        return {
            type: "open_content_response",
            updatedContent: await lT(this.output, this.readOnlyTempFileProvider, this.rightTempFileProvider, v, z, U, V)
        }
    }
    planCommentsByChannel = new Map;
    planPreviewPanelByChannel = new Map;
    async openMarkdownPreview(v, z, U) {
        this.planCommentsByChannel.set(v, []);
        let V = this.planPreviewPanelByChannel.get(v);
        if (V) V.dispose();
        let N = jY(z, U || "Claude Plan", (K) => {
            let x = this.planCommentsByChannel.get(v) ?? [];
            x.push(K), this.planCommentsByChannel.set(v, x), this.send({
                type: "plan_comment",
                channelId: v,
                comment: K
            })
        });
        return this.planPreviewPanelByChannel.set(v, N), {
            type: "open_markdown_preview_response"
        }
    }
    async getPlanComments(v) {
        return {
            type: "get_plan_comments_response",
            comments: this.planCommentsByChannel.get(v) ?? []
        }
    }
    async removePlanComment(v, z) {
        let U = this.planCommentsByChannel.get(v) ?? [];
        this.planCommentsByChannel.set(v, U.filter((N) => N.id !== z));
        let V = this.planPreviewPanelByChannel.get(v);
        if (V) V.webview.postMessage({
            type: "removeComment",
            commentId: z
        });
        return {
            type: "remove_plan_comment_response"
        }
    }
    async closePlanPreview(v) {
        let z = this.planPreviewPanelByChannel.get(v);
        if (z) z.dispose(), this.planPreviewPanelByChannel.delete(v);
        return {
            type: "close_plan_preview_response"
        }
    }
    async openDiff(v, z, U, V, N) {
        return {
            type: "open_diff_response",
            newEdits: await RY(this.output, this.leftTempFileProvider, this.rightTempFileProvider, v, z, U, V, this.acceptOrRejectDiffs, N)
        }
    }
    async openURL(v) {
        await z6.env.openExternal(z6.Uri.parse(v))
    }
    async openClaudeInTerminal(v, z, U) {
        await z6.commands.executeCommand("claude-vscode.terminal.open", v, z, U)
    }
    async openTerminal(v, z = [], U, V, N) {
        let K = {
                ...process.env
            },
            x = "Claude Code",
            j = V === "beside" || V === void 0 ? {
                viewColumn: z6.ViewColumn.Beside
            } : V === "window" ? {
                viewColumn: z6.ViewColumn.One
            } : void 0,
            B = z6.window.createTerminal({
                name: x,
                iconPath: z6.Uri.file(S4.join(this.context.extensionPath, "resources", "claude-logo.svg")),
                cwd: U || this.cwd,
                location: j,
                isTransient: !0,
                env: K,
                strictEnv: !0
            }),
            O = [v, ...z];
        B.show();
        let J, q;
        if (await new Promise((H) => {
                let D = !1;
                J = z6.window.onDidChangeTerminalShellIntegration((A) => {
                    if (A.terminal === B && !D) D = !0, q = z6.window.onDidStartTerminalShellExecution((w) => {
                        if (w.terminal === B) H()
                    }), A.shellIntegration.executeCommand(MF.quote(O))
                }), setTimeout(() => {
                    if (!B.shellIntegration && !D) D = !0, B.sendText(MF.quote(O)), H()
                }, 3000)
            }).finally(() => {
                J?.dispose(), q?.dispose()
            }), V === "window") await z6.commands.executeCommand("workbench.action.moveEditorToNewWindow")
    }
    async showClaudeTerminalSetting() {
        await z6.commands.executeCommand("workbench.action.focusFirstEditorGroup"), await z6.commands.executeCommand("workbench.action.openSettings", "claudeCode.useTerminal")
    }
    async dismissTerminalBanner() {
        this.showTerminalBanner = !1, await this.context.globalState.update("showTerminalBanner", !1)
    }
    async dismissReviewUpsellBanner(v) {
        this.context.globalState.update("reviewUpsellDismissedMetadata", v), this.showReviewUpsellBanner = !1, await this.pushStateUpdate()
    }
    async dismissOnboarding(v) {
        await this.settings.setHideOnboarding(!0), await this.pushStateUpdate()
    }
    getIsOnboardingDismissed() {
        return this.settings.getHideOnboarding()
    }
    async checkAndUpdateReviewUpsellBanner() {
        try {
            if (this.showReviewUpsellBanner !== void 0 || !this.experimentGates.tengu_vscode_review_upsell) return;
            if (this.context.globalState.get("reviewUpsellDismissedMetadata") !== void 0) {
                this.showReviewUpsellBanner = !1, await this.pushStateUpdate();
                return
            }
            let z = this.context.globalState.get("reviewUpsellLastShownTimestamp");
            if (XY(z)) {
                this.showReviewUpsellBanner = !1, await this.pushStateUpdate();
                return
            }
            let U = gY();
            if (U && this.showReviewUpsellBanner !== !0) {
                if (this.showReviewUpsellBanner = U, U) this.context.globalState.update("reviewUpsellLastShownTimestamp", Date.now());
                await this.pushStateUpdate()
            }
        } catch (v) {
            this.output.warn(`Failed to check review upsell banner: ${v}`)
        }
    }
    async openFolderPicker() {
        return await z6.commands.executeCommand("vscode.openFolder") !== void 0 || !0
    }
    async openConfig(v) {
        await z6.commands.executeCommand("workbench.action.focusFirstEditorGroup"), await z6.commands.executeCommand("workbench.action.openSettings", v || "claudeCode")
    }
    async openHelp() {
        let v = z6.Uri.parse("https://code.claude.com/docs/en/vs-code");
        await z6.env.openExternal(v)
    }
    async openOutputPanel() {
        this.output.show()
    }
    async openFileDiffs(v) {
        let z = [];
        for (let [U, V] of Object.entries(v.diffs)) {
            if (V.oldContent === V.newContent) continue;
            let N, j;
            // --- Patch 12b: forceLocal  resolve diff paths to remote URIs ---
            if (isForceLocalMode()) {
                try {
                    var _rt = require("./src/remote-tools");
                    var _remotePath = _rt.toRemotePath(U);
                    N = _remotePath;
                    j = _rt.getRemoteUri(U);
                } catch (_e) {
                    N = S4.isAbsolute(U) ? U : S4.join(this.cwd, U);
                    j = z6.Uri.file(N);
                }
            } else {
                N = S4.isAbsolute(U) ? U : S4.join(this.cwd, U);
                j = z6.Uri.file(N);
            }
            let K = V.oldContent !== null ? this.leftTempFileProvider.createFile(N, V.oldContent).uri : void 0,
                x;
            if (V.newContent !== null) {
                let B;
                try {
                    if (isForceLocalMode()) {
                        var _rdUri = require("./src/remote-tools").getRemoteUri(U);
                        var _rdData = await z6.workspace.fs.readFile(_rdUri);
                        B = Buffer.from(_rdData).toString("utf8");
                    } else {
                        B = P4.readFileSync(N, "utf8");
                    }
                } catch {}
                if (B === V.newContent) x = j;
                else x = this.readOnlyTempFileProvider.createFile(N, V.newContent)
            }
            z.push([j, K, x])
        }
        if (z.length > 0) {
            let U = v.title ?? "Review changes";
            await z6.commands.executeCommand("vscode.changes", U, z)
        }
    }
    isSpeechToTextEnabled() {
        if (process.env.CLAUDE_SPEECH_TO_TEXT !== "true") return !1;
        return z6.extensions.getExtension("ms-vscode.vscode-speech") !== void 0
    }
    async handleStartSpeechToText(v) {
        if (this.output.info(`Starting speech-to-text on channel: ${v}`), this.speechToTextChannels.has(v)) throw Error(`Speech-to-text channel already exists: ${v}`);
        try {
            let {
                iterator: z,
                abort: U
            } = await this.createSpeechToTextStream();
            this.speechToTextChannels.set(v, {
                abort: U
            }), (async () => {
                try {
                    for await (let V of z) this.send({
                        type: "speech_to_text_message",
                        channelId: v,
                        text: V,
                        done: !1
                    });
                    this.closeSpeechToTextChannel(v, !0)
                } catch (V) {
                    this.closeSpeechToTextChannel(v, !0, String(V)), this.output.error(`Error from speech-to-text (on channel ${v}): ${V}`)
                }
            })()
        } catch (z) {
            this.closeSpeechToTextChannel(v, !0, String(z)), this.output.error(`Error starting speech-to-text (on channel ${v}): ${z}`)
        }
    }
    async handleStopSpeechToText(v) {
        let z = this.speechToTextChannels.get(v);
        if (!z) {
            this.output.warn(`Speech-to-text channel not found: ${v}`);
            return
        }
        try {
            z.abort(), this.output.info(`Stopped speech-to-text for channel: ${v}`)
        } catch (U) {
            this.output.error(`Failed to stop speech-to-text: ${U}`)
        }
    }
    closeSpeechToTextChannel(v, z, U) {
        if (this.output.info(`Closing speech-to-text on channel: ${v}`), z) this.send({
            type: "close_channel",
            channelId: v,
            error: U
        });
        this.speechToTextChannels.delete(v)
    }
    async createSpeechToTextStream() {
        let v = z6.extensions.getExtension("ms-vscode.vscode-speech");
        if (!v) throw Error("Speech extension not found. Please install ms-vscode.vscode-speech");
        if (!v.isActive) await v.activate();
        let z = await z6.workspace.openTextDocument({
            content: "",
            language: "plaintext"
        });
        await z6.window.showTextDocument(z, {
            preview: !0,
            preserveFocus: !1
        });
        let U = !1,
            V = "",
            N = [],
            K = null,
            x = z6.workspace.onDidChangeTextDocument((O) => {
                if (O.document === z && O.contentChanges.length > 0) {
                    let J = z.getText();
                    if (this.output.info(`Speech document changed. Current text length: ${J.length}, Last text length: ${V.length}`), J !== V) {
                        if (V = J, N.push(J), this.output.info(`Enqueued speech text: "${J}"`), K) K(), K = null
                    }
                }
            }),
            j = () => {
                if (U = !0, z6.commands.executeCommand("workbench.action.editorDictation.stop"), x.dispose(), z6.commands.executeCommand("workbench.action.revertAndCloseActiveEditor"), K) K(), K = null
            };
        if (await z6.commands.executeCommand("workbench.action.editorDictation.start"), this.panelTab) this.panelTab.reveal();
        else await z6.commands.executeCommand("claudeVSCodeSidebar.focus");
        async function* B() {
            try {
                while (!U)
                    if (N.length > 0) yield N.shift();
                    else await new Promise((O) => {
                        K = O, setTimeout(() => {
                            if (K === O) K = null, O()
                        }, 100)
                    })
            } finally {
                x.dispose(), z6.commands.executeCommand("workbench.action.revertAndCloseActiveEditor")
            }
        }
        return {
            iterator: B(),
            abort: j
        }
    }
    getAssetUris() {
        let v = nb(),
            z = (U) => {
                return this.webview.asWebviewUri(z6.Uri.file(this.context.asAbsolutePath(U))).toString()
            };
        for (let U of Object.keys(v)) v[U] = {
            light: z(v[U].light),
            dark: z(v[U].dark)
        };
        return v
    }
    async findFiles(v) {
        let z = v?.toLowerCase() ?? "";
        if (z.startsWith("browser:")) return this.getMatchingBrowserTabs(v, !1);
        if (process.env.AT_MENTION_TERMINAL === "true") {
            if (z.startsWith("terminal:")) return this.getMatchingTerminals(v)
        }
        let U = "browser:",
            V = "terminal:",
            N = z && U.startsWith(z),
            K = z && V.startsWith(z),
            x = [];
        if (process.env.AT_MENTION_TERMINAL === "true") x = this.getMatchingTerminals(v);
        let j = await this.getMatchingBrowserTabs(v, !0),
            B = z6.workspace.workspaceFolders;
        if (!B || B.length === 0) return [...x, ...j];
        let O;
        try {
            O = await TT(v, this.cwd, i1(this.output))
        } catch (J) {
            this.output.warn(`Ripgrep search failed, falling back to VSCode findFiles: ${J}`), O = await C2(v)
        }
        if (N) return [...j, ...x, ...O];
        else if (K) return [...x, ...j, ...O];
        return [...O, ...x, ...j]
    }
    getMatchingTerminals(v) {
        let z = v?.toLowerCase() ?? "";
        return z6.window.terminals.filter((U) => {
            let V = U.name.replace(/ /g, "_");
            return !v || `terminal:${V}`.toLowerCase().includes(z)
        }).map((U) => {
            let V = U.name.replace(/ /g, "_");
            return {
                path: `terminal:${V}`,
                name: `terminal:${V}`,
                type: "terminal"
            }
        })
    }
    refreshBrowserTabsCache() {
        if (!this.chromeMcpClient) this.chromeMcpClient = new IN(this.output, () => this.getClaudeBinary());
        this.chromeMcpClient.getBrowserTabs().then((v) => {
            this.browserTabsCache = {
                tabs: v,
                timestamp: Date.now()
            }
        }, (v) => {
            this.output.warn(`Failed to refresh browser tabs cache: ${v}`)
        })
    }
    filterBrowserTabs(v, z) {
        let U = z?.toLowerCase() ?? "";
        return v.filter((V) => {
            if (!z) return !0;
            return `browser:${V.title}`.toLowerCase().includes(U) || V.url.toLowerCase().includes(U)
        }).map((V) => {
            let N = V.title.replace(/ /g, "_");
            return {
                path: V.tabGroupId === "" && V.tabId === 0 ? "browser:new_tab" : `browser:${V.tabGroupId}:${V.tabId}:${V.url}`,
                name: `browser:${N}`,
                type: "browser"
            }
        })
    }
    async getMatchingBrowserTabs(v, z = !1) {
        try {
            if (z) {
                let V = this.browserTabsCache?.tabs ?? [];
                return this.refreshBrowserTabsCache(), this.filterBrowserTabs(V, v)
            }
            if (!this.chromeMcpClient) this.chromeMcpClient = new IN(this.output, () => this.getClaudeBinary());
            let U = await this.chromeMcpClient.getBrowserTabs();
            return this.browserTabsCache = {
                tabs: U,
                timestamp: Date.now()
            }, this.filterBrowserTabs(U, v)
        } catch (U) {
            return this.output.warn(`Failed to get browser tabs: ${U}`), this.filterBrowserTabs(this.browserTabsCache?.tabs ?? [], v)
        }
    }
    async ensureChromeMcpEnabled(v) {
        if (process.platform === "darwin") {
            if (!this.context.globalState.get("chromeExtensionNotificationDismissed")) try {
                if (!await Bg()) {
                    this.output.info("Chrome extension not detected, showing installation prompt");
                    let V = await z6.window.showInformationMessage("Claude in Chrome: Install the browser extension to control Chrome from Claude Code", "Install Extension", "Don't Show Again");
                    if (V === "Install Extension") await z6.env.openExternal(z6.Uri.parse(jg));
                    else if (V === "Don't Show Again") await this.context.globalState.update("chromeExtensionNotificationDismissed", !0)
                }
            } catch (U) {
                this.output.warn(`Failed to check Chrome extension installation: ${U}`)
            }
        }
        return super.ensureChromeMcpEnabled(v)
    }
    async disableChromeMcp(v) {
        if (this.chromeMcpClient) await this.chromeMcpClient.disconnect();
        return super.disableChromeMcp(v)
    }
    async createNewBrowserTab() {
        if (!this.chromeMcpClient) this.chromeMcpClient = new IN(this.output, () => this.getClaudeBinary());
        let {
            tabGroupId: v,
            tabId: z
        } = await this.chromeMcpClient.createNewBrowserTab();
        return {
            type: "create_new_browser_tab_response",
            tabGroupId: v,
            tabId: z
        }
    }
    getMarketplaceType() {
        let v = z6.env.appName.toLowerCase();
        if (v.includes("vscodium") || v.includes("gitpod") || v.includes("code - oss") || v.includes("cursor")) return "openvsx";
        return "vscode"
    }
    isBrowserIntegrationSupported() {
        return this.authManager.getAuthStatus()?.authMethod === "claudeai" && !!this.experimentGates.tengu_quiet_fern
    }
    async getTerminalContents(v) {
        let z = z6.window.terminals.find((V) => V.name.replace(/ /g, "_") === v);
        if (!z) return null;
        let U = await z6.env.clipboard.readText();
        try {
            z.show(), await z6.commands.executeCommand("workbench.action.terminal.selectAll"), await z6.commands.executeCommand("workbench.action.terminal.copySelection"), await z6.commands.executeCommand("workbench.action.terminal.clearSelection");
            let V = await z6.env.clipboard.readText(),
                N = 100,
                K = V.split(`
`);
            if (K.length > N) V = K.slice(-N).join(`
`);
            return await z6.env.clipboard.writeText(U), V
        } catch (V) {
            return await z6.env.clipboard.writeText(U), this.output.error(`Failed to get terminal contents: ${V}`), null
        }
    }
    async saveFileIfNeeded(v) {
        if (!R4("autosave")) return {
            continue: !0
        };
        if (v.hook_event_name !== "PreToolUse") return {
            continue: !0
        };
        if (v.tool_name !== "Edit" && v.tool_name !== "Write" && v.tool_name !== "Read") return {
            continue: !0
        };
        let z = v.tool_input?.file_path,
            U = zj(z);
        try {
            let V = await z6.workspace.openTextDocument(U);
            if (V.isDirty) await V.save()
        } catch (V) {}
        return {
            continue: !0
        }
    }
    getAdditionalMcpServers() {
        return {}
    }
    getInitialDebuggerState() {
        return this.extensionMcpServer.debuggerController.getState().hasActiveSession ? {
            status: "active"
        } : {
            status: "inactive"
        }
    }
    async askDebuggerHelp(v) {
        return {
            type: "ask_debugger_help_response"
        }
    }
    updateDebuggerStateForAllChannels(v) {
        for (let [z, U] of this.channels) {
            let V = "claude-vscode-extension" in U.mcpServers;
            if (v.hasActiveSession && !V) this.addDebuggerMcpToChannel(z);
            else if (!v.hasActiveSession && V) this.removeDebuggerMcpFromChannel(z)
        }
    }
    async addDebuggerMcpToChannel(v) {
        let z = this.channels.get(v);
        if (!z) return;
        this.logEvent(v, "debugger_mcp_add_to_channel");
        try {
            this.output.info(`[Debugger] Adding extension MCP server to channel ${v}`);
            let U = {
                    ...z.mcpServers,
                    "claude-vscode-extension": this.extensionMcpServer.config
                },
                V = await z.query.setMcpServers(U);
            if (V.errors && Object.keys(V.errors).length > 0) {
                let N = Object.entries(V.errors).map(([K, x]) => `${K}: ${x}`).join(", ");
                throw Error(N)
            }
            z.mcpServers = U, z.debuggerMcpState = {
                status: "active"
            }, await this.pushChannelStateUpdate(v)
        } catch (U) {
            let V = U instanceof Error ? U.message : "Unknown error";
            this.output.error(`[Debugger] Failed to add MCP server: ${V}`), z.debuggerMcpState = {
                status: "error",
                error: V
            }, await this.pushChannelStateUpdate(v)
        }
    }
    async removeDebuggerMcpFromChannel(v) {
        let z = this.channels.get(v);
        if (!z) return;
        try {
            this.output.info(`[Debugger] Removing extension MCP server from channel ${v}`);
            let {
                "claude-vscode-extension": U,
                ...V
            } = z.mcpServers;
            await z.query.setMcpServers(V), z.mcpServers = V, z.debuggerMcpState = {
                status: "inactive"
            }, await this.pushChannelStateUpdate(v)
        } catch (U) {
            let V = U instanceof Error ? U.message : "Unknown error";
            this.output.error(`[Debugger] Failed to remove MCP server: ${V}`)
        }
    }
    getInitialJupyterState() {
        let v = this.extensionMcpServer.jupyterController?.getState();
        if (v?.hasNotebooks) return {
            status: "available",
            notebookCount: v.notebookCount,
            isActiveEditorNotebook: v.isActiveEditorNotebook
        };
        return {
            status: "inactive"
        }
    }
    async enableJupyterMcp(v) {
        let z = this.channels.get(v);
        if (!z) throw Error(`Channel not found: ${v}`);
        this.logEvent(v, "jupyter_mcp_enable", {});
        try {
            this.output.info(`[Jupyter] Adding extension MCP server to channel ${v}`);
            let U = {
                    ...z.mcpServers,
                    "claude-vscode-extension": this.extensionMcpServer.config
                },
                V = await z.query.setMcpServers(U);
            if (V.errors && Object.keys(V.errors).length > 0) {
                let N = Object.entries(V.errors).map(([K, x]) => `${K}: ${x}`).join(", ");
                throw Error(N)
            }
            return z.mcpServers = U, z.jupyterMcpState = {
                status: "active"
            }, await this.pushChannelStateUpdate(v), {
                type: "enable_jupyter_mcp_response"
            }
        } catch (U) {
            let V = U instanceof Error ? U.message : "Unknown error";
            throw this.output.error(`[Jupyter] Failed to add MCP server: ${V}`), z.jupyterMcpState = {
                status: "error",
                error: V
            }, await this.pushChannelStateUpdate(v), U
        }
    }
    async disableJupyterMcp(v) {
        let z = this.channels.get(v);
        if (!z) throw Error(`Channel not found: ${v}`);
        try {
            this.output.info(`[Jupyter] Removing extension MCP server from channel ${v}`);
            let {
                "claude-vscode-extension": U,
                ...V
            } = z.mcpServers;
            await z.query.setMcpServers(V), z.mcpServers = V;
            let N = this.extensionMcpServer.jupyterController?.getState();
            if (N?.hasNotebooks) z.jupyterMcpState = {
                status: "available",
                notebookCount: N.notebookCount,
                isActiveEditorNotebook: N.isActiveEditorNotebook
            };
            else z.jupyterMcpState = {
                status: "inactive"
            };
            return await this.pushChannelStateUpdate(v), {
                type: "disable_jupyter_mcp_response"
            }
        } catch (U) {
            let V = U instanceof Error ? U.message : "Unknown error";
            throw this.output.error(`[Jupyter] Failed to remove MCP server: ${V}`), U
        }
    }
    updateJupyterStateForAllChannels(v) {
        for (let [z, U] of this.channels) {
            let V = U.jupyterMcpState.status;
            if (v.hasNotebooks) {
                if (V === "inactive") U.jupyterMcpState = {
                    status: "available",
                    notebookCount: v.notebookCount,
                    isActiveEditorNotebook: v.isActiveEditorNotebook
                }, this.pushChannelStateUpdate(z);
                else if (V === "available") U.jupyterMcpState = {
                    status: "available",
                    notebookCount: v.notebookCount,
                    isActiveEditorNotebook: v.isActiveEditorNotebook
                }, this.pushChannelStateUpdate(z)
            } else if (V === "active") U.jupyterMcpState = {
                status: "inactive"
            }, this.pushChannelStateUpdate(z);
            else if (V === "available") U.jupyterMcpState = {
                status: "inactive"
            }, this.pushChannelStateUpdate(z)
        }
    }
    async shutdown() {
        if (this.chromeMcpClient) await this.chromeMcpClient.disconnect(), this.chromeMcpClient = void 0;
        await super.shutdown()
    }
}

function i1(v) {
    return {
        log: (z, ...U) => v.info(z, ...U),
        warn: (z, ...U) => v.warn(z, ...U),
        error: (z, ...U) => v.error(z, ...U)
    }
}

function $D6() {
    if (process.platform !== "linux") return !1;
    try {
        if (P4.existsSync("/lib/libc.musl-x86_64.so.1") || P4.existsSync("/lib/libc.musl-aarch64.so.1")) return !0;
        let v = E3("ldd /bin/ls 2>/dev/null", {
            env: process.env,
            maxBuffer: 1e6,
            timeout: 20000,
            stdio: ["ignore", "pipe", "pipe"],
            shell: !0,
            reject: !1
        });
        return v.stdout && v.stdout.includes("musl")
    } catch {
        return !1
    }
}

function wD6(v) {
    let z = process.platform === "win32" ? "claude.exe" : "claude",
        U = $D6() ? `${process.arch}-musl` : process.arch,
        V = v.asAbsolutePath(S4.join("resources", "native-binaries", `${process.platform}-${U}`, z));
    if (P4.existsSync(V)) return V;
    if (process.platform === "win32" && process.arch === "arm64") {
        let K = v.asAbsolutePath(S4.join("resources", "native-binaries", "win32-x64", z));
        if (P4.existsSync(K)) return K
    }
    let N = v.asAbsolutePath(S4.join("resources", "native-binary", z));
    if (P4.existsSync(N)) return N;
    return
}

function ZD6() {
    if (process.platform === "win32") try {
        E3("where.exe", ["git"], {
            stdio: "pipe",
            encoding: "utf8"
        })
    } catch {
        throw Error("Claude Code on Windows requires git-bash (https://git-scm.com/downloads/win). If installed but not in PATH, set environment variable pointing to your bash.exe, similar to: CLAUDE_CODE_GIT_BASH_PATH=C:\\Program Files\\Git\\bin\\bash.exe")
    }
    return
}

function LD6() {
    try {
        let v = process.platform === "win32" ? "node.exe" : "node",
            U = E3(v, ["--version"], {
                stdio: "pipe",
                encoding: "utf8"
            }).stdout.trim();
        if (!yg.default.gte(U, "18.0.0")) throw Error(`Claude Code requires Node.js version 18 or higher. Found version ${U}.`)
    } catch (v) {
        if (v instanceof Error && v.message.includes("requires Node.js")) throw v;
        throw Error("Claude Code requires Node.js version 18 or higher to be installed.")
    }
}

function GJ() {
    let v = R4("environmentVariables") || [],
        z = {
            ...process.env
        };
    z.MCP_CONNECTION_NONBLOCKING = "true";
    for (let U of v)
        if (U.name) z[U.name] = U.value || "";
    return z.CLAUDE_CODE_ENTRYPOINT = "claude-vscode", z
}
class WF {
    extensionUri;
    context;
    output;
    settings;
    leftTempFileProvider;
    rightTempFileProvider;
    readOnlyTempFileProvider;
    acceptOrRejectDiffs;
    atMentionEvents;
    selectionChangedEvents;
    getSelection;
    disposables = [];
    allComms = new Set;
    webviews = new Set;
    constructor(v, z, U, V, N, K, x, j, B, O, J) {
        this.extensionUri = v;
        this.context = z;
        this.output = U;
        this.settings = V;
        this.leftTempFileProvider = N;
        this.rightTempFileProvider = K;
        this.readOnlyTempFileProvider = x;
        this.acceptOrRejectDiffs = j;
        this.atMentionEvents = B;
        this.selectionChangedEvents = O;
        this.getSelection = J
    }
    hasVisibleWebview() {
        for (let v of this.webviews)
            if (v.isVisible()) return !0;
        return !1
    }
    resolveWebviewView(v, z, U) {
        let V = {
            isVisible: () => v.visible
        };
        this.webviews.add(V), v.webview.options = {
            enableScripts: !0,
            localResourceRoots: [M0.Uri.joinPath(this.extensionUri, "webview"), M0.Uri.joinPath(this.extensionUri, "resources")]
        }, v.webview.html = this.getHtmlForWebview(v.webview, void 0, void 0, !0), v.show(!0);
        let N = M0.workspace.workspaceFolders?.map((j) => j.uri.fsPath) || [],
            K = isForceLocalMode() ? getForceLocalCwd() : RF.realpathSync(N[0] || bF.homedir()).normalize("NFC"),
            x = new IJ(this.context, K, this.settings, v.webview, this.output, this.atMentionEvents, this.selectionChangedEvents, this.leftTempFileProvider, this.rightTempFileProvider, this.readOnlyTempFileProvider, this.acceptOrRejectDiffs, this.getSelection, () => v.visible, () => v.show(), void 0, () => this.broadcastUsageUpdate());
        this.allComms.add(x), v.webview.onDidReceiveMessage((j) => {
            this.output.info(`Received message from webview: ${JSON.stringify(j)}`), x?.fromClient(j)
        }, null, this.disposables), v.onDidDispose(() => {
            x.shutdown(), this.allComms.delete(x), this.webviews.delete(V), this.updateSidebarActiveState()
        }, null, this.disposables), v.onDidChangeVisibility(() => {
            this.updateSidebarActiveState()
        }, null, this.disposables), this.updateSidebarActiveState(), v.show(!0)
    }
    updateSidebarActiveState() {
        M0.commands.executeCommand("setContext", "claude-vscode.sideBarActive", this.hasVisibleWebview())
    }
    dispose() {
        while (this.disposables.length) {
            let v = this.disposables.pop();
            if (v) v.dispose()
        }
    }
    async notifyLogout() {
        for (let v of this.allComms) v.invalidateConfigCache(), v.pushStateUpdate()
    }
    notifyCreateNewConversation() {
        for (let v of this.allComms) v.notifyCreateNewConversation()
    }
    async notifyOpenPluginsDialog(v, z) {
        while (this.allComms.size === 0) await new Promise((U) => setTimeout(U, 100));
        for (let U of this.allComms) U.notifyOpenPluginsDialog(v, z)
    }
    notifyFontConfigurationChange() {
        let v = M0.workspace.getConfiguration("chat.editor"),
            z = v.get("fontFamily") || "default";
        if (z === "default") z = "monospace";
        let U = v.get("fontSize") || 12,
            V = v.get("fontWeight") || "normal",
            N = M0.workspace.getConfiguration("chat"),
            K = N.get("fontSize") || 13,
            x = N.get("fontFamily") || "default";
        if (x === "default") x = "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif";
        for (let j of this.allComms) j.notifyFontConfigurationChange({
            editorFontFamily: z,
            editorFontSize: U,
            editorFontWeight: V,
            chatFontSize: K,
            chatFontFamily: x
        })
    }
    async broadcastUsageUpdate() {
        let v = this.allComms.values().next().value;
        if (!v) return;
        let {
            utilization: z,
            error: U
        } = await v.fetchUsageData();
        for (let V of this.allComms) V.sendUsageUpdate(z, U)
    }
    createPanel(v, z) {
        let U = !1,
            V = M0.ViewColumn.Beside,
            N = M0.window.tabGroups.all.find((x) => {
                if (x.tabs.length === 0) return !1;
                return x.tabs.every((j) => {
                    if (j.input instanceof M0.TabInputWebview) return j.input.viewType.includes("claudeVSCodePanel");
                    return !1
                })
            });
        if (N && N.viewColumn) V = N.viewColumn;
        else V = this.findUnusedColumn(), U = !0;
        let K = M0.window.createWebviewPanel("claudeVSCodePanel", "Claude Code", V, {
            enableScripts: !0,
            retainContextWhenHidden: !0,
            enableFindWidget: !0,
            localResourceRoots: [M0.Uri.joinPath(this.extensionUri, "webview"), M0.Uri.joinPath(this.extensionUri, "resources")]
        });
        return this.setupPanel(K, v, z), {
            startedInNewColumn: U
        }
    }
    findUnusedColumn() {
        let v = new Set;
        M0.window.tabGroups.all.forEach((z) => {
            if (z.viewColumn !== void 0) v.add(z.viewColumn)
        });
        for (let z = M0.ViewColumn.One; z <= M0.ViewColumn.Nine; z++)
            if (!v.has(z)) return z;
        return M0.ViewColumn.Beside
    }
    setupPanel(v, z, U) {
        let V = {
            isVisible: () => v.visible
        };
        this.webviews.add(V);
        let N = M0.workspace.workspaceFolders?.map((j) => j.uri.fsPath) || [],
            K = isForceLocalMode() ? getForceLocalCwd() : RF.realpathSync(N[0] || bF.homedir()).normalize("NFC");
        v.iconPath = M0.Uri.file(mg.join(this.context.extensionPath, "resources", "claude-logo.svg")), v.webview.options = {
            enableScripts: !0,
            localResourceRoots: [M0.Uri.joinPath(this.extensionUri, "webview"), M0.Uri.joinPath(this.extensionUri, "resources")]
        }, v.webview.html = this.getHtmlForWebview(v.webview, z, U);
        let x = new IJ(this.context, K, this.settings, v.webview, this.output, this.atMentionEvents, this.selectionChangedEvents, this.leftTempFileProvider, this.rightTempFileProvider, this.readOnlyTempFileProvider, this.acceptOrRejectDiffs, this.getSelection, () => v.visible, () => v.reveal(), v, () => this.broadcastUsageUpdate());
        this.allComms.add(x), v.webview.onDidReceiveMessage((j) => {
            this.output.info(`Received message from webview: ${JSON.stringify(j)}`), x?.fromClient(j)
        }, null, this.disposables), v.onDidChangeViewState(() => x.notifyVisibilityChange(v.visible), null, this.disposables), v.onDidDispose(() => {
            x.shutdown(), this.allComms.delete(x), this.webviews.delete(V)
        }, null, this.disposables), this.disposables.push(v)
    }
    getHtmlForWebview(v, z, U, V) {
        let N = M0.Uri.joinPath(this.extensionUri, "webview", "index.js"),
            K = v.asWebviewUri(N),
            x = M0.Uri.joinPath(this.extensionUri, "webview", "index.css"),
            j = v.asWebviewUri(x),
            B = e8(),
            O = `style-src ${v.cspSource} 'unsafe-inline'`,
            J = `font-src ${v.cspSource}`,
            q = `img-src ${v.cspSource} data:`,
            H = `worker-src ${v.cspSource}`,
            D = M0.workspace.getConfiguration("chat.editor"),
            A = D.get("fontFamily") || "default";
        if (A === "default") A = "monospace";
        let w = D.get("fontSize") || 12,
            Z = D.get("fontWeight") || "normal",
            $ = M0.workspace.getConfiguration("chat"),
            F = $.get("fontSize") || 13,
            L = $.get("fontFamily") || "default";
        if (L === "default") L = "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif";
        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">

        <!--
          Use a content security policy to only allow loading images from our extension directory or data URIs,
          and only allow scripts that have a specific nonce.
          Note: External https: URLs are blocked to prevent data exfiltration via markdown image URLs.
        -->
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; ${O}; ${J}; ${q}; script-src 'nonce-${B}'; ${H};">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="${j}" rel="stylesheet">
        <style>
          :root {
            --vscode-editor-font-family: ${A} !important;
            --vscode-editor-font-size: ${w}px !important;
            --vscode-editor-font-weight: ${Z} !important;
            --vscode-chat-font-size: ${F}px;
            --vscode-chat-font-family: ${L};
          }
          .force-local-badge {
            display: inline-flex;
            align-items: center;
            background: var(--vscode-badge-background);
            color: var(--vscode-badge-foreground);
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            padding: 1px 6px;
            border-radius: 3px;
            margin-right: 4px;
            height: 20px;
            line-height: 20px;
            white-space: nowrap;
            user-select: none;
            pointer-events: none;
          }
        </style>
      </head>
      <body>
        <pre id="claude-error"></pre>
        <div id="root"></div>
        <script nonce="${B}">
          window.initialConfiguration = {
            initialPrompt: ${U?JSON.stringify(U):"undefined"},
            initialSession: ${z?JSON.stringify(z):"undefined"},
          }
          window.IS_SIDEBAR = ${V?"true":"false"}
          window.FORCE_LOCAL_MODE = ${isForceLocalMode()?"true":"false"}
        </script>
        <script nonce="${B}">
          (function() {
            if (typeof window.FORCE_LOCAL_MODE === 'undefined') return;
            var badgeText = window.FORCE_LOCAL_MODE ? 'UI' : 'Workspace';
            var BADGE_ID = '__force-local-badge';
            function injectBadge() {
              if (document.getElementById(BADGE_ID)) return true;
              var btn = document.querySelector('button[aria-label="New session"]');
              if (!btn) return false;
              var badge = document.createElement('span');
              badge.id = BADGE_ID;
              badge.className = 'force-local-badge';
              badge.textContent = badgeText;
              btn.parentNode.insertBefore(badge, btn);
              return true;
            }
            var root = document.getElementById('root');
            if (!root) return;
            var observer = new MutationObserver(function() {
              injectBadge();
            });
            observer.observe(root, { childList: true, subtree: true });
            injectBadge();
          })();
        </script>
        <script nonce="${B}" src="${K}" type="module"></script>
      </body>
      </html>`
    }
}
var MJ = o(require("vscode"));
var FD6 = o(Xq(), 1);
var Xg = o(require("child_process")),
    gg = require("util"),
    qX6 = gg.promisify(Xg.execFile);
var q4 = o(require("vscode"));

function EF(v) {
    if (!v.includes("\\")) return v;
    if (v.startsWith("\\\\")) return "/" + v.substring(2).replace(/\\/g, "/");
    if (/^[a-zA-Z]:/.test(v)) v = v.replace(/^([a-zA-Z]):/, (z, U) => "/" + U.toLowerCase() + ":");
    return v.replace(/\\/g, "/")
}
class cg {
    uri;
    contents;
    type = q4.FileType.File;
    ctime;
    modifiedTime;
    constructor(v, z) {
        this.uri = v;
        this.contents = z;
        this.ctime = this.modifiedTime = Date.now()
    }
    get mtime() {
        return this.modifiedTime
    }
    get size() {
        return this.data.length
    }
    get data() {
        return this.contents
    }
    write(v) {
        this.modifiedTime = Date.now(), this.contents = v, this.emitter.fire()
    }
    emitter = new q4.EventEmitter;
    onDidSave = this.emitter.event
}
class bJ {
    scheme;
    documents = new Map;
    constructor(v) {
        this.scheme = v
    }
    createFile(v, z) {
        let U = v;
        if (process.platform === "win32") U = EF(v);
        let V = q4.Uri.from({
                scheme: this.scheme,
                path: U
            }),
            N = this.documents.get(V.path);
        if (N) return this.writeFile(V, new TextEncoder().encode(z)), N;
        return N = new cg(V, new TextEncoder().encode(z)), this.documents.set(V.path, N), N
    }
    emitter = new q4.EventEmitter;
    onDidChangeFile = this.emitter.event;
    watch(v) {
        return new q4.Disposable(() => {})
    }
    stat(v) {
        return this.find(v)
    }
    find(v) {
        let z = v.path;
        if (process.platform === "win32") z = EF(v.path);
        let U = this.documents.get(z);
        if (!U) throw q4.FileSystemError.FileNotFound(v);
        return U
    }
    readDirectory(v) {
        throw q4.FileSystemError.FileNotFound(v)
    }
    readFile(v) {
        let z = this.find(v).data;
        if (z) return z;
        throw q4.FileSystemError.FileNotFound(v)
    }
    writeFile(v, z) {
        this.find(v).write(z), this.emitter.fire([{
            type: q4.FileChangeType.Changed,
            uri: v
        }])
    }
    createDirectory(v) {
        throw q4.FileSystemError.Unavailable()
    }
    delete(v) {
        throw q4.FileSystemError.Unavailable()
    }
    rename(v, z, U) {
        throw q4.FileSystemError.Unavailable()
    }
}
class SF {
    scheme;
    documents = new Map;
    onDidChangeEmitter = new q4.EventEmitter;
    onDidChange = this.onDidChangeEmitter.event;
    constructor(v) {
        this.scheme = v
    }
    createFile(v, z) {
        let U = v;
        if (process.platform === "win32") U = EF(v);
        let V = q4.Uri.from({
            scheme: this.scheme,
            path: U
        });
        return this.addDocument(V, z), V
    }
    provideTextDocumentContent(v) {
        return this.documents.get(v.toString()) || ""
    }
    addDocument(v, z) {
        this.documents.set(v.toString(), z), this.onDidChangeEmitter.fire(v)
    }
}
var g9 = o(require("vscode"));
var _4 = o(require("vscode"));

function ig(v) {
    if (!v.includes("\\")) return v;
    if (v.startsWith("\\\\")) return "/" + v.substring(2).replace(/\\/g, "/");
    if (/^[a-zA-Z]:/.test(v)) v = v.replace(/^([a-zA-Z]):/, (z, U) => "/" + U.toLowerCase() + ":");
    return v.replace(/\\/g, "/")
}
class lg {
    uri;
    contents;
    type = _4.FileType.File;
    ctime;
    modifiedTime;
    constructor(v, z) {
        this.uri = v;
        this.contents = z;
        this.ctime = this.modifiedTime = Date.now()
    }
    get mtime() {
        return this.modifiedTime
    }
    get size() {
        return this.data.length
    }
    get data() {
        return this.contents
    }
    write(v) {
        this.modifiedTime = Date.now(), this.contents = v, this.emitter.fire()
    }
    emitter = new _4.EventEmitter;
    onDidSave = this.emitter.event
}
class RJ {
    scheme;
    documents = new Map;
    constructor(v) {
        this.scheme = v
    }
    createFile(v, z) {
        let U = v;
        if (process.platform === "win32") U = ig(v);
        let V = _4.Uri.from({
                scheme: this.scheme,
                path: U
            }),
            N = this.documents.get(V.path);
        if (N) return this.writeFile(V, new TextEncoder().encode(z)), N;
        return N = new lg(V, new TextEncoder().encode(z)), this.documents.set(V.path, N), N
    }
    emitter = new _4.EventEmitter;
    onDidChangeFile = this.emitter.event;
    watch(v) {
        return new _4.Disposable(() => {})
    }
    stat(v) {
        return this.find(v)
    }
    find(v) {
        let z = v.path;
        if (process.platform === "win32") z = ig(v.path);
        let U = this.documents.get(z);
        if (!U) throw _4.FileSystemError.FileNotFound(v);
        return U
    }
    readDirectory(v) {
        throw _4.FileSystemError.FileNotFound(v)
    }
    readFile(v) {
        let z = this.find(v).data;
        if (z) return z;
        throw _4.FileSystemError.FileNotFound(v)
    }
    writeFile(v, z) {
        this.find(v).write(z), this.emitter.fire([{
            type: _4.FileChangeType.Changed,
            uri: v
        }])
    }
    createDirectory(v) {
        throw _4.FileSystemError.Unavailable()
    }
    delete(v) {
        throw _4.FileSystemError.Unavailable()
    }
    rename(v, z, U) {
        throw _4.FileSystemError.Unavailable()
    }
}
var u7 = o(require("vscode")),
    Mi = require("crypto");
class PF {
    constructor(v) {
        this._server = v
    }
    requestStream(v, z, U) {
        return this._server.requestStream(v, z, U)
    }
    async getTask(v, z) {
        return this._server.getTask({
            taskId: v
        }, z)
    }
    async getTaskResult(v, z, U) {
        return this._server.getTaskResult({
            taskId: v
        }, z, U)
    }
    async listTasks(v, z) {
        return this._server.listTasks(v ? {
            cursor: v
        } : void 0, z)
    }
    async cancelTask(v, z) {
        return this._server.cancelTask({
            taskId: v
        }, z)
    }
}
class _F extends dV {
    constructor(v, z) {
        var U, V;
        super(z);
        if (this._serverInfo = v, this._loggingLevels = new Map, this.LOG_LEVEL_SEVERITY = new Map(pV.options.map((N, K) => [N, K])), this.isMessageIgnored = (N, K) => {
                let x = this._loggingLevels.get(K);
                return x ? this.LOG_LEVEL_SEVERITY.get(N) < this.LOG_LEVEL_SEVERITY.get(x) : !1
            }, this._capabilities = (U = z === null || z === void 0 ? void 0 : z.capabilities) !== null && U !== void 0 ? U : {}, this._instructions = z === null || z === void 0 ? void 0 : z.instructions, this._jsonSchemaValidator = (V = z === null || z === void 0 ? void 0 : z.jsonSchemaValidator) !== null && V !== void 0 ? V : new FN, this.setRequestHandler(xZ, (N) => this._oninitialize(N)), this.setNotificationHandler(BZ, () => {
                var N;
                return (N = this.oninitialized) === null || N === void 0 ? void 0 : N.call(this)
            }), this._capabilities.logging) this.setRequestHandler(IZ, async (N, K) => {
            var x;
            let j = K.sessionId || ((x = K.requestInfo) === null || x === void 0 ? void 0 : x.headers["mcp-session-id"]) || void 0,
                {
                    level: B
                } = N.params,
                O = pV.safeParse(B);
            if (O.success) this._loggingLevels.set(j, O.data);
            return {}
        })
    }
    get experimental() {
        if (!this._experimental) this._experimental = {
            tasks: new PF(this)
        };
        return this._experimental
    }
    registerCapabilities(v) {
        if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
        this._capabilities = fO(this._capabilities, v)
    }
    setRequestHandler(v, z) {
        var U, V, N;
        let K = l8(v),
            x = K === null || K === void 0 ? void 0 : K.method;
        if (!x) throw Error("Schema is missing a method literal");
        let j;
        if (z3(x)) {
            let O = x,
                J = (U = O._zod) === null || U === void 0 ? void 0 : U.def;
            j = (V = J === null || J === void 0 ? void 0 : J.value) !== null && V !== void 0 ? V : O.value
        } else {
            let O = x,
                J = O._def;
            j = (N = J === null || J === void 0 ? void 0 : J.value) !== null && N !== void 0 ? N : O.value
        }
        if (typeof j !== "string") throw Error("Schema method literal must be a string");
        if (j === "tools/call") {
            let O = async (J, q) => {
                let H = U3(b1, J);
                if (!H.success) {
                    let Z = H.error instanceof Error ? H.error.message : String(H.error);
                    throw new x6(H6.InvalidParams, `Invalid tools/call request: ${Z}`)
                }
                let {
                    params: D
                } = H.data, A = await Promise.resolve(z(J, q));
                if (D.task) {
                    let Z = U3(_9, A);
                    if (!Z.success) {
                        let $ = Z.error instanceof Error ? Z.error.message : String(Z.error);
                        throw new x6(H6.InvalidParams, `Invalid task creation result: ${$}`)
                    }
                    return Z.data
                }
                let w = U3(w8, A);
                if (!w.success) {
                    let Z = w.error instanceof Error ? w.error.message : String(w.error);
                    throw new x6(H6.InvalidParams, `Invalid tools/call result: ${Z}`)
                }
                return w.data
            };
            return super.setRequestHandler(v, O)
        }
        return super.setRequestHandler(v, z)
    }
    assertCapabilityForMethod(v) {
        var z, U, V;
        switch (v) {
            case "sampling/createMessage":
                if (!((z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.sampling)) throw Error(`Client does not support sampling (required for ${v})`);
                break;
            case "elicitation/create":
                if (!((U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.elicitation)) throw Error(`Client does not support elicitation (required for ${v})`);
                break;
            case "roots/list":
                if (!((V = this._clientCapabilities) === null || V === void 0 ? void 0 : V.roots)) throw Error(`Client does not support listing roots (required for ${v})`);
                break;
            case "ping":
                break
        }
    }
    assertNotificationCapability(v) {
        var z, U;
        switch (v) {
            case "notifications/message":
                if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${v})`);
                break;
            case "notifications/resources/updated":
            case "notifications/resources/list_changed":
                if (!this._capabilities.resources) throw Error(`Server does not support notifying about resources (required for ${v})`);
                break;
            case "notifications/tools/list_changed":
                if (!this._capabilities.tools) throw Error(`Server does not support notifying of tool list changes (required for ${v})`);
                break;
            case "notifications/prompts/list_changed":
                if (!this._capabilities.prompts) throw Error(`Server does not support notifying of prompt list changes (required for ${v})`);
                break;
            case "notifications/elicitation/complete":
                if (!((U = (z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.elicitation) === null || U === void 0 ? void 0 : U.url)) throw Error(`Client does not support URL elicitation (required for ${v})`);
                break;
            case "notifications/cancelled":
                break;
            case "notifications/progress":
                break
        }
    }
    assertRequestHandlerCapability(v) {
        if (!this._capabilities) return;
        switch (v) {
            case "completion/complete":
                if (!this._capabilities.completions) throw Error(`Server does not support completions (required for ${v})`);
                break;
            case "logging/setLevel":
                if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${v})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!this._capabilities.prompts) throw Error(`Server does not support prompts (required for ${v})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
                if (!this._capabilities.resources) throw Error(`Server does not support resources (required for ${v})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!this._capabilities.tools) throw Error(`Server does not support tools (required for ${v})`);
                break;
            case "tasks/get":
            case "tasks/list":
            case "tasks/result":
            case "tasks/cancel":
                if (!this._capabilities.tasks) throw Error(`Server does not support tasks capability (required for ${v})`);
                break;
            case "ping":
            case "initialize":
                break
        }
    }
    assertTaskCapability(v) {
        var z, U;
        wJ((U = (z = this._clientCapabilities) === null || z === void 0 ? void 0 : z.tasks) === null || U === void 0 ? void 0 : U.requests, v, "Client")
    }
    assertTaskHandlerCapability(v) {
        var z;
        if (!this._capabilities) return;
        $J((z = this._capabilities.tasks) === null || z === void 0 ? void 0 : z.requests, v, "Server")
    }
    async _oninitialize(v) {
        let z = v.params.protocolVersion;
        return this._clientCapabilities = v.params.capabilities, this._clientVersion = v.params.clientInfo, {
            protocolVersion: BO.includes(z) ? z : mV,
            capabilities: this.getCapabilities(),
            serverInfo: this._serverInfo,
            ...this._instructions && {
                instructions: this._instructions
            }
        }
    }
    getClientCapabilities() {
        return this._clientCapabilities
    }
    getClientVersion() {
        return this._clientVersion
    }
    getCapabilities() {
        return this._capabilities
    }
    async ping() {
        return this.request({
            method: "ping"
        }, P9)
    }
    async createMessage(v, z) {
        var U, V;
        if (v.tools || v.toolChoice) {
            if (!((V = (U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.sampling) === null || V === void 0 ? void 0 : V.tools)) throw Error("Client does not support sampling tools capability.")
        }
        if (v.messages.length > 0) {
            let N = v.messages[v.messages.length - 1],
                K = Array.isArray(N.content) ? N.content : [N.content],
                x = K.some((J) => J.type === "tool_result"),
                j = v.messages.length > 1 ? v.messages[v.messages.length - 2] : void 0,
                B = j ? Array.isArray(j.content) ? j.content : [j.content] : [],
                O = B.some((J) => J.type === "tool_use");
            if (x) {
                if (K.some((J) => J.type !== "tool_result")) throw Error("The last message must contain only tool_result content if any is present");
                if (!O) throw Error("tool_result blocks are not matching any tool_use from the previous message")
            }
            if (O) {
                let J = new Set(B.filter((H) => H.type === "tool_use").map((H) => H.id)),
                    q = new Set(K.filter((H) => H.type === "tool_result").map((H) => H.toolUseId));
                if (J.size !== q.size || ![...J].every((H) => q.has(H))) throw Error("ids of tool_result blocks and tool_use blocks from previous message do not match")
            }
        }
        if (v.tools) return this.request({
            method: "sampling/createMessage",
            params: v
        }, bZ, z);
        return this.request({
            method: "sampling/createMessage",
            params: v
        }, nV, z)
    }
    async elicitInput(v, z) {
        var U, V, N, K, x;
        switch ((U = v.mode) !== null && U !== void 0 ? U : "form") {
            case "url": {
                if (!((N = (V = this._clientCapabilities) === null || V === void 0 ? void 0 : V.elicitation) === null || N === void 0 ? void 0 : N.url)) throw Error("Client does not support url elicitation.");
                let B = v;
                return this.request({
                    method: "elicitation/create",
                    params: B
                }, R1, z)
            }
            case "form": {
                if (!((x = (K = this._clientCapabilities) === null || K === void 0 ? void 0 : K.elicitation) === null || x === void 0 ? void 0 : x.form)) throw Error("Client does not support form elicitation.");
                let B = v.mode === "form" ? v : {
                        ...v,
                        mode: "form"
                    },
                    O = await this.request({
                        method: "elicitation/create",
                        params: B
                    }, R1, z);
                if (O.action === "accept" && O.content && B.requestedSchema) try {
                    let q = this._jsonSchemaValidator.getValidator(B.requestedSchema)(O.content);
                    if (!q.valid) throw new x6(H6.InvalidParams, `Elicitation response content does not match requested schema: ${q.errorMessage}`)
                } catch (J) {
                    if (J instanceof x6) throw J;
                    throw new x6(H6.InternalError, `Error validating elicitation response: ${J instanceof Error?J.message:String(J)}`)
                }
                return O
            }
        }
    }
    createElicitationCompletionNotifier(v, z) {
        var U, V;
        if (!((V = (U = this._clientCapabilities) === null || U === void 0 ? void 0 : U.elicitation) === null || V === void 0 ? void 0 : V.url)) throw Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
        return () => this.notification({
            method: "notifications/elicitation/complete",
            params: {
                elicitationId: v
            }
        }, z)
    }
    async listRoots(v, z) {
        return this.request({
            method: "roots/list",
            params: v
        }, EZ, z)
    }
    async sendLoggingMessage(v, z) {
        if (this._capabilities.logging) {
            if (!this.isMessageIgnored(v.level, z)) return this.notification({
                method: "notifications/message",
                params: v
            })
        }
    }
    async sendResourceUpdated(v) {
        return this.notification({
            method: "notifications/resources/updated",
            params: v
        })
    }
    async sendResourceListChanged() {
        return this.notification({
            method: "notifications/resources/list_changed"
        })
    }
    async sendToolListChanged() {
        return this.notification({
            method: "notifications/tools/list_changed"
        })
    }
    async sendPromptListChanged() {
        return this.notification({
            method: "notifications/prompts/list_changed"
        })
    }
}
var pg = Symbol.for("mcp.completable");

function ng(v) {
    return !!v && typeof v === "object" && pg in v
}

function Qg(v) {
    let z = v[pg];
    return z === null || z === void 0 ? void 0 : z.complete
}
var hg;
(function(v) {
    v.Completable = "McpCompletable"
})(hg || (hg = {}));
var GD6 = /^[A-Za-z0-9._-]{1,128}$/;

function ID6(v) {
    let z = [];
    if (v.length === 0) return {
        isValid: !1,
        warnings: ["Tool name cannot be empty"]
    };
    if (v.length > 128) return {
        isValid: !1,
        warnings: [`Tool name exceeds maximum length of 128 characters (current: ${v.length})`]
    };
    if (v.includes(" ")) z.push("Tool name contains spaces, which may cause parsing issues");
    if (v.includes(",")) z.push("Tool name contains commas, which may cause parsing issues");
    if (v.startsWith("-") || v.endsWith("-")) z.push("Tool name starts or ends with a dash, which may cause parsing issues in some contexts");
    if (v.startsWith(".") || v.endsWith(".")) z.push("Tool name starts or ends with a dot, which may cause parsing issues in some contexts");
    if (!GD6.test(v)) {
        let U = v.split("").filter((V) => !/[A-Za-z0-9._-]/.test(V)).filter((V, N, K) => K.indexOf(V) === N);
        return z.push(`Tool name contains invalid characters: ${U.map((V)=>`"${V}"`).join(", ")}`, "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)"), {
            isValid: !1,
            warnings: z
        }
    }
    return {
        isValid: !0,
        warnings: z
    }
}

function MD6(v, z) {
    if (z.length > 0) {
        console.warn(`Tool name validation warning for "${v}":`);
        for (let U of z) console.warn(`  - ${U}`);
        console.warn("Tool registration will proceed, but this may cause compatibility issues."), console.warn("Consider updating the tool name to conform to the MCP tool naming standard."), console.warn("See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.")
    }
}

function CF(v) {
    let z = ID6(v);
    return MD6(v, z.warnings), z.isValid
}
class fF {
    constructor(v) {
        this._mcpServer = v
    }
    registerToolTask(v, z, U) {
        let V = {
            taskSupport: "required",
            ...z.execution
        };
        if (V.taskSupport === "forbidden") throw Error(`Cannot register task-based tool '${v}' with taskSupport 'forbidden'. Use registerTool() instead.`);
        return this._mcpServer._createRegisteredTool(v, z.title, z.description, z.inputSchema, z.outputSchema, z.annotations, V, z._meta, U)
    }
}
class YF {
    constructor(v, z) {
        this._registeredResources = {}, this._registeredResourceTemplates = {}, this._registeredTools = {}, this._registeredPrompts = {}, this._toolHandlersInitialized = !1, this._completionHandlerInitialized = !1, this._resourceHandlersInitialized = !1, this._promptHandlersInitialized = !1, this.server = new _F(v, z)
    }
    get experimental() {
        if (!this._experimental) this._experimental = {
            tasks: new fF(this)
        };
        return this._experimental
    }
    async connect(v) {
        return await this.server.connect(v)
    }
    async close() {
        await this.server.close()
    }
    setToolRequestHandlers() {
        if (this._toolHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(f5(WO)), this.server.assertCanSetRequestHandler(f5(b1)), this.server.registerCapabilities({
            tools: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(WO, () => ({
            tools: Object.entries(this._registeredTools).filter(([, v]) => v.enabled).map(([v, z]) => {
                let U = {
                    name: v,
                    title: z.title,
                    description: z.description,
                    inputSchema: (() => {
                        let V = Z1(z.inputSchema);
                        return V ? TZ(V, {
                            strictUnions: !0,
                            pipeStrategy: "input"
                        }) : bD6
                    })(),
                    annotations: z.annotations,
                    execution: z.execution,
                    _meta: z._meta
                };
                if (z.outputSchema) {
                    let V = Z1(z.outputSchema);
                    if (V) U.outputSchema = TZ(V, {
                        strictUnions: !0,
                        pipeStrategy: "output"
                    })
                }
                return U
            })
        })), this.server.setRequestHandler(b1, async (v, z) => {
            var U;
            try {
                let V = this._registeredTools[v.params.name];
                if (!V) throw new x6(H6.InvalidParams, `Tool ${v.params.name} not found`);
                if (!V.enabled) throw new x6(H6.InvalidParams, `Tool ${v.params.name} disabled`);
                let N = !!v.params.task,
                    K = (U = V.execution) === null || U === void 0 ? void 0 : U.taskSupport,
                    x = "createTask" in V.handler;
                if ((K === "required" || K === "optional") && !x) throw new x6(H6.InternalError, `Tool ${v.params.name} has taskSupport '${K}' but was not registered with registerToolTask`);
                if (K === "required" && !N) throw new x6(H6.MethodNotFound, `Tool ${v.params.name} requires task augmentation (taskSupport: 'required')`);
                if (K === "optional" && !N && x) return await this.handleAutomaticTaskPolling(V, v, z);
                let j = await this.validateToolInput(V, v.params.arguments, v.params.name),
                    B = await this.executeToolHandler(V, j, z);
                if (N) return B;
                return await this.validateToolOutput(V, B, v.params.name), B
            } catch (V) {
                if (V instanceof x6) {
                    if (V.code === H6.UrlElicitationRequired) throw V
                }
                return this.createToolError(V instanceof Error ? V.message : String(V))
            }
        }), this._toolHandlersInitialized = !0
    }
    createToolError(v) {
        return {
            content: [{
                type: "text",
                text: v
            }],
            isError: !0
        }
    }
    async validateToolInput(v, z, U) {
        if (!v.inputSchema) return;
        let V = Z1(v.inputSchema),
            N = V !== null && V !== void 0 ? V : v.inputSchema,
            K = await nB(N, z);
        if (!K.success) {
            let x = "error" in K ? K.error : "Unknown error",
                j = QB(x);
            throw new x6(H6.InvalidParams, `Input validation error: Invalid arguments for tool ${U}: ${j}`)
        }
        return K.data
    }
    async validateToolOutput(v, z, U) {
        if (!v.outputSchema) return;
        if (!("content" in z)) return;
        if (z.isError) return;
        if (!z.structuredContent) throw new x6(H6.InvalidParams, `Output validation error: Tool ${U} has an output schema but no structured content was provided`);
        let V = Z1(v.outputSchema),
            N = await nB(V, z.structuredContent);
        if (!N.success) {
            let K = "error" in N ? N.error : "Unknown error",
                x = QB(K);
            throw new x6(H6.InvalidParams, `Output validation error: Invalid structured content for tool ${U}: ${x}`)
        }
    }
    async executeToolHandler(v, z, U) {
        let V = v.handler;
        if ("createTask" in V) {
            if (!U.taskStore) throw Error("No task store provided.");
            let K = {
                ...U,
                taskStore: U.taskStore
            };
            if (v.inputSchema) return await Promise.resolve(V.createTask(z, K));
            else return await Promise.resolve(V.createTask(K))
        }
        if (v.inputSchema) return await Promise.resolve(V(z, U));
        else return await Promise.resolve(V(U))
    }
    async handleAutomaticTaskPolling(v, z, U) {
        var V;
        if (!U.taskStore) throw Error("No task store provided for task-capable tool.");
        let N = await this.validateToolInput(v, z.params.arguments, z.params.name),
            K = v.handler,
            x = {
                ...U,
                taskStore: U.taskStore
            },
            j = N ? await Promise.resolve(K.createTask(N, x)) : await Promise.resolve(K.createTask(x)),
            B = j.task.taskId,
            O = j.task,
            J = (V = O.pollInterval) !== null && V !== void 0 ? V : 5000;
        while (O.status !== "completed" && O.status !== "failed" && O.status !== "cancelled") {
            await new Promise((H) => setTimeout(H, J));
            let q = await U.taskStore.getTask(B);
            if (!q) throw new x6(H6.InternalError, `Task ${B} not found during polling`);
            O = q
        }
        return await U.taskStore.getTaskResult(B)
    }
    setCompletionRequestHandler() {
        if (this._completionHandlerInitialized) return;
        this.server.assertCanSetRequestHandler(f5(EO)), this.server.registerCapabilities({
            completions: {}
        }), this.server.setRequestHandler(EO, async (v) => {
            switch (v.params.ref.type) {
                case "ref/prompt":
                    return Hy(v), this.handlePromptCompletion(v, v.params.ref);
                case "ref/resource":
                    return Dy(v), this.handleResourceCompletion(v, v.params.ref);
                default:
                    throw new x6(H6.InvalidParams, `Invalid completion reference: ${v.params.ref}`)
            }
        }), this._completionHandlerInitialized = !0
    }
    async handlePromptCompletion(v, z) {
        let U = this._registeredPrompts[z.name];
        if (!U) throw new x6(H6.InvalidParams, `Prompt ${z.name} not found`);
        if (!U.enabled) throw new x6(H6.InvalidParams, `Prompt ${z.name} disabled`);
        if (!U.argsSchema) return MN;
        let V = l8(U.argsSchema),
            N = V === null || V === void 0 ? void 0 : V[v.params.argument.name];
        if (!ng(N)) return MN;
        let K = Qg(N);
        if (!K) return MN;
        let x = await K(v.params.argument.value, v.params.context);
        return og(x)
    }
    async handleResourceCompletion(v, z) {
        let U = Object.values(this._registeredResourceTemplates).find((K) => K.resourceTemplate.uriTemplate.toString() === z.uri);
        if (!U) {
            if (this._registeredResources[z.uri]) return MN;
            throw new x6(H6.InvalidParams, `Resource template ${v.params.ref.uri} not found`)
        }
        let V = U.resourceTemplate.completeCallback(v.params.argument.name);
        if (!V) return MN;
        let N = await V(v.params.argument.value, v.params.context);
        return og(N)
    }
    setResourceRequestHandlers() {
        if (this._resourceHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(f5(GO)), this.server.assertCanSetRequestHandler(f5(IO)), this.server.assertCanSetRequestHandler(f5(MO)), this.server.registerCapabilities({
            resources: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(GO, async (v, z) => {
            let U = Object.entries(this._registeredResources).filter(([N, K]) => K.enabled).map(([N, K]) => ({
                    uri: N,
                    name: K.name,
                    ...K.metadata
                })),
                V = [];
            for (let N of Object.values(this._registeredResourceTemplates)) {
                if (!N.resourceTemplate.listCallback) continue;
                let K = await N.resourceTemplate.listCallback(z);
                for (let x of K.resources) V.push({
                    ...N.metadata,
                    ...x
                })
            }
            return {
                resources: [...U, ...V]
            }
        }), this.server.setRequestHandler(IO, async () => {
            return {
                resourceTemplates: Object.entries(this._registeredResourceTemplates).map(([z, U]) => ({
                    name: z,
                    uriTemplate: U.resourceTemplate.uriTemplate.toString(),
                    ...U.metadata
                }))
            }
        }), this.server.setRequestHandler(MO, async (v, z) => {
            let U = new URL(v.params.uri),
                V = this._registeredResources[U.toString()];
            if (V) {
                if (!V.enabled) throw new x6(H6.InvalidParams, `Resource ${U} disabled`);
                return V.readCallback(U, z)
            }
            for (let N of Object.values(this._registeredResourceTemplates)) {
                let K = N.resourceTemplate.uriTemplate.match(U.toString());
                if (K) return N.readCallback(U, K, z)
            }
            throw new x6(H6.InvalidParams, `Resource ${U} not found`)
        }), this.setCompletionRequestHandler(), this._resourceHandlersInitialized = !0
    }
    setPromptRequestHandlers() {
        if (this._promptHandlersInitialized) return;
        this.server.assertCanSetRequestHandler(f5(bO)), this.server.assertCanSetRequestHandler(f5(RO)), this.server.registerCapabilities({
            prompts: {
                listChanged: !0
            }
        }), this.server.setRequestHandler(bO, () => ({
            prompts: Object.entries(this._registeredPrompts).filter(([, v]) => v.enabled).map(([v, z]) => {
                return {
                    name: v,
                    title: z.title,
                    description: z.description,
                    arguments: z.argsSchema ? WD6(z.argsSchema) : void 0
                }
            })
        })), this.server.setRequestHandler(RO, async (v, z) => {
            let U = this._registeredPrompts[v.params.name];
            if (!U) throw new x6(H6.InvalidParams, `Prompt ${v.params.name} not found`);
            if (!U.enabled) throw new x6(H6.InvalidParams, `Prompt ${v.params.name} disabled`);
            if (U.argsSchema) {
                let V = Z1(U.argsSchema),
                    N = await nB(V, v.params.arguments);
                if (!N.success) {
                    let j = "error" in N ? N.error : "Unknown error",
                        B = QB(j);
                    throw new x6(H6.InvalidParams, `Invalid arguments for prompt ${v.params.name}: ${B}`)
                }
                let K = N.data,
                    x = U.callback;
                return await Promise.resolve(x(K, z))
            } else {
                let V = U.callback;
                return await Promise.resolve(V(z))
            }
        }), this.setCompletionRequestHandler(), this._promptHandlersInitialized = !0
    }
    resource(v, z, ...U) {
        let V;
        if (typeof U[0] === "object") V = U.shift();
        let N = U[0];
        if (typeof z === "string") {
            if (this._registeredResources[z]) throw Error(`Resource ${z} is already registered`);
            let K = this._createRegisteredResource(v, void 0, z, V, N);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), K
        } else {
            if (this._registeredResourceTemplates[v]) throw Error(`Resource template ${v} is already registered`);
            let K = this._createRegisteredResourceTemplate(v, void 0, z, V, N);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), K
        }
    }
    registerResource(v, z, U, V) {
        if (typeof z === "string") {
            if (this._registeredResources[z]) throw Error(`Resource ${z} is already registered`);
            let N = this._createRegisteredResource(v, U.title, z, U, V);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), N
        } else {
            if (this._registeredResourceTemplates[v]) throw Error(`Resource template ${v} is already registered`);
            let N = this._createRegisteredResourceTemplate(v, U.title, z, U, V);
            return this.setResourceRequestHandlers(), this.sendResourceListChanged(), N
        }
    }
    _createRegisteredResource(v, z, U, V, N) {
        let K = {
            name: v,
            title: z,
            metadata: V,
            readCallback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                uri: null
            }),
            update: (x) => {
                if (typeof x.uri < "u" && x.uri !== U) {
                    if (delete this._registeredResources[U], x.uri) this._registeredResources[x.uri] = K
                }
                if (typeof x.name < "u") K.name = x.name;
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.metadata < "u") K.metadata = x.metadata;
                if (typeof x.callback < "u") K.readCallback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendResourceListChanged()
            }
        };
        return this._registeredResources[U] = K, K
    }
    _createRegisteredResourceTemplate(v, z, U, V, N) {
        let K = {
            resourceTemplate: U,
            title: z,
            metadata: V,
            readCallback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                name: null
            }),
            update: (x) => {
                if (typeof x.name < "u" && x.name !== v) {
                    if (delete this._registeredResourceTemplates[v], x.name) this._registeredResourceTemplates[x.name] = K
                }
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.template < "u") K.resourceTemplate = x.template;
                if (typeof x.metadata < "u") K.metadata = x.metadata;
                if (typeof x.callback < "u") K.readCallback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendResourceListChanged()
            }
        };
        return this._registeredResourceTemplates[v] = K, K
    }
    _createRegisteredPrompt(v, z, U, V, N) {
        let K = {
            title: z,
            description: U,
            argsSchema: V === void 0 ? void 0 : w1(V),
            callback: N,
            enabled: !0,
            disable: () => K.update({
                enabled: !1
            }),
            enable: () => K.update({
                enabled: !0
            }),
            remove: () => K.update({
                name: null
            }),
            update: (x) => {
                if (typeof x.name < "u" && x.name !== v) {
                    if (delete this._registeredPrompts[v], x.name) this._registeredPrompts[x.name] = K
                }
                if (typeof x.title < "u") K.title = x.title;
                if (typeof x.description < "u") K.description = x.description;
                if (typeof x.argsSchema < "u") K.argsSchema = w1(x.argsSchema);
                if (typeof x.callback < "u") K.callback = x.callback;
                if (typeof x.enabled < "u") K.enabled = x.enabled;
                this.sendPromptListChanged()
            }
        };
        return this._registeredPrompts[v] = K, K
    }
    _createRegisteredTool(v, z, U, V, N, K, x, j, B) {
        CF(v);
        let O = {
            title: z,
            description: U,
            inputSchema: dg(V),
            outputSchema: dg(N),
            annotations: K,
            execution: x,
            _meta: j,
            handler: B,
            enabled: !0,
            disable: () => O.update({
                enabled: !1
            }),
            enable: () => O.update({
                enabled: !0
            }),
            remove: () => O.update({
                name: null
            }),
            update: (J) => {
                if (typeof J.name < "u" && J.name !== v) {
                    if (typeof J.name === "string") CF(J.name);
                    if (delete this._registeredTools[v], J.name) this._registeredTools[J.name] = O
                }
                if (typeof J.title < "u") O.title = J.title;
                if (typeof J.description < "u") O.description = J.description;
                if (typeof J.paramsSchema < "u") O.inputSchema = w1(J.paramsSchema);
                if (typeof J.callback < "u") O.handler = J.callback;
                if (typeof J.annotations < "u") O.annotations = J.annotations;
                if (typeof J._meta < "u") O._meta = J._meta;
                if (typeof J.enabled < "u") O.enabled = J.enabled;
                this.sendToolListChanged()
            }
        };
        return this._registeredTools[v] = O, this.setToolRequestHandlers(), this.sendToolListChanged(), O
    }
    tool(v, ...z) {
        if (this._registeredTools[v]) throw Error(`Tool ${v} is already registered`);
        let U, V, N, K;
        if (typeof z[0] === "string") U = z.shift();
        if (z.length > 1) {
            let j = z[0];
            if (TF(j)) {
                if (V = z.shift(), z.length > 1 && typeof z[0] === "object" && z[0] !== null && !TF(z[0])) K = z.shift()
            } else if (typeof j === "object" && j !== null) K = z.shift()
        }
        let x = z[0];
        return this._createRegisteredTool(v, void 0, U, V, N, K, {
            taskSupport: "forbidden"
        }, void 0, x)
    }
    registerTool(v, z, U) {
        if (this._registeredTools[v]) throw Error(`Tool ${v} is already registered`);
        let {
            title: V,
            description: N,
            inputSchema: K,
            outputSchema: x,
            annotations: j,
            _meta: B
        } = z;
        return this._createRegisteredTool(v, V, N, K, x, j, {
            taskSupport: "forbidden"
        }, B, U)
    }
    prompt(v, ...z) {
        if (this._registeredPrompts[v]) throw Error(`Prompt ${v} is already registered`);
        let U;
        if (typeof z[0] === "string") U = z.shift();
        let V;
        if (z.length > 1) V = z.shift();
        let N = z[0],
            K = this._createRegisteredPrompt(v, void 0, U, V, N);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), K
    }
    registerPrompt(v, z, U) {
        if (this._registeredPrompts[v]) throw Error(`Prompt ${v} is already registered`);
        let {
            title: V,
            description: N,
            argsSchema: K
        } = z, x = this._createRegisteredPrompt(v, V, N, K, U);
        return this.setPromptRequestHandlers(), this.sendPromptListChanged(), x
    }
    isConnected() {
        return this.server.transport !== void 0
    }
    async sendLoggingMessage(v, z) {
        return this.server.sendLoggingMessage(v, z)
    }
    sendResourceListChanged() {
        if (this.isConnected()) this.server.sendResourceListChanged()
    }
    sendToolListChanged() {
        if (this.isConnected()) this.server.sendToolListChanged()
    }
    sendPromptListChanged() {
        if (this.isConnected()) this.server.sendPromptListChanged()
    }
}
var bD6 = {
    type: "object",
    properties: {}
};

function rg(v) {
    return v !== null && typeof v === "object" && "parse" in v && typeof v.parse === "function" && "safeParse" in v && typeof v.safeParse === "function"
}

function RD6(v) {
    return "_def" in v || "_zod" in v || rg(v)
}

function TF(v) {
    if (typeof v !== "object" || v === null) return !1;
    if (RD6(v)) return !1;
    if (Object.keys(v).length === 0) return !0;
    return Object.values(v).some(rg)
}

function dg(v) {
    if (!v) return;
    if (TF(v)) return w1(v);
    return v
}

function WD6(v) {
    let z = l8(v);
    if (!z) return [];
    return Object.entries(z).map(([U, V]) => {
        let N = qu(V),
            K = Hu(V);
        return {
            name: U,
            description: N,
            required: !K
        }
    })
}

function f5(v) {
    let z = l8(v),
        U = z === null || z === void 0 ? void 0 : z.method;
    if (!U) throw Error("Schema is missing a method literal");
    let V = dB(U);
    if (typeof V === "string") return V;
    throw Error("Schema method literal must be a string")
}

function og(v) {
    return {
        completion: {
            values: v.slice(0, 100),
            total: v.length,
            hasMore: v.length > 100
        }
    }
}
var MN = {
    completion: {
        values: [],
        hasMore: !1
    }
};
var bi = o(require("http"));
var l6 = o(require("vscode")),
    T5 = o(require("path"));
async function ag(v = {}) {
    try {
        let z = fU(v.uri);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(z, null, 2)
            }]
        }
    } catch (z) {
        throw console.error("Error getting diagnostics through MCP:", z), z
    }
}
async function tg({
    filePath: v,
    preview: z,
    startText: U,
    endText: V,
    selectToEndOfLine: N,
    makeFrontmost: K = !0
}) {
    try {
        if (!v) throw Error("File path is required");
        let x;
        if (!T5.isAbsolute(v) && l6.workspace.workspaceFolders && l6.workspace.workspaceFolders.length > 0) {
            let j = l6.workspace.workspaceFolders[0].uri.fsPath,
                B = T5.join(j, v);
            x = l6.Uri.file(B), console.log(`Converted relative path '${v}' to absolute: '${B}'`)
        } else x = l6.Uri.file(v);
        try {
            await l6.workspace.fs.stat(x);
            let j = await l6.workspace.openTextDocument(x),
                B = l6.window.visibleTextEditors.some((q) => q.document.uri.toString() === x.toString()),
                O;
            if (K || !B) O = await l6.window.showTextDocument(j, {
                preview: z,
                preserveFocus: !K
            });
            else O = l6.window.visibleTextEditors.find((q) => q.document.uri.toString() === x.toString());
            if (U && O) {
                let q = j.getText(),
                    H = {
                        success: !0,
                        filePath: x.fsPath,
                        message: `Opened file: ${x.fsPath}`
                    },
                    D = q.indexOf(U);
                if (D !== -1) {
                    let A = j.positionAt(D),
                        w;
                    if (V) {
                        let $ = q.substring(D + U.length).indexOf(V);
                        if ($ !== -1) {
                            let F = D + U.length + $ + V.length;
                            if (w = j.positionAt(F), N) w = new l6.Position(w.line, Number.MAX_SAFE_INTEGER);
                            O.selection = new l6.Selection(A, w), O.revealRange(new l6.Range(A, w), l6.TextEditorRevealType.InCenter), H.message = `Opened file and selected text from "${U}" to "${V}"`
                        } else O.selection = new l6.Selection(A, A), O.revealRange(new l6.Range(A, A), l6.TextEditorRevealType.InCenter), H.message = `Opened file and positioned at "${U}" (end text "${V}" not found)`
                    } else w = j.positionAt(D + U.length), O.selection = new l6.Selection(A, w), O.revealRange(new l6.Range(A, w), l6.TextEditorRevealType.InCenter), H.message = `Opened file and selected text "${U}"`
                } else H.message = `Opened file, but text "${U}" not found`;
                return {
                    content: [{
                        type: "text",
                        text: H.message
                    }]
                }
            }
            let J = {
                success: !0,
                filePath: x.fsPath,
                fileUrl: j.uri.toString(),
                message: `Opened file: ${x.fsPath}`
            };
            if (!K) J.languageId = j.languageId, J.lineCount = j.lineCount, J.isDirty = j.isDirty, J.isUntitled = j.isUntitled, J.isClosed = j.isClosed;
            return {
                content: [{
                    type: "text",
                    text: K ? J.message : JSON.stringify(J, null, 2)
                }]
            }
        } catch (j) {
            throw Error(`File not found: ${x.fsPath}`)
        }
    } catch (x) {
        throw console.error("Error opening file through MCP:", x), x
    }
}
async function sg() {
    try {
        let v = l6.window.activeTextEditor,
            z = [];
        for (let V of l6.window.tabGroups.all)
            for (let N of V.tabs)
                if (N.input instanceof l6.TabInputText) {
                    let K = N.input.uri,
                        x = l6.workspace.textDocuments.find((B) => B.uri.toString() === K.toString()),
                        j = {
                            uri: K.toString(),
                            isActive: N.isActive,
                            isPinned: N.isPinned,
                            isPreview: N.isPreview,
                            isDirty: N.isDirty,
                            label: N.label,
                            groupIndex: V.viewColumn ? V.viewColumn - 1 : 0,
                            viewColumn: V.viewColumn,
                            isGroupActive: V.isActive
                        };
                    if (x) {
                        if (j.fileName = x.fileName, j.languageId = x.languageId, j.lineCount = x.lineCount, j.isUntitled = x.isUntitled, v && v.document.uri.toString() === K.toString()) j.selection = {
                            start: {
                                line: v.selection.start.line,
                                character: v.selection.start.character
                            },
                            end: {
                                line: v.selection.end.line,
                                character: v.selection.end.character
                            },
                            isReversed: v.selection.isReversed
                        }
                    }
                    z.push(j)
                } return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    tabs: z
                }, null, 2)
            }]
        }
    } catch (v) {
        throw console.error("Error getting open editors through MCP:", v), v
    }
}
async function eg() {
    try {
        let v = l6.window.activeTextEditor;
        if (!v) return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !1,
                    message: "No active editor found"
                }, null, 2)
            }]
        };
        let {
            selection: z,
            document: U
        } = v, V = U.getText(z), N = U.uri.fsPath;
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    text: V,
                    filePath: N,
                    fileUrl: U.uri.toString(),
                    selection: {
                        start: {
                            line: z.start.line,
                            character: z.start.character
                        },
                        end: {
                            line: z.end.line,
                            character: z.end.character
                        },
                        isEmpty: z.isEmpty
                    }
                }, null, 2)
            }]
        }
    } catch (v) {
        throw console.error("Error getting current selection through MCP:", v), v
    }
}
async function vc() {
    try {
        let z = (l6.workspace.workspaceFolders || []).map((U) => ({
            name: U.name,
            uri: U.uri.toString(),
            path: U.uri.fsPath,
            index: U.index
        }));
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    folders: z,
                    rootPath: l6.workspace.rootPath || null,
                    workspaceFile: l6.workspace.workspaceFile?.toString() || null
                }, null, 2)
            }]
        }
    } catch (v) {
        throw console.error("Error getting workspace folders through MCP:", v), v
    }
}
async function zc({
    filePath: v
}) {
    try {
        if (!v) throw Error("File path is required");
        let z;
        if (!T5.isAbsolute(v) && l6.workspace.workspaceFolders && l6.workspace.workspaceFolders.length > 0) {
            let V = l6.workspace.workspaceFolders[0].uri.fsPath,
                N = T5.join(V, v);
            z = l6.Uri.file(N), console.log(`Converted relative path '${v}' to absolute: '${N}'`)
        } else z = l6.Uri.file(v);
        let U = l6.workspace.textDocuments.find((V) => V.uri.toString() === z.toString());
        if (!U) return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !1,
                    message: `Document not open: ${z.fsPath}`
                }, null, 2)
            }]
        };
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    filePath: z.fsPath,
                    isDirty: U.isDirty,
                    isUntitled: U.isUntitled
                }, null, 2)
            }]
        }
    } catch (z) {
        throw console.error("Error checking document dirty state through MCP:", z), z
    }
}
async function Uc({
    filePath: v
}) {
    try {
        if (!v) throw Error("File path is required");
        let z;
        if (!T5.isAbsolute(v) && l6.workspace.workspaceFolders && l6.workspace.workspaceFolders.length > 0) {
            let N = l6.workspace.workspaceFolders[0].uri.fsPath,
                K = T5.join(N, v);
            z = l6.Uri.file(K), console.log(`Converted relative path '${v}' to absolute: '${K}'`)
        } else z = l6.Uri.file(v);
        let U = l6.workspace.textDocuments.find((N) => N.uri.toString() === z.toString());
        if (!U) return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !1,
                    message: `Document not open: ${z.fsPath}`
                }, null, 2)
            }]
        };
        let V = await U.save();
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    filePath: z.fsPath,
                    saved: V,
                    message: V ? "Document saved successfully" : "Document was not dirty or save failed"
                }, null, 2)
            }]
        }
    } catch (z) {
        throw console.error("Error saving document through MCP:", z), z
    }
}
var n0 = o(require("vscode")),
    uF;
async function ED6() {
    if (!uF) {
        let v = n0.extensions.getExtension("ms-toolsai.jupyter");
        if (!v) throw Error("Jupyter extension not installed");
        uF = Promise.resolve(v.activate())
    }
    return uF
}

function l1(v, z) {
    return v.error(z), {
        content: [{
            type: "text",
            text: z
        }]
    }
}
async function Vc(v, z) {
    let U = n0.window.activeNotebookEditor;
    if (!U) return l1(v, "No active notebook editor found.");
    let V;
    try {
        V = await ED6()
    } catch (x) {
        return l1(v, "Unable to request Jupyter extension API. It is either not installed or not activated.")
    }
    let N = await V.kernels.getKernel(U.notebook.uri);
    if (!N) return l1(v, "No kernel found for the active notebook. Please connect to a kernel.");
    if (N.language !== "python") return l1(v, `Kernel language is ${N?.language}, not python.`);
    let K = {
        content: []
    };
    try {
        v.info(`Executing ${z}`);
        let x = new TextDecoder,
            j = await PD6(z, U.notebook),
            B = U.notebook.getCells().find((q) => q.metadata.id === j);
        if (!B) return l1(v, "No cell found in the notebook.");
        let O = U.notebook.getCells().indexOf(B);
        if (U.revealRange(new n0.NotebookRange(O, O + 1), n0.NotebookEditorRevealType.InCenter), !await SD6(v)) return l1(v, "Code execution cancelled by user. Ask the user how they would like to proceed.");
        await n0.commands.executeCommand("notebook.cell.execute", {
            ranges: [{
                start: O,
                end: O + 1
            }],
            document: U.notebook.uri
        });
        for (let q of B.outputs)
            for (let H of q.items)
                if (H.mime === _D6) {
                    let D = JSON.parse(x.decode(H.data));
                    v.appendLine(`Error executing code ${D.name}: ${D.message},/n ${D.stack}`), K.content.push({
                        type: "text",
                        text: `Error: ${D.name}: ${D.message},/n ${D.stack}`
                    })
                } else if (H.mime === CD6) {
            let D = Buffer.from(H.data).toString("base64");
            K.content.push({
                type: "image",
                data: D,
                mimeType: H.mime
            })
        } else K.content.push({
            type: "text",
            text: x.decode(H.data)
        });
        v.info("Code execution completed")
    } catch (x) {
        v.error(`Code execution failed with an error '${x}'`)
    }
    return K
}
async function SD6(v) {
    return (await n0.window.showQuickPick([{
        label: "Execute",
        description: "Run the code in the notebook"
    }, {
        label: "Cancel",
        description: "Do not execute the code"
    }], {
        title: "Claude Code Execution",
        placeHolder: "Choose whether to execute the code"
    }))?.label === "Execute"
}
async function PD6(v, z) {
    let U = new n0.NotebookCellData(n0.NotebookCellKind.Code, v, "python"),
        V = Math.random().toString(36).substring(2, 15);
    U.metadata = {
        id: V
    };
    let N = z.getCells().length,
        K = n0.NotebookEdit.insertCells(N, [U]),
        x = new n0.WorkspaceEdit;
    return x.set(z.uri, [K]), await n0.workspace.applyEdit(x), V
}
var _D6 = n0.NotebookCellOutputItem.error(Error("")).mime,
    CD6 = "image/png";
var WJ = o(require("vscode")),
    t8 = o(require("fs")),
    EJ = o(require("path")),
    Nc = o(require("os")),
    Kc = o(require("http"));

function fD6() {
    return Math.floor(Math.random() * 55536) + 1e4
}

function xc() {
    let v = EJ.join(Nc.homedir(), ".claude", "ide");
    if (!t8.existsSync(v)) t8.mkdirSync(v, {
        recursive: !0,
        mode: 448
    });
    return v
}

function yF(v, z) {
    let U = xc(),
        V = EJ.join(U, `${v}.lock`),
        N = t8.existsSync(V),
        K = isForceLocalMode() ? [getForceLocalCwd()] : WJ.workspace.workspaceFolders?.map((j) => j.uri.fsPath) || [],
        x = {
            pid: process.ppid,
            workspaceFolders: K,
            ideName: WJ.env.appName,
            transport: "ws",
            runningInWindows: process.platform === "win32",
            authToken: z
        };
    if (t8.writeFileSync(V, JSON.stringify(x), {
            mode: 384
        }), N) console.log(`Updated lock file with new workspace folders: ${V}`);
    return V
}

function jc(v) {
    let z = xc(),
        U = EJ.join(z, `${v}.lock`);
    if (t8.existsSync(U)) try {
        t8.unlinkSync(U)
    } catch (V) {
        console.error(`Failed to delete lock file ${U}:`, V)
    }
}

function TD6(v) {
    return new Promise((z) => {
        let U = Kc.createServer();
        U.once("error", () => {
            z(!1)
        }), U.once("listening", () => {
            U.close(), z(!0)
        }), U.listen(v)
    })
}
async function Bc() {
    for (let v = 0; v < 50; v++) {
        let z = fD6();
        if (await TD6(z)) return z
    }
    throw Error("Failed to find an available port after multiple attempts")
}
var x4 = o(require("vscode")),
    Dc = o(require("fs"));
var Oc = o(require("vscode"));

function W8() {
    try {
        let v = Oc.window.activeTerminal;
        if (v) v.show()
    } catch (v) {
        console.error("Error focusing terminal:", v)
    }
}
var u9 = o(require("vscode"));
async function Jc(v, z) {
    let U = v.input;
    if (U instanceof u9.TabInputTextDiff) try {
        await (await u9.workspace.openTextDocument(U.modified)).save()
    } catch (V) {
        z.error("Error saving modified file:", V)
    }
    await u9.window.tabGroups.close(v)
}
async function SJ(v) {
    let z = 0;
    v.info("Closing all diff tabs in the editor...");
    for (let U of u9.window.tabGroups.all)
        for (let V of U.tabs)
            if (V.input instanceof u9.TabInputTextDiff && V.label.includes("[Claude Code]")) await Jc(V, v), z++;
    return v.info(`Closed ${z} diff tabs.`), z
}
async function qc(v, z) {
    for (let U of u9.window.tabGroups.all)
        for (let V of U.tabs)
            if (V.label === v) return await Jc(V, z), !0;
    return !1
}
var Y5;
async function Ac(v, z, U, V, N, K, x, j, B) {
    v.info("diff from", V, "to", N, "as", x);
    let O;
    if (isForceLocalMode()) {
        // forceLocal: read old content from remote, fall back to empty
        var _oldContent_ac = "";
        try {
            var _rt_ac = require("./src/remote-tools");
            var _remoteUri_ac = _rt_ac.getRemoteUri(V);
            var _remoteData_ac = await x4.workspace.fs.readFile(_remoteUri_ac);
            _oldContent_ac = Buffer.from(_remoteData_ac).toString("utf8");
        } catch (_err_ac) {
            v.info("forceLocal: Ac remote read failed", V, _err_ac.message || _err_ac);
        }
        O = z.createFile(V, _oldContent_ac).uri;
    } else {
        O = x4.Uri.file(V);
        try {
            if ((await x4.workspace.openTextDocument(O)).isDirty) {
                let X = Dc.readFileSync(V, "utf8");
                O = z.createFile(V, X).uri
            }
        } catch (T) {
            v.info("leftTempFileProvider.createFile", V), O = z.createFile(V, "").uri
        }
    }
    let q = U.createFile(N, K).uri,
        H = await x4.workspace.openTextDocument(q),
        D = (T) => {
            return T.input instanceof x4.TabInputTextDiff && T.input.modified.toString() === q.toString()
        };
    if (await SJ(v) > 0) await new Promise((T) => setTimeout(T, 200));
    let w = {
            preview: !1
        },
        Z = K,
        $ = K,
        F = void 0;
    B.push(x4.workspace.onDidChangeTextDocument((T) => {
        if (T.document.uri.toString() === q.toString()) {
            if (Z = $, $ = T.document.getText(), T.contentChanges.length > 3 && T.reason !== x4.TextDocumentChangeReason.Undo && T.reason !== x4.TextDocumentChangeReason.Redo) F = {
                time: Date.now(),
                contents: Z
            }
        }
    }));
    let L = new Promise((T) => {
            B.push(x4.workspace.onWillSaveTextDocument((X) => {
                if (X.document.uri.toString() === q.toString()) {
                    let Q = X.document.getText();
                    if (F && Date.now() - F.time < 500) Q = F.contents;
                    T(Q)
                }
            }))
        }),
        G = !0;
    if (Y5) Y5.dispose(), Y5 = void 0;
    try {
        Y5 = x4.commands.registerCommand("type", (T) => {
            if (G && x4.window.activeTextEditor?.document.uri.toString() === q.toString()) return;
            return x4.commands.executeCommand("default:type", T)
        }), setTimeout(() => {
            if (G = !1, Y5) Y5.dispose(), Y5 = void 0
        }, 1000), B.push(Y5)
    } catch (T) {
        v.warn("Could not register type command interceptor:", T)
    }
    let I = PJ(),
        M = await x4.commands.executeCommand("vscode.diff", O, q, x, w);
    v.info("diff result", M, x, O, q, w);
    try {
        await Hc(() => {
            return PJ().some((T) => T.label === x)
        }, 1000)
    } catch (T) {
        let X = PJ().filter((Q) => !I.some((m) => m.label === Q.label)).map((Q) => {
            return {
                label: Q.label,
                isDiff: Q.isDiff
            }
        });
        throw v.error(`Failed to open diff tab, possibly new tabs: ${JSON.stringify(X)}`), T
    }
    W8();
    let b = new Promise((T) => {
            B.push(j((X) => {
                if (X.activeTab && D(X.activeTab)) T(X)
            }))
        }).then((T) => {
            if (T.accepted) return v.info("diff_accepted", x), {
                content: [{
                    type: "text",
                    text: "FILE_SAVED"
                }, {
                    type: "text",
                    text: H.getText()
                }]
            };
            else return {
                content: [{
                    type: "text",
                    text: "DIFF_REJECTED"
                }, {
                    type: "text",
                    text: x
                }]
            }
        }),
        W = Hc(() => {
            return !PJ().some((T) => T.label === x)
        }).then(() => {
            return v.info("tab_closed", x), {
                content: [{
                    type: "text",
                    text: "DIFF_REJECTED"
                }, {
                    type: "text",
                    text: x
                }]
            }
        }),
        E = L.then(async (T) => {
            return v.info("file_saved", x), {
                content: [{
                    type: "text",
                    text: "FILE_SAVED"
                }, {
                    type: "text",
                    text: T
                }]
            }
        }),
        y = [W, b];
    if (x4.workspace.getConfiguration("files").get("autoSave") === "off") y.push(E);
    return await Promise.race(y)
}

function PJ() {
    return x4.window.tabGroups.all.flatMap((v) => v.tabs.map((z) => ({
        tab: z,
        label: z.label,
        isDiff: z.input instanceof x4.TabInputTextDiff,
        viewColumn: v.viewColumn,
        isActive: z.isActive
    })))
}

function Hc(v, z) {
    return new Promise((U, V) => {
        let N, K = setInterval(() => {
            if (v()) {
                if (clearInterval(K), N) clearTimeout(N);
                U()
            }
        }, 100);
        if (z) N = setTimeout(() => {
            clearInterval(K), V(Error(`Timeout waiting after ${z}ms`))
        }, z)
    })
}
async function $c(v, z, U) {
    if (v.environmentVariableCollection.get(z)?.value === U) return;
    v.environmentVariableCollection.replace(z, U);
    let K = ["KEY", "TOKEN", "SECRET", "PASSWORD", "CREDENTIAL"].some((x) => z.toUpperCase().includes(x));
    console.log(`Set ${z}=${K?"[REDACTED]":U} in terminal environment (in-memory)`)
}
var a26 = o(Ji(), 1),
    t26 = o(iF(), 1),
    s26 = o(hF(), 1),
    Li = o(gJ(), 1),
    aF = o(Zi(), 1);
var a1 = Li.default;
class tF {
    ws;
    started = !1;
    opened;
    constructor(v) {
        this.ws = v;
        this.opened = new Promise((z, U) => {
            if (this.ws.readyState === a1.OPEN) z();
            else this.ws.on("open", () => {
                z()
            }), this.ws.on("error", (V) => {
                U(V)
            })
        }), this.ws.on("message", this.onMessageHandler), this.ws.on("error", this.onErrorHandler), this.ws.on("close", this.onCloseHandler)
    }
    onclose;
    onerror;
    onmessage;
    onMessageHandler = (v) => {
        try {
            let z = JSON.parse(v.toString("utf-8")),
                U = qO.parse(z);
            this.onmessage?.(U)
        } catch (z) {
            this.onErrorHandler(z)
        }
    };
    onErrorHandler = (v) => {
        this.onerror?.(v instanceof Error ? v : Error("Failed to process message"))
    };
    onCloseHandler = () => {
        this.onclose?.(), this.ws.off("message", this.onMessageHandler), this.ws.off("error", this.onErrorHandler), this.ws.off("close", this.onCloseHandler)
    };
    async start() {
        if (this.started) throw Error("Start can only be called once per transport.");
        if (await this.opened, this.ws.readyState !== a1.OPEN) throw Error("WebSocket is not open. Cannot start transport.");
        this.started = !0
    }
    async close() {
        if (this.ws.readyState === a1.OPEN || this.ws.readyState === a1.CONNECTING) this.ws.close();
        this.onCloseHandler()
    }
    async send(v) {
        if (this.ws.readyState !== a1.OPEN) throw Error("WebSocket is not open. Cannot send message.");
        let z = JSON.stringify(v);
        try {
            await new Promise((U, V) => {
                this.ws.send(z, (N) => {
                    if (N) V(N);
                    else U()
                })
            })
        } catch (U) {
            throw this.onErrorHandler(U), U
        }
    }
}
var sF = o(require("vscode"));
async function iJ(v, z) {
    try {
        z.send({
            jsonrpc: "2.0",
            method: "selection_changed",
            params: v
        }).catch((U) => {
            console.error("Error sending selection change notification:", U)
        })
    } catch (U) {
        console.error("Error sending selection change notification:", U)
    }
}
async function Fi(v, z) {
    try {
        z.send({
            jsonrpc: "2.0",
            method: "at_mentioned",
            params: v
        }).catch((U) => {
            console.error("Error sending at-mentioned notification:", U)
        })
    } catch (U) {
        console.error("Error sending at-mentioned notification:", U)
    }
}
var X9 = null;

function eF() {
    return X9
}

function Gi(v, z) {
    let U = null,
        V = sF.window.onDidChangeTextEditorSelection((N) => {
            let K = N.textEditor,
                x = K.selection,
                j = K.document,
                B = j.getText(x);
            if (j.uri.scheme === "comment" || j.uri.scheme === "output") return;
            let O = {
                    text: B,
                    filePath: j.uri.fsPath,
                    fileUrl: j.uri.toString(),
                    selection: {
                        start: {
                            line: x.start.line,
                            character: x.start.character
                        },
                        end: {
                            line: x.end.line,
                            character: x.end.character
                        },
                        isEmpty: x.isEmpty
                    }
                },
                J = !X9 || X9.text !== O.text || X9.filePath !== O.filePath || X9.selection.start.line !== O.selection.start.line || X9.selection.start.character !== O.selection.start.character || X9.selection.end.line !== O.selection.end.line || X9.selection.end.character !== O.selection.end.character;
            X9 = O;
            let q = z();
            if (J && q && v.server) {
                if (U) clearTimeout(U);
                U = setTimeout(() => {
                    let H = z();
                    if (H) iJ(O, H)
                }, 300)
            }
        });
    return {
        dispose: () => {
            if (V.dispose(), U) clearTimeout(U)
        }
    }
}

function Ii(v, z, U) {
    return v(() => {
        let V = sF.window.activeTextEditor;
        if (!V) return;
        let N = V.selection,
            K = {
                filePath: V.document.uri.fsPath
            };
        if (!N.isEmpty) K.lineStart = N.start.line, K.lineEnd = N.end.line;
        let x = U();
        if (x && z.server) Fi(K, x), W8()
    })
}

function e26() {
    let v = u7.env.appName,
        z;
    switch (v.toLowerCase()) {
        case "visual studio code":
            z = "Claude Code VSCode MCP";
            break;
        case "cursor":
            z = "Claude Code Cursor MCP";
            break;
        case "windsurf":
            z = "Claude Code Windsurf MCP";
            break;
        default:
            z = `Claude Code ${v} MCP`
    }
    return z
}

function vA6(v, z, U, V) {
    return v.logged.event((N) => {
        let K = V();
        if (K && z.server) Ei(U, N, K);
        else vG.push(N)
    })
}

// --- forceLocal mode helper ---
function isForceLocalMode() {
    const _vsc = require("vscode");
    const _cfg = _vsc.workspace.getConfiguration("claudeCode");
    const forceLocal = _cfg.get("forceLocal", false);
    if (!forceLocal) return false;
    // Accept if sshHost is explicitly set, or remoteAuthority/remoteName is present
    const sshHost = _cfg.get("sshHost", "");
    if (sshHost) return true;
    if (_vsc.env.remoteAuthority) return true;
    if (_vsc.env.remoteName) return true;
    // Also check if workspace folders have remote URIs
    const folders = _vsc.workspace.workspaceFolders;
    if (folders && folders.length > 0 && folders[0].uri.scheme !== "file") return true;
    return false;
}

/**
 * In forceLocal mode, create a dedicated local directory as cwd.
 * This avoids accessing remote paths locally and keeps session isolation.
 * Returns the local cwd path (guaranteed to exist).
 */
function getForceLocalCwd() {
    const _vsc = require("vscode");
    const _os = require("os");
    const _path = require("path");
    const _fs = require("fs");

    const folders = _vsc.workspace.workspaceFolders;
    const remotePath = folders && folders.length > 0 ? folders[0].uri.path : "default";
    const host = (() => {
        const cfg = _vsc.workspace.getConfiguration("claudeCode");
        const override = cfg.get("sshHost", "");
        if (override) return override;
        const authority = _vsc.env.remoteAuthority || "";
        const m = authority.match(/^ssh-remote\+(.+)$/);
        return m ? m[1] : "unknown";
    })();

    // ~/.claude/remote/<host>/<encoded-remote-path>/
    const safeRemotePath = remotePath.replace(/\//g, "-").replace(/^-/, "");
    const localCwd = _path.join(_os.homedir(), ".claude", "remote", host, safeRemotePath);
    _fs.mkdirSync(localCwd, { recursive: true, mode: 0o755 });
    return localCwd;
}

function Ri(v, z, U, V, N, K, x) {
    let j = new YF({
        name: e26(),
        version: v.extension.packageJSON.version || "0.0.1"
    });
    j.tool("openDiff", "Open a git diff for the file", {
        old_file_path: s.string().describe("Path to the file to show diff for. If not provided, uses active editor."),
        new_file_path: s.string().describe("Path to the file to show diff for. If not provided, uses active editor."),
        new_file_contents: s.string().describe("Contents of the new file. If not provided then the current file contents of new_file_path will be used."),
        tab_name: s.string().describe("Path to the file to show diff for. If not provided, uses active editor.")
    }, async ({
        old_file_path: G,
        new_file_path: I,
        new_file_contents: M,
        tab_name: b
    }) => {
        let W = [];
        try {
            return await Ac(V, z, U, G, I, M, b, N, W)
        } catch (E) {
            throw V.error(`Error opening diff: ${E}`), E
        } finally {
            for (let E of W) E.dispose()
        }
    }), j.tool("getDiagnostics", "Get language diagnostics from VS Code", {
        uri: s.string().optional().describe("Optional file URI to get diagnostics for. If not provided, gets diagnostics for all files.")
    }, ag), j.tool("close_tab", {
        tab_name: s.string()
    }, async ({
        tab_name: G
    }) => {
        return await qc(G, V), setTimeout(() => {
            W8()
        }, 500), {
            content: [{
                type: "text",
                text: "TAB_CLOSED"
            }]
        }
    }), j.tool("closeAllDiffTabs", "Close all diff tabs in the editor", {}, async () => {
        let G = await SJ(V);
        return setTimeout(() => {
            W8()
        }, 500), {
            content: [{
                type: "text",
                text: `CLOSED_${G}_DIFF_TABS`
            }]
        }
    }), j.tool("openFile", "Open a file in the editor and optionally select a range of text", {
        filePath: s.string().describe("Path to the file to open"),
        preview: s.boolean().describe("Whether to open the file in preview mode").default(!1),
        startText: s.string().describe("Text pattern to find the start of the selection range. Selects from the beginning of this match."),
        endText: s.string().describe("Text pattern to find the end of the selection range. Selects up to the end of this match. If not provided, only the startText match will be selected."),
        selectToEndOfLine: s.boolean().describe("If true, selection will extend to the end of the line containing the endText match.").default(!1),
        makeFrontmost: s.boolean().describe("Whether to make the file the active editor tab. If false, the file will be opened in the background without changing focus.").default(!0)
    }, {
        readOnlyHint: !0
    }, tg), j.tool("getOpenEditors", "Get information about currently open editors", {}, sg), j.tool("getWorkspaceFolders", "Get all workspace folders currently open in the IDE", {}, vc), j.tool("getCurrentSelection", "Get the current text selection in the active editor", {}, eg), j.tool("checkDocumentDirty", "Check if a document has unsaved changes (is dirty)", {
        filePath: s.string().describe("Path to the file to check")
    }, zc), j.tool("saveDocument", "Save a document with unsaved changes", {
        filePath: s.string().describe("Path to the file to save")
    }, Uc), j.tool("getLatestSelection", "Get the most recent text selection (even if not in the active editor)", {}, async () => {
        return {
            content: [{
                type: "text",
                text: JSON.stringify(eF() || {
                    success: !1,
                    message: "No selection available"
                }, null, 2)
            }]
        }
    }), j.tool("executeCode", `Execute python code in the Jupyter kernel for the current notebook file.
    
    All code will be executed in the current Jupyter kernel.
    
    Avoid declaring variables or modifying the state of the kernel unless the user
    explicitly asks for it.
    
    Any code executed will persist across calls to this tool, unless the kernel
    has been restarted.`, {
        code: s.string().describe("The code to be executed on the kernel.")
    }, ({
        code: G
    }) => {
        return Vc(V, G)
    });
    // --- forceLocal: register remote file proxy tools ---
    if (isForceLocalMode()) {
        try {
            var _remoteTools = require("./src/remote-tools");
            _remoteTools.registerTools(j, s, V);
            V.info("forceLocal: remote tools registered on WebSocket MCP server. Total tools: " + Object.keys(j._registeredTools).length);
        } catch (_rtErr) {
            V.error("forceLocal: FAILED to register remote tools: " + (_rtErr.message || _rtErr));
        }
    } else {
        V.info("forceLocal: MCP remote tools NOT registered (forceLocal mode not active)");
    }
    let B = bi.createServer(),
        O = new aF.default({
            server: B
        }),
        J = null,
        q = null,
        H = H7.getInstance(V),
        D = Mi.randomUUID();
    O.on("connection", function(G, I) {
        if (I.headers["x-claude-code-ide-authorization"] !== D) {
            V.error("Unauthorized WebSocket connection attempt"), G.close(1008, "Unauthorized");
            return
        }
        if (V.info("New WS connection from:", I.url || "unknown"), J) {
            if (V.info("Disconnecting previous WebSocket client"), q) H.unregisterClient(q), V.info(`Unregistered previous diagnostic client: ${q}`), q = null;
            try {
                J.close()
            } catch (W) {
                V.error("Error closing previous transport:", W)
            }
        }
        let M = new tF(G);
        J = M;
        let b = null;
        j.connect(M).then(() => {
            V.info("MCP server connected to transport"), b = H.registerClient((W) => {
                M.send({
                    jsonrpc: "2.0",
                    method: "diagnostics_changed",
                    params: {
                        uris: W
                    }
                }).catch((E) => {
                    V.error("Error sending diagnostics notification:", E.message)
                })
            }), q = b, V.info(`Registered diagnostic client: ${b}`), setTimeout(() => {
                let W = eF();
                if (W) iJ(W, M);
                let E = [...vG];
                vG.length = 0;
                for (let y of E) Ei(V, y, M)
            }, 500)
        }).catch((W) => {
            console.error("Error connecting transport:", W), J = null;
            try {
                G.close()
            } catch (E) {
                V.error("Error closing WebSocket:", E)
            }
        }), G.on("close", () => {
            if (V.info("WS client disconnected"), J === M) {
                if (J = null, b && q === b) H.unregisterClient(b), V.info(`Unregistered diagnostic client: ${b}`), q = null
            }
        })
    });
    let A = () => J,
        w = vA6(x, j, V, A),
        Z = Ii(K, j, A),
        $ = Gi(j, A),
        F = null;
    B.on("listening", () => {
        let G = B.address();
        if (G && typeof G !== "string") F = G.port
    });
    let L = u7.workspace.onDidChangeWorkspaceFolders(() => {
        if (F !== null) yF(F, D), V.info(`Updated lock file for port ${F} with new workspace folders`)
    });
    return {
        httpServer: B,
        authToken: D,
        dispose: async () => {
            if (F !== null) jc(F), V.info(`Deleted lock file for port ${F}`);
            if (w.dispose(), Z.dispose(), $.dispose(), L.dispose(), H.dispose(), B.close(), typeof j.close === "function") await j.close()
        }
    }
}
async function Wi(v, z, U, V) {
    try {
        let N = await Bc(),
            K = null;
        return new Promise((x, j) => {
            v.listen(N, "127.0.0.1", async () => {
                V.info(`MCP Server running on port ${N} (localhost only)`), K = yF(N, z), console.log(`Created lock file at ${K}`);
                try {
                    await $c(U, "CLAUDE_CODE_SSE_PORT", String(N)), x(N)
                } catch (B) {
                    console.error("Failed to set environment variables:", B), j(B)
                }
            }).on("error", (B) => {
                console.error("Failed to start MCP server:", B), u7.window.showErrorMessage(`Failed to start MCP server: ${B}`), j(B)
            })
        })
    } catch (N) {
        throw console.error("Failed to start MCP server:", N), u7.window.showErrorMessage(`Failed to start MCP server: ${N}`), N
    }
}

function Ei(v, z, U) {
    v.info("Logging event:", z.eventName, z.eventData);
    let V = {
        eventName: z.eventName,
        eventData: z.eventData ?? {}
    };
    U.send({
        jsonrpc: "2.0",
        method: "log_event",
        params: V
    }).catch((N) => {
        v.error("Error sending log event:", N)
    })
}
var vG = [];
var C0 = o(require("vscode")),
    Si = o(require("path"));
var zG = o(n2(), 1);

function zA6(v) {
    return typeof v === "string" && ["bottom", "window", "beside"].includes(v)
}
async function UA6(v, z, U = !0, V, N = [], K) {
    if (v.info("Creating new Claude terminal"), U) C0.window.withProgress({
        location: C0.ProgressLocation.Notification,
        title: "Claude Code launching...",
        cancellable: !1
    }, async (O) => {
        return new Promise((J) => setTimeout(J, 2000))
    });
    // --- Patch 13: forceLocal terminal mode  use node-pty to run CLI locally ---
    // In Remote SSH, createTerminal() creates a REMOTE terminal  but the remote
    // server has no internet. We need the CLI to run LOCALLY (where API access works).
    // Solution: use ExtensionTerminalOptions with a Pseudoterminal backed by node-pty.
    // The pty runs in the extension host (local/UI side). node-pty creates a real PTY
    // so the CLI's TUI renders properly (box-drawing, 24-bit color, resize).
    // Python pty wrapper is kept as fallback if node-pty is unavailable.
    if (isForceLocalMode()) {
        var _flCwd = getForceLocalCwd();
        var _flCliPath = Si.join(z.extensionPath, "resources", "native-binary", "claude");

        // Build CLI args: disallowed + allowed tools (MUST be space-separated, not comma)
        var _flCliArgs = [...N,
            "--disallowed-tools", "Read", "Write", "Edit", "MultiEdit", "Glob", "Grep", "Bash", "NotebookEdit"
        ];
        var _flAllowed = [
            "mcp__claude-vscode__read_file",
            "mcp__claude-vscode__glob",
            "mcp__claude-vscode__grep",
            "mcp__claude-vscode__bash"
        ];
        var _flDiffMode = C0.workspace.getConfiguration("claudeCode").get("forceLocalDiffMode", "auto");
        if (_flDiffMode !== "review") {
            _flAllowed.push("mcp__claude-vscode__write_file", "mcp__claude-vscode__edit_file");
        }
        _flCliArgs.push("--allowed-tools", ..._flAllowed);
        if (V) _flCliArgs.push(V); // append prompt if provided

        // Try to load node-pty from VS Code's bundled modules
        var _flNodePty = null;
        try {
            _flNodePty = require(require("path").join(C0.env.appRoot, "node_modules", "node-pty"));
            v.info("forceLocal terminal: loaded node-pty from VS Code");
        } catch (_e) {
            v.warn("forceLocal terminal: node-pty not available (" + _e.message + "), falling back to Python pty");
        }

        var _flWriteEmitter = new C0.EventEmitter();
        var _flCloseEmitter = new C0.EventEmitter();
        var _flPtyProc = null;

        var _flPty;
        if (_flNodePty) {
            // --- Primary: node-pty (correct PTY with TIOCSWINSZ, ONLCR, 24-bit color) ---
            _flPty = {
                onDidWrite: _flWriteEmitter.event,
                onDidClose: _flCloseEmitter.event,
                open: function(dims) {
                    var _env = Object.assign({}, process.env);
                    delete _env.CLAUDECODE;
                    _env.TERM = "xterm-256color";
                    _env.COLORTERM = "truecolor";
                    _env.FORCE_COLOR = "3";

                    _flPtyProc = _flNodePty.spawn(_flCliPath, _flCliArgs, {
                        name: "xterm-256color",
                        cols: dims ? dims.columns : 120,
                        rows: dims ? dims.rows : 30,
                        cwd: _flCwd,
                        env: _env
                    });

                    _flPtyProc.onData(function(data) {
                        _flWriteEmitter.fire(data);
                    });
                    _flPtyProc.onExit(function(e) {
                        _flWriteEmitter.fire("\r\n[Process exited with code " + (e.exitCode || 0) + "]\r\n");
                        _flCloseEmitter.fire(e.exitCode || 0);
                        _flPtyProc = null;
                    });
                },
                close: function() {
                    if (_flPtyProc) {
                        _flPtyProc.kill();
                    }
                },
                handleInput: function(data) {
                    if (_flPtyProc) {
                        _flPtyProc.write(data);
                    }
                },
                setDimensions: function(dims) {
                    if (_flPtyProc) {
                        _flPtyProc.resize(dims.columns, dims.rows);
                    }
                }
            };
        } else {
            // --- Fallback: Python pty wrapper (for environments without node-pty) ---
            var _flCp = require("child_process");
            var _flPyPty = `
import pty, os, sys, select, signal, struct, fcntl, termios

pid, fd = pty.openpty()

try:
    cols = int(os.environ.get('COLUMNS', '120'))
    rows = int(os.environ.get('LINES', '30'))
    fcntl.ioctl(fd, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))
except:
    pass

child = os.fork()
if child == 0:
    os.setsid()
    import tty
    tty.setraw(fd)
    os.dup2(fd, 0)
    os.dup2(fd, 1)
    os.dup2(fd, 2)
    os.close(fd)
    os.close(pid)
    os.execvp(sys.argv[1], sys.argv[1:])
else:
    os.close(fd)
    def handle_winch(signum, frame):
        try:
            cols = int(os.environ.get('COLUMNS', '120'))
            rows = int(os.environ.get('LINES', '30'))
            fcntl.ioctl(pid, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))
            os.kill(child, signal.SIGWINCH)
        except:
            pass
    signal.signal(signal.SIGWINCH, handle_winch)
    try:
        while True:
            r, _, _ = select.select([pid, 0], [], [], 1)
            if pid in r:
                try:
                    data = os.read(pid, 4096)
                    if not data:
                        break
                    os.write(1, data)
                except OSError:
                    break
            if 0 in r:
                try:
                    data = os.read(0, 4096)
                    if not data:
                        break
                    os.write(pid, data)
                except OSError:
                    break
    except:
        pass
    try:
        os.kill(child, signal.SIGTERM)
    except:
        pass
    _, status = os.waitpid(child, 0)
    sys.exit(os.WEXITSTATUS(status) if os.WIFEXITED(status) else 1)
`;
            _flPty = {
                onDidWrite: _flWriteEmitter.event,
                onDidClose: _flCloseEmitter.event,
                open: function(dims) {
                    var _env = Object.assign({}, process.env);
                    delete _env.CLAUDECODE;
                    _env.TERM = "xterm-256color";
                    _env.COLORTERM = "truecolor";
                    _env.FORCE_COLOR = "3";
                    if (dims) {
                        _env.COLUMNS = String(dims.columns);
                        _env.LINES = String(dims.rows);
                    }

                    _flPtyProc = _flCp.spawn("python3", ["-c", _flPyPty, _flCliPath].concat(_flCliArgs), {
                        cwd: _flCwd,
                        env: _env,
                        stdio: ["pipe", "pipe", "pipe"]
                    });

                    _flPtyProc.stdout.on("data", function(d) {
                        _flWriteEmitter.fire(d.toString());
                    });
                    _flPtyProc.stderr.on("data", function(d) {
                        _flWriteEmitter.fire(d.toString());
                    });
                    _flPtyProc.on("close", function(code) {
                        _flWriteEmitter.fire("\r\n[Process exited with code " + (code || 0) + "]\r\n");
                        _flCloseEmitter.fire(code || 0);
                    });
                    _flPtyProc.on("error", function(err) {
                        _flWriteEmitter.fire("\r\n[Error: " + err.message + "]\r\n");
                        _flCloseEmitter.fire(1);
                    });
                },
                close: function() {
                    if (_flPtyProc) {
                        _flPtyProc.kill("SIGTERM");
                        setTimeout(function() {
                            try { if (_flPtyProc && !_flPtyProc.killed) _flPtyProc.kill("SIGKILL"); } catch(e) {}
                        }, 3000);
                    }
                },
                handleInput: function(data) {
                    if (_flPtyProc && _flPtyProc.stdin && _flPtyProc.stdin.writable) {
                        _flPtyProc.stdin.write(data);
                    }
                },
                setDimensions: function(dims) {
                    if (_flPtyProc && _flPtyProc.pid) {
                        try { process.kill(_flPtyProc.pid, "SIGWINCH"); } catch(e) {}
                    }
                }
            };
        }

        let x = K === "beside" || K === void 0 ? {
                viewColumn: C0.ViewColumn.Beside
            } : K === "window" ? {
                viewColumn: C0.ViewColumn.One
            } : void 0;

        let j = C0.window.createTerminal({
            name: process.env.CLAUDE_CODE_TERMINAL_TITLE || "Claude Code (Local)",
            pty: _flPty,
            iconPath: C0.Uri.file(Si.join(z.extensionPath, "resources", "claude-logo.svg")),
            location: x,
            isTransient: !0
        });

        j.show();
        if (K === "window") await C0.commands.executeCommand("workbench.action.moveEditorToNewWindow");
        v.info("forceLocal terminal: launched LOCAL CLI via " + (_flNodePty ? "node-pty" : "Python pty fallback") + ", cwd=" + _flCwd + ", cli=" + _flCliPath);
        return { terminal: j, claudeRunning: !0 };
    }
    // --- end Patch 13 (forceLocal early return above; normal path below) ---
    let x = K === "beside" || K === void 0 ? {
            viewColumn: C0.ViewColumn.Beside
        } : K === "window" ? {
            viewColumn: C0.ViewColumn.One
        } : void 0,
        j = C0.window.createTerminal({
            name: process.env.CLAUDE_CODE_TERMINAL_TITLE || "Claude Code",
            iconPath: C0.Uri.file(Si.join(z.extensionPath, "resources", "claude-logo.svg")),
            location: x,
            isTransient: !0
        });
    z.subscriptions.push(C0.window.onDidEndTerminalShellExecution((O) => {
        if (O.terminal === j && O.execution.commandLine.value.startsWith("claude ")) v.info(`Claude terminal closed after executing ${O.execution.commandLine.value}`), j.dispose()
    }));
    let B = !1;
    if (z.subscriptions.push(C0.window.onDidChangeTerminalShellIntegration(async (O) => {
            let J = ["claude", ...N];
            if (V) J.push(V);
            if (O.terminal === j && !B) B = !0, v.info("Terminal shell integration available"), O.shellIntegration.executeCommand(zG.quote(J))
        })), setTimeout(() => {
            if (!j.shellIntegration && !B) {
                B = !0;
                let O = ["claude", ...N];
                if (V) O.push(V);
                j.sendText(zG.quote(O))
            }
        }, 3000), j.show(), K === "window") await C0.commands.executeCommand("workbench.action.moveEditorToNewWindow");
    return {
        terminal: j,
        claudeRunning: !0
    }
}

function Pi(v, z, U) {
    let V = async (N, K, x) => {
        try {
            await UA6(v, z, !0, N, K, x)
        } catch (j) {
            v.error("Error running Claude Code:", j), C0.window.showErrorMessage(`Failed to run Claude Code: ${j}`)
        }
    };
    z.subscriptions.push(C0.commands.registerCommand("claude-vscode.terminal.open", (N, K, x) => {
        U.logEvent("run_claude_command");
        let j = typeof N === "string" ? N : void 0,
            B = Array.isArray(K) ? K : void 0,
            O = zA6(x) ? x : void 0;
        V(j, B, O)
    })), z.subscriptions.push(C0.commands.registerCommand("claude-vscode.terminal.open.keyboard", () => {
        U.logEvent("run_claude_command_keyboard"), V()
    }))
}

function _i(v) {
    let z = new C0.EventEmitter;
    return v.push(C0.commands.registerCommand("claude-code.acceptProposedDiff", async () => {
        let U = C0.window.tabGroups.activeTabGroup.activeTab;
        z.fire({
            accepted: !0,
            activeTab: U
        }), W8()
    })), v.push(C0.commands.registerCommand("claude-code.rejectProposedDiff", async () => {
        let U = C0.window.tabGroups.activeTabGroup.activeTab;
        z.fire({
            accepted: !1,
            activeTab: U
        }), W8()
    })), z.event
}

function Ci(v, z) {
    let U = new C0.EventEmitter;
    return v.push(C0.commands.registerCommand("claude-code.insertAtMentioned", async () => {
        if (z?.nativeAtMentionCallback) {
            let V = C0.window.activeTextEditor;
            if (!V) return;
            let N = V.document,
                K = C0.workspace.asRelativePath(N.fileName),
                x = V.selection,
                j;
            if (x.isEmpty) j = `@${K}`;
            else {
                let O = x.start.line + 1,
                    J = x.end.line + 1;
                j = O !== J ? `@${K}#L${O}-${J}` : `@${K}#L${O}`
            }
            if (!z.nativeAtMentionCallback(j)) U.fire({})
        } else U.fire({}), W8()
    })), U.event
}
var fi = o(require("vscode"));
class UG {
    logged = new fi.EventEmitter;
    logEvent(v, z) {
        this.logged.fire({
            eventName: v,
            eventData: z
        })
    }
}

function Ti(v, z, U) {
    v.subscriptions.push(z);
    let V = new UG;
    z.info("Claude code extension is now active?");
    let N = new RJ("_claude_fs_left");
    let K = new RJ("_claude_fs_right");
    if (isForceLocalMode()) {
        // In forceLocal mode (UI side), registerFileSystemProvider may require
        // the 'resolvers' proposed API. Wrap in try-catch to allow activation to continue.
        try {
            v.subscriptions.push(g9.workspace.registerFileSystemProvider(N.scheme, N));
            v.subscriptions.push(g9.workspace.registerFileSystemProvider(K.scheme, K)), v.subscriptions.push(VA6(K.scheme));
        } catch (fsErr) {
            z.warn("FileSystemProvider registration failed (expected in forceLocal/UI mode):", fsErr.message || fsErr);
        }
    } else {
        v.subscriptions.push(g9.workspace.registerFileSystemProvider(N.scheme, N));
        v.subscriptions.push(g9.workspace.registerFileSystemProvider(K.scheme, K)), v.subscriptions.push(VA6(K.scheme));
    }
    let x = _i(v.subscriptions),
        j = Ci(v.subscriptions, {
            output: z,
            context: v,
            nativeAtMentionCallback: U.nativeAtMentionCallback
        });
    Pi(z, v, V);
    try {
        let {
            httpServer: B,
            authToken: O,
            dispose: J
        } = Ri(v, N, K, z, x, j, V);
        Wi(B, O, v, z).catch((q) => {
            z.error("Failed to start MCP server:", q), g9.window.showErrorMessage(`Failed to start MCP server: ${q}`)
        }), v.subscriptions.push({
            dispose: async () => {
                await J()
            }
        })
    } catch (B) {
        z.error("Error during extension activation:", B), g9.window.showErrorMessage(`Failed to activate Claude Code extension: ${B}`)
    }
}

function VA6(v) {
    return g9.window.onDidChangeVisibleTextEditors((z) => {
        let U = z.some((V) => V?.document.uri.scheme === v);
        g9.commands.executeCommand("setContext", "claude-code.viewingProposedDiff", U)
    })
}

function VG(v, z) {
    let U = v.document,
        V = U.fileName,
        N = v.selection;
    if (N.isEmpty) return {
        filePath: V,
        startLine: N.start.line + 1,
        endLine: N.start.line + 1
    };
    else {
        let K;
        if (!z) K = U.getText(N);
        return {
            filePath: V,
            startLine: N.start.line + 1,
            endLine: N.end.line + 1,
            startColumn: N.start.character,
            endColumn: N.end.character,
            selectedText: K
        }
    }
}
var Yi = !1;

function NA6(v) {
    Yi = !0;
    let z = L6.window.createOutputChannel("Claude VSCode", {
        log: !0
    });
    v.subscriptions.push(z), L6.commands.executeCommand("setContext", "claude-vscode.updateSupported", !1);
    // --- forceLocal: guide user when remote detected but forceLocal is OFF ---
    // This extension (claude-code-local) always runs on the UI/local side due to extensionKind: ["ui", "workspace"].
    // When connected to a remote server with forceLocal OFF, the CLI would try to access remote paths locally  ENOENT.
    // We cannot switch extensionKind at runtime, so present the user with clear options.
    (function _checkForceLocalRemoteGuide() {
        var _vsc = L6;
        var _cfg = _vsc.workspace.getConfiguration("claudeCode");
        var _forceLocal = _cfg.get("forceLocal", false);
        if (_forceLocal) return; // already enabled, nothing to do
        // Detect remote connection
        var _isRemote = false;
        if (_vsc.env.remoteAuthority) _isRemote = true;
        else if (_vsc.env.remoteName) _isRemote = true;
        else {
            var _folders = _vsc.workspace.workspaceFolders;
            if (_folders && _folders.length > 0 && _folders[0].uri.scheme !== "file") _isRemote = true;
        }
        if (!_isRemote) return; // local workspace, no action needed
        // Remote detected but forceLocal is OFF  guide user
        z.info("forceLocal: remote connection detected but forceLocal is OFF. This extension runs locally and cannot use the remote CLI without Force Local mode.");
        _vsc.window.showWarningMessage(
            "Claude Code Local detected a remote connection, but Force Local mode is OFF. " +
            "This extension always runs locally  without Force Local, file operations will fail. " +
            "If the remote server has internet, use the official Claude Code extension instead.",
            "Enable Force Local", "Disable This Extension"
        ).then(function(choice) {
            if (choice === "Enable Force Local") {
                _cfg.update("forceLocal", true, _vsc.ConfigurationTarget.Workspace).then(function() {
                    _vsc.window.showInformationMessage(
                        "Force Local mode enabled for this workspace. Please reload the window.",
                        "Reload"
                    ).then(function(r) {
                        if (r === "Reload") _vsc.commands.executeCommand("workbench.action.reloadWindow");
                    });
                });
            } else if (choice === "Disable This Extension") {
                _vsc.commands.executeCommand("workbench.action.openExtensionsView");
                _vsc.window.showInformationMessage(
                    "Disable 'Claude Code Local' and install/enable the official 'Claude Code' extension for remote servers with internet."
                );
            }
        });
    })();
    let U = new P2(v);
    U.migrateAllSettings(), v.subscriptions.push(L6.workspace.onDidChangeConfiguration(($) => {
        if ($.affectsConfiguration("claudeCode.respectGitIgnore")) kx.cache.clear?.()
    }));
    let V = new bJ("_claude_vscode_fs_left");
    let N = new bJ("_claude_vscode_fs_right");
    let K = new SF("_claude_vscode_fs_readonly");
    if (isForceLocalMode()) {
        try {
            v.subscriptions.push(L6.workspace.registerFileSystemProvider(V.scheme, V));
            v.subscriptions.push(L6.workspace.registerFileSystemProvider(N.scheme, N));
            v.subscriptions.push(L6.workspace.registerTextDocumentContentProvider(K.scheme, K)), v.subscriptions.push(BA6(N.scheme));
        } catch (fsErr) {
            z.warn("FileSystemProvider registration failed (expected in forceLocal/UI mode):", fsErr.message || fsErr);
        }
    } else {
        v.subscriptions.push(L6.workspace.registerFileSystemProvider(V.scheme, V));
        v.subscriptions.push(L6.workspace.registerFileSystemProvider(N.scheme, N));
        v.subscriptions.push(L6.workspace.registerTextDocumentContentProvider(K.scheme, K)), v.subscriptions.push(BA6(N.scheme));
    }
    let x = WY(v.subscriptions),
        j = new L6.EventEmitter;
    v.subscriptions.push(j);
    let B = j.event,
        O = jA6(v.subscriptions),
        J = new WF(v.extensionUri, v, z, U, V, N, K, x, B, O, () => fN);
    v.subscriptions.push(J), v.subscriptions.push(L6.workspace.onDidChangeConfiguration(($) => {
        if ($.affectsConfiguration("chat.fontSize") || $.affectsConfiguration("chat.fontFamily") || $.affectsConfiguration("chat.editor.fontSize") || $.affectsConfiguration("chat.editor.fontFamily") || $.affectsConfiguration("chat.editor.fontWeight")) J.notifyFontConfigurationChange()
    })), xA6(v.subscriptions, j, J), Ti(v, z, {
        nativeAtMentionCallback: ($) => {
            if (J.hasVisibleWebview()) return j.fire($), !0;
            return !1
        }
    });
    let q = L6.version.split(".").map(Number),
        H = q[0] ?? 0,
        D = q[1] ?? 0,
        A = H > 1 || H === 1 && D >= 106;
    if (!A) L6.commands.executeCommand("setContext", "claude-code:doesNotSupportSecondarySidebar", !0);
    v.subscriptions.push(L6.window.registerWebviewViewProvider("claudeVSCodeSidebar", J, {
        webviewOptions: {
            retainContextWhenHidden: !0
        }
    })), v.subscriptions.push(L6.window.registerWebviewViewProvider("claudeVSCodeSidebarSecondary", J, {
        webviewOptions: {
            retainContextWhenHidden: !0
        }
    })), v.subscriptions.push(L6.window.registerWebviewPanelSerializer("claudeVSCodePanel", {
        async deserializeWebviewPanel($, F) {
            J.setupPanel($, void 0, void 0)
        }
    })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.editor.open", async ($, F) => {
        U.setPreferredLocation("panel");
        let {
            startedInNewColumn: L
        } = J.createPanel($, F);
        if (L) await L6.commands.executeCommand("workbench.action.lockEditorGroup")
    })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.editor.openLast", async () => {
        if (U.getPreferredLocation() === "sidebar") {
            await L6.commands.executeCommand("claude-vscode.sidebar.open");
            return
        }
        await L6.commands.executeCommand("claude-vscode.editor.open")
    })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.newConversation", async () => {
        J.notifyCreateNewConversation()
    }));
    let w = L6.window.createStatusBarItem(L6.StatusBarAlignment.Right);
    if (w.text = " Claude Code", w.command = "claude-vscode.editor.openLast", w.tooltip = "Open Claude Code", v.subscriptions.push(w), U.getPreferredLocation() === "sidebar" && A) w.show();
    if (v.subscriptions.push(L6.commands.registerCommand("claude-vscode.sidebar.open", async () => {
            if (U.setPreferredLocation("sidebar"), !A) {
                L6.window.showWarningMessage("Secondary Sidebar not supported in this version of VSCode. Please update your VSCode to use. Opening in Activity Bar instead."), await L6.commands.executeCommand("claudeVSCodeSidebar.focus");
                return
            }
            await L6.commands.executeCommand("claudeVSCodeSidebarSecondary.focus"), w.show()
        })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.window.open", async () => {
            J.createPanel(void 0, void 0), await L6.commands.executeCommand("workbench.action.moveEditorToNewWindow"), w.hide()
        })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.logout", async () => {
            if (await new YU(i1(z), GJ()).logout()) await J.notifyLogout(), L6.window.showInformationMessage("Successfully logged out from Claude");
            else L6.window.showErrorMessage("Failed to logout completely. Some credentials may remain.")
        })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.showLogs", () => {
            z.show()
        })), v.subscriptions.push(L6.commands.registerCommand("claude-vscode.openWalkthrough", () => {
            let $ = v.extension.id;
            L6.commands.executeCommand("workbench.action.openWalkthrough", `${$}#claude-code-walkthrough`, !1)
        })), v.subscriptions.push(L6.window.registerUriHandler({
            handleUri($) {
                if ($.path === "/install-plugin") {
                    let F = new URLSearchParams($.query),
                        L = F.get("plugin"),
                        G = F.get("marketplace") ?? "anthropics/claude-plugins-official";
                    if (!L) {
                        L6.window.showErrorMessage("Invalid plugin installation URL. The plugin parameter is required.");
                        return
                    }
                    L6.commands.executeCommand("claude-vscode.editor.openLast").then(() => {
                        J.notifyOpenPluginsDialog(L, G)
                    })
                }
            }
        })), process.env.ENABLE_INSTALL_PLUGIN === "true") v.subscriptions.push(L6.commands.registerCommand("claude-vscode.installPlugin", async () => {
        let $ = await L6.window.showInputBox({
            prompt: "plugin@marketplace (e.g. my-plugin@https://github.com/org/repo)",
            placeHolder: "plugin@marketplace"
        });
        if (!$) return;
        let [F, ...L] = $.split("@"), G = L.join("@") || "anthropics/claude-plugins-official";
        if (!F) return;
        await L6.commands.executeCommand("claude-vscode.editor.openLast"), J.notifyOpenPluginsDialog(F, G)
    }));
    KA6(v)
}
async function KA6(v) {
    if (v.globalState.get("lastClaudeLocationMigrated")) return;
    if (v.globalState.get("walkthroughShown") !== void 0) return;
    await v.globalState.update("walkthroughShown", Date.now()), setTimeout(() => {
        L6.commands.executeCommand("claude-vscode.openWalkthrough")
    }, 1000)
}

function xA6(v, z, U) {
    v.push(L6.commands.registerCommand("claude-vscode.insertAtMention", async () => {
        let V = L6.window.activeTextEditor;
        if (!V) return;
        let N = V.document,
            K = L6.workspace.asRelativePath(N.fileName),
            x = V.selection;
        if (x.isEmpty) {
            z.fire(`@${K}`);
            return
        }
        let j = x.start.line + 1,
            B = x.end.line + 1,
            O = j !== B ? `@${K}#${j}-${B}` : `@${K}#${j}`;
        z.fire(O)
    })), v.push(L6.commands.registerCommand("claude-vscode.blur", async () => {
        L6.commands.executeCommand("workbench.action.focusFirstEditorGroup")
    })), v.push(L6.commands.registerCommand("claude-vscode.focus", async () => {
        if (!U.hasVisibleWebview()) await L6.commands.executeCommand("claude-vscode.editor.openLast");
        let V = L6.window.activeTextEditor;
        if (!V) {
            z.fire("");
            return
        }
        let N = V.document,
            K = L6.workspace.asRelativePath(N.fileName),
            x = V.selection;
        if (x.isEmpty) {
            z.fire("");
            return
        }
        let j = x.start.line + 1,
            B = x.end.line + 1,
            O = j !== B ? `@${K}#${j}-${B}` : `@${K}#${j}`;
        z.fire(O)
    }))
}
var fN;

function jA6(v) {
    let z = new L6.EventEmitter;
    return v.push(L6.window.onDidChangeTextEditorSelection(async (U) => {
        if (U.textEditor !== L6.window.activeTextEditor) return;
        let V = await kx(U.textEditor.document.uri);
        if (U.textEditor.document.uri.scheme === "comment" || U.textEditor.document.uri.scheme === "output") return;
        if (U.selections.length === 0) {
            z.fire(void 0);
            return
        }
        fN = VG(U.textEditor, V), z.fire(fN)
    })), v.push(L6.window.onDidChangeActiveTextEditor(async (U) => {
        if (!U) return;
        let V = await kx(U.document.uri);
        fN = VG(U, V), z.fire(fN)
    })), z.event
}

function BA6(v) {
    return L6.window.onDidChangeVisibleTextEditors((z) => {
        let U = z.some((V) => V?.document.uri.scheme === v);
        L6.commands.executeCommand("setContext", "claude-vscode.viewingProposedDiff", U)
    })
}

function OA6() {
    console.log("Claude code extension is now deactivated"), Yi = !1
}

function JA6() {
    return L6.window.tabGroups.all.flatMap((v) => v.tabs)
}